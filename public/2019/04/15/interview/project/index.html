

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="海霸">
  <meta name="keywords" content="">
  <title>project 项目 - 628</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>628 blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="project 项目">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2019-04-15 22:48" pubdate>
        April 15, 2019 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      78
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">project 项目</h1>
            
            <div class="markdown-body">
              <h2 id="一-性能监控和错误监控"><a href="#一-性能监控和错误监控" class="headerlink" title="一 性能监控和错误监控"></a>一 性能监控和错误监控</h2><h3 id="1、性能监控"><a href="#1、性能监控" class="headerlink" title="1、性能监控"></a>1、性能监控</h3><p>前端性能监控流程：<br>数据采集 –&gt; 数据上报 –&gt; 服务端处理 –&gt; 数据库存储 –&gt; 数据监控可视化平台</p>
<h4 id="1-接口请求时间监控"><a href="#1-接口请求时间监控" class="headerlink" title="(1) 接口请求时间监控"></a>(1) 接口请求时间监控</h4><p>在 Node 层的中间件中判断请求的是 接口(reqInfo.type == ‘api’) 还是 页面</p>
<pre><code class="hljs JavaScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;
   <span class="hljs-keyword">const</span> &#123; reqInfo &#125; = ctx;
	<span class="hljs-keyword">if</span> (reqInfo.type == <span class="hljs-string">&#x27;api&#x27;</span>) &#123;
		<span class="hljs-comment">// 表示请求的是 接口</span>
		<span class="hljs-comment">// 请求接口时，定义一个时间戳</span>
	&#125; <span class="hljs-keyword">else</span> &#123;
		<span class="hljs-comment">// 否则请求的是 页面</span>
	&#125;
	<span class="hljs-comment">// 在 await next() 时表示收到响应了，中间的时间差 就是接口请求时间</span>
&#125;</code></pre>

<h4 id="2-页面监控"><a href="#2-页面监控" class="headerlink" title="(2) 页面监控"></a>(2) 页面监控</h4><p><a target="_blank" rel="noopener" href="https://github.com/woai3c/Front-end-articles/blob/master/monitor.md">前端性能和错误监控</a></p>
<p>页面性能数据采集的api: <strong>Web API-&gt; window.performance</strong></p>
<p><code>Performance</code> 接口可以获取到当前页面中与性能相关的信息，它是 <code>High Resolution Time API</code> 的一部分，同时也融合了 <code>Performance Timeline API</code>、<code>Navigation Timing API</code>、 <code>User Timing API</code> 和 <code>Resource Timing API</code>。</p>
<p>通过 <code>window.performance.timing</code> 属性，可以获取页面加载的各个有效数据。</p>
<img src="https://i.loli.net/2021/02/24/sxKmXLWdOAjJM2F.png" srcset="/img/loading.gif" >

<img src="https://i.loli.net/2021/02/24/cFLPZYtdofmp1MD.jpg" srcset="/img/loading.gif" >

<p>通过以上数据，我们可以得到几个有用的时间:</p>
<pre><code class="hljs javaScript"><span class="hljs-comment">// 重定向耗时 (最后一个HTTP重定向完成时的时间戳 - 第一个HTTP重定向开始时的时间戳)</span>
redirect: timing.redirectEnd - timing.redirectStart,

<span class="hljs-comment">// DOM 渲染耗时</span>
<span class="hljs-comment">// domComplete:当前文档解析完成，即Document.readyState 变为 &#x27;complete&#x27; </span>
<span class="hljs-comment">//      且相对应的readystatechange 被触发时的时间戳</span>
<span class="hljs-comment">// domLoading: 当前网页DOM结构开始解析时</span>
<span class="hljs-comment">//      （即Document.readyState 属性变为 “loading” 、</span>
<span class="hljs-comment">//       相应的 readystatechange 事件触发时）的时间戳。</span>
dom: timing.domComplete - timing.domLoading,

<span class="hljs-comment">// 页面加载耗时</span>
<span class="hljs-comment">// loadEventEnd: 当load事件结束，即加载事件完成时的时间戳</span>
<span class="hljs-comment">// navigationStart: 同一个浏览器上一个页面卸载(unload)结束时的时间戳。</span>
<span class="hljs-comment">//      如果没有上一个页面，这个值会和fetchStart相同</span>
<span class="hljs-comment">// fetch: 浏览器准备好使用HTTP请求来获取(fetch)文档的时间戳。这个时间点会在检查任何应用缓存之前</span>
load: timing.loadEventEnd - timing.navigationStart,

<span class="hljs-comment">// 页面卸载耗时</span>
unload: timing.unloadEventEnd - timing.unloadEventStart,

<span class="hljs-comment">// 请求耗时</span>
<span class="hljs-comment">// responseEnd: 返回浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时</span>
<span class="hljs-comment">//      （如果在此之前HTTP连接已经关闭，则返回关闭时）的Unix毫秒时间戳</span>
<span class="hljs-comment">// requestStart: 返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的时间戳。</span>
<span class="hljs-comment">//      如果传输层在开始请求之后失败并且连接被重开,</span>
<span class="hljs-comment">//      则该属性将会被数制成新的请求的相对应的发起时间。</span>
request: timing.responseEnd - timing.requestStart,

<span class="hljs-comment">// 获取性能信息时当前时间</span>
time: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime(),</code></pre>

<p>除此之外，还有一个比较重要的时间就是<strong>白屏时间</strong>，它指从输入网址，到页面开始显示内容的时间。</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 将以下脚本放在 &lt;/head&gt; 前面就能获取白屏时间。 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="javascript">    whiteScreen = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() - performance.timing.navigationStart</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

<p>获取资源加载时间API: <code>window.performance.getEntriesByType(&#39;resource&#39;)</code></p>
<img src="https://i.loli.net/2021/02/24/sfEplXLtPn19NSe.png" srcset="/img/loading.gif" >

<p>它一般包括以下几个类型: script、link、img、css、fetch、other、xmlhttprequest<br>数据中比较有用的信息是:</p>
<pre><code class="hljs javaScript"><span class="hljs-comment">// 资源的名称</span>
name: item.name,
<span class="hljs-comment">// 资源加载耗时</span>
duration: item.duration.toFixed(<span class="hljs-number">2</span>),
<span class="hljs-comment">// 资源大小</span>
size: item.transferSize,
<span class="hljs-comment">// 资源所用协议</span>
protocol: item.nextHopProtocol,</code></pre>

<p><strong>用户信息收集</strong>：</p>
<ol>
<li>使用 <code>window.navigator</code> 可以收集到用户的设备信息，操作系统，浏览器信息<br>用户设备信息：<code>window.navigator.userAgent</code> 中可以获取用户设备信息<br> 设备网络信息：<code>window.navigator.connection</code></li>
<li><code>UV(Unique visitor)</code> —— 是指通过互联网访问、浏览这个网页的自然人。00:00-24:00内相同的客户端只被计算一次，多次访问只计算一次UV。<br>在用户访问网站时，可以生成一个随机字符串+时间日期，保存在本地。在网页发生请求时（如果超过当天24:00，则重新生成），把这些参数传到后端，后端利用这些信息生成 UV 统计报告。<br>统计方法：统计 PV 时采集 userId 去重即可<br>SPA页面，可以监听hashChange</li>
<li><code>PV（Page View）</code>—— 即页面浏览量或点击量，用户每1次对网站中的每个网页访问均被记录1个PV。用户对同一页面的多次访问，访问量累计，用以衡量网站用户访问的网页数量。<br>统计方法：（以 Vue 应用为例）<ul>
<li>SPA 应用：仅单入口，在入口文件全局定义 Router.beforeEach 方便可行（或者可以监听hashChange）</li>
<li>MPA 应用：多入口，在每个入口文件定义 Router.beforeEach？可封装公用逻辑（伪装单入口），免去重复构造 entry 的成本</li>
<li>SSR 应用：调用 TemplateView 则为渲染页面（不同于前后端分离项目，服务端无法获知接口调用与页面渲染的对应关系），统计其调用次数及 TemplateName 可知页面 PV。</li>
</ul>
</li>
<li>页面停留时间 ——<br><strong>传统网站</strong> 用户在进入 A 页面时，通过后台请求把用户进入页面的时间捎上。过了 10 分钟，用户进入 B 页面，这时后台可以通过接口捎带的参数可以判断出用户在 A 页面停留了 10 分钟。<br><strong>SPA</strong> 可以利用 router 来获取用户停留时间，拿 Vue 举例，通过 <code>router.beforeEach destroyed</code> 这两个钩子函数来获取用户停留该路由组件的时间。</li>
<li>浏览深度 —— 通过 <code>document.documentElement.scrollTop</code> 属性以及屏幕高度，可以判断用户是否浏览完网站内容。</li>
<li>页面跳转来源 —— 通过 <code>document.referrer</code> 属性，可以知道用户是从哪个网站跳转而来。</li>
</ol>
<p><strong>用户信息收集</strong>：</p>
<ol>
<li><p><code>FP（First Paint）</code>首次绘制：首次绘制,是时间线上的第一个时间点，它代表网页的第一个像素渲染到屏幕上所用时间，也就是页面在屏幕上首次发生视觉变化的时间</p>
 <pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFPTime</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">const</span> timings = performance.getEntriesByType(<span class="hljs-string">&#x27;paint&#x27;</span>)[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">return</span> timings ? <span class="hljs-built_in">Math</span>.round(timings.startTime) : <span class="hljs-literal">null</span>
&#125;</code></pre>

<p> FP与FCP这两个指标之间的主要区别是：</p>
<ul>
<li>FP是当浏览器开始绘制内容到屏幕上的时候，只要在视觉上开始发生变化，无论是什么内容触发的视觉变化，在这一刻，这个时间点，叫做FP。</li>
<li>FCP指的是浏览器首次绘制来自DOM的内容。例如：文本，图片，SVG，canvas元素等，这个时间点叫FCP。<br>FP和FCP可能是相同的时间，也可能是先FP后FCP。</li>
</ul>
</li>
<li><p><code>FCP（ First Contentful Paint）</code>首次内容绘制</p>
<p> 首次内容绘制，顾名思义，它代表浏览器第一次向屏幕绘内容。<br> 通过performance.getEntriesByType(‘paint’)，取第二个pain的时间，或者通过Mutation Observer观察到首次节点变动的时间。</p>
 <pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFPTime</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">const</span> timings = performance.getEntriesByType(<span class="hljs-string">&#x27;paint&#x27;</span>);
    <span class="hljs-keyword">if</span>(timings.length &gt; <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> timings[<span class="hljs-number">1</span>]
    <span class="hljs-keyword">return</span> timings ? <span class="hljs-built_in">Math</span>.round(timings.startTime) : <span class="hljs-literal">null</span>
    <span class="hljs-comment">//伪代码,算 DOM 变化时的最小那个时间，即节点首次变动的时间</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.round(domEntries.length ? <span class="hljs-built_in">Math</span>.min(...domEntries.map(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> entry.time)) : <span class="hljs-number">0</span>);
&#125;
<span class="hljs-keyword">const</span> domEntries = []
<span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> MutationObserver(<span class="hljs-function">(<span class="hljs-params">mutationsList</span>)=&gt;</span>&#123;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> mutation <span class="hljs-keyword">of</span> mutationsList) &#123;
        <span class="hljs-keyword">if</span> (mutation.type == <span class="hljs-string">&#x27;childList&#x27;</span>) &#123;
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;A child node has been added or removed.&#x27;</span>);
        &#125;
        <span class="hljs-keyword">if</span> (mutation.type == <span class="hljs-string">&#x27;addedNodes&#x27;</span>) &#123;
            <span class="hljs-comment">//TODO新增了节点，做处理，计算此时的可见性/位置/出现时间等信息，然后 push 进数组</span>
            ...
            domEntries.push(mutation)
        &#125;
    &#125;
&#125;)</code></pre>
</li>
<li><p><code>FMP（First Meaningful Paint)</code>首次有意义的绘制<br>首次有意义的绘制，是页面主要内容出现在屏幕上的时间, 这是用户感知加载体验的主要指标。目前尚无标准化的定义, 因为很难以通用的方式去确定各种类型页面的关键内容。<br>目前没有统一逻辑，阿里有个标准为最高可见增量元素，采用深度优先遍历方法<br>其次，可以自定义，比如通 Mutation Observer 观察页面加载的一段时间(如前20s)内页面节点的变化, 即元素新增/移除/隐藏等变化记录下来，这样可以得到页面元素的可见时间点及元素与可视区域的交叉信息等。<br>然后，自定义一个计算公式，比如根据元素的类型进行权重取值(div 权重1，img 权重2等), 然后取元素与可视区域的交叉区域面积、可见度、 权重值之间的乘积为元素评分。<br>根据上面得到的信息, 以时间点为X轴, 该时间点可见元素的评分总和为Y轴, 取最高点对应的最小时间为页面主要内容出现在屏幕上的时间。</p>
</li>
<li><p><code>FID（ First Input Delay）</code>首次输入延迟<br>首次输入延迟，是测量用户首次与站点交互时的时间（即当他们单击链接/点击按钮/使用自定义的JavaScript驱动控件时）到浏览器实际能够回应这种互动的时间。</p>
<p> 方式一，通过performanceObserver(目前支持性为88.78%)观察类型为first-input的entry，获得其startTime/duration等数即可</p>
<p> 方式二，初始化时为特定事件类型(click/touch/keydown)绑定通用统计逻辑事件,开始调用时从event.timeStamp取开始处理的时间(这个时间就是首次输入延迟时间)，在事件处理中注册requestIdleCallback事件回调onIdleCallback，当onIdleCallback被执行时，当前时间减开始的event.timeStamp即为duration时间</p>
 <pre><code class="hljs javaScript"><span class="hljs-comment">// 方式一</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFIDTime</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">const</span> timings = performance.getEntriesByType(<span class="hljs-string">&#x27;first-input&#x27;</span>)[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">return</span> timings ? timings : <span class="hljs-literal">null</span>
&#125;
<span class="hljs-comment">// 方式二，以下代码仅代表思路</span>
[<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-string">&#x27;touch&#x27;</span>,<span class="hljs-string">&#x27;keydown&#x27;</span>].forEach(<span class="hljs-function"><span class="hljs-params">eventType</span> =&gt;</span> &#123;
    <span class="hljs-built_in">window</span>.addEventListener(eventType, eventHandle);
&#125;);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eventHandle</span>(<span class="hljs-params">e</span>) </span>&#123;
    <span class="hljs-keyword">const</span> eventTime = e.timeStamp;
    <span class="hljs-built_in">window</span>.requestIdleCallback(onIdleCallback.bind(<span class="hljs-built_in">this</span>, eventTime, e));
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onIdleCallback</span>(<span class="hljs-params">eventTime, e</span>) </span>&#123;
    <span class="hljs-keyword">const</span> now = <span class="hljs-built_in">window</span>.performance.now();
    <span class="hljs-keyword">const</span> duration = now - eventTime;

    <span class="hljs-keyword">return</span> &#123;
        duration: <span class="hljs-built_in">Math</span>.round(duration),
        timestamp: <span class="hljs-built_in">Math</span>.round(eventTime)
    &#125;

    [<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-string">&#x27;touch&#x27;</span>,<span class="hljs-string">&#x27;keydown&#x27;</span>].forEach(<span class="hljs-function"><span class="hljs-params">eventType</span> =&gt;</span> &#123;
        <span class="hljs-built_in">window</span>.removeEventListener(eventType, eventHandle);
    &#125;);
&#125;</code></pre>
</li>
<li><p><code>TTI（ Time To Interactive）</code>可交互时间</p>
<p> 可交互时间，指的是应用在视觉上都已渲染出了，完全可以响应用户的输入了。是衡量应用加载所需时间并能够快速响应用户交互的指标。</p>
<p> 与 FMP 相同，很难规范化适用于所有网页的 TTI 指标定义。</p>
<p> 统计方式一：谷歌实验室写的npm包，tti-polyfill</p>
 <pre><code class="hljs javaScript"><span class="hljs-keyword">import</span> ttiPolyfill <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;tti-polyfill&#x27;</span>;

ttiPolyfill.getFirstConsistentlyInteractive().then(<span class="hljs-function">(<span class="hljs-params">tti</span>) =&gt;</span> &#123;
ga(<span class="hljs-string">&#x27;send&#x27;</span>, <span class="hljs-string">&#x27;event&#x27;</span>, &#123;
    eventCategory:<span class="hljs-string">&#x27;Performance Metrics&#x27;</span>,
    eventAction:<span class="hljs-string">&#x27;TTI&#x27;</span>,
    eventValue: tti,
    nonInteraction: <span class="hljs-literal">true</span>,
&#125;);
&#125;);</code></pre>
</li>
<li><p><code>FCI（First CPU Idle）</code>首次CPU空闲时间<br>首次CPU空闲时间代表着一个网页已经满足了最小程度的与用户发生交互行为的时刻。当我们打开一个网页，我们并不需要等到一个网页完全加载好了，每一个元素都已经完成了渲染，然后再去与网页进行交互行为。网页满足了我们基本的交互的时间点是衡量网页性能的一个重要指标。</p>
<p> FCI为在FMP之后，首次在一定窗口时间内没有长任务发生的那一时刻，并且如果这个时间点早于DOMContentLoaded时间，那么FCI的时间为DOMContentLoaded时间，窗口时间的计算函数可以根据Lighthouse提供的计算公式 <code>N = f(t) = 4 * e^(-0.045 * t) + 1</code> 进行自定义设计</p>
</li>
<li><p><code>FPS（ Frames Per Second）</code>为每秒帧率<br> 表示的是每秒钟画面更新次数，当今大多数设备的屏幕刷新率都是60次/秒。</p>
<p> 参考标准：单位(帧率)</p>
<pre><code> 50 ～ 60 FPS:动画将会相当流畅，让人倍感舒适；
 30 ～ 50 FPS 之间的动画，因各人敏感程度不同，舒适度因人而异；
 30 FPS 以下的动画，让人感觉到明显的卡顿和不适感；
 帧率波动很大的动画，亦会使人感觉到卡顿。</code></pre>
<p> 统计逻辑<br> 利用requestAnimationFrame,循环调用，当now大于lastTime+1S时，计算FPS。若小于某个阀值则可以认为当前帧率较差，若连续小于多个阀值，则停止统计，当前页面处于卡顿状态，进入卡顿处理逻辑</p>
</li>
</ol>
<p><strong>总结</strong>:收集这些数据的代码：</p>
<pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">monitorInit</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">const</span> monitor = &#123;
        <span class="hljs-comment">// 数据上传地址</span>
        url: <span class="hljs-string">&#x27;&#x27;</span>,
        <span class="hljs-comment">// 性能信息</span>
        performance: &#123;&#125;,
        <span class="hljs-comment">// 资源信息</span>
        resources: &#123;&#125;,
        <span class="hljs-comment">// 错误信息</span>
        errors: [],
        <span class="hljs-comment">// 用户信息</span>
        user: &#123;
            <span class="hljs-comment">// 屏幕宽度</span>
            screen: screen.width,
            <span class="hljs-comment">// 屏幕高度</span>
            height: screen.height,
            <span class="hljs-comment">// 浏览器平台</span>
            platform: navigator.platform,
            <span class="hljs-comment">// 浏览器的用户代理信息</span>
            userAgent: navigator.userAgent,
            <span class="hljs-comment">// 浏览器用户界面的语言</span>
            language: navigator.language,
        &#125;,
        <span class="hljs-comment">// 重置 monitor 对象</span>
        <span class="hljs-function"><span class="hljs-title">reset</span>(<span class="hljs-params"></span>)</span> &#123;
            <span class="hljs-built_in">window</span>.performance &amp;&amp; <span class="hljs-built_in">window</span>.performance.clearResourceTimings()
            monitor.performance = getPerformance()
            monitor.resources = getResources()
            monitor.errors = []
        &#125;,
        <span class="hljs-comment">// 清空 error 信息</span>
        <span class="hljs-function"><span class="hljs-title">clearError</span>(<span class="hljs-params"></span>)</span> &#123;
            monitor.errors = []
        &#125;,
        <span class="hljs-comment">// 上传监控数据</span>
        <span class="hljs-function"><span class="hljs-title">upload</span>(<span class="hljs-params"></span>)</span> &#123;
            <span class="hljs-comment">// 自定义上传</span>
            <span class="hljs-comment">// axios.post(&#123;</span>
            <span class="hljs-comment">//     url: monitor.url,</span>
            <span class="hljs-comment">//     data: &#123;</span>
            <span class="hljs-comment">//         performance,</span>
            <span class="hljs-comment">//         resources,</span>
            <span class="hljs-comment">//         errors,</span>
            <span class="hljs-comment">//         user,</span>
            <span class="hljs-comment">//     &#125;</span>
            <span class="hljs-comment">// &#125;)</span>
        &#125;,
        <span class="hljs-comment">// 设置数据上传地址</span>
        <span class="hljs-function"><span class="hljs-title">setURL</span>(<span class="hljs-params">url</span>)</span> &#123;
            monitor.url = url
        &#125;,
    &#125;

    <span class="hljs-comment">// 获取性能信息</span>
    <span class="hljs-keyword">const</span> getPerformance = <span class="hljs-function">() =&gt;</span> &#123;
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">window</span>.performance) <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">const</span> timing = <span class="hljs-built_in">window</span>.performance.timing
        <span class="hljs-keyword">const</span> performance = &#123;
            <span class="hljs-comment">// 重定向耗时</span>
            redirect: timing.redirectEnd - timing.redirectStart,
            <span class="hljs-comment">// 白屏时间</span>
            whiteScreen: whiteScreen,
            <span class="hljs-comment">// DOM 渲染耗时</span>
            dom: timing.domComplete - timing.domLoading,
            <span class="hljs-comment">// 页面加载耗时</span>
            load: timing.loadEventEnd - timing.navigationStart,
            <span class="hljs-comment">// 页面卸载耗时</span>
            unload: timing.unloadEventEnd - timing.unloadEventStart,
            <span class="hljs-comment">// 请求耗时</span>
            request: timing.responseEnd - timing.requestStart,
            <span class="hljs-comment">// 获取性能信息时当前时间</span>
            time: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime(),
        &#125;

        <span class="hljs-keyword">return</span> performance
    &#125;

    <span class="hljs-comment">// 获取资源信息</span>
    <span class="hljs-keyword">const</span> getResources = <span class="hljs-function">() =&gt;</span> &#123;
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">window</span>.performance) <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">const</span> data = <span class="hljs-built_in">window</span>.performance.getEntriesByType(<span class="hljs-string">&#x27;resource&#x27;</span>)
        <span class="hljs-keyword">const</span> resource = &#123;
            xmlhttprequest: [],
            css: [],
            other: [],
            script: [],
            img: [],
            link: [],
            fetch: [],
            <span class="hljs-comment">// 获取资源信息时当前时间</span>
            time: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime(),
        &#125;

        data.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;
            <span class="hljs-keyword">const</span> arry = resource[item.initiatorType]
            arry &amp;&amp; arry.push(&#123;
                <span class="hljs-comment">// 资源的名称</span>
                name: item.name,
                <span class="hljs-comment">// 资源加载耗时</span>
                duration: item.duration.toFixed(<span class="hljs-number">2</span>),
                <span class="hljs-comment">// 资源大小</span>
                size: item.transferSize,
                <span class="hljs-comment">// 资源所用协议</span>
                protocol: item.nextHopProtocol,
            &#125;)
        &#125;)

        <span class="hljs-keyword">return</span> resource
    &#125;

    <span class="hljs-built_in">window</span>.onload = <span class="hljs-function">() =&gt;</span> &#123;
        <span class="hljs-comment">// 在浏览器空闲时间获取性能及资源信息</span>
        <span class="hljs-comment">// https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.requestIdleCallback) &#123;
            <span class="hljs-built_in">window</span>.requestIdleCallback(<span class="hljs-function">() =&gt;</span> &#123;
                monitor.performance = getPerformance()
                monitor.resources = getResources()
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;页面性能信息&#x27;</span>)
                <span class="hljs-built_in">console</span>.log(monitor.performance)
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;页面资源信息&#x27;</span>)
                <span class="hljs-built_in">console</span>.log(monitor.resources)
            &#125;)
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
                monitor.performance = getPerformance()
                monitor.resources = getResources()
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;页面性能信息&#x27;</span>)
                <span class="hljs-built_in">console</span>.log(monitor.performance)
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;页面资源信息&#x27;</span>)
                <span class="hljs-built_in">console</span>.log(monitor.resources)
            &#125;, <span class="hljs-number">0</span>)
        &#125;
    &#125;

    <span class="hljs-comment">// 捕获资源加载失败错误 js css img...</span>
    addEventListener(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;
        <span class="hljs-keyword">const</span> target = e.target
        <span class="hljs-keyword">if</span> (target != <span class="hljs-built_in">window</span>) &#123;
            monitor.errors.push(&#123;
                type: target.localName,
                url: target.src || target.href,
                msg: (target.src || target.href) + <span class="hljs-string">&#x27; is load error&#x27;</span>,
                <span class="hljs-comment">// 错误发生的时间</span>
                time: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime(),
            &#125;)

            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;所有的错误信息&#x27;</span>)
            <span class="hljs-built_in">console</span>.log(monitor.errors)
        &#125;
    &#125;, <span class="hljs-literal">true</span>)

    <span class="hljs-comment">// 监听 js 错误</span>
    <span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg, url, row, col, error</span>) </span>&#123;
        monitor.errors.push(&#123;
            type: <span class="hljs-string">&#x27;javascript&#x27;</span>, <span class="hljs-comment">// 错误类型</span>
            row: row, <span class="hljs-comment">// 发生错误时的代码行数</span>
            col: col, <span class="hljs-comment">// 发生错误时的代码列数</span>
            msg: error &amp;&amp; error.stack? error.stack : msg, <span class="hljs-comment">// 错误信息</span>
            url: url, <span class="hljs-comment">// 错误文件</span>
            time: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime(), <span class="hljs-comment">// 错误发生的时间</span>
        &#125;)

        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;所有的错误信息&#x27;</span>)
        <span class="hljs-built_in">console</span>.log(monitor.errors)
    &#125;

    <span class="hljs-comment">// 监听 promise 错误 缺点是获取不到行数数据</span>
    addEventListener(<span class="hljs-string">&#x27;unhandledrejection&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;
        monitor.errors.push(&#123;
            type: <span class="hljs-string">&#x27;promise&#x27;</span>,
            msg: (e.reason &amp;&amp; e.reason.msg) || e.reason || <span class="hljs-string">&#x27;&#x27;</span>,
            <span class="hljs-comment">// 错误发生的时间</span>
            time: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime(),
        &#125;)

        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;所有的错误信息&#x27;</span>)
        <span class="hljs-built_in">console</span>.log(monitor.errors)
    &#125;)

    <span class="hljs-keyword">return</span> monitor
&#125;

<span class="hljs-keyword">const</span> monitor = monitorInit()</code></pre>

<p>性能数据可以在页面加载完之后上报，尽量不要对页面性能造成影响<br><code>window.requestIdleCallback()</code>方法将在浏览器的空闲时段内调用的函数排队.</p>
<pre><code class="hljs javaScript"><span class="hljs-comment">// 信息收集</span>
<span class="hljs-built_in">window</span>.onload = <span class="hljs-function">() =&gt;</span> &#123;
    <span class="hljs-comment">// 在浏览器空闲时间获取性能及资源信息</span>
    <span class="hljs-comment">// https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.requestIdleCallback) &#123;
        <span class="hljs-built_in">window</span>.requestIdleCallback(<span class="hljs-function">() =&gt;</span> &#123;
            monitor.performance = getPerformance()
            monitor.resources = getResources()
        &#125;)
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
            monitor.performance = getPerformance()
            monitor.resources = getResources()
        &#125;, <span class="hljs-number">0</span>)
    &#125;
&#125;</code></pre>

<p><code>window.performance API</code> 是有缺点: 在 SPA 切换路由时，<code>window.performance.timing</code> 的数据不会更新.<br>解决办法之一: 拿Vue举例，在路由的全局前置守卫 <code>beforeEach</code> 里获取开始时间，<br>在组件的 <code>mounted</code> 钩子里执行 <code>vm.$nextTick</code> 函数来获取组件的渲染完毕时间。</p>
<pre><code class="hljs JavaScript">router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;
	store.commit(<span class="hljs-string">&#x27;setPageLoadedStartTime&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>())
&#125;)
<span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;
	<span class="hljs-built_in">this</span>.$nextTick(<span class="hljs-function">() =&gt;</span> &#123;
		<span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;setPageLoadedTime&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() - <span class="hljs-built_in">this</span>.$store.state.pageLoadedStartTime)
	&#125;)
&#125;</code></pre>

<h3 id="2、错误监控"><a href="#2、错误监控" class="headerlink" title="2、错误监控"></a>2、错误监控</h3><p>前端错误监控流程：<br>错误日志采集 –&gt; 上报  –&gt; 服务端处理 –&gt; 数据库存储  –&gt; 日志收敛 –&gt; 数据监控可视化平台</p>
<ul>
<li>可疑区域增加 <code>try...catch</code></li>
<li>全程监控JS异常<code>window.onerror</code></li>
<li>静态资源异常<code>window.addEventListener</code></li>
<li><code>Promise.catch</code> 异常 <code>window.addEventListener(&quot;unhandledrejection&quot;, function()&#123;&#125;)</code></li>
<li><code>Vue errorHandler</code> 和 <code>React componentDidCatch</code></li>
<li>跨域异常通过<code>crossOrigin</code>解决</li>
<li>监控网页崩溃：<code>window</code>对象的<code>load</code>和<code>beforeunload</code> 或<code>navigator.serviceWorker.controller.postMessage API</code></li>
</ul>
<h4 id="1-sentry引入"><a href="#1-sentry引入" class="headerlink" title="(1) sentry引入"></a>(1) sentry引入</h4><p>1、 在 src/main.js 入口文件引入 sentry 并初始化<br>    在初始化时，需要传入配置信息</p>
<pre><code class="hljs JavaScript"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> InitSentry <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;common/sentry&#x27;</span>;
<span class="hljs-comment">// 初始化sentry</span>
InitSentry();

<span class="hljs-comment">// common/sentry.js</span>
<span class="hljs-keyword">import</span> moment <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;moment&#x27;</span>;
<span class="hljs-keyword">import</span> &#123; EnvEnum &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;common/const/common/env&#x27;</span>; 
<span class="hljs-comment">// 配置环境信息: 开发环境、预发环境、线上环境 等等</span>
<span class="hljs-keyword">import</span> &#123; init, captureException, withScope, Severity &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@sentry/browser&#x27;</span>;
<span class="hljs-keyword">import</span> &#123; beforeSendHandler &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./handler&#x27;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> initSentry = <span class="hljs-function">() =&gt;</span> &#123;
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">const</span> _global = <span class="hljs-built_in">window</span>._global;
        <span class="hljs-keyword">const</span> &#123; NODE_ENV_DOCKER &#125; = _global.env;

			<span class="hljs-comment">// 预发和线上环境才监控</span>
		  <span class="hljs-keyword">if</span> (NODE_ENV_DOCKER !== EnvEnum.ONLINE 
				  &amp;&amp; NODE_ENV_DOCKER !== EnvEnum.PROD 
				  &amp;&amp; NODE_ENV_DOCKER !== EnvEnum.PRE) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;

        <span class="hljs-keyword">const</span> &#123; BUILD_TIME = <span class="hljs-built_in">Date</span>.now() &#125; = process.env;

        <span class="hljs-keyword">const</span> dsn = <span class="hljs-string">&#x27;https://4a7e72a34bdd438ebc1a9c649de1dc72@crash.youzan.com/31&#x27;</span>;
        <span class="hljs-comment">/** 统一线上环境变量值 */</span>
        <span class="hljs-keyword">const</span> environment = NODE_ENV_DOCKER === EnvEnum.ONLINE ? EnvEnum.PROD : NODE_ENV_DOCKER;
        <span class="hljs-comment">/** 使用打包时的时间作为 release 版本控制 */</span>
        <span class="hljs-keyword">const</span> release = moment(BUILD_TIME).format(<span class="hljs-string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>);

        <span class="hljs-comment">/** 初始化 传入配置 */</span>
        init(&#123;
            dsn, <span class="hljs-comment">// 识别</span>
            release, <span class="hljs-comment">// 发布版本</span>
            environment, <span class="hljs-comment">// 环境</span>
            beforeSend: beforeSendHandler, <span class="hljs-comment">// 上报的钩子 附加信息</span>
        &#125;);
    &#125; <span class="hljs-keyword">catch</span> (error) &#123;
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;sentry 初始化失败&#x27;</span>);
    &#125;
&#125;;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> catchReqException = <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;
    withScope(<span class="hljs-function"><span class="hljs-params">scope</span> =&gt;</span> &#123;
        scope.setLevel(Severity.Warning);
        captureException(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-built_in">JSON</span>.stringify(err)));
    &#125;);
&#125;;
<span class="hljs-comment">/** 自定义上传sentry */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> catchDebugException = <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;
    withScope(<span class="hljs-function"><span class="hljs-params">scope</span> =&gt;</span> &#123;
        scope.setLevel(Severity.Debug);
        captureException(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-built_in">JSON</span>.stringify(err)));
    &#125;);
&#125;;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> initSentry;


<span class="hljs-comment">// handler.js</span>
<span class="hljs-keyword">import</span> &#123; Event &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@sentry/types&#x27;</span>;
<span class="hljs-keyword">import</span> &#123; merge &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;
<span class="hljs-keyword">import</span> &#123; ATTENTION_URLS &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../config&#x27;</span>;
<span class="hljs-comment">// 以下url中发生的错误都会标记 alert 的标识 </span>
<span class="hljs-comment">// const ATTENTION_URLS: string[] = [&#x27;#/bill&#x27;, &#x27;#/cashier&#x27;, &#x27;#/dashboard&#x27;, &#x27;#/reserve&#x27;, &#x27;#/verification&#x27;];</span>
<span class="hljs-keyword">const</span> &#123; _global &#125; = <span class="hljs-built_in">window</span>;
<span class="hljs-keyword">const</span> DeptInfo = &#123;
    kdtId: _global.env.team_info.kdt_id,
    shopName: _global.env.team_info.team_name,
    userId: _global.env.user_info.user_id,
    userAccount: _global.env.user_info.account,
    roleName: _global.env.user_info.roleName,
&#125;;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> composeTag = (
    event: Event,
    targetTag: &#123;
        [key: string]: any;
    &#125;
) =&gt; &#123;
    <span class="hljs-keyword">if</span> (!event.tags) &#123;
        event.tags = &#123;&#125;;
    &#125;
    <span class="hljs-keyword">return</span> merge(event.tags, targetTag);
&#125;;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> composeUser = (
    event: Event,
    targetUrl: &#123;
        [key: string]: any;
    &#125;
) =&gt; &#123;
    <span class="hljs-keyword">if</span> (!event.user) &#123;
        event.user = &#123;&#125;;
    &#125;
    <span class="hljs-keyword">return</span> merge(event.user, targetUrl);
&#125;;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> setUserContext = (event: Event): <span class="hljs-function"><span class="hljs-params">Event</span> =&gt;</span> &#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 设置基础用户上下文</span>
<span class="hljs-comment">     * 提交 event 时会带上</span>
<span class="hljs-comment">     */</span>
    composeUser(event, DeptInfo);

    <span class="hljs-keyword">return</span> event;
&#125;;
<span class="hljs-comment">/** 重置 tags.url 为完整路径 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> setTagUrl = (event: Event): <span class="hljs-function"><span class="hljs-params">Event</span> =&gt;</span> &#123;
    composeTag(event, &#123;
        url: <span class="hljs-built_in">window</span>.location.href,
    &#125;);
    <span class="hljs-keyword">return</span> event;
&#125;;

<span class="hljs-comment">/** 设置店铺信息tag方便sentry搜索 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> setTagDept = (event: Event): <span class="hljs-function"><span class="hljs-params">Event</span> =&gt;</span> &#123;
    composeTag(event, DeptInfo);
    <span class="hljs-keyword">return</span> event;
&#125;;
<span class="hljs-comment">/** 根据 url 判断是否需要增加tags.alert: send */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> setTagsAlert = (event: Event): <span class="hljs-function"><span class="hljs-params">Event</span> =&gt;</span> &#123;
    <span class="hljs-keyword">const</span> requestUrl = event.request.url;
    <span class="hljs-keyword">const</span> isAttentioned = !!ATTENTION_URLS.find(<span class="hljs-function">(<span class="hljs-params">url: string</span>) =&gt;</span> !!requestUrl.match(url));
    <span class="hljs-keyword">if</span> (isAttentioned) &#123;
        composeTag(event, &#123;
            alert: <span class="hljs-string">&#x27;send&#x27;</span>,
        &#125;);
    &#125;
    <span class="hljs-keyword">return</span> event;
&#125;;
<span class="hljs-comment">/** 设置event 的 tags.route 可以根据 route 进行分类 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> setTagsRoute = <span class="hljs-function">(<span class="hljs-params">event: Event</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">const</span> requestUrl = event.request.url;
    <span class="hljs-keyword">const</span> hash = requestUrl.split(<span class="hljs-string">&#x27;#&#x27;</span>).slice(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">if</span> (!hash) &#123;
        <span class="hljs-keyword">return</span> event;
    &#125;
    <span class="hljs-keyword">const</span> route = hash.split(<span class="hljs-string">&#x27;?&#x27;</span>).slice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">if</span> (!route) &#123;
        <span class="hljs-keyword">return</span> event;
    &#125;
    composeTag(event, &#123;
        route,
    &#125;);
    <span class="hljs-keyword">return</span> event;
&#125;;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> beforeSendHandler = (event: Event): <span class="hljs-function"><span class="hljs-params">Event</span> =&gt;</span> &#123;
    <span class="hljs-keyword">try</span> &#123;
        setTagUrl(event);
        setTagDept(event);
        setTagsAlert(event);
        setTagsRoute(event);
        setUserContext(event);
    &#125; <span class="hljs-keyword">catch</span> (error) &#123;
        <span class="hljs-built_in">console</span>.error(error);
    &#125; <span class="hljs-keyword">finally</span> &#123;
        <span class="hljs-keyword">return</span> event; <span class="hljs-comment">// eslint-disable-line</span>
    &#125;
&#125;;
</code></pre>

<p>2、 接口：接口请求和响应 发生错误时的收集</p>
<pre><code class="hljs JavaScript"><span class="hljs-comment">// 在 ajax.js 中引入 sentry 的 catchReqException方法</span>
<span class="hljs-keyword">import</span> &#123; catchReqException &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;common/sentry&#x27;</span>;

<span class="hljs-comment">// 2、在接口请求和响应 发生错误时 调用 catchReqException(err) 方法，收集 错误信息</span>
catchReqException(err);</code></pre>

<p>3、增加 config/sentry.properties 配置文件</p>
<pre><code class="hljs text">auth.token=35a38b7ba2fb4fb5b4946f94d572f89c997f00a136074df2a68c70eefac0e05f
defaults.url=https://sentry.xxx.com/
defaults.org=sentry
defaults.project=project-web
http.verify_ssl=false</code></pre>

<h4 id="2-错误日志收敛"><a href="#2-错误日志收敛" class="headerlink" title="(2) 错误日志收敛"></a>(2) 错误日志收敛</h4><h4 id="3-错误收集-接口错误和页面错误"><a href="#3-错误收集-接口错误和页面错误" class="headerlink" title="(3) 错误收集(接口错误和页面错误)"></a>(3) 错误收集(接口错误和页面错误)</h4><p>(Koa框架) 在 Node 层的中间件中，采用 try…catch -&gt; await next() 方式抓取错误</p>
<pre><code class="hljs javaScript"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 统一错误处理</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;
    <span class="hljs-keyword">const</span> &#123; reqInfo &#125; = ctx;
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">await</span> next();
        <span class="hljs-comment">// 如果能正常收到响应，但是响应体是 404时，需要做对应的错误处理</span>
        <span class="hljs-keyword">if</span> (ctx.status == <span class="hljs-number">404</span>) &#123;
            <span class="hljs-keyword">if</span> (reqInfo.type == <span class="hljs-string">&#x27;api&#x27;</span>) &#123;
                <span class="hljs-comment">// 如果是接口报错，则在响应体重增加 响应错误的信息</span>
                ctx.body = &#123; <span class="hljs-attr">response</span>: &#123; <span class="hljs-attr">code</span>: <span class="hljs-number">99999</span>, <span class="hljs-attr">desc</span>: <span class="hljs-string">&#x27;接口不存在&#x27;</span> &#125; &#125;;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-comment">// 如果是页面请求报错，则重定向到 错误页面的路由（错误页面已经准备好）</span>
                ctx.redirect(<span class="hljs-string">&#x27;/dashboard#/notFound&#x27;</span>);
            &#125;
        &#125;
    &#125; <span class="hljs-keyword">catch</span> (e) &#123;
        <span class="hljs-comment">// 如果无法收到服务端的响应，被 catch 了</span>
        <span class="hljs-keyword">if</span> (reqInfo.type == <span class="hljs-string">&#x27;api&#x27;</span>) &#123;
            <span class="hljs-comment">// 接口报错</span>
            ctx.body = &#123;
                response: &#123;
                    code: e.code || <span class="hljs-number">99999</span>,
                    desc: e.desc || <span class="hljs-string">&#x27;接口调用出错&#x27;</span>,
                    message: e.message || <span class="hljs-string">&#x27;&#x27;</span>,
                &#125;,
            &#125;;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// 页面请求报错，则通过 ctx.render 将错误信息渲染到模板上</span>
            <span class="hljs-keyword">await</span> ctx.render(<span class="hljs-string">&#x27;error&#x27;</span>, &#123; <span class="hljs-attr">status</span>: <span class="hljs-number">500</span>, <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;系统错误&#x27;</span> &#125;);
        &#125;
        <span class="hljs-comment">// 并且将错误信息上报到自定义的 错误收集平台</span>
        nodejsLogger.warn(<span class="hljs-string">&#x27;系统错误&#x27;</span>, e, &#123;
            url: ctx.url,
            userId: _.get(ctx.state, <span class="hljs-string">&#x27;userInfo.id&#x27;</span>),
            kdtId: _.get(ctx.state, <span class="hljs-string">&#x27;shopInfo.kdtId&#x27;</span>),
        &#125;);
    &#125;
&#125;;</code></pre>

<h2 id="二、上报与展示"><a href="#二、上报与展示" class="headerlink" title="二、上报与展示"></a>二、上报与展示</h2><h2 id="三-Node-js环境性能监控"><a href="#三-Node-js环境性能监控" class="headerlink" title="三 Node.js环境性能监控"></a>三 Node.js环境性能监控</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903781889474567#heading-1">Node.js环境性能监控</a></p>
<h3 id="1、指标"><a href="#1、指标" class="headerlink" title="1、指标"></a>1、指标</h3><ul>
<li>CPU</li>
<li>内存</li>
<li>磁盘</li>
<li>I/O</li>
<li>网络</li>
</ul>
<p>在大多数场景下，CPU、内存以及网络就可以说是 Node 的主要性能瓶颈。</p>
<h3 id="2、CPU指标"><a href="#2、CPU指标" class="headerlink" title="2、CPU指标"></a>2、CPU指标</h3><ul>
<li>CPU负载和CPU使用率<ul>
<li>CPU负载： 进程角度</li>
<li>CPU使用率： CPU时间分配</li>
</ul>
</li>
<li>量化CPU指标</li>
</ul>
<h3 id="3、内存指标"><a href="#3、内存指标" class="headerlink" title="3、内存指标"></a>3、内存指标</h3><p>内存是一个非常容易量化的指标。 内存占用率是评判一个系统的内存瓶颈的常见指标。 对于Node来说，内部内存堆栈的使用状态也是一个可以量化的指标。</p>
<pre><code class="hljs JavaScript"><span class="hljs-comment">// /app/lib/memory.js</span>
<span class="hljs-keyword">const</span> os = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;os&#x27;</span>);
<span class="hljs-comment">// 获取当前Node内存堆栈情况</span>
<span class="hljs-keyword">const</span> &#123; rss, heapUsed, heapTotal &#125; = process.memoryUsage();
<span class="hljs-comment">// 获取系统空闲内存</span>
<span class="hljs-keyword">const</span> sysFree = os.freemem();
<span class="hljs-comment">// 获取系统总内存</span>
<span class="hljs-keyword">const</span> sysTotal = os.totalmem();

<span class="hljs-built_in">module</span>.exports = &#123;
memory: <span class="hljs-function">() =&gt;</span> &#123;
	<span class="hljs-keyword">return</span> &#123;
		sys: <span class="hljs-number">1</span> - sysFree / sysTotal,  <span class="hljs-comment">// 系统内存占用率</span>
		heap: heapUsed / headTotal,   <span class="hljs-comment">// Node堆内存占用率</span>
		node: rss / sysTotal,         <span class="hljs-comment">// Node占用系统内存的比例</span>
	&#125;
&#125;
&#125;</code></pre>

<p>对于process.memoryUsage()拿到的值有一些需要关注的地方：</p>
<ul>
<li>rss：表示node进程占用的内存总量</li>
<li>heapTotal：表示堆内存的总量</li>
<li>heapUsed：实际堆内存的使用量</li>
<li>external：外部程序的内存使用量，包含Node核心的C++程序的内存使用量</li>
</ul>
<h3 id="4、QPS"><a href="#4、QPS" class="headerlink" title="4、QPS"></a>4、QPS</h3><h3 id="5、环境压测"><a href="#5、环境压测" class="headerlink" title="5、环境压测"></a>5、环境压测</h3><h2 id="四-项目"><a href="#四-项目" class="headerlink" title="四 项目"></a>四 项目</h2><h3 id="1-发现性能瓶颈并优化的经验"><a href="#1-发现性能瓶颈并优化的经验" class="headerlink" title="1 发现性能瓶颈并优化的经验"></a>1 发现性能瓶颈并优化的经验</h3><p>分享一下我近期的经验，之前项目也碰到过用起来很卡的情况，就是用element ui的tab切换组件时，点击tab切换非常卡，非常耗时，在排除了网络请求和js代码执行时间过长等原因后，跑了一次perfermance，结果发现大部分时间都花费在了 DOM GC上了，分析了下原因可能时dom结构太多导致每次tab切换渲染太耗时了。由于我每个tab里面的html结构都一样，都是一个table，只是每次tab切换时请求的数据不一样，我就把table抽离出来了，放到tab组件外面，然后tab里面就空了，就没有那么多dom了，tab切换就不卡了，很流畅。（ps：tab有20-30个切换选项，本人语文水平不行，描述的不清楚，望轻喷。）</p>
<h3 id="2-项目"><a href="#2-项目" class="headerlink" title="2 项目"></a>2 项目</h3><p>登录 - 本域登录、第三方接入登录（小红书、微博、爱逛等等）<br>店铺装修 - 素材、模板、员工（列表、排班、考勤、业绩提成）<br>商品 - 服务、卡项、产品，耗材、入库、出库<br>订单 - 开单、采购单、退款、欠款、核销、<br>预约<br>客户<br>数据<br>资产<br>会员<br>营销活动</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/interview/">interview</a>
                    
                      <a class="hover-with-bg" href="/tags/js/">js</a>
                    
                      <a class="hover-with-bg" href="/tags/project/">project</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/04/15/interview/%E6%89%8B%E5%86%99%E6%97%B6%E9%92%9F/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">js-时钟</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/12/08/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">
                        <span class="hidden-mobile">React 生命周期</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>





  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
