<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaScript-深入理解浮点数精度问题</title>
    <link href="/2021/05/12/interview/js%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6/"/>
    <url>/2021/05/12/interview/js%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://zhuanlan.zhihu.com/p/371530318">JavaScript-深入理解浮点数精度问题-Ninnka</a></p></blockquote><p><strong>深入问题前的准备</strong></p><p>在深入问题之前，我们先来了解下JS的Number在二进制中是怎么存储的</p><p><strong>双精度浮点数</strong></p><p>JS中的Number是以双精度浮点数的形式计算的，双精度浮点数总共有8个字节（byte），每字节有8比特（bit-位），即 8bit/byet，所以总共占位64位。</p><p>根据IEEE754的标准，双精度浮点数中的占位分为3个部分</p><img src="https://i.loli.net/2021/05/12/MtiLfeyuD4wZoGx.jpg" ><p>这三个部分组成这样一个公式</p><img src="https://i.loli.net/2021/05/12/fokFy5Qp2VmYnqP.jpg" ><p><strong>第一部分：</strong><br>Sign-符号位，长度是1，0是整数，1是负数</p><p><strong>第二部分：</strong><br>Exponent-指数位，长度是11，取值范围是[0,2047]（也可以说是0 ~ 2^11-1），本身是无符号位，取值范围是[0,2047]</p><p><strong>第三部分</strong><br>Mantissa-尾数，长度是52，取值范围是[0, 2^53-1]</p><p>根据第二部分的描述，我们可以把公式优化成这样：</p><img src="https://i.loli.net/2021/05/12/CpJmeGOixKycjhb.jpg" ><p>看完这两个公式，可能有同学开始疑惑了？？？</p><p>为什么需要M+1 ？</p><p>公式是遵循科学计数法规范的，我们常见的科学计数法是这样的</p><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">2021</span>;<span class="hljs-comment">// =&gt; 2.21 * 10^3</span><span class="hljs-comment">// =&gt; 2.21E3;</span></code></pre><p>二进制中的科学计数法则是这样的</p><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> a = <span class="hljs-string">&quot;101011000&quot;</span>;<span class="hljs-comment">// =&gt; 1.01011 * 2^8</span><span class="hljs-comment">// 去除整数部分的1后，剩余 M=01011</span><span class="hljs-comment">// 整数部分只能为1，满足 0 &lt; N &lt; 2</span><span class="hljs-comment">// M 是去除1之后剩下的部分，最终计算时需要加回来，所以会有 M+1</span></code></pre><p>为什么需要E-1023 ？</p><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> a = <span class="hljs-string">&quot;101011000&quot;</span>;<span class="hljs-comment">// =&gt; 1.01011 * 2^8</span><span class="hljs-comment">// E本身是无符号位，取值范围是[0,2047]，但是指数可以是负数</span><span class="hljs-comment">// 所以IEEE754标准规定，对于E为11位的情况，中间数是 2^10-1=1023</span><span class="hljs-comment">// 正数和负数各占1023个数字</span></code></pre><p>所以E的实际取值范围分为负数[0,1022]，正数[1024,2047]</p><p>举个例子</p><pre><code class="hljs javaScript"><span class="hljs-comment">// 举一个我们常用的十进制数字</span><span class="hljs-keyword">const</span> num = <span class="hljs-number">8080</span>;<span class="hljs-comment">// 这个数字转成二进制之后</span><span class="hljs-keyword">const</span> numDec = num.toString(<span class="hljs-number">2</span>);<span class="hljs-comment">// =&gt; 1111110010000</span><span class="hljs-comment">// 用科学计数法表示</span><span class="hljs-comment">// =&gt; 1.111110010000 * 2^12</span><span class="hljs-comment">// E = 12 + 1023 =&gt; 10000001011</span><span class="hljs-comment">// M = 111110010000&#123;000...000补全到52位&#125;</span><span class="hljs-comment">// 结果如下图</span></code></pre><img src="https://i.loli.net/2021/05/12/5cnlKYbfitAZ4vF.jpg" ><p><strong>0.1 + 0.2 === 0.3 ？</strong><br>大家一定经常看到 0.1 + 0.2 这样的送命题，也知道结果肯定不等于0.3</p><p>相似的问题还有</p><p>0.1 + 0.7 === 0.8 ？</p><p>0.2 + 0.4 === 0.6 ？</p><p>等等…</p><p><strong>问题出现的原因</strong><br>在我们了解完JS的Number存储机制后，我们分析一下0.1+0.2中出现的问题</p><p>先分析0.1</p><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">0.1</span>;<span class="hljs-comment">// 转为二进制</span><span class="hljs-keyword">const</span> aDec = a.toString(<span class="hljs-number">2</span>)<span class="hljs-comment">// =&gt; 0.000110011001100110011001100110011001100110011001100110011001100&#123;后面循环1100&#125;</span><span class="hljs-comment">// 0.1转为二进制时因为有无限循环，在获取尾数时，第53位需要判断是否为1来进行进位，存在精度丢失</span><span class="hljs-comment">// 因为第53位为1的缘故，最后得到的二进制会比真实的0.1要大</span><span class="hljs-comment">// =&gt; 11001100110011001100110011001100110011001100110011010 * 2^-4</span><span class="hljs-comment">// 转换回十进制后</span><span class="hljs-comment">// =&gt; 1.00000000000000005551115123126E-1</span><span class="hljs-comment">// =&gt; 0.100000000000000005551115123126 &gt; 0.1</span></code></pre><p>同理 0.2 也会进行一样的操作</p><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">0.2</span>;<span class="hljs-comment">// 转为二进制</span><span class="hljs-keyword">const</span> aDec = a.toString(<span class="hljs-number">2</span>)<span class="hljs-comment">// =&gt; 0.001100110011001100110011001100110011001100110011001101&#123;后面循环0011&#125;</span><span class="hljs-comment">// 0.2转为二进制时因为有无限循环，在获取尾数时，第53位需要判断是否为1来进行进位，存在精度丢失</span><span class="hljs-comment">// 因为第53位为1的缘故，最后得到的二进制会比真实的0.1要大</span><span class="hljs-comment">// =&gt; 1100110011001100110011001100110011001100110011001101 * 2^-3</span><span class="hljs-comment">// 转换回十进制后</span><span class="hljs-comment">// =&gt; 2.00000000000000011102230246252E-1</span><span class="hljs-comment">// =&gt; 0.200000000000000011102230246252 &gt; 0.2</span></code></pre><p>0.1+0.2 ===</p><p>0.100000000000000005551115123126 + 0.200000000000000011102230246252 ===</p><p>0.30000000000000004</p><p>到这里真实应该都大白了(●—●)</p><p>最大安全数为什么是 2^53-1<br>JavaScript 中的 API 都是精度安全的吗？</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/371530318">JavaScript-深入理解浮点数精度问题-Ninnka</a><br><a href="https://github.com/camsong/blog/issues/9">JavaScript 浮点数陷阱及解法</a><br><a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html">浮点数的二进制表示</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTMLCSS</title>
    <link href="/2021/03/31/interview/HTML&amp;CSS/"/>
    <url>/2021/03/31/interview/HTML&amp;CSS/</url>
    
    <content type="html"><![CDATA[<p>1.手写图片瀑布流效果<br>2.使用CSS绘制几何图形（圆形、三角形、扇形、菱形等）<br>3.使用纯CSS实现曲线运动（贝塞尔曲线）<br>4.实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点</p><h3 id="1-三栏布局"><a href="#1-三栏布局" class="headerlink" title="1 三栏布局"></a>1 三栏布局</h3><pre><code class="hljs HTML"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">dir</span>=<span class="hljs-string">&quot;ltr&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>test1<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen&quot;</span>&gt;</span><span class="css">      <span class="hljs-selector-class">.left</span> &#123;</span>        width: 300px;        background-color: blue;        height: 200px;        text-align: center;      &#125;<span class="css">      <span class="hljs-selector-class">.center</span> &#123;</span><span class="css">        <span class="hljs-selector-tag">background-color</span>: <span class="hljs-selector-id">#ccc</span>;</span>        height: 200px;        text-align: center;      &#125;<span class="css">      <span class="hljs-selector-class">.right</span> &#123;</span>        text-align: center;        width: 300px;        background-color: red;        height: 200px;      &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 浮动 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sec1&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen&quot;</span>&gt;</span><span class="css">        <span class="hljs-selector-class">.sec1</span> <span class="hljs-selector-class">.left</span> &#123;</span>          float: left;        &#125;<span class="css">        <span class="hljs-selector-class">.sec1</span> <span class="hljs-selector-class">.right</span> &#123;</span>          float: right;        &#125;      <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>浮动 ： center--center--center--<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 绝对定位 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sec2&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen&quot;</span>&gt;</span><span class="css">      <span class="hljs-selector-class">.sec2</span> &#123;</span>        margin-top: 20px;        position: relative;      &#125;<span class="css">      <span class="hljs-selector-class">.sec2</span> &gt; <span class="hljs-selector-tag">div</span> &#123;</span>        position: absolute;      &#125;<span class="css">      <span class="hljs-selector-class">.sec2</span> <span class="hljs-selector-class">.left</span> &#123;</span>        left: 0;      &#125;<span class="css">      <span class="hljs-selector-class">.sec2</span> <span class="hljs-selector-class">.right</span> &#123;</span>        right: 0;      &#125;<span class="css">      <span class="hljs-selector-class">.sec2</span> <span class="hljs-selector-class">.center</span> &#123;</span>        left: 300px;        right: 300px;      &#125;      <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>绝对定位 ： center--center--center--<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>     <span class="hljs-comment">&lt;!-- flex布局 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sec3&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen&quot;</span>&gt;</span><span class="css">        <span class="hljs-selector-class">.sec3</span> &#123;</span>          margin-top: 240px;          display: flex;        &#125;<span class="css">        <span class="hljs-selector-class">.sec3</span> <span class="hljs-selector-class">.center</span> &#123;</span>          flex: 1;        &#125;      <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>flex : center--center--center--<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 表格布局 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sec4&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen&quot;</span>&gt;</span><span class="css">        <span class="hljs-selector-class">.sec4</span> &#123;</span>          margin-top: 20px;          display: table;          width: 100%        &#125;<span class="css">        <span class="hljs-selector-class">.sec4</span> &gt; <span class="hljs-selector-tag">div</span> &#123;</span>          display: table-cell;        &#125;      <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>表格布局 : center--center--center--<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 网格布局 --&gt;</span>    <span class="hljs-comment">&lt;!-- CSS3下一代标准 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sec5&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen&quot;</span>&gt;</span><span class="css">        <span class="hljs-selector-class">.sec5</span> &#123;</span>          margin-top: 20px;          display: grid;          width: 100%;<span class="css">          <span class="hljs-comment">/* grid-template-rows: 100px; */</span></span>          grid-template-columns: 300px auto 300px;        &#125;      <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>网格布局 : center--center--center--<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><span class="hljs-comment">&lt;!--</span><span class="hljs-comment">1、以上各种布局的优缺点，以及比较推荐哪一种方案</span><span class="hljs-comment">  (1)浮动 :</span><span class="hljs-comment">    - 缺点 :浮动是脱离文档流的，有些时候需要清除浮动，需要很好的处理浮动周边元素的关系</span><span class="hljs-comment">    - 优点 :兼容性比较好</span><span class="hljs-comment">  (2)绝对定位 :</span><span class="hljs-comment">    - 缺点 :该布局脱离文档流，所以子元素也必须脱离文档流，因此可使用性比较差</span><span class="hljs-comment">    - 优点 :快捷，比较不容易出问题</span><span class="hljs-comment">  (3)flex :</span><span class="hljs-comment">    - 缺点 :兼容性比较差(css3的属性)，不兼容IE8及以下</span><span class="hljs-comment">    - 优点 :非常有效的解决了浮动和绝对定位的问题</span><span class="hljs-comment">  (4)表格布局 :</span><span class="hljs-comment">    - 缺点 :操作繁琐，当三栏中其中某一栏高度超出时，其他两栏的高度也会自动跟着调整(不符合某些场景)</span><span class="hljs-comment">    - 优点 :兼容性非常好，补缺了flex布局兼容的问题</span><span class="hljs-comment">  (5)网格布局 :</span><span class="hljs-comment">    - 新技术，CSS3下一代局部方案</span><span class="hljs-comment">2、如果去掉&quot;高度已知&quot;， 以上哪种方案同样适用？</span><span class="hljs-comment">  只有 flex布局 和 表格布局 同样适用 </span><span class="hljs-comment"> --&gt;</span></code></pre><h3 id="2-水平垂直居中"><a href="#2-水平垂直居中" class="headerlink" title="2 水平垂直居中"></a>2 水平垂直居中</h3><p>（1）绝对定位+margin:auto</p><pre><code class="hljs CSS"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<span class="hljs-attribute">background</span>: green;<span class="hljs-attribute">position</span>: absolute;<span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">margin</span>: auto;&#125;</code></pre><p>(2) 绝对定位+负margin</p><pre><code class="hljs CSS"><span class="hljs-selector-tag">div</span>&#123;<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<span class="hljs-attribute">background</span>: green;<span class="hljs-attribute">position</span>: absolute;<span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100px</span>;<span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">100px</span>;&#125;</code></pre><p>(3) 绝对定位+transform</p><pre><code class="hljs CSS"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<span class="hljs-attribute">background</span>: green;<span class="hljs-attribute">position</span>: absolute;<span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;    <span class="hljs-comment">/* 定位父级的50% */</span><span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>); <span class="hljs-comment">/*自己的50% */</span>&#125;</code></pre><p>(4) flex布局</p><pre><code class="hljs CSS"><span class="hljs-selector-class">.box</span> &#123;      <span class="hljs-attribute">height</span>:<span class="hljs-number">600px</span>;              <span class="hljs-attribute">display</span>:flex;      <span class="hljs-attribute">justify-content</span>:center;  <span class="hljs-comment">/* 子元素水平居中 */</span>      <span class="hljs-attribute">align-items</span>:center;      <span class="hljs-comment">/* 子元素垂直居中 */</span>      <span class="hljs-comment">/* 只要三句话就可以实现不定宽高水平垂直居中 */</span> &#125; <span class="hljs-selector-class">.box</span>&gt;<span class="hljs-selector-tag">div</span>&#123;     <span class="hljs-attribute">background</span>: green;     <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;     <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>; &#125;</code></pre><p>(5) table-cell实现居中</p><pre><code class="hljs CSS"><span class="hljs-selector-class">.box</span> &#123;    <span class="hljs-attribute">display</span>: table-cell;<span class="hljs-attribute">text-align</span>: center;<span class="hljs-attribute">vertical-align</span>: middle;&#125;</code></pre><h3 id="3-BFC"><a href="#3-BFC" class="headerlink" title="3 BFC"></a>3 BFC</h3><p>三种文档流的定位方案：</p><p>常规流(Normal flow)</p><ul><li>在常规流中，盒一个接着一个排列;</li><li>在块级格式化上下文里面， 它们竖着排列；</li><li>在行内格式化上下文里面， 它们横着排列;</li><li>当position为static或relative，并且float为none时会触发常规流；</li><li>对于静态定位(static positioning)，position: static，盒的位置是常规流布局里的位置；</li><li>对于相对定位(relative positioning)，position: relative，盒偏移位置由top、bottom、left、right属性定义。即使有偏移，仍然保留原有的位置，其它常规流不能占用这个位置。</li></ul><p>浮动(Floats)</p><ul><li>左浮动元素尽量靠左、靠上，右浮动同理</li><li>这导致常规流环绕在它的周边，除非设置 clear 属性</li><li>浮动元素不会影响块级元素的布局</li><li>但浮动元素会影响行内元素的布局，让其围绕在自己周围，撑大父级元素，从而间接影响块级元素布局</li><li>最高点不会超过当前行的最高点、它前面的浮动元素的最高点</li><li>不超过它的包含块，除非元素本身已经比包含块更宽</li><li>行内元素出现在左浮动元素的右边和右浮动元素的左边，左浮动元素的左边和右浮动元素的右边是不会摆放浮动元素的</li></ul><p>绝对定位(Absolute positioning)</p><ul><li>绝对定位方案，盒从常规流中被移除，不影响常规流的布局；</li><li>它的定位相对于它的包含块，相关CSS属性：top、bottom、left、right；</li><li>如果元素的属性position为absolute或fixed，它是绝对定位元素；</li><li>对于position: absolute，元素定位将相对于上级元素中最近的一个relative、fixed、absolute，如果没有则相对于body；</li></ul><p>BFC触发方式：</p><ul><li>根元素，即HTML标签</li><li>浮动元素：float值为left、right</li><li>overflow值不为 visible，为 auto、scroll、hidden</li><li>display值为 inline-block、table-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid</li><li>定位元素：position值为 absolute、fixed</li></ul><p>浏览器对BFC区域的约束规则：</p><ul><li>内部的Box会在垂直方向上一个接一个的放置</li><li>内部的Box垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生折叠，不同BFC不会发生折叠。）</li><li>每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）</li><li>BFC的区域不会与float的元素区域重叠</li><li>计算BFC的高度时，浮动子元素也参与计算</li></ul><p>作用：</p><ul><li>BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素</li><li>阻止元素被浮动元素覆盖<br>一个正常文档流的block元素可能被一个float元素覆盖，挤占正常文档流，因此可以设置一个元素的float、display、position值等方式触发BFC，以阻止被浮动盒子覆盖。</li><li>可以包含浮动元素<br>通过改变包含浮动子元素的父盒子的属性值，触发BFC，以此来包含子元素的浮动盒子。</li><li>阻止因为浏览器因为四舍五入造成的多列布局换行的情况<br>有时候因为多列布局采用小数点位的width导致因为浏览器因为四舍五入造成的换行的情况，可以在最后一列触发BFC的形式来阻止换行的发生。</li><li>阻止相邻元素的margin合并<br>属于同一个BFC的两个相邻块级子元素的上下margin会发生重叠，所以当两个相邻块级子元素分属于不同的BFC时可以阻止margin重叠</li></ul><p>BFC、IFC、GFC、FFC：</p><ul><li>BFC BFC(Block Formatting Contexts)直译为”块级格式化上下文”。Block Formatting Contexts就是页面上的一个隔离的渲染区域，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此。如何产生BFC？ float的值不为none。  overflow的值不为visible。  position的值不为relative和static。 display的值为table-cell,table-caption, inline-block中的任何一个。  那BFC一般有什么用呢？比如常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行。 </li><li>IFC IFC(Inline Formatting Contexts)直译为”内联格式化上下文”，IFC的line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的padding/margin影响) IFC中的line box一般左右都贴紧整个IFC，但是会因为float元素而扰乱。float元素会位于IFC与与line box之间，使得line box宽度缩短。 同个ifc下的多个line box高度会不同。<br>IFC中时不可能有块级元素的，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。 那么IFC一般有什么用呢？ 水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。 垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</li><li>GFC GFC(GridLayout Formatting Contexts)直译为”网格布局格式化上下文”，当为一个元素设置display值为grid的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid<br>columns）为每一个网格项目（grid item）定义位置和空间。  那么GFC有什么用呢，和table又有什么区别呢？首先同样是一个二维的表格，但GridLayout会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。 </li><li>FFC FFC(Flex Formatting Contexts)直译为”自适应格式化上下文”，display值为flex或者inline-flex的元素将会生成自适应容器（flex container），可惜这个牛逼的属性只有谷歌和火狐支持，不过在移动端也足够了，至少safari和chrome还是OK的，毕竟这俩在移动端才是王道。 Flex Box 由伸缩容器和伸缩项目组成。通过设置元素的 display 属性为 flex 或 inline-flex<br>可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。 伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flexbox 定义了伸缩容器内伸缩项目该如何布局。</li></ul><h3 id="4-选择器和权重"><a href="#4-选择器和权重" class="headerlink" title="4 选择器和权重"></a>4 选择器和权重</h3><p>选择器分类：</p><ul><li>id选择器 #id { }</li><li>类选择器 .link { }</li><li>元素选择器 a { }</li><li>属性选择器  [ type = radio ] { }</li><li>伪元素选择器  ::before { }</li><li>伪类选择器  :hover { }</li><li>否定选择器 :not ( .link ) { }</li><li>通用选择器  * { }</li><li>组合选择器  [ type = radio] + babel { }</li></ul><p>同样的方式权重计算规则：</p><ul><li>id选择器 #id { }    +100</li><li>类/属性/伪类       +10</li><li>元素/伪元素        +1</li><li>其他选择器         +0</li></ul><p>不同方式的权重计算规则：</p><ul><li>!important 优先级最高</li><li>元素属性的内联样式 优先级高</li><li>相同权重 后写的生效</li></ul><h3 id="5-超过省略号"><a href="#5-超过省略号" class="headerlink" title="5 超过省略号"></a>5 超过省略号</h3><pre><code class="hljs CSS"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">overflow</span>: hidden;<span class="hljs-attribute">white-space</span>: nowrap;<span class="hljs-attribute">text-overflow</span>: ellipsis;&#125;</code></pre><pre><code class="hljs CSS"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">overflow</span>: hidden;<span class="hljs-attribute">text-overflow</span>: ellipsis;<span class="hljs-attribute">display</span>: -webkit-box;<span class="hljs-attribute">-webkit-line-clamp</span>: <span class="hljs-number">2</span>;  <span class="hljs-comment">/* 控制多行的行数 */</span><span class="hljs-comment">/* ! autoprefixer: off */</span><span class="hljs-attribute">-webkit-box-orient</span>: vertical;<span class="hljs-comment">/* autoprefixer: on */</span>&#125;</code></pre><h3 id="6-上中下三栏布局"><a href="#6-上中下三栏布局" class="headerlink" title="6 上中下三栏布局"></a>6 上中下三栏布局</h3><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>headerBodyFooter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>body &#123;margin: 0;padding: 0;&#125;<span class="css"><span class="hljs-selector-class">.content</span> &#123;</span>min-height: 100vh;display: flex;flex-direction: column;text-align: center;&#125;<span class="css"><span class="hljs-selector-class">.head</span> &#123;</span>height: 100px;position: fixed;width: 100%;    top: 0;background-color: cadetblue;&#125;<span class="css"><span class="hljs-selector-class">.center</span> &#123;</span>flex-grow: 1;margin-top: 100px;background-color: mediumspringgreen;&#125;<span class="css"><span class="hljs-selector-class">.footer</span> &#123;</span>height: 100px;background-color: gold;&#125;<span class="css"><span class="hljs-selector-class">.center-1</span> &#123;</span>height: 200px;&#125;<span class="css"><span class="hljs-selector-class">.center-2</span> &#123;</span>height: 900px;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;head&quot;</span>&gt;</span>head<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>center<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center-1&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center-2&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span>footer<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>HTMLCSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js-性能优化</title>
    <link href="/2021/03/11/interview/js-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2021/03/11/interview/js-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="一-网络层面"><a href="#一-网络层面" class="headerlink" title="一 网络层面"></a>一 网络层面</h2><h3 id="1-减少-HTTP-请求"><a href="#1-减少-HTTP-请求" class="headerlink" title="1 减少 HTTP 请求"></a>1 减少 HTTP 请求</h3><p>通过 <code>webpack</code> 打包的方式，对文件压缩和图片合并。</p><p>一个完整的 HTTP 请求需要经历 <strong>DNS 查找 -&gt; TCP 握手 -&gt; 浏览器发出 HTTP 请求 -&gt; 服务器接收请求 -&gt; 服务器处理请求并发回响应 -&gt; 浏览器接收响应</strong>等过程。接下来看一个具体的例子帮助理解 HTTP</p><h3 id="2-使用-HTTP2"><a href="#2-使用-HTTP2" class="headerlink" title="2 使用 HTTP2"></a>2 使用 HTTP2</h3><ul><li><strong>二进制分帧</strong> —— 不再需要像 <code>HTTP1.1</code> 那样不断地读入字节，直到遇到分隔符 <code>CRLF</code> 为止。<code>HTTP2</code> 是基于帧的协议，每个帧都有表示帧长度的字段。</li><li><strong>多路复用</strong> —— <code>HTTP1.1</code> 如果要同时发起多个请求，就得建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 <code>HTTP1.1</code> 的请求。在 <code>HTTP2</code> 上，多个请求可以共用一个 TCP 连接，同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。并且可以乱序发送，到达目的地后再通过流 ID 重新组建。</li><li><strong>首部压缩</strong> —— <code>HTTP/2</code> 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送。当客户端发送请求时，它会根据首部值创建一张表，如果服务器收到了请求，它会照样创建一张表。当客户端发送下一个请求的时候，如果首部相同，客户端只需要发送表的索引，服务端按照表的索引查找并还原成完整首部。</li><li><strong>优先级</strong> —— <code>HTTP2</code> 可以对比较紧急的请求设置一个较高的优先级，服务器在收到这样的请求后，可以优先处理。</li><li><strong>服务器推送</strong> —— 服务器根据所客户端需要的资源，主动向客户端推送资源，而无需客户端明确地请求。</li></ul><h3 id="3-使用服务端渲染"><a href="#3-使用服务端渲染" class="headerlink" title="3 使用服务端渲染"></a>3 使用服务端渲染</h3><ul><li>优点：首屏渲染快，SEO 好</li><li>缺点：配置麻烦，增加了服务器的计算压力</li></ul><h3 id="4-静态资源使用-CDN"><a href="#4-静态资源使用-CDN" class="headerlink" title="4 静态资源使用 CDN"></a>4 静态资源使用 CDN</h3><p>在多个位置部署 CDN 服务器，让用户离服务器更近，从而缩短请求时间。</p><h3 id="5-善用缓存，不重复加载相同的资源"><a href="#5-善用缓存，不重复加载相同的资源" class="headerlink" title="5 善用缓存，不重复加载相同的资源"></a>5 善用缓存，不重复加载相同的资源</h3><p>对于不经常修改的文件使用强缓存: <code>Expires:12 Mar 2021 14:36:50 GMT</code> 或者 <code>Cache-Control: max-age=300</code><br>可能会修改变动的文件使用协商缓存: <code>Last-Modified / If-Modified-Since</code> 或者 <code>ETag / If-None-Match</code></p><h2 id="二-打包层面"><a href="#二-打包层面" class="headerlink" title="二 打包层面"></a>二 打包层面</h2><h3 id="1-减少-ES6-转为-ES5-的冗余代码"><a href="#1-减少-ES6-转为-ES5-的冗余代码" class="headerlink" title="1 减少 ES6 转为 ES5 的冗余代码"></a>1 减少 ES6 转为 ES5 的冗余代码</h3><p><code>@babel/runtime</code> 包声明了所有需要用到的帮助函数，而 <code>@babel/plugin-transform-runtime</code> 的作用就是将所有需要 <code>helper</code> 函数的文件，从 <code>@babel/runtime</code> 包 引进来.</p><pre><code class="hljs javaScript"><span class="hljs-comment">// 在 .babelrc 文件中</span><span class="hljs-string">&quot;plugins&quot;</span>: [<span class="hljs-string">&quot;@babel/plugin-transform-runtime&quot;</span>]</code></pre><h3 id="2-压缩文件"><a href="#2-压缩文件" class="headerlink" title="2 压缩文件"></a>2 压缩文件</h3><p>webpack 可以使用如下插件进行压缩：</p><ul><li><code>JavaScript：UglifyPlugin</code></li><li><code>CSS ：MiniCssExtractPlugin</code></li><li><code>HTML：HtmlWebpackPlugin</code></li></ul><p>或者使用 gzip 压缩。可以通过向 HTTP 请求头中的 <code>Accept-Encoding</code> 头添加 gzip 标识来开启这一功能，但是服务器也得支持这一功能。</p><pre><code class="hljs javaScript"><span class="hljs-comment">// webpack 配置</span><span class="hljs-keyword">const</span> CompressionPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;compression-webpack-plugin&#x27;</span>);<span class="hljs-built_in">module</span>.exports = &#123;  plugins: [<span class="hljs-keyword">new</span> CompressionPlugin()],&#125;<span class="hljs-comment">// node 层配置</span><span class="hljs-keyword">const</span> compression = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;compression&#x27;</span>)<span class="hljs-comment">// 在其他中间件前使用</span>app.use(compression())</code></pre><h3 id="3-根据文件内容生成文件名，结合-import-动态引入组件实现按需加载"><a href="#3-根据文件内容生成文件名，结合-import-动态引入组件实现按需加载" class="headerlink" title="3 根据文件内容生成文件名，结合 import 动态引入组件实现按需加载"></a>3 根据文件内容生成文件名，结合 import 动态引入组件实现按需加载</h3><p>通过配置 output 的 filename 属性可以实现这个需求。filename 属性的值选项中有一个 [contenthash]，它将根据文件内容创建出唯一 hash。当文件内容发生变化时，[contenthash] 也会发生变化。</p><h3 id="4-提取第三方库"><a href="#4-提取第三方库" class="headerlink" title="4 提取第三方库"></a>4 提取第三方库</h3><p>打包时提取公共代码和第三方库<br><code>optimization - splitChunks - cacheGroups - &#123; vendor, common&#125;</code></p><h3 id="5-图片压缩"><a href="#5-图片压缩" class="headerlink" title="5 图片压缩"></a>5 图片压缩</h3><p>打包时降低图片质量。<br>将图片切成 JPG 格式，并且将它压缩到 60% 的质量，基本上看不出来区别。<br>压缩方法有两种，一是通过 webpack 插件 <code>image-webpack-loader</code> ，二是通过在线网站进行压缩。</p><h2 id="三-代码层面"><a href="#三-代码层面" class="headerlink" title="三 代码层面"></a>三 代码层面</h2><h3 id="1-图片优化"><a href="#1-图片优化" class="headerlink" title="1 图片优化"></a>1 图片优化</h3><h4 id="1-图片延迟加载"><a href="#1-图片延迟加载" class="headerlink" title="(1) 图片延迟加载"></a>(1) 图片延迟加载</h4><p>先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片.</p><pre><code class="hljs javaScript"><span class="hljs-comment">// 通过设置 data-src 来保存真实的 src 图片地址</span>&lt;img data-src=<span class="hljs-string">&quot;https://cdn.xxx....&quot;</span> /&gt;<span class="hljs-comment">// 等页面可见时，使用 JS 加载图片：</span><span class="hljs-keyword">const</span> img = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;img&#x27;</span>)img.src = img.dataset.src<span class="hljs-comment">// 判断图片是否显示</span><span class="hljs-keyword">let</span> coords = el.getBoundingClientRect();  <span class="hljs-keyword">return</span> (coords.left &gt;= <span class="hljs-number">0</span> &amp;&amp; coords.left &gt;= <span class="hljs-number">0</span> &amp;&amp; coords.top)&lt;= (<span class="hljs-built_in">document</span>.documentElement.clientHeight || <span class="hljs-built_in">window</span>.innerHeight) + <span class="hljs-built_in">parseInt</span>(offset);<span class="hljs-comment">// getBoundingClientRect: 元素的上下左右分别相对浏览器视窗的位置</span><span class="hljs-comment">// document.querySelector(&#x27;div&#x27;).clientWidth  可视区域的宽度（包括padding，不包括滚动条）</span><span class="hljs-comment">// document.querySelector(&#x27;div&#x27;).offsetWidth  可视区域的宽度（包括padding、border、滚动条）</span><span class="hljs-comment">// document.querySelector(&#x27;div&#x27;).scrollWidth  实际内容的宽度（可视区域宽度+被隐藏区域宽度）</span></code></pre><h4 id="2-响应式图片"><a href="#2-响应式图片" class="headerlink" title="(2) 响应式图片"></a>(2) 响应式图片</h4><p>可以通过 <code>picture</code> 标签 或者 媒体查询(<code>@media</code>) 实现</p><pre><code class="hljs javaScript"><span class="hljs-comment">// picture 标签</span>&lt;picture&gt;    &lt;source srcset=<span class="hljs-string">&quot;banner_w1000.jpg&quot;</span> media=<span class="hljs-string">&quot;(min-width: 801px)&quot;</span>&gt;    &lt;source srcset=<span class="hljs-string">&quot;banner_w800.jpg&quot;</span> media=<span class="hljs-string">&quot;(max-width: 800px)&quot;</span>&gt;    &lt;img src=<span class="hljs-string">&quot;banner_w800.jpg&quot;</span> alt=<span class="hljs-string">&quot;&quot;</span>&gt;&lt;/picture&gt;</code></pre><h4 id="3-使用-webp-格式的图片"><a href="#3-使用-webp-格式的图片" class="headerlink" title="(3) 使用 webp 格式的图片"></a>(3) 使用 webp 格式的图片</h4><p>如果能通过服务器端判断浏览器支持WebP就用WebP或SVG格式(颜色数多用JPG格式，而很少使用PNG格式)。<br>Chrome浏览器完全兼容，但是 IE、Firefox、Safari完全不支持。<br>WebP 具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。</p><p>PNG/JPG：无损 webp 体积减少 40% 左右，有损 webp 图片体积减少 75% 左右<br>GIF：无损 webp 体积减少 88% 左右</p><h4 id="4-小图片转-base64"><a href="#4-小图片转-base64" class="headerlink" title="(4) 小图片转 base64"></a>(4) 小图片转 base64</h4><p>在 <code>url-loader</code> 中增加 options 配置，指定 limit，图片转 base64 的图片大小</p><h4 id="5-使用-iconfont-代替图片图标"><a href="#5-使用-iconfont-代替图片图标" class="headerlink" title="(5) 使用 iconfont 代替图片图标"></a>(5) 使用 iconfont 代替图片图标</h4><p>icon-font 字体图标是矢量图，不会失真，还有一个优点是生成的文件特别小。<br>压缩字体文件：使用 fontmin-webpack 插件对字体文件进行压缩。</p><h4 id="6-为图片标明高度和宽度"><a href="#6-为图片标明高度和宽度" class="headerlink" title="(6) 为图片标明高度和宽度"></a>(6) 为图片标明高度和宽度</h4><p>如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小。如果图片很多，浏览器需要不断地调整页面。这不但影响速度，而且影响浏览体验。当浏览器知道高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容，从而优化加载时间，提升浏览体验。</p><h4 id="7-CSS-Sprite-图精灵、雪碧图"><a href="#7-CSS-Sprite-图精灵、雪碧图" class="headerlink" title="(7) CSS Sprite(图精灵、雪碧图)"></a>(7) CSS Sprite(图精灵、雪碧图)</h4><h3 id="2-Js-CSS-代码优化"><a href="#2-Js-CSS-代码优化" class="headerlink" title="2 Js/CSS 代码优化"></a>2 Js/CSS 代码优化</h3><h4 id="1-减少重绘重排"><a href="#1-减少重绘重排" class="headerlink" title="(1) 减少重绘重排"></a>(1) 减少重绘重排</h4><p>浏览器渲染过程：<br>1 解析HTML生成DOM树<br>2 解析CSS生成CSSOM规则树<br>3 将DOM树与CSSOM规则树合并在一起生成渲染树<br>4 遍历渲染树开始布局，计算每个节点的位置大小信息<br>5 将渲染树每个节点绘制到屏幕</p><p>重排: 当改变 DOM 元素位置或大小时，会导致浏览器重新生成渲染树.<br>重绘: 当重新生成渲染树后，就要将渲染树每个节点绘制到屏幕，这个过程叫重绘。</p><p>重排和重绘这两个操作都是非常昂贵的，因为 JavaScript 引擎线程与 GUI 渲染线程是互斥，它们同时只能一个在工作。</p><p>什么操作会导致重排: 添加或删除可见的 DOM 元素、元素位置改变、元素尺寸改变、内容改变、浏览器窗口尺寸改变<br>什么操作会导致重绘: 改变字体颜色、改变背景色 等等</p><p>如何减少重排重绘：<br>1 避免逐项更改样式。最好一次性更改style属性，或者将样式列表定义为class并一次性更改class属性<br>2 避免循环操作DOM。 可以在一个display:none的元素上进行操作，最终把它显示出来。因为<code>display:none</code>上的DOM操作不会引发重排和重绘。<br>3 避免循环读取<code>offsetLeft</code>等属性。在循环之前把它们存起来。读取<code>offsetWidth</code>等属性值，会会强制浏览器刷新队列，先回流重排，在计算结果。<br>4 绝对定位具有复杂动画的元素。绝对定位使它脱离文档流，否则会引起父元素及后续元素大量的重排。<br>5 尽量使用 <code>CSS3</code> 提供的功能实现动画效果，比如 <code>transform、opacity、filters</code>，CSS 使用了硬件加速(GPU 加速)。</p><p>CSS最终的表现分为四步：<code>Recalculate([ri:&#39;kælkjuleit]) Style</code> -&gt; <code>Layout</code> -&gt; <code>Paint Setup and Paint</code> -&gt; <code>Composite Layers</code><br>按照中文的意思大致是：查找并计算样式 -&gt; 排列 -&gt; 绘制 -&gt; 组合层<br><code>transform</code>是位于<code>Composite Layers</code>（组合层），而<code>width、left、margin</code>等是位于<code>layout</code>（排列层），所以所以<code>transform</code>实现动画肯定比<code>left</code>这些更流畅。</p><h4 id="2-使用事件委托"><a href="#2-使用事件委托" class="headerlink" title="(2) 使用事件委托"></a>(2) 使用事件委托</h4><p>好处：<br>1 子元素增加或者删除时，可以避免重复操作绑定解绑等操作，因此可以减少重复与DOM的交互次数，提高性能，减少重绘与重排的次数<br>2 减少内存，只需要在父元素绑定一次事件</p><h4 id="3-if-else-对比-switch"><a href="#3-if-else-对比-switch" class="headerlink" title="(3) if-else 对比 switch"></a>(3) if-else 对比 switch</h4><p>当判断条件数量越来越多时，越倾向于使用 switch 而不是 if-else。<br>因为 if-else 语句要进行 多次 判断，switch 只需要进行一次判断。<br>或者将需要查找的遍历存放在一个数组、Object对象、Map对象中，可以直接通过key值索引到对应的value。</p><h4 id="4-不要覆盖原生方法"><a href="#4-不要覆盖原生方法" class="headerlink" title="(4) 不要覆盖原生方法"></a>(4) 不要覆盖原生方法</h4><p>无论你的 JavaScript 代码如何优化，都比不上原生方法。因为原生方法是用低级语言写的（C/C++），并且被编译成机器码，成为浏览器的一部分。当原生方法可用时，尽量使用它们，特别是数学运算和 DOM 操作。比如 js Math方法等</p><h4 id="5-降低-CSS-选择器的复杂性"><a href="#5-降低-CSS-选择器的复杂性" class="headerlink" title="(5) 降低 CSS 选择器的复杂性"></a>(5) 降低 CSS 选择器的复杂性</h4><ul><li>原则是从选择器的右边到左边读取 —— 因此当可以确定能准确查找到对象即可，不要过于复杂</li><li>CSS 选择器优先级 —— 优先级：内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器</li></ul><p>因此选择器越短越好，尽量使用高优先级的选择器，避免使用通配符 *<br>其实，CSS 选择器没有优化的必要，因为最慢和慢快的选择器性能差别非常小</p><h4 id="6-使用-requestAnimationFrame-来实现视觉变化"><a href="#6-使用-requestAnimationFrame-来实现视觉变化" class="headerlink" title="(6) 使用 requestAnimationFrame 来实现视觉变化"></a>(6) 使用 requestAnimationFrame 来实现视觉变化</h4><p>目前大多数设备的屏幕刷新率为 60 次/秒（60fps）,最好保持浏览器渲染动画或页面的每一帧的速率也需要跟设备屏幕的刷新率保持一致。<br>其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动，此现象通常称为卡顿。<br>假设某个动画其中的一帧花了 50 ms，那么此时的帧率为 1s / 50ms = 20fps，页面看起来就像卡顿了一样。<br>保证 JavaScript 在帧开始时运行的唯一方式是使用 requestAnimationFrame。</p><h4 id="7-将-CSS-放在文件头部，JavaScript-文件放在底部"><a href="#7-将-CSS-放在文件头部，JavaScript-文件放在底部" class="headerlink" title="(7) 将 CSS 放在文件头部，JavaScript 文件放在底部"></a>(7) 将 CSS 放在文件头部，JavaScript 文件放在底部</h4><p>所有放在 head 标签里的 CSS 和 JS 文件都会堵塞渲染。如果这些 CSS 和 JS 需要加载和解析很久的话，那么页面就空白了。所以 JS 文件要放在底部，等 HTML 解析完了再加载 JS 文件。<br>如果先加载 HTML 再加载 CSS，会让用户第一时间看到的页面是没有样式的、“丑陋”的，为了避免这种情况发生，就要将 CSS 文件放在头部了。<br>JS 文件也不是不可以放在头部，只要给 script 标签加上 defer 属性就可以了，异步下载，延迟执行。</p><h4 id="8-使用-Web-Worker"><a href="#8-使用-Web-Worker" class="headerlink" title="(8) 使用 Web Worker"></a>(8) 使用 Web Worker</h4><p>Web Worker 使用其他工作线程从而独立于主线程之外，它可以执行任务而不干扰用户界面。一个 worker 可以将消息发送到创建它的 JavaScript 代码, 通过将消息发送到该代码指定的事件处理程序（反之亦然）.</p><p>Web Worker 适用于那些处理纯数据，或者与浏览器 UI 无关的长时间运行脚本。</p><p>不过在worker内，不能直接操作DOM节点，也不能使用window对象的默认方法和属性。然而你可以使用大量window对象之下的东西，包括WebSockets，IndexedDB以及FireFox OS专用的Data Store API等数据存储机制。</p><h4 id="9-不滥用-Float"><a href="#9-不滥用-Float" class="headerlink" title="(9) 不滥用 Float"></a>(9) 不滥用 Float</h4><p>Float在渲染时计算量比较大，尽量少使用</p><h2 id="四-移动端性能如何优化"><a href="#四-移动端性能如何优化" class="headerlink" title="四 移动端性能如何优化"></a>四 移动端性能如何优化</h2><ul><li>尽量使用CSS3动画，开启硬件加速。</li><li>适当使用 touch事件代替 click事件。</li><li>避免使用CSS3渐变阴影效果。</li><li>可以用 transform:translateZ（0）来开启硬件加速。</li><li>不滥用 Float, Float在渲染时计算量比较大，尽量少使用。</li><li>不滥用 Web 字体，Web字体需要下载、解析、重绘当前页面，尽量少使用。</li><li>合理使用requestAnimation Frame动画代替 setTimeout。</li><li>合理使用CSS3中的属性（CSS3 transitions、CSS3 3D transforms、 Opacity、 Canvas、 WebGL、Video）触发GPU渲染。过度使用会使手机耗电量増加。</li></ul><p>H5秒开方案：</p><ul><li>降低请求量：合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。</li><li>加快请求速度：预解析DNS，减少域名数，并行加载，CDN 分发。</li><li>缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。</li><li>渲染：JS/CSS优化，加载顺序，服务端渲染模板直出。</li></ul><h2 id="五-优化首屏加载速度"><a href="#五-优化首屏加载速度" class="headerlink" title="五 优化首屏加载速度"></a>五 优化首屏加载速度</h2><ul><li>降低请求量：合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。</li><li>加快请求速度：预解析DNS，减少域名数，并行加载，CDN 分发。</li><li>缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。</li><li>渲染：JS/CSS优化，加载顺序，服务端渲染模板直出。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js-设计模式</title>
    <link href="/2021/03/09/interview/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/03/09/interview/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-设计模式6大原则"><a href="#1-设计模式6大原则" class="headerlink" title="1 设计模式6大原则"></a>1 设计模式6大原则</h3><ul><li>开放封闭原则</li><li>单一职责原则</li><li>里氏替换原则</li><li>依赖倒置原则</li><li>接口隔离原则</li><li>迪米特法则</li></ul><ol><li><p>开放封闭原则<br> 解释：<strong>对扩展开放，对修改关闭</strong><br> 核心：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化。<br> 好处：提高项目的稳定性、灵活性。</p></li><li><p>单一职责原则<br> 解释：<strong>实现类要职责单一，即一个类应该只负责一项职责</strong><br> 核心思想：应该有且仅有一个原因引起类的变更<br> 好处：降低了 类的复杂度 和 变更引起的风险，提高了 可读性、可维护性、扩展性<br> 需注意：单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可以度量的，因项目和环境而异。</p></li><li><p>里氏替换原则<br> 解释：<strong>在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类</strong><br> 说明：只要父类能出现的地方子类就能出现。反之，父类则未必能胜任。<br> 好处：增强程序的健壮性，即使增加了子类，原有的子类还可以继续运行。<br> 需注意：如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚合、组合等关系代替继承</p></li><li><p>依赖倒置原则<br>解释：<strong>通过抽象（接口或抽象类）使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合</strong><br> 说明：高层模块不应该依赖低层模块，二者都该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。<br> 高层模块就是调用端，低层模块就是具体实现类。抽象就是指接口或抽象类。细节就是实现类。<br> 好处：依赖倒置的好处在小型项目中很难体现出来。但在大中型项目中可以减少需求变化引起的工作量。使并行开发更友好。</p></li><li><p>接口隔离原则<br>解释：<strong>类间的依赖关系应该建立在最小的接口上，建立单一接口，不要建立庞大臃肿的接口</strong><br> 说明：接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。<br> 需注意：<strong>接口尽量小，但是要有限度</strong>（对接口进行细化可以提高程序设计灵活性，但是如果过小，则会造成接口数量过多，使设计复杂）；<strong>提高内聚，减少对外交互</strong>（使接口用最少的方法去完成最多的事情）；<strong>为依赖接口的类定制服务</strong>（只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。）</p></li><li><p>迪米特法则<br>解释：<strong>类间解耦，降低耦合</strong><br> 说明： 一个类对自己依赖的类知道的越少越好，即：低耦合，高内聚。使各个模块之间的耦合尽量的低，才能提高代码的复用率。</p></li></ol><h3 id="2-面向对象的基本特征"><a href="#2-面向对象的基本特征" class="headerlink" title="2 面向对象的基本特征"></a>2 面向对象的基本特征</h3><p>面向对象的三个基本特征是：<strong>封装、继承、多态</strong></p><ul><li><p>封装<br>封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p></li><li><p>继承<br>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。<br>要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。</p></li><li><p>多态性<br>多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。<br>实现多态，有两种方式，覆盖和重载。覆盖和重载的区别在于，覆盖在运行时决定，重载是在编译时决定。并且覆盖和重载的机制不同，例如在 Java 中，重载方法的签名必须不同于原先方法的，但对于覆盖签名必须相同。</p></li></ul><h3 id="3-常见设计模式"><a href="#3-常见设计模式" class="headerlink" title="3 常见设计模式"></a>3 常见设计模式</h3><h4 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="(1) 单例模式"></a>(1) 单例模式</h4><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>优点</p><ul><li>划分命名空间，减少全局变量</li><li>增强模块性，把自己的代码组织在一个全局变量名下，放在单一位置，便于维护</li><li>且只会实例化一次。简化了代码的调试和维护</li></ul><p>缺点</p><ul><li>由于单例模式提供的是一种单点访问，所以它有可能导致模块间的强耦合 从而不利于单元测试。无法单独测试一个调用了来自单例的方法的类，而只能把它与那个单例作为一个单元一起测试。</li></ul><p>场景例子</p><ul><li>定义命名空间和实现分支型方法</li><li>登录框</li><li>vuex 和 redux中的store</li></ul><pre><code class="hljs javaScript"><span class="hljs-comment">// 提取出通用的单例</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSingleton</span>(<span class="hljs-params">fn</span>) </span>&#123;<span class="hljs-keyword">var</span> instance = <span class="hljs-literal">null</span>;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">if</span> (!instance) &#123;instance = fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);&#125;<span class="hljs-keyword">return</span> instance;&#125;&#125;<span class="hljs-comment">// 构造函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name;<span class="hljs-built_in">this</span>.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;this.name:&#x27;</span>, <span class="hljs-built_in">this</span>.name);<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;&#125;<span class="hljs-built_in">this</span>.setName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name;&#125;&#125;<span class="hljs-comment">// 获取单例</span><span class="hljs-keyword">var</span> personSingleton = getSingleton(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(name);<span class="hljs-keyword">return</span> p;&#125;);<span class="hljs-keyword">const</span> p1 = personSingleton(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<span class="hljs-keyword">const</span> p2 = personSingleton(<span class="hljs-string">&#x27;lisi&#x27;</span>);<span class="hljs-keyword">const</span> p3 = personSingleton(<span class="hljs-string">&#x27;wangwu&#x27;</span>);p1.getName(); <span class="hljs-comment">// &#x27;zhangsan&#x27;</span>p2.getName(); <span class="hljs-comment">// &#x27;zhangsan&#x27;</span>p3.getName(); <span class="hljs-comment">// &#x27;zhangsan&#x27;</span><span class="hljs-built_in">console</span>.log(p1 === p2); <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(p2 === p3); <span class="hljs-comment">// true</span></code></pre><h4 id="2-观察者模式-发布订阅者模式"><a href="#2-观察者模式-发布订阅者模式" class="headerlink" title="(2) 观察者模式/发布订阅者模式"></a>(2) 观察者模式/发布订阅者模式</h4><p>定义了一种一对多的关系，让多个观察者对象同时监听某一个被观察对象，这个被观察对象的状态发生变化时就会通知所有的观察者对象。</p><p>优点</p><ul><li>支持简单的广播通信，自动通知所有已经订阅过的对象</li><li>目标对象与观察者之间的抽象耦合关系能单独扩展以及重用</li><li>增加了灵活性</li><li>观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。</li></ul><p>缺点</p><ul><li>过度使用会导致对象与对象之间的联系弱化，会导致程序难以跟踪维护和理解</li></ul><p>场景</p><ul><li>DOM事件 （document.body.addEventListener(‘click’, function(){}）</li><li>vue 响应式</li></ul><pre><code class="hljs javaScript"><span class="hljs-comment">// 对象：观察者/订阅者</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<span class="hljs-built_in">this</span>.name = name;&#125;<span class="hljs-function"><span class="hljs-title">update</span>(<span class="hljs-params">val</span>)</span> &#123;<span class="hljs-built_in">console</span>.log(val);&#125;&#125;<span class="hljs-comment">// 观察者模式</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-comment">// 观察者列表</span><span class="hljs-built_in">this</span>.observerList = [];&#125;<span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">observer</span>)</span> &#123;<span class="hljs-built_in">this</span>.observerList.push(observer);&#125;<span class="hljs-function"><span class="hljs-title">notify</span>(<span class="hljs-params">...args</span>)</span> &#123;<span class="hljs-built_in">this</span>.observerList.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.update(...args));&#125;&#125;<span class="hljs-keyword">const</span> s1 = <span class="hljs-keyword">new</span> Subject(); <span class="hljs-comment">// 创建一个观察对象</span>s1.add(<span class="hljs-keyword">new</span> Observer(<span class="hljs-string">&#x27;zhangsan&#x27;</span>)); <span class="hljs-comment">// 添加一个观察者</span>s1.add(<span class="hljs-keyword">new</span> Observer(<span class="hljs-string">&#x27;lisi&#x27;</span>));<span class="hljs-comment">// 再添加一个观察者</span>s1.notify(<span class="hljs-string">&#x27;abc&#x27;</span>); <span class="hljs-comment">// 通知所有的观察者</span><span class="hljs-comment">// 发布订阅者</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PubSub</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.subscribers = &#123;&#125;&#125;<span class="hljs-function"><span class="hljs-title">subscribe</span>(<span class="hljs-params">type, fn</span>)</span> &#123;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(<span class="hljs-built_in">this</span>.subscribers, type)) &#123;<span class="hljs-built_in">this</span>.subscribers[type] = [];&#125;<span class="hljs-built_in">this</span>.subscribers[type].push(fn);&#125;<span class="hljs-function"><span class="hljs-title">publish</span>(<span class="hljs-params">type, ...args</span>)</span> &#123;<span class="hljs-keyword">let</span> listeners = <span class="hljs-built_in">this</span>.subscribers[type];<span class="hljs-keyword">if</span> (!listeners || !listeners.length) <span class="hljs-keyword">return</span>;listeners.forEach(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn(...args));        &#125;&#125;<span class="hljs-keyword">let</span> ob = <span class="hljs-keyword">new</span> PubSub(); <span class="hljs-comment">// 创建一个发布对象</span><span class="hljs-comment">// A 订阅了 add 事件（A只关注add本身，而不关心谁发布这个事件）</span>ob.subscribe(<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(val));<span class="hljs-comment">// B 订阅了 add 事件（B只关注add本身，而不关心谁发布这个事件）</span>ob.subscribe(<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(val));<span class="hljs-comment">// C发布了 add 事件（C只关注 add 本身，不关心谁订阅了这个事件）</span>ob.publish(<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-string">&#x27;I published `add` event&#x27;</span>);</code></pre><h4 id="3-工厂模式"><a href="#3-工厂模式" class="headerlink" title="(3) 工厂模式"></a>(3) 工厂模式</h4><p>工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。<br>该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。</p><p>适用场景</p><ul><li>如果不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择</li><li>将new操作简单封装，遇到new的时候就应该考虑是否用工厂模式；</li><li>需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性</li></ul><p>优点</p><ul><li>创建对象的过程可能很复杂，但我们只需要关心创建结果。</li><li>构造函数和创建者分离, 符合“开闭原则”</li><li>一个调用者想创建一个对象，只要知道其名称就可以了。</li><li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li></ul><p>缺点</p><ul><li>添加新产品时，需要编写新的具体产品类,一定程度上增加了系统的复杂度</li><li>考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度</li></ul><pre><code class="hljs javaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<span class="hljs-built_in">this</span>.name = name&#125;<span class="hljs-function"><span class="hljs-title">fun</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fun&#x27;</span>)&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">create</span>(<span class="hljs-params">name</span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Product(name)&#125;&#125;<span class="hljs-comment">// use</span><span class="hljs-keyword">let</span> factory = <span class="hljs-keyword">new</span> Factory()<span class="hljs-keyword">let</span> p = factory.create(<span class="hljs-string">&#x27;p1&#x27;</span>)p.fun()</code></pre><h4 id="4-适配器模式"><a href="#4-适配器模式" class="headerlink" title="(4) 适配器模式"></a>(4) 适配器模式</h4><p>将一个类的接口转化为另外一个接口，以满足用户需求，使类之间接口不兼容问题通过适配器得以解决。</p><p>优点</p><ul><li>可以让任何两个没有关联的类一起运行。</li><li>提高了类的复用。</li><li>适配对象，适配库，适配数据</li></ul><p>缺点</p><ul><li>额外对象的创建，非直接调用，存在一定的开销（且不像代理模式在某些功能点上可实现性能优化)</li><li>如果没必要使用适配器模式的话，可以考虑重构，如果使用的话，尽量把文档完善</li></ul><p>场景</p><ul><li>整合第三方SDK</li><li>封装旧接口</li></ul><pre><code class="hljs javaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plug</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;iphone充电头&#x27;</span>;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Target</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.plug = <span class="hljs-keyword">new</span> Plug();&#125;<span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.plug.getName() + <span class="hljs-string">&#x27; 适配器Type-c充电头&#x27;</span>;&#125;&#125;<span class="hljs-keyword">let</span> target = <span class="hljs-keyword">new</span> Target();<span class="hljs-comment">// iphone充电头 适配器转Type-c充电头</span>target.getName();</code></pre><h4 id="5-装饰者模式"><a href="#5-装饰者模式" class="headerlink" title="(5) 装饰者模式"></a>(5) 装饰者模式</h4><p>动态地给某个对象添加一些额外的职责，是一种实现继承的替代方案。<br>在不改变原对象的基础上，通过对其进行包装扩展，使原有对象可以满足用户的更复杂需求，而不会影响从这个类中派生的其他对象。</p><p>装饰者模式 与 适配器模式的区别：</p><ul><li>装饰着模式 给<strong>对象</strong>添加额外的职责，因此需要传入一个实例对象</li><li>适配器模式 给一个类的接口提供了包装和转化，因此只需要实例化调用包装后的构造函数即可</li></ul><p>场景例子</p><ul><li>ES7 Decorator</li><li>core-decorators</li></ul><p>优点</p><ul><li>装饰类和被装饰类都只关心自身的核心业务，实现了解耦。</li><li>方便动态的扩展功能，且提供了比继承更多的灵活性。</li></ul><p>缺点</p><ul><li>多层装饰比较复杂。</li><li>常常会引入许多小对象，看起来比较相似，实际功能大相径庭，从而使得我们的应用程序架构变得复杂起来</li></ul><pre><code class="hljs javaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cellphone</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">create</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;生成一个手机&#x27;</span>)&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">cellphone</span>)</span> &#123;<span class="hljs-built_in">this</span>.cellphone = cellphone&#125;<span class="hljs-function"><span class="hljs-title">create</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.cellphone.create()<span class="hljs-built_in">this</span>.createShell(cellphone)&#125;<span class="hljs-function"><span class="hljs-title">createShell</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;生成手机壳&#x27;</span>)&#125;&#125;<span class="hljs-comment">// 测试代码</span><span class="hljs-keyword">let</span> cellphone = <span class="hljs-keyword">new</span> Cellphone();cellphone.create();<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;------------&#x27;</span>);<span class="hljs-comment">// 需要传入被庄饰的实例对象</span><span class="hljs-keyword">let</span> dec = <span class="hljs-keyword">new</span> Decorator(cellphone);dec.create();</code></pre><h4 id="6-代理模式"><a href="#6-代理模式" class="headerlink" title="(6) 代理模式"></a>(6) 代理模式</h4><p>是为一个对象提供一个代用品或占位符，以便控制对它的访问</p><p>装饰者模式实现上 和 代理模式 的区别:</p><ul><li>装饰者模式： 扩展功能，原有功能不变且可直接使用</li><li>代理模式： 显示原有功能，但是经过限制之后的</li></ul><p>场景</p><ul><li>HTML元素 事件代理</li><li>ES6 的 proxy</li></ul><p>优点</p><ul><li>代理模式能将代理对象与被调用对象分离，降低了系统的耦合度。代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用</li><li>代理对象可以扩展目标对象的功能；通过修改代理对象就可以了，符合开闭原则；</li></ul><p>缺点</p><ul><li>处理请求速度可能有差别，非直接访问存在开销</li></ul><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> Flower = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-keyword">let</span> xiaoming = &#123;sendFlower: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target</span>) </span>&#123;<span class="hljs-keyword">let</span> flower = <span class="hljs-keyword">new</span> Flower()target.receiveFlower(flower)&#125;&#125;<span class="hljs-keyword">let</span> B = &#123;receiveFlower: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">flower</span>) </span>&#123;A.listenGoodMood(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;A.receiveFlower(flower)&#125;)&#125;&#125;<span class="hljs-keyword">let</span> A = &#123;receiveFlower: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">flower</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;收到花&#x27;</span>+ flower)&#125;,listenGoodMood: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>&#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;fn()&#125;, <span class="hljs-number">1000</span>)&#125;&#125;xiaoming.sendFlower(B)</code></pre><blockquote><p><a href="https://juejin.cn/post/6844904032826294286#heading-0">设计模式简介</a><br><a href="https://www.cnblogs.com/imwtr/p/9451129.html">JS设计模式</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法汇总</title>
    <link href="/2021/03/07/interview/%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <url>/2021/03/07/interview/%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="一-排序和二分搜索"><a href="#一-排序和二分搜索" class="headerlink" title="一 排序和二分搜索"></a>一 排序和二分搜索</h2><p>1冒泡排序 - 2选择排序 - 3插入排序(3-2 希尔排序) - 4归并排序 - 5快速排序 - 6二分搜索<br>7x的平方根 - 8猜数字大小</p><table><thead><tr><th>排序类型</th><th>平均情况</th><th>最好情况</th><th>最坏情况</th><th>辅助空间</th><th>稳定性</th><th>思路</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td><td>比较所有相邻元素，如果第一个比第二个大，则交换它们</td></tr><tr><td>选择排序</td><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td><td>找到最小值，与第一位互换</td></tr><tr><td>插入排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td><td>对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</td></tr><tr><td>归并排序</td><td>O(n logn)</td><td>O(n logn)</td><td>O(n logn)</td><td>O(n)</td><td>稳定</td><td>从中间一分为二，排序后再合并</td></tr><tr><td>快速排序</td><td>O(n logn)</td><td>O(n logn)</td><td>O(n²)</td><td>O(n logn)</td><td>不稳定</td><td>选择一个基准，比基准大的放在左边数组，小的放在右边数组，依次递归，再合并</td></tr></tbody></table><p>Array.prototype.srot:<br>Chrome 长度 <code>&lt;= 10</code> 的数组使用的是<strong>插入排序</strong>(稳定排序算法) ，<code>&gt;10</code> 的数组使用的是<strong>快速排序</strong>。快速排序是不稳定的排序算法<br> Firefox 用的 <strong>归并排序</strong></p><p> 冒泡排序：稳定，</p><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1 冒泡排序"></a>1 冒泡排序</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 1 冒泡排序-稳定-平均 O(n^2) [时间: O(n)&lt;O(n^2) 空间: O(1)]</span><span class="hljs-comment">// (1) 比较所有相邻元素，如果第一个比第二个大，则交换它们</span><span class="hljs-comment">// (2) 一轮下来，可以保证最后一个数是最大的</span><span class="hljs-comment">// (3) 执行 n-1 轮，就可以完成排序</span><span class="hljs-built_in">Array</span>.prototype.bubbleSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">this</span>.length; j++) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-built_in">this</span>.length - <span class="hljs-number">1</span> - j; i++) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>[i] &gt; <span class="hljs-built_in">this</span>[i + <span class="hljs-number">1</span>]) &#123;<span class="hljs-keyword">const</span> tem = <span class="hljs-built_in">this</span>[i];<span class="hljs-built_in">this</span>[i] = <span class="hljs-built_in">this</span>[i + <span class="hljs-number">1</span>];<span class="hljs-built_in">this</span>[i + <span class="hljs-number">1</span>] = tem;&#125;&#125;&#125;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 2 选择排序-不稳定-时间: O(n^2) 空间: O(1)</span><span class="hljs-comment">// 选出最小值后需要交换位置,位置一变就会变得不稳定</span><span class="hljs-comment">// (1) 找到数组中的最小值，选中它并将其放置到第一位，</span><span class="hljs-comment">// (2) 接着找到第二小的值，选中它并将其放置到第二位</span><span class="hljs-comment">// (3) 以此类推，执行 n-1 轮</span><span class="hljs-built_in">Array</span>.prototype.selectSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length - <span class="hljs-number">1</span>; i++ ) &#123;<span class="hljs-keyword">let</span> indexMin = i;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i; j &lt; <span class="hljs-built_in">this</span>.length; j++) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>[j] &lt; <span class="hljs-built_in">this</span>[indexMin]) &#123;indexMin = j;&#125;&#125;<span class="hljs-keyword">if</span> (indexMin !== i) &#123;<span class="hljs-keyword">const</span> tem = <span class="hljs-built_in">this</span>[i];<span class="hljs-built_in">this</span>[i] = <span class="hljs-built_in">this</span>[indexMin];<span class="hljs-built_in">this</span>[indexMin] = tem;&#125;&#125;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 3 插入排序 稳定 平均 O(n^2)[时间: O(n)&lt;O(n^2) 空间: O(1)]</span><span class="hljs-comment">// 原理是通过构建有序序列，对于未排序数据，在已排序序列中 从后向前 扫描，找到相应位置并插入。</span><span class="hljs-comment">// (1) 从第二个数开始往前比</span><span class="hljs-comment">// (2) 如果前面的数字比它大 就往后排</span><span class="hljs-comment">// (3) 以此类推 进行到最后一个数字</span><span class="hljs-built_in">Array</span>.prototype.insertSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;<span class="hljs-keyword">const</span> tem = <span class="hljs-built_in">this</span>[i];<span class="hljs-keyword">let</span> j = i;<span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>[j - <span class="hljs-number">1</span>] &gt; tem) &#123;<span class="hljs-built_in">this</span>[j] = <span class="hljs-built_in">this</span>[j - <span class="hljs-number">1</span>];j--;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-built_in">this</span>[j] = tem;&#125;&#125;<span class="hljs-comment">// 3-2 希尔排序 / 缩小增量排序</span><span class="hljs-comment">// 是 插入排序 的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</span><span class="hljs-comment">// (1)选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</span><span class="hljs-comment">// (2)按增量序列个数k，对序列进行k 趟排序；</span><span class="hljs-comment">// (3)每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。</span><span class="hljs-comment">//仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shellSort</span>(<span class="hljs-params">arr</span>) </span>&#123;    <span class="hljs-keyword">var</span> len = arr.length;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k = <span class="hljs-built_in">Math</span>.floor(len / <span class="hljs-number">2</span>); k &gt; <span class="hljs-number">0</span>; k = <span class="hljs-built_in">Math</span>.floor(k / <span class="hljs-number">2</span>)) &#123;        <span class="hljs-comment">// 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = k; i &lt; len; i++) &#123;            varj = i;            <span class="hljs-keyword">var</span> current = arr[i];            <span class="hljs-keyword">while</span>(j - k &gt;= <span class="hljs-number">0</span> &amp;&amp; current &lt; arr[j - k]) &#123;                 arr[j] = arr[j - k];                 j = j - k;            &#125;            arr[j] = current;        &#125;    &#125;    <span class="hljs-keyword">return</span> arr;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 4 归并排序 稳定 时间:O(n logn) 空间:O(n)</span><span class="hljs-comment">// 分而治之</span><span class="hljs-comment">//（1）把长度为n的输入序列分成两个长度为n/2的子序列</span><span class="hljs-comment">// (2) 对这两个子序列分别采用归并排序</span><span class="hljs-comment">// (3) 将两个排序好的子序列合并成一个最终的排序序列</span><span class="hljs-built_in">Array</span>.prototype.mergeSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">const</span> rec = <span class="hljs-function"><span class="hljs-params">arr</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-comment">// 除二取整: arr.length &gt;&gt;&gt; 1</span><span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>);<span class="hljs-keyword">const</span> left = arr.slice(<span class="hljs-number">0</span>, mid);<span class="hljs-keyword">const</span> right = arr.slice(mid, arr.length);<span class="hljs-keyword">const</span> orderLeft = rec(left);<span class="hljs-keyword">const</span> orderRight = rec(right);<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">while</span>(orderLeft.length || orderRight.length) &#123;<span class="hljs-keyword">if</span> (orderLeft.length &amp;&amp; orderRight.length) &#123;res.push(orderLeft[<span class="hljs-number">0</span>] &lt; orderRight[<span class="hljs-number">0</span>] ?orderLeft.shift() : orderRight.shift());&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (orderLeft.length) &#123;res.push(orderLeft.shift());&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (orderRight.length) &#123;res.push(orderRight.shift());&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">const</span> res = rec(<span class="hljs-built_in">this</span>);res.forEach(<span class="hljs-function">(<span class="hljs-params">n, i</span>) =&gt;</span> <span class="hljs-built_in">this</span>[i] = n);&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 5 快速排序 不稳定 平均: O(n logn)</span><span class="hljs-comment">// 时间:O(n logn) &lt; O(n²) 空间:O(n logn)</span><span class="hljs-comment">// 排序过程中位置会发生变化,位置一变就会变得不稳定</span><span class="hljs-comment">// 分而治之：将选择一个基准，比基准大的放在左边数组，小的放在右边数组，依次递归，再合并</span><span class="hljs-built_in">Array</span>.prototype.quickSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">const</span> rec = <span class="hljs-function"><span class="hljs-params">arr</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span>(arr.length &lt; <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-keyword">const</span> left = [];<span class="hljs-keyword">const</span> right = [];<span class="hljs-keyword">const</span> mid = arr[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<span class="hljs-keyword">if</span> (arr[i] &lt; mid) &#123;left.push(arr[i]);&#125; <span class="hljs-keyword">else</span> &#123;right.push(arr[i])&#125;&#125;<span class="hljs-keyword">return</span> [...rec(left), mid, ...rec(right)];&#125;;<span class="hljs-keyword">const</span> res = rec(<span class="hljs-built_in">this</span>);res.forEach(<span class="hljs-function">(<span class="hljs-params">n, i</span>) =&gt;</span> <span class="hljs-built_in">this</span>[i] = n);&#125;</code></pre><h3 id="6-二分搜索"><a href="#6-二分搜索" class="headerlink" title="6 二分搜索"></a>6 二分搜索</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 6 二分搜索 O(logN)</span><span class="hljs-built_in">Array</span>.prototype.binarySearch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<span class="hljs-keyword">let</span> low = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> high = <span class="hljs-built_in">this</span>.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(low &lt;= high) &#123;<span class="hljs-comment">// 除二取整: (high + low) &gt;&gt;&gt; 1</span><span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor((high + low) / <span class="hljs-number">2</span>);<span class="hljs-keyword">const</span> element = <span class="hljs-built_in">this</span>[mid];<span class="hljs-keyword">if</span> (element &lt; item) &#123;low = mid + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element &gt; item) &#123;high = mid - <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> mid;&#125;&#125;<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 7 x 的平方根</span><span class="hljs-keyword">var</span> mySqrt = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>&#123;<span class="hljs-comment">// 时间复杂度: O(log N)</span>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-keyword">let</span> low = <span class="hljs-number">1</span>; <span class="hljs-comment">// 除二取整</span>    <span class="hljs-keyword">let</span> higt = x &gt;&gt;&gt; <span class="hljs-number">1</span>;     <span class="hljs-keyword">while</span>(low + <span class="hljs-number">1</span> &lt; higt) &#123;        <span class="hljs-comment">// Math.floor((low + higt) / 2);</span>        <span class="hljs-keyword">const</span> mid = (low + higt) &gt;&gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">const</span> s = x / mid;        <span class="hljs-keyword">if</span> (s === mid) &#123;            <span class="hljs-keyword">return</span> mid;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &gt; mid) &#123;            low = mid;        &#125; <span class="hljs-keyword">else</span> &#123;            higt = mid;        &#125;    &#125;    <span class="hljs-keyword">return</span> x / higt &gt;= higt ? higt : low;&#125;;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 8 猜数字大小 二分搜索 时间 O(logN) 空间 O(1)</span><span class="hljs-keyword">var</span> guessNumber = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;    <span class="hljs-keyword">let</span> low = <span class="hljs-number">1</span>;    <span class="hljs-keyword">let</span> high = n;    <span class="hljs-keyword">while</span>(high &gt;= low) &#123; <span class="hljs-comment">// 除以二并取整</span> <span class="hljs-comment">// Math.floor((low + high) / 2);</span>        <span class="hljs-keyword">const</span> mid = (low + high) &gt;&gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">const</span> res = guess(mid);        <span class="hljs-keyword">if</span> (res === -<span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 比mid 小,搜索 0 - mid 范围</span>            high = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res === <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 比mid 大,搜索 mid - n 范围</span>            low = mid + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res === <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> mid;        &#125;    &#125;&#125;;<span class="hljs-comment">// 解法二</span><span class="hljs-comment">// 猜数字大小,分而治之 ,时间O(logN),空间O(logN)</span><span class="hljs-keyword">var</span> guessNumber = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;<span class="hljs-keyword">const</span> rec = <span class="hljs-function">(<span class="hljs-params">low, high</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (low &gt; high) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">// 除二取整</span><span class="hljs-keyword">const</span> mid = (low + high) &gt;&gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> res = guess(mid);<span class="hljs-keyword">if</span> (res === <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 猜对了</span><span class="hljs-keyword">return</span> mid;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res === <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//比mid大</span><span class="hljs-keyword">return</span> rec(mid + <span class="hljs-number">1</span>, high);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res === -<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//比mid小</span><span class="hljs-keyword">return</span> rec(low, mid - <span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-keyword">return</span> rec(<span class="hljs-number">1</span>, n);&#125;;</code></pre><h2 id="二-树"><a href="#二-树" class="headerlink" title="二 树"></a>二 树</h2><p>1 树深度优先/广度优先<br>2 二叉树深度优先/广度优先 - 二叉树<br>3 先序/4中序/5后序<br>6 二叉树的最大深度<br>7 二叉树的最小深度<br>8 二叉树的层序遍历<br>9 二叉树的锯齿形层序遍历<br>10 相同的树<br>11 翻转二叉树<br>12 二叉树的层序遍历II （自底向上）<br>13 二叉树中第二小的节点<br>14 把二叉搜索树转换为累加树 (从二叉搜索树到更大和树)<br>15 二叉搜索树中的搜索 （从 二叉搜索树找到 给定值 的子树）<br>16 N叉树的最大深度<br>17 N叉树的前序遍历<br>18 N叉树的后序遍历<br>19 递增顺序查找树 （按中序遍历 重新排列树，使树中最左边的结点现在是树的根）<br>20 二叉树所有路径<br>21 另一个树的子树 ( 树s 中是否包含和 树t)<br>22 从前序与中序遍历序列构造二叉树<br>23 从中序与后序遍历序列构造二叉树<br>24 平衡二叉树 —— 判断是不是平衡二叉树<br>25 有序链表转换平衡二叉树<br>26 路径总和 Ⅰ II</p><h3 id="1-树-深度优先"><a href="#1-树-深度优先" class="headerlink" title="1 树 - 深度优先"></a>1 树 - 深度优先</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 1 树 - 深度优先</span><span class="hljs-keyword">const</span> dfs = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;<span class="hljs-comment">// 访问节点数据</span><span class="hljs-built_in">console</span>.log(root.val);<span class="hljs-comment">// 递归 访问子节点</span>root.children.forEach(dfs);&#125;dfs(tree);<span class="hljs-comment">// 树 - 广度优先</span><span class="hljs-keyword">const</span> bfs = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;<span class="hljs-comment">// 先把各节点入队</span><span class="hljs-keyword">const</span> q = [root];<span class="hljs-keyword">while</span>(q.length &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 出队</span><span class="hljs-keyword">const</span> n = q.shift();<span class="hljs-comment">// 访问节点数据</span><span class="hljs-built_in">console</span>.log(n.val);<span class="hljs-keyword">if</span> (n.children) &#123;n.children.forEach(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;q.push(child);&#125;)&#125;&#125;&#125;bfs(tree);</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 2 二叉树 - 深度/广度优先遍历</span><span class="hljs-comment">// 深度1 - 打印结果</span><span class="hljs-keyword">const</span> dfs = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<span class="hljs-comment">// 访问节点数据</span><span class="hljs-built_in">console</span>.log(root.val);dfs(root.left);dfs(root.right)&#125;<span class="hljs-comment">// 深度2 - 递归版 - 收集并返回结果</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs2</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) &#123;<span class="hljs-keyword">return</span> [];&#125;<span class="hljs-keyword">const</span> res = []<span class="hljs-keyword">const</span> rec = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tree</span>) </span>&#123;<span class="hljs-comment">// console.log(tree.val);</span>res.push(tree.val);<span class="hljs-keyword">if</span> (tree.left) rec(tree.left);<span class="hljs-keyword">if</span> (tree.right) rec(tree.right);&#125;rec(root);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 深度3 - 非递归版 - 收集并返回结果</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs3</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) &#123;<span class="hljs-keyword">return</span> [];&#125;<span class="hljs-keyword">const</span> res = []<span class="hljs-keyword">const</span> stack = [root];<span class="hljs-keyword">while</span>(stack.length) &#123;<span class="hljs-keyword">const</span> item = stack.pop();<span class="hljs-comment">// console.log(item.val);</span>res.push(item.val);<span class="hljs-keyword">if</span> (item.right) &#123;stack.push(item.right);&#125;<span class="hljs-keyword">if</span> (item.left) &#123;stack.push(item.left);&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 广度 - 收集并返回结果</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fbs</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> stack = [root];<span class="hljs-keyword">while</span>(stack.length) &#123;<span class="hljs-keyword">const</span> item = stack.shift();<span class="hljs-comment">// console.log(item.val);</span>res.push(item.val);<span class="hljs-keyword">if</span> (item.left) &#123;stack.push(item.left);&#125;<span class="hljs-keyword">if</span> (item.right) &#123;stack.push(item.right);&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 3先序遍历: 根 -&gt; 左 -&gt; 右</span><span class="hljs-comment">// 递归版1 - 打印结果</span><span class="hljs-keyword">const</span> preorder = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!root) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-built_in">console</span>.log(root.val);preorder(root.left);preorder(root.right);&#125;<span class="hljs-comment">// 递归版2 - 收集并返回结果</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preorder2</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) &#123;<span class="hljs-keyword">return</span> [];&#125;<span class="hljs-keyword">const</span> res = []<span class="hljs-keyword">const</span> stack = [root];<span class="hljs-keyword">while</span>(stack.length) &#123;<span class="hljs-keyword">const</span> item = stack.pop();<span class="hljs-comment">// console.log(item.val);</span>res.push(item.val);<span class="hljs-keyword">if</span> (item.right) &#123;stack.push(item.right);&#125;<span class="hljs-keyword">if</span> (item.left) &#123;stack.push(item.left);&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 3先序遍历: 根 -&gt; 左 -&gt; 右</span><span class="hljs-comment">// 非递归版</span><span class="hljs-keyword">const</span> preorder2 = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!root) &#123;<span class="hljs-keyword">return</span> [];&#125;<span class="hljs-keyword">const</span> res = []<span class="hljs-keyword">const</span> stack = [root];<span class="hljs-keyword">while</span>(stack.length) &#123;<span class="hljs-keyword">const</span> item = stack.pop();<span class="hljs-comment">// console.log(item.val);</span>res.push(item.val);<span class="hljs-keyword">if</span> (item.right) &#123;stack.push(item.right);&#125;<span class="hljs-keyword">if</span> (item.left) &#123;stack.push(item.left);&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 4中序遍历: 左 -&gt; 根 -&gt; 右</span><span class="hljs-comment">// 中序 - 递归版1 -  打印结果</span><span class="hljs-keyword">const</span> inorder = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!root) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (root.left) inorder(root.left);<span class="hljs-built_in">console</span>.log(root.val);<span class="hljs-keyword">if</span> (root.right) inorder(root.right);&#125;<span class="hljs-comment">// 中序 - 递归版2 - 收集并返回结果</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inorder2</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> rec = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tr</span>) </span>&#123;<span class="hljs-keyword">if</span> (tr.left) rec(tr.left);<span class="hljs-comment">// console.log(tr.val);</span>res.push(tr.val);<span class="hljs-keyword">if</span> (tr.right) rec(tr.right);&#125;rec(root);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 4中序遍历: 左 -&gt; 根 -&gt; 右</span><span class="hljs-comment">// 中序 -&gt; 非递归版</span><span class="hljs-keyword">const</span> inorder3 = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!root) &#123;<span class="hljs-keyword">return</span> [];&#125;<span class="hljs-keyword">const</span> stack = [];<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">let</span> p = root;<span class="hljs-keyword">while</span> (stack.length || p) &#123;<span class="hljs-keyword">while</span>(p) &#123;stack.push(p);p = p.left;&#125;<span class="hljs-keyword">const</span> item = stack.pop();<span class="hljs-comment">// console.log(item.val);</span>res.push(item.val);p = item.right;&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 5后序遍历: 左 -&gt; 右 &gt; 根</span><span class="hljs-comment">// 后序遍历 -&gt; 递归版1 -  打印结果</span><span class="hljs-keyword">const</span> postorder = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!root) &#123;<span class="hljs-keyword">return</span>;&#125;postorder(root.left);postorder(root.right);<span class="hljs-comment">// 访问当前节点</span><span class="hljs-built_in">console</span>.log(root.val);&#125;<span class="hljs-comment">// 后序遍历 -&gt; 递归版2 - 收集并返回结果</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postorder2</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> rec = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tr</span>) </span>&#123;<span class="hljs-keyword">if</span> (tr.left) rec(tr.left);<span class="hljs-keyword">if</span> (tr.right) rec(tr.right);<span class="hljs-comment">// console.log(tr.val);</span>res.push(tr.val);&#125;rec(root);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 后序遍历 -&gt; 非递归版 - 收集并返回结果</span><span class="hljs-keyword">const</span> postorder3 = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!root) &#123;<span class="hljs-keyword">return</span> [];&#125;<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> outputStack = [];<span class="hljs-keyword">const</span> stack = [root];<span class="hljs-keyword">while</span> (stack.length) &#123;<span class="hljs-keyword">const</span> item = stack.pop();outputStack.push(item);<span class="hljs-keyword">if</span> (item.left) stack.push(item.left);<span class="hljs-keyword">if</span> (item.right) stack.push(item.right);&#125; <span class="hljs-keyword">while</span>(outputStack.length) &#123;<span class="hljs-keyword">const</span> item = outputStack.pop();<span class="hljs-comment">// 访问当前节点</span><span class="hljs-comment">// console.log(item.val);</span>res.push(item.val);&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre><h3 id="6-二叉树的最大深度"><a href="#6-二叉树的最大深度" class="headerlink" title="6 二叉树的最大深度"></a>6 二叉树的最大深度</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 6 题: 二叉树的最大深度 104</span><span class="hljs-comment">// 给定一个二叉树，找出其最大深度。</span><span class="hljs-comment">// 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</span><span class="hljs-comment">// 说明: 叶子节点是指没有子节点的节点。</span><span class="hljs-comment">// 示例：</span><span class="hljs-comment">// 给定二叉树 [3,9,20,null,null,15,7]，</span><span class="hljs-comment">//     3</span><span class="hljs-comment">//    / \</span><span class="hljs-comment">//   9  20</span><span class="hljs-comment">//     /  \</span><span class="hljs-comment">//    15   7</span><span class="hljs-comment">// 返回它的最大深度 3 。</span><span class="hljs-keyword">var</span> maxDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> dpt = <span class="hljs-function">(<span class="hljs-params">root, l</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;res = <span class="hljs-built_in">Math</span>.max(res, l)&#125;<span class="hljs-keyword">if</span> (root.left) dpt(root.left, l + <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span> (root.right) dpt(root.right, l + <span class="hljs-number">1</span>);&#125;dpt(root, <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 7 题: 二叉树的最小深度 111</span><span class="hljs-comment">// 给定一个二叉树，找出其最小深度。</span><span class="hljs-comment">// 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</span><span class="hljs-comment">// 说明：叶子节点是指没有子节点的节点。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">//     3</span><span class="hljs-comment">//    / \</span><span class="hljs-comment">//   9  20</span><span class="hljs-comment">//     /  \</span><span class="hljs-comment">//    15   7</span><span class="hljs-comment">// 输入：root = [3,9,20,null,null,15,7]</span><span class="hljs-comment">// 输出：2</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：root = [2,null,3,null,4,null,5,null,6]</span><span class="hljs-comment">// 输出：5</span><span class="hljs-comment">// 解法一 深度遍历法</span><span class="hljs-keyword">var</span> minDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;   <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> res = <span class="hljs-literal">Infinity</span>;<span class="hljs-keyword">const</span> dpt = <span class="hljs-function">(<span class="hljs-params">root, l</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;res = <span class="hljs-built_in">Math</span>.min(res, l);&#125;<span class="hljs-keyword">if</span> (root.left) dpt(root.left, l + <span class="hljs-number">1</span>); <span class="hljs-keyword">if</span> (root.right) dpt(root.right, l + <span class="hljs-number">1</span>); &#125;dpt(root, <span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-comment">// 解法二 广度优先遍历</span><span class="hljs-keyword">var</span> minDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> stack = [[root, <span class="hljs-number">1</span>]];<span class="hljs-keyword">while</span> (stack.length) &#123;<span class="hljs-keyword">const</span> [n, l] = stack.shift();<span class="hljs-keyword">if</span> (!n.left &amp;&amp; !n.right) &#123;<span class="hljs-keyword">return</span> l;&#125;<span class="hljs-keyword">if</span> (n.left) stack.push([n.left, l + <span class="hljs-number">1</span>]);<span class="hljs-keyword">if</span> (n.right) stack.push([n.right, l + <span class="hljs-number">1</span>]);&#125;&#125;;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 8 二叉树的层序遍历 102</span><span class="hljs-comment">// 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</span><span class="hljs-comment">// 示例：</span><span class="hljs-comment">// 二叉树：[3,9,20,null,null,15,7],</span><span class="hljs-comment">//     3</span><span class="hljs-comment">//    / \</span><span class="hljs-comment">//   9  20</span><span class="hljs-comment">//     /  \</span><span class="hljs-comment">//    15   7</span><span class="hljs-comment">// 返回其层序遍历结果：</span><span class="hljs-comment">// [</span><span class="hljs-comment">//   [3],</span><span class="hljs-comment">//   [9,20],</span><span class="hljs-comment">//   [15,7]</span><span class="hljs-comment">// ]</span><span class="hljs-comment">// 广度优先遍历 【推荐 二颗星】</span><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">var</span> stack = [[root, <span class="hljs-number">0</span>]];<span class="hljs-keyword">var</span> res = [];<span class="hljs-keyword">while</span> (stack.length) &#123;<span class="hljs-keyword">var</span> [n, level] = stack.shift();<span class="hljs-keyword">if</span> (!res[level]) &#123;res.push([n.val]);&#125; <span class="hljs-keyword">else</span> &#123;res[level].push(n.val);&#125;<span class="hljs-keyword">if</span> (n.left) stack.push([n.left, level + <span class="hljs-number">1</span>]);<span class="hljs-keyword">if</span> (n.right) stack.push([n.right, level + <span class="hljs-number">1</span>]); &#125;<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-comment">// 广度优先遍历-每次清空当前层级数据【推荐 三星】</span><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">const</span> stack = [root];<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">while</span>(stack.length) &#123;res.push([]);<span class="hljs-keyword">let</span> len = stack.length;<span class="hljs-keyword">while</span>(len--) &#123;<span class="hljs-keyword">const</span> n = stack.shift();res[res.length - <span class="hljs-number">1</span>].push(n.val);<span class="hljs-keyword">if</span> (n.left) stack.push(n.left);<span class="hljs-keyword">if</span> (n.right) stack.push(n.right);&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-comment">// 递归写法</span><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">let</span> res = []<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root, depth</span>) </span>&#123;<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">if</span> (!res[depth]) &#123;res[depth] = []&#125;traversal(root.left, depth + <span class="hljs-number">1</span>)res[depth].push(root.val)traversal(root.right, depth + <span class="hljs-number">1</span>)&#125;&#125;traversal(root, <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 9 二叉树的锯齿形层序遍历 103</span><span class="hljs-comment">// 给定一个二叉树，返回其节点值的锯齿形层序遍历</span><span class="hljs-comment">//（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</span><span class="hljs-comment">// 例如：</span><span class="hljs-comment">// 给定二叉树 [3,9,20,null,null,15,7],</span><span class="hljs-comment">//     3</span><span class="hljs-comment">//    / \</span><span class="hljs-comment">//   9  20</span><span class="hljs-comment">//     /  \</span><span class="hljs-comment">//    15   7</span><span class="hljs-comment">// 返回锯齿形层序遍历如下：</span><span class="hljs-comment">// [</span><span class="hljs-comment">//   [3],</span><span class="hljs-comment">//   [20,9],</span><span class="hljs-comment">//   [15,7]</span><span class="hljs-comment">// ]</span><span class="hljs-keyword">var</span> zigzagLevelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">let</span> stack = [root];<span class="hljs-keyword">while</span>(stack.length) &#123;        <span class="hljs-keyword">let</span> len = stack.length;        res.push([]);        <span class="hljs-keyword">while</span>(len--) &#123;    <span class="hljs-keyword">const</span> n = stack.shift();            res[res.length - <span class="hljs-number">1</span>].push(n.val);            <span class="hljs-keyword">if</span> (n.left) stack.push(n.left);            <span class="hljs-keyword">if</span> (n.right) stack.push(n.right);        &#125;&#125;res.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> index % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? item : item.reverse());<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 10 相同的树 100</span><span class="hljs-comment">// 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</span><span class="hljs-comment">// 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：p = [1,2,3], q = [1,2,3]</span><span class="hljs-comment">// 输出：true</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：p = [1,2], q = [1,null,2]</span><span class="hljs-comment">// 输出：false</span><span class="hljs-keyword">var</span> isSameTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">p, q</span>) </span>&#123;<span class="hljs-keyword">if</span>(!p &amp;&amp; !q) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">if</span>(p &amp;&amp; q &amp;&amp; p.val === q.val &amp;&amp;isSameTree(p.left, q.left) &amp;&amp;isSameTree(p.right, q.right)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;</code></pre><h3 id="11-翻转二叉树"><a href="#11-翻转二叉树" class="headerlink" title="11 翻转二叉树"></a>11 翻转二叉树</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 11 翻转二叉树 226</span><span class="hljs-comment">// 翻转一棵二叉树。</span><span class="hljs-comment">// 示例：</span><span class="hljs-comment">// 输入：</span><span class="hljs-comment">//      4</span><span class="hljs-comment">//    /   \</span><span class="hljs-comment">//   2     7</span><span class="hljs-comment">//  / \   / \</span><span class="hljs-comment">// 1   3 6   9</span><span class="hljs-comment">// 输出：</span><span class="hljs-comment">//      4</span><span class="hljs-comment">//    /   \</span><span class="hljs-comment">//   7     2</span><span class="hljs-comment">//  / \   / \</span><span class="hljs-comment">// 9   6 3   1</span><span class="hljs-keyword">var</span> invertTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-comment">// 时间复杂度: O(N)</span><span class="hljs-comment">// 空间复杂度: O(h)  h是树的高度 </span><span class="hljs-keyword">if</span>(!root) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;<span class="hljs-keyword">return</span> &#123;val: root.val,left: invertTree(root.right),right: invertTree(root.left),&#125;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 12 二叉树的层序遍历 II 107</span><span class="hljs-comment">// 自底向上</span><span class="hljs-comment">// 给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</span><span class="hljs-comment">// 例如：</span><span class="hljs-comment">// 给定二叉树 [3,9,20,null,null,15,7],</span><span class="hljs-comment">//     3</span><span class="hljs-comment">//    / \</span><span class="hljs-comment">//   9  20</span><span class="hljs-comment">//     /  \</span><span class="hljs-comment">//    15   7</span><span class="hljs-comment">// 返回其自底向上的层序遍历为：</span><span class="hljs-comment">// [</span><span class="hljs-comment">//   [15,7],</span><span class="hljs-comment">//   [9,20],</span><span class="hljs-comment">//   [3]</span><span class="hljs-comment">// ]</span><span class="hljs-comment">// 解法一 递归写法</span><span class="hljs-keyword">var</span> levelOrderBottom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">let</span> res = []<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root, depth</span>) </span>&#123;<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">if</span> (!res[depth]) &#123;res[depth] = []&#125;traversal(root.left, depth + <span class="hljs-number">1</span>)res[depth].push(root.val)traversal(root.right, depth + <span class="hljs-number">1</span>)&#125;&#125;traversal(root, <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> res.reverse()&#125;<span class="hljs-comment">// 解法二 广度优先 非递归</span><span class="hljs-keyword">var</span> levelOrderBottom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">const</span> stack = [root];<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">while</span>(stack.length) &#123;res.push([]);<span class="hljs-keyword">let</span> len = stack.length;<span class="hljs-keyword">while</span>(len--) &#123;<span class="hljs-keyword">const</span> n = stack.shift();res[res.length - <span class="hljs-number">1</span>].push(n.val);<span class="hljs-keyword">if</span> (n.left) stack.push(n.left);<span class="hljs-keyword">if</span> (n.right) stack.push(n.right);&#125;&#125;    <span class="hljs-keyword">return</span> res.reverse();&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 13 二叉树中第二小的节点 671</span><span class="hljs-comment">// 给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0</span><span class="hljs-comment">// 如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</span><span class="hljs-comment">// 更正式地说，root.val = min(root.left.val, root.right.val) 总成立。</span><span class="hljs-comment">// 给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">//      2</span><span class="hljs-comment">//    /   \</span><span class="hljs-comment">//   2     5</span><span class="hljs-comment">//        / \</span><span class="hljs-comment">//       5   7</span><span class="hljs-comment">// 输入：root = [2,2,5,null,null,5,7]</span><span class="hljs-comment">// 输出：5</span><span class="hljs-comment">// 解释：最小的值是 2 ，第二小的值是 5 。</span><span class="hljs-keyword">var</span> findSecondMinimumValue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;  <span class="hljs-keyword">let</span> arr = [];  (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;      traversal(root.left)      arr.push(root.val)      traversal(root.right)    &#125;  &#125;)(root)  <span class="hljs-keyword">let</span> _arr = [...new <span class="hljs-built_in">Set</span>(arr)].sort()  <span class="hljs-keyword">return</span> _arr[<span class="hljs-number">1</span>] ? _arr[<span class="hljs-number">1</span>] : -<span class="hljs-number">1</span>&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 14 把二叉搜索树转换为累加树 1038</span><span class="hljs-comment">// 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree）</span><span class="hljs-comment">// 使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</span><span class="hljs-comment">// 提醒一下，二叉搜索树满足下列约束条件：</span><span class="hljs-comment">//  - 节点的左子树仅包含键 小于 节点键的节点。</span><span class="hljs-comment">//  - 节点的右子树仅包含键 大于 节点键的节点。</span><span class="hljs-comment">//  - 左右子树也必须是二叉搜索树。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</span><span class="hljs-comment">// 输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：root = [0,null,1]</span><span class="hljs-comment">// 输出：[1,null,1]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：root = [1,0,2]</span><span class="hljs-comment">// 输出：[3,3,2]</span><span class="hljs-comment">// 示例 4：</span><span class="hljs-comment">// 输入：root = [3,2,4,1]</span><span class="hljs-comment">// 输出：[7,9,4,10]</span><span class="hljs-keyword">var</span> bstToGst = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;traversal(root.right);root.val += sum;sum = root.val;traversal(root.left);&#125;&#125;traversal(root);<span class="hljs-keyword">return</span> root;&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 15 二叉搜索树中的搜索 700</span><span class="hljs-comment">// 给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点</span><span class="hljs-comment">// 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</span><span class="hljs-comment">// 例如，</span><span class="hljs-comment">// 给定二叉搜索树:</span><span class="hljs-comment">//         4</span><span class="hljs-comment">//        / \</span><span class="hljs-comment">//       2   7</span><span class="hljs-comment">//      / \</span><span class="hljs-comment">//     1   3</span><span class="hljs-comment">// 和值: 2</span><span class="hljs-comment">// 你应该返回如下子树:</span><span class="hljs-comment">//       2     </span><span class="hljs-comment">//      / \   </span><span class="hljs-comment">//     1   3</span><span class="hljs-comment">// 在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。</span><span class="hljs-keyword">var</span> searchBST = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, val</span>) </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">if</span> (root.val === val) &#123;<span class="hljs-keyword">return</span> root;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &lt; val) &#123;<span class="hljs-keyword">return</span> traversal(root.right);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> traversal(root.left);&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> root;&#125;  &#125;  <span class="hljs-keyword">return</span> traversal(root);&#125;</code></pre><h3 id="16-N叉树的最大深度"><a href="#16-N叉树的最大深度" class="headerlink" title="16 N叉树的最大深度"></a>16 N叉树的最大深度</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 16 N叉树的最大深度 559</span><span class="hljs-comment">// 给定一个 N 叉树，找到其最大深度。</span><span class="hljs-comment">// 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</span><span class="hljs-comment">// N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：root = [1,null,3,2,4,null,5,6]</span><span class="hljs-comment">// 输出：3</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]</span><span class="hljs-comment">// 输出：5</span><span class="hljs-keyword">var</span> maxDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">let</span> depth = <span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root, curDepth</span>) </span>&#123;<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">if</span> (curDepth &gt; depth) &#123;depth = curDepth;&#125;root.children.forEach(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> traversal(child, curDepth + <span class="hljs-number">1</span>));&#125;&#125;traversal(root, <span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> depth;&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 17 N叉树的前序遍历 589</span><span class="hljs-comment">// 给定一个 N 叉树，返回其节点值的 前序遍历 。</span><span class="hljs-comment">// N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</span><span class="hljs-comment">// 进阶：</span><span class="hljs-comment">// 递归法很简单，你可以使用迭代法完成此题吗?</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：root = [1,null,3,2,4,null,5,6]</span><span class="hljs-comment">// 输出：[1,3,5,6,2,4]</span><span class="hljs-comment">// 解法一：递归</span><span class="hljs-keyword">var</span> preorder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">const</span> res = [];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;res.push(root.val);root.children.forEach(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> traversal(child));&#125;&#125;traversal(root);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 解法二： 迭代</span><span class="hljs-keyword">var</span> preorder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">let</span> array = [];<span class="hljs-keyword">let</span> stack = [root];<span class="hljs-keyword">while</span> (stack.length) &#123;<span class="hljs-keyword">let</span> len = stack.length;<span class="hljs-keyword">let</span> node = stack.shift(); <span class="hljs-comment">// 弹出栈中第一个，先进先出</span>array.push(node.val);<span class="hljs-keyword">if</span> (node.children.length &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 这里有别于层序遍历，用 node.children 连接 queue</span><span class="hljs-comment">// 而不是 queue.concat(node.children)这样就实现了前序遍历的效果</span>stack = node.children.concat(stack);&#125;&#125;<span class="hljs-keyword">return</span> array;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 18 N叉树的后序遍历 590</span><span class="hljs-comment">// 给定一个 N 叉树，返回其节点值的 后序遍历 。</span><span class="hljs-comment">// N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</span><span class="hljs-comment">// 进阶：</span><span class="hljs-comment">// 递归法很简单，你可以使用迭代法完成此题吗?</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：root = [1,null,3,2,4,null,5,6]</span><span class="hljs-comment">// 输出：[5,6,3,2,4,1]</span><span class="hljs-comment">// 解法一：递归</span><span class="hljs-keyword">var</span> postorder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">const</span> res = [];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;root.children.forEach(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;<span class="hljs-built_in">arguments</span>.callee(child);&#125;)res.push(root.val);&#125;&#125;traversal(root);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 解法二：迭代</span><span class="hljs-keyword">var</span> postorder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">let</span> stack = [root];<span class="hljs-keyword">while</span> (stack.length) &#123;<span class="hljs-keyword">let</span> node = stack.pop(); <span class="hljs-comment">// 弹出最后面的一个元素</span><span class="hljs-keyword">if</span> (node.children.length &gt; <span class="hljs-number">0</span>) &#123;stack = stack.concat(node.children);&#125;res.unshift(node.val); <span class="hljs-comment">// 节点先进后出，数值压栈存储</span>&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 19 递增顺序查找树 897</span><span class="hljs-comment">// 给你一个树，请你 按中序遍历 重新排列树，使树中最左边的结点现在是树的根</span><span class="hljs-comment">// 并且每个结点没有左子结点，只有一个右子结点。</span><span class="hljs-comment">// 示例 ：</span><span class="hljs-comment">// 输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]</span><span class="hljs-comment">//        5</span><span class="hljs-comment">//       / \</span><span class="hljs-comment">//     3    6</span><span class="hljs-comment">//    / \    \</span><span class="hljs-comment">//   2   4    8</span><span class="hljs-comment">//  /        / \ </span><span class="hljs-comment">// 1        7   9</span><span class="hljs-comment">// 输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]</span><span class="hljs-comment">//  1</span><span class="hljs-comment">//   \</span><span class="hljs-comment">//    2</span><span class="hljs-comment">//     \</span><span class="hljs-comment">//      3</span><span class="hljs-comment">//       \</span><span class="hljs-comment">//        4</span><span class="hljs-comment">//         \</span><span class="hljs-comment">//          5</span><span class="hljs-comment">//           \</span><span class="hljs-comment">//            6</span><span class="hljs-comment">//             \</span><span class="hljs-comment">//              7</span><span class="hljs-comment">//               \</span><span class="hljs-comment">//                8</span><span class="hljs-comment">//                 \</span><span class="hljs-comment">//                  9  </span><span class="hljs-keyword">var</span> increasingBST = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">const</span> arr = [];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;traversal(root.left);arr.push(root.val);traversal(root.right);&#125;&#125;traversal(root);<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> TreeNode(arr[<span class="hljs-number">0</span>]);<span class="hljs-keyword">let</span> currentNode = res;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;currentNode.left = <span class="hljs-literal">null</span>;currentNode.right = <span class="hljs-keyword">new</span> TreeNode(arr[i + <span class="hljs-number">1</span>]);currentNode = currentNode.right;&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 20 二叉树的所有路径 257</span><span class="hljs-comment">// 给定一个二叉树，返回所有从根节点到叶子节点的路径。</span><span class="hljs-comment">// 说明: 叶子节点是指没有子节点的节点。</span><span class="hljs-comment">// 例如：</span><span class="hljs-comment">// 输入:</span><span class="hljs-comment">//    1</span><span class="hljs-comment">//  /   \</span><span class="hljs-comment">// 2     3</span><span class="hljs-comment">//  \</span><span class="hljs-comment">//   5</span><span class="hljs-comment">// 输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span><span class="hljs-comment">// 解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3</span><span class="hljs-keyword">var</span> binaryTreePaths = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">root, str = <span class="hljs-string">&#x27;&#x27;</span></span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (root.left) dfs(root.left, str + root.val + <span class="hljs-string">&#x27;-&gt;&#x27;</span>);<span class="hljs-keyword">if</span> (root.right) dfs(root.right, str + root.val + <span class="hljs-string">&#x27;-&gt;&#x27;</span>);<span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right) res.push(str + root.val);<span class="hljs-keyword">return</span>; &#125;dfs(root);<span class="hljs-keyword">return</span> res;&#125;;</code></pre><h3 id="21-另一个树的子树"><a href="#21-另一个树的子树" class="headerlink" title="21 另一个树的子树"></a>21 另一个树的子树</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 21 另一个树的子树 257</span><span class="hljs-comment">// 给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树</span><span class="hljs-comment">// s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 给定的树 s:</span><span class="hljs-comment">//      3</span><span class="hljs-comment">//     / \</span><span class="hljs-comment">//    4   5</span><span class="hljs-comment">//   / \</span><span class="hljs-comment">//  1   2</span><span class="hljs-comment">// 给定的树 t：</span><span class="hljs-comment">//    4 </span><span class="hljs-comment">//   / \</span><span class="hljs-comment">//  1   2</span><span class="hljs-comment">// 返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</span><span class="hljs-comment">// 示例 2:</span><span class="hljs-comment">// 给定的树 s：</span><span class="hljs-comment">//      3</span><span class="hljs-comment">//     / \</span><span class="hljs-comment">//    4   5</span><span class="hljs-comment">//   / \</span><span class="hljs-comment">//  1   2</span><span class="hljs-comment">//     /</span><span class="hljs-comment">//    0</span><span class="hljs-comment">// 给定的树 t：</span><span class="hljs-comment">//    4</span><span class="hljs-comment">//   / \</span><span class="hljs-comment">//  1   2</span><span class="hljs-comment">// 返回 false</span><span class="hljs-keyword">var</span> isSubtree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<span class="hljs-keyword">if</span> (!s) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">if</span> (isSameTree(s, t)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">return</span> isSubtree(s.left, t) || isSubtree(s.right, t); <span class="hljs-comment">// 有一个true就true</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSameTree</span>(<span class="hljs-params">s, t</span>) </span>&#123; <span class="hljs-comment">// 100题</span><span class="hljs-keyword">if</span> (!s &amp;&amp; !t) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;<span class="hljs-keyword">if</span> (!s || !t ) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">return</span> s.val == t.val &amp;&amp; isSameTree(s.left, t.left) &amp;&amp; isSameTree(s.right, t.right);&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 22 从前序与中序遍历序列构造二叉树 105</span><span class="hljs-comment">// 根据一棵树的前序遍历与中序遍历构造二叉树。</span><span class="hljs-comment">// 注意:</span><span class="hljs-comment">// 你可以假设树中没有重复的元素。</span><span class="hljs-comment">// 例如，给出</span><span class="hljs-comment">// 前序遍历 preorder = [3,9,20,15,7]</span><span class="hljs-comment">// 中序遍历 inorder = [9,3,15,20,7]</span><span class="hljs-comment">// 返回如下的二叉树：</span><span class="hljs-comment">//     3</span><span class="hljs-comment">//    / \</span><span class="hljs-comment">//   9  20</span><span class="hljs-comment">//     /  \</span><span class="hljs-comment">//    15   7</span><span class="hljs-keyword">var</span> buildTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">preorder, inorder</span>) </span>&#123;<span class="hljs-keyword">if</span>(!inorder.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-keyword">const</span> rootVal = preorder[<span class="hljs-number">0</span>];<span class="hljs-keyword">const</span> rootIndex = inorder.indexOf(rootVal);<span class="hljs-keyword">let</span> root = <span class="hljs-keyword">new</span> TreeNode(rootVal);root.left = buildTree(preorder.slice(<span class="hljs-number">1</span>, rootIndex + <span class="hljs-number">1</span>),inorder.slice(<span class="hljs-number">0</span>, rootIndex));root.right = buildTree(preorder.slice(rootIndex + <span class="hljs-number">1</span>),inorder.slice(rootIndex + <span class="hljs-number">1</span>));<span class="hljs-keyword">return</span> root;<span class="hljs-comment">// 解法二</span><span class="hljs-comment">// let build = (inorder) =&gt; &#123;</span><span class="hljs-comment">// if(!inorder || !inorder.length) return null;</span><span class="hljs-comment">// const rootVal = preorder.shift();</span><span class="hljs-comment">// const rootIndex = inorder.indexOf(rootVal);</span><span class="hljs-comment">// let root = new TreeNode(rootVal);</span><span class="hljs-comment">// root.left = build(inorder.slice(0, rootIndex));</span><span class="hljs-comment">// root.right = build(inorder.slice(rootIndex + 1));</span><span class="hljs-comment">// return root</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// return build(inorder)</span>&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 23 从中序与后序遍历序列构造二叉树 106</span><span class="hljs-comment">// 根据一棵树的前序遍历与中序遍历构造二叉树。</span><span class="hljs-comment">// 注意:</span><span class="hljs-comment">// 你可以假设树中没有重复的元素。</span><span class="hljs-comment">// 例如，给出</span><span class="hljs-comment">// 前序遍历 preorder = [3,9,20,15,7]</span><span class="hljs-comment">// 中序遍历 inorder = [9,3,15,20,7]</span><span class="hljs-comment">// 返回如下的二叉树：</span><span class="hljs-comment">//     3</span><span class="hljs-comment">//    / \</span><span class="hljs-comment">//   9  20</span><span class="hljs-comment">//     /  \</span><span class="hljs-comment">//    15   7</span><span class="hljs-keyword">var</span> buildTree = <span class="hljs-function">(<span class="hljs-params">inorder, postorder</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span>(!inorder.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-keyword">const</span> rootVal = postorder.pop();<span class="hljs-keyword">const</span> rootIndex = inorder.indexOf(rootVal);<span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> TreeNode(rootVal);root.left = buildTree(inorder.slice(<span class="hljs-number">0</span>, rootIndex), postorder.slice(<span class="hljs-number">0</span>, rootIndex));root.right = buildTree(inorder.slice(rootIndex + <span class="hljs-number">1</span>), postorder.slice(rootIndex));<span class="hljs-keyword">return</span> root;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 24 平衡二叉树 110</span><span class="hljs-comment">// 给定一个二叉树，判断它是否是高度平衡的二叉树。</span><span class="hljs-comment">// 本题中，一棵高度平衡二叉树定义为：</span><span class="hljs-comment">// 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：root = [3,9,20,null,null,15,7]</span><span class="hljs-comment">// 输出：true</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：root = [1,2,2,3,3,null,null,4,4]</span><span class="hljs-comment">// 输出：false</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：root = []</span><span class="hljs-comment">// 输出：true</span><span class="hljs-comment">// 解法一</span><span class="hljs-keyword">var</span> isBalanced = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span>(!root || root.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">const</span> maxLeft = getMaxLevel(root.left);    <span class="hljs-keyword">const</span> maxRight = getMaxLevel(root.right);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.abs(maxLeft - maxRight) &lt;= <span class="hljs-number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMaxLevel</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> max = <span class="hljs-number">1</span>;    <span class="hljs-keyword">const</span> dp = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, l</span>) </span>&#123;        <span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right)  max = <span class="hljs-built_in">Math</span>.max(max, l);        <span class="hljs-keyword">if</span> (root.left) dp(root.left, l + <span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span> (root.right) dp(root.right, l + <span class="hljs-number">1</span>);    &#125;    dp(root, <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> max;&#125;<span class="hljs-comment">// 解法二</span><span class="hljs-keyword">const</span> isBalanced = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-comment">// 获取当前节点高度的递归函数</span>    <span class="hljs-keyword">const</span> getH = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">// 返回左右节点的最大高度+1,（+1:根节点）</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(getH(root.left), getH(root.right)) + <span class="hljs-number">1</span>;    &#125;;    <span class="hljs-comment">// 能递归到达这里，这个子树肯定是平衡二叉树</span>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-comment">// 平衡二叉树的条件：</span>    <span class="hljs-keyword">return</span> (        <span class="hljs-comment">// 1. 根节点的左右节点高度差不超过1</span>        <span class="hljs-built_in">Math</span>.abs(getH(root.left) - getH(root.right)) &lt;= <span class="hljs-number">1</span> &amp;&amp;        <span class="hljs-comment">// 2. 左子树是平衡二叉树</span>        isBalanced(root.left) &amp;&amp;        <span class="hljs-comment">// 3. 右子树是平衡二叉树</span>        isBalanced(root.right)    );&#125;;<span class="hljs-comment">// 解法三</span><span class="hljs-keyword">var</span> isBalanced = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">return</span> balanced(root) !== -<span class="hljs-number">1</span>&#125;;<span class="hljs-keyword">var</span> balanced = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    <span class="hljs-keyword">const</span> left = balanced(node.left)    <span class="hljs-keyword">const</span> right = balanced(node.right)    <span class="hljs-keyword">if</span> (left === -<span class="hljs-number">1</span> || right === -<span class="hljs-number">1</span> || <span class="hljs-built_in">Math</span>.abs(left - right) &gt; <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(left, right) + <span class="hljs-number">1</span>&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 25 有序链表转换平衡二叉树 109</span><span class="hljs-comment">// 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</span><span class="hljs-comment">// 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</span><span class="hljs-comment">// 示例:</span><span class="hljs-comment">// 给定的有序链表： [-10, -3, 0, 5, 9],</span><span class="hljs-comment">// 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span><span class="hljs-comment">//       0</span><span class="hljs-comment">//      / \</span><span class="hljs-comment">//    -3   9</span><span class="hljs-comment">//    /   /</span><span class="hljs-comment">//  -10  5</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> sortedListToBST = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTree</span>(<span class="hljs-params">head, end</span>) </span>&#123;<span class="hljs-keyword">if</span> (head === end) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><span class="hljs-keyword">let</span> p1 = head; <span class="hljs-comment">// 慢指针，中间节点</span><span class="hljs-keyword">let</span> p2 = head; <span class="hljs-comment">// 快指针，结束节点</span><span class="hljs-keyword">while</span>(p2 !== end) &#123;p2 = p2.next;<span class="hljs-keyword">if</span> (p2 !== end) &#123;p1 = p1.next;p2 = p2.next;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(p1.val, getTree(head, p1), getTree(p1.next, end))&#125;<span class="hljs-keyword">return</span> getTree(head, <span class="hljs-literal">null</span>)&#125;;</code></pre><h3 id="26-路径总和"><a href="#26-路径总和" class="headerlink" title="26 路径总和"></a>26 路径总和</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 26-1 路径总和 Ⅰ 112</span><span class="hljs-comment">// 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。</span><span class="hljs-comment">// 实例</span><span class="hljs-comment">// 输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><span class="hljs-comment">// 输出：true</span><span class="hljs-keyword">var</span> hasPathSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, sum</span>) </span>&#123;<span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">let</span> res = <span class="hljs-literal">false</span>;<span class="hljs-keyword">const</span> dpt = <span class="hljs-function">(<span class="hljs-params">root, s</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right &amp;&amp; s === sum) &#123;res = <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">if</span> (root.left) &#123;dpt(root.left, s + root.left.val)&#125;<span class="hljs-keyword">if</span> (root.right) &#123;dpt(root.right, s + root.right.val)&#125;&#125;dpt(root, root.val);<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-comment">// 26-2 路径总和 ⅠⅠ 113</span><span class="hljs-comment">// 给你二叉树的根节点 root 和一个整数目标和 targetSum</span><span class="hljs-comment">// 找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</span><span class="hljs-comment">// 实例1：</span><span class="hljs-comment">// 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><span class="hljs-comment">// 输出：[[5,4,11,2],[5,8,4,5]]</span><span class="hljs-keyword">var</span> pathSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, targetSum</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> dp = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, arr</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;<span class="hljs-keyword">const</span> sum = arr.reduce(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + cur);<span class="hljs-keyword">if</span> (sum == targetSum) &#123;res.push(arr);&#125;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (root.left) dp(root.left, [...arr, root.left.val]);<span class="hljs-keyword">if</span> (root.right) dp(root.right, [...arr, root.right.val]);&#125;dp(root, [root.val]);<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 27  填充每个节点的下一个右侧节点指针 116</span><span class="hljs-comment">// 给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。</span><span class="hljs-comment">// 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</span><span class="hljs-comment">// 初始状态下，所有 next 指针都被设置为 NULL。</span><span class="hljs-comment">// 实例1：</span><span class="hljs-comment">// 输入：root = [1,2,3,4,5,6,7]</span><span class="hljs-comment">// 输出：[1,#,2,3,#,4,5,6,7,#]</span><span class="hljs-comment">// 解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#x27;#&#x27; 标志着每一层的结束。</span><span class="hljs-comment">// 进阶：</span><span class="hljs-comment">// 1. 你只能使用常量级额外空间。</span><span class="hljs-comment">// 2. 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</span><span class="hljs-keyword">var</span> connect = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-comment">// 解法一: 广度遍历</span><span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-keyword">const</span> stack = [root];<span class="hljs-keyword">while</span>(stack.length) &#123;<span class="hljs-keyword">let</span> len = stack.length;<span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>;<span class="hljs-keyword">while</span>(len) &#123;<span class="hljs-keyword">const</span> item = stack.shift();<span class="hljs-keyword">if</span> (item &amp;&amp; item.left) stack.push(item.left);<span class="hljs-keyword">if</span> (item &amp;&amp; item.right) stack.push(item.right);<span class="hljs-keyword">if</span> (pre) pre.next = item;pre = item;len--;&#125;&#125;<span class="hljs-keyword">return</span> root;<span class="hljs-comment">// 解法二: 递归 </span><span class="hljs-comment">// 解法二更符合题目中进阶的要求</span><span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-keyword">if</span> (root.left) root.left.next = root.right;<span class="hljs-keyword">if</span> (root.right &amp;&amp; root.next) root.right.next = root.next.left;connect(root.left);connect(root.right);<span class="hljs-keyword">return</span> root;&#125;;</code></pre><h2 id="三-数组"><a href="#三-数组" class="headerlink" title="三 数组"></a>三 数组</h2><p>1 全排列 ——（给定一个 没有重复 nums，返回其所有可能的全排列）<br>2 全排列II ——（给定一个 可能重复 的数组 nums ，返回所有不重复的全排列）<br>3 子集 ——（给你一个整数数组 nums，返回所有子集数组）<br>4 子集II ——（给定一个可能重复数组 nums，返回所有子集数组）<br>5 组合总和 ——（从无重复数组 nums 中找到和 为target 的所有子数组）<br>6 组合总和II ——（从可能重复数组 nums 中找到和 为target 的所有子数组）<br>7 组合 ——（给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合）<br>8 优美的排列<br>9 优美的排列II<br>10 电话号码的字母组合 —— (从一个仅包含数字2-9的字符串，返回所有它能表示的字母组合)<br>11 括号生成 —— (数字 n 代表生成括号的对数，找到所有 有效的 括号组合)<br>12 盛最多水的容器 ——（从数组中找到 盛最多水的 两个值）<br>13 三数之和 ——（三数之和为0）<br>14 删除有序数组中的重复项<br>15 加一<br>16 移动零 —— （把数组 nums 的所有 0 移动到数组的末尾）<br>17 最小栈 —— （设计一个栈，支持push/pop/top/操作，以及检索到最小元素的栈）<br>18 跳跃游戏 —— （nums元素代表可以跳跃的最大长度，判断是否能够到达最后一个下标）<br>19 跳跃游戏 II —— （nums元素代表可以跳跃的最大长度，判断是否能够到达最后一个下标）<br>20 最大子序和 —— （从数组中找到最大和的连续子数组的和）<br>21 最接近的三数之和 —— （找出 nums 中的三个整数的和与 target 最接近）<br>22 四数之和<br>23 字母异位词分组 —— 字符串数组，将包含相同字母项组合在一起<br>24 最长连续递增序列 —— 找到数组中找到 最长且 连续递增 的子序列<br>25 最长递增子序列 —— 找到其中最长严格递增子序列的长度<br>26 寻找两个正序数组的中位数 - 找到两个正序数组的中位数<br>27 和为K的子数组 —— 找到数组中和为 k 的连续的子数组的个数<br>28 两数之和 II - 输入有序数组 —— 升序的有序数组中找到和为target的目标<br>29 合并区间 —— 合并二维数组中区间重复的项<br>30 插入区间 —— 将一个区间数组 插入 到另一个 二维区间数组中<br>31 搜索旋转排序数组 —— 从已排序的数组中找到 指定的值<br>32 在排序数组中查找元素的第一个和最后一个位置<br>33 下一个排列 —— 找到数组的下一个更大的值<br>34 旋转图像<br>35 螺旋矩阵 —— 把二维数组(m * n) 按照 顺时针螺旋顺序 旋转</p><h3 id="1-全排列"><a href="#1-全排列" class="headerlink" title="1 全排列"></a>1 全排列</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 1 全排列 46</span><span class="hljs-comment">// 给定一个 没有重复 数字的序列，返回其所有可能的全排列。</span><span class="hljs-comment">// 示例:</span><span class="hljs-comment">// 输入: [1,2,3]</span><span class="hljs-comment">// 输出:</span><span class="hljs-comment">// [</span><span class="hljs-comment">//   [1,2,3],</span><span class="hljs-comment">//   [1,3,2],</span><span class="hljs-comment">//   [2,1,3],</span><span class="hljs-comment">//   [2,3,1],</span><span class="hljs-comment">//   [3,1,2],</span><span class="hljs-comment">//   [3,2,1]</span><span class="hljs-comment">// ]</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> permute = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-comment">// 时间复杂度：O(!n) ; !n = 1 x 2 x 3 x ... x (n-1) x n</span><span class="hljs-comment">// 空间复杂度：O(n)</span><span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> backtrck = <span class="hljs-function"><span class="hljs-params">path</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (path.length === nums.length) &#123;res.push(path);<span class="hljs-keyword">return</span>;&#125;nums.forEach(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (path.includes(n)) <span class="hljs-keyword">return</span>;backtrck(path.concat(n));&#125;)&#125;backtrck([]);<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 2 全排列II 47</span><span class="hljs-comment">// 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [1,1,2]</span><span class="hljs-comment">// 输出：</span><span class="hljs-comment">// [[1,1,2],</span><span class="hljs-comment">//  [1,2,1],</span><span class="hljs-comment">//  [2,1,1]]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：nums = [1,2,3]</span><span class="hljs-comment">// 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><span class="hljs-keyword">var</span> permuteUnique = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">const</span> len = nums.length;<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> used = [];nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b)<span class="hljs-keyword">const</span> backtrack = <span class="hljs-function">(<span class="hljs-params">deepStack</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (deepStack.length === len) &#123;res.push(deepStack.slice())<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<span class="hljs-comment">// 当前选项与上一项相同、且上一项存在、且没有被使用过，则忽略</span><span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] === nums[i] &amp;&amp; i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; !used[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span> <span class="hljs-keyword">if</span> (used[i]) <span class="hljs-keyword">continue</span> <span class="hljs-comment">// 使用过便不再使用</span>deepStack.push(nums[i])used[i] = <span class="hljs-literal">true</span>backtrack(deepStack)deepStack.pop()used[i] = <span class="hljs-literal">false</span>&#125;&#125;backtrack([])<span class="hljs-keyword">return</span> res&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 3 子集 78</span><span class="hljs-comment">// 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</span><span class="hljs-comment">// 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [1,2,3]</span><span class="hljs-comment">// 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><span class="hljs-comment">// 解法一： 回溯</span><span class="hljs-keyword">var</span> subsets = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-comment">// 时间复杂度：O(2^n) 因为每个元素都有两种可能（存在或不存在）</span>    <span class="hljs-comment">// 空间复杂度：O(n)</span><span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> backtrack = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr, len, startIndex</span>) </span>&#123;<span class="hljs-keyword">if</span> (arr.length === len) &#123;res.push(arr);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = startIndex; index &lt; nums.length; index++) &#123;backtrack([...arr, nums[index]], len, index + <span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (i &lt;= nums.length) &#123;backtrack([], i, <span class="hljs-number">0</span>);i++;&#125;<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-comment">// 解法二 迭代 动态规划</span><span class="hljs-comment">// 重复将新的元素加入到上一个结果集中的每个子集当中去</span><span class="hljs-comment">// 形成n个新的子集，再全部加入到结果集中去</span><span class="hljs-keyword">var</span> subsets = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">let</span> res = [[]];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<span class="hljs-keyword">let</span> len = res.length;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; len; j++)&#123;<span class="hljs-keyword">let</span> sub = res[j].slice();sub.push(nums[i]);res.push(sub);&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-comment">// 解法三 递归</span><span class="hljs-keyword">const</span> subsets = <span class="hljs-function">(<span class="hljs-params">nums</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">index, list</span>) =&gt;</span> &#123;res.push(list.slice());     <span class="hljs-comment">// 调用子递归前，加入解集</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = index; i &lt; nums.length; i++) &#123; <span class="hljs-comment">// 枚举出所有可选的数</span>list.push(nums[i]);       <span class="hljs-comment">// 选这个数</span>dfs(i + <span class="hljs-number">1</span>, list);         <span class="hljs-comment">// 基于选这个数，继续递归，传入的是i+1，不是index+1</span>list.pop();               <span class="hljs-comment">// 撤销选这个数</span>&#125;&#125;;dfs(<span class="hljs-number">0</span>, []);<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 4 子集II  90.</span><span class="hljs-comment">// 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</span><span class="hljs-comment">// 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [1,2,2]</span><span class="hljs-comment">// 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><span class="hljs-keyword">var</span> subsetsWithDup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">if</span> (nums.length==<span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> [nums];&#125;<span class="hljs-keyword">if</span> (nums.length==<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> [[],nums];&#125;nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b); <span class="hljs-comment">// 先排序</span><span class="hljs-keyword">let</span> result = [[]]; <span class="hljs-comment">// 记录全部子数组</span><span class="hljs-keyword">let</span> lastLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录上一个元素添加前，result的长度</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;<span class="hljs-comment">// 当遇到重复元素时，从上一个元素添加前</span><span class="hljs-comment">// result的长度处，开始每一个子数组都添加该元素</span><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>])&#123;j = lastLength;&#125;<span class="hljs-keyword">let</span> n = result.length;<span class="hljs-comment">// 保持lastLength的更新</span>lastLength = result.length;<span class="hljs-comment">// 如果不是重复元素，j初始为0,从result开头，每个子数组都添加上该元素</span><span class="hljs-keyword">for</span> (; j &lt; n; j++)&#123;result.push([...result[j],nums[i]])&#125;&#125;<span class="hljs-keyword">return</span> result;&#125;;<span class="hljs-comment">// 解法二 </span><span class="hljs-keyword">var</span> subsetsWithDup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">let</span> n = nums.length;nums = nums.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> a - b&#125;);<span class="hljs-keyword">let</span> tmpPath = [];<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">let</span> hash = &#123;&#125;<span class="hljs-keyword">let</span> backtrack = <span class="hljs-function">(<span class="hljs-params">tmpPath,start</span>) =&gt;</span> &#123;res.push(tmpPath);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = start;i &lt; n;i++)&#123;<span class="hljs-keyword">if</span>(hash[i] || (i &gt; <span class="hljs-number">0</span> &amp;&amp; !hash[i-<span class="hljs-number">1</span>] &amp;&amp; nums[i-<span class="hljs-number">1</span>] == nums[i])) <span class="hljs-keyword">continue</span>;hash[i] = <span class="hljs-literal">true</span>;tmpPath.push(nums[i]);backtrack(tmpPath.slice(),i+<span class="hljs-number">1</span>);hash[i] = <span class="hljs-literal">false</span>;tmpPath.pop();&#125; &#125;backtrack(tmpPath,<span class="hljs-number">0</span>);<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 5 组合总和 39</span><span class="hljs-comment">// 给定一个无重复元素的数组 candidates 和一个目标数 target </span><span class="hljs-comment">// 找出 candidates 中所有可以使数字和为 target 的组合。</span><span class="hljs-comment">// candidates 中的数字可以无限制重复被选取。</span><span class="hljs-comment">// 说明：</span><span class="hljs-comment">// 所有数字（包括 target）都是正整数。</span><span class="hljs-comment">// 解集不能包含重复的组合。 </span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：candidates = [2,3,6,7], target = 7,</span><span class="hljs-comment">// 所求解集为：</span><span class="hljs-comment">// [</span><span class="hljs-comment">//   [7],</span><span class="hljs-comment">//   [2,2,3]</span><span class="hljs-comment">// ]</span><span class="hljs-keyword">var</span> combinationSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums,target</span>) </span>&#123;<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> dfs = <span class="hljs-function">(<span class="hljs-params">subArr, sum, start</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span>(sum &gt; target) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>(sum  == target)&#123;<span class="hljs-comment">//这里不能直接push subArr这个数组，对于js这门语言来说，可以充分利用js的...运算符</span>res.push([...subArr]);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i  = start ; i &lt; nums.length ; i++)&#123;<span class="hljs-keyword">let</span> temp = sum;sum = sum + nums[i];subArr.push(nums[i]);dfs(subArr, sum,i);<span class="hljs-comment">//回到之前的状态，对于数组来讲就是pop，对于sum来讲可以用一个变量来记录以前的值</span>subArr.pop(nums[i]);sum = temp;&#125;&#125;dfs([], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-comment">// 解法二</span><span class="hljs-keyword">var</span> combinationSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">candidates, target</span>) </span>&#123;<span class="hljs-keyword">let</span> n = candidates.length;<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">let</span> tmpPath = [];<span class="hljs-keyword">let</span> backtrack = <span class="hljs-function">(<span class="hljs-params">tmpPath,target,start</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span>(target &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)&#123;res.push(tmpPath);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = start;i &lt; n;i++)&#123;tmpPath.push(candidates[i]);backtrack(tmpPath.slice(),target - candidates[i],i);tmpPath.pop();&#125;&#125;backtrack(tmpPath, target, <span class="hljs-number">0</span>);<span class="hljs-keyword">return</span> res;&#125;;</code></pre><h3 id="6-组合总和-II"><a href="#6-组合总和-II" class="headerlink" title="6 组合总和 II"></a>6 组合总和 II</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 6 组合总和 II 40</span><span class="hljs-comment">// 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><span class="hljs-comment">// candidates 中的每个数字在每个组合中只能使用一次。</span><span class="hljs-comment">// 说明：</span><span class="hljs-comment">// 所有数字（包括目标数）都是正整数。</span><span class="hljs-comment">// 解集不能包含重复的组合。 </span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><span class="hljs-comment">// 所求解集为:</span><span class="hljs-comment">// [</span><span class="hljs-comment">//   [1, 7],</span><span class="hljs-comment">//   [1, 2, 5],</span><span class="hljs-comment">//   [2, 6],</span><span class="hljs-comment">//   [1, 1, 6]</span><span class="hljs-comment">// ]</span><span class="hljs-keyword">var</span> combinationSum2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">candidates, target</span>) </span>&#123;<span class="hljs-keyword">let</span> n = candidates.length;<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">let</span> tmpPath = [];candidates = candidates.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> a - b&#125;)<span class="hljs-keyword">let</span> backtrack = <span class="hljs-function">(<span class="hljs-params">tmpPath,target,start</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)&#123;res.push(tmpPath);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = start;i &lt; n;i++)&#123;<span class="hljs-keyword">if</span>(target &lt; candidates[i]) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">if</span>(i &gt; start &amp;&amp; candidates[i-<span class="hljs-number">1</span>] == candidates[i]) <span class="hljs-keyword">continue</span>;tmpPath.push(candidates[i]);backtrack(tmpPath.slice(),target - candidates[i],i + <span class="hljs-number">1</span>);tmpPath.pop();&#125;&#125;backtrack(tmpPath,target,<span class="hljs-number">0</span>);<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 7 组合 77</span><span class="hljs-comment">// 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。</span><span class="hljs-comment">// 示例:</span><span class="hljs-comment">// 输入: n = 4, k = 2</span><span class="hljs-comment">// 输出:</span><span class="hljs-comment">// [</span><span class="hljs-comment">//   [2,4],</span><span class="hljs-comment">//   [3,4],</span><span class="hljs-comment">//   [2,3],</span><span class="hljs-comment">//   [1,2],</span><span class="hljs-comment">//   [1,3],</span><span class="hljs-comment">//   [1,4],</span><span class="hljs-comment">// ]</span><span class="hljs-comment">// 解法一 动态规划</span><span class="hljs-keyword">var</span> combine = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n, k</span>) </span>&#123;<span class="hljs-keyword">var</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;dp[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(k+<span class="hljs-number">1</span>);dp[i][<span class="hljs-number">0</span>] = [[]];&#125;<span class="hljs-built_in">console</span>.log(dp);<span class="hljs-comment">// i：1~n</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<span class="hljs-comment">//j：1～i/k</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>;j &lt;= i &amp;&amp; j &lt;= k ;j++)&#123;dp[i][j] = [];<span class="hljs-comment">// 从 i-1 个里选 j 个</span><span class="hljs-comment">// 即从上题解法的：从 n-1 个里选 k个</span><span class="hljs-keyword">if</span>(i &gt; j)&#123;<span class="hljs-keyword">var</span> tmpA = dp[i-<span class="hljs-number">1</span>][j];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> t = <span class="hljs-number">0</span>;t&lt;tmpA.length;t++)&#123;dp[i][j].push(tmpA[t]);&#125;&#125;<span class="hljs-comment">// 从 i-1 个里选 j-1个</span><span class="hljs-keyword">var</span> tmpB = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> z = <span class="hljs-number">0</span>; z &lt; tmpB.length; z++)&#123;<span class="hljs-comment">// 这里注意不能修改dp[i-1][j-1]的原数组元素，需要深拷贝</span><span class="hljs-keyword">var</span> tmpC = [].concat(tmpB[z]);tmpC.push(i);dp[i][j].push(tmpC);&#125;&#125;&#125;<span class="hljs-keyword">return</span> dp[n][k];&#125;;<span class="hljs-comment">// 解法二：迭代回溯</span><span class="hljs-keyword">var</span> combine = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n, k</span>) </span>&#123;<span class="hljs-keyword">var</span> result = [];<span class="hljs-keyword">var</span> subresult = [];<span class="hljs-comment">// 初始化k个数字的临时组合各个元素为0</span><span class="hljs-comment">// 便于++对应 n的1，2，3，4..n</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> r = <span class="hljs-number">0</span>; r &lt; k; r++)&#123;subresult[r] = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// n的总个数达不到k组合的个数 不可能实现</span><span class="hljs-keyword">if</span>(n &lt; k)&#123;<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-comment">// 迭代索引</span><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">// 当前数字加一 对于回溯中 subresult push 一个新的i 即为上一个i+1</span>subresult[i]++;<span class="hljs-comment">// 当i循环到n时，此时 i=n+1 </span><span class="hljs-comment">// i-- 对应回溯的函数调用执行栈的逆序出栈 即回到上一层的组合状态操作</span><span class="hljs-keyword">if</span>(subresult[i] &gt; n)&#123;i--;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == k -<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">// 索引从0开始 i == k-1 相等于 回溯i从1开始后i==k 的情况</span>result.push(subresult.slice(<span class="hljs-number">0</span>));&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 对于回溯外层for循环的下一层i操作 即start</span>++i;<span class="hljs-comment">// 相当于回溯的pop操作 去掉新加的值 退回上一层的值重新递归 此处为迭代</span>subresult[i] = subresult[i-<span class="hljs-number">1</span>];&#125;&#125;<span class="hljs-keyword">return</span> result;&#125;;<span class="hljs-comment">// 解法三 </span><span class="hljs-keyword">var</span> combine = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n, k</span>) </span>&#123;<span class="hljs-keyword">var</span> result = [];<span class="hljs-keyword">var</span> subresult = [];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combineSub</span>(<span class="hljs-params">start,subresult</span>)</span>&#123;<span class="hljs-keyword">if</span>(subresult.length == k)&#123;result.push(subresult.slice(<span class="hljs-number">0</span>));<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">var</span> len = subresult.length;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i= start;i&lt;=n-(k-len)+<span class="hljs-number">1</span>;i++)&#123;subresult.push(i);combineSub(i+<span class="hljs-number">1</span>,subresult);subresult.pop();            &#125;   &#125;combineSub(<span class="hljs-number">1</span>,subresult);<span class="hljs-keyword">return</span> result;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 8 优美的排列 526</span><span class="hljs-comment">// 假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组</span><span class="hljs-comment">// 使得数组的第 i 位 (1 &lt;= i &lt;= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：</span><span class="hljs-comment">// 第 i 位的数字能被 i 整除</span><span class="hljs-comment">// i 能被第 i 位上的数字整除</span><span class="hljs-comment">// 现在给定一个整数 N，请问可以构造多少个优美的排列？</span><span class="hljs-comment">// 示例1:</span><span class="hljs-comment">// 输入: 2</span><span class="hljs-comment">// 输出: 2</span><span class="hljs-comment">// 解释: </span><span class="hljs-comment">// 第 1 个优美的排列是 [1, 2]:</span><span class="hljs-comment">//   第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除</span><span class="hljs-comment">//   第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除</span><span class="hljs-comment">// 第 2 个优美的排列是 [2, 1]:</span><span class="hljs-comment">//   第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除</span><span class="hljs-comment">//   第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除</span><span class="hljs-comment">// 说明:</span><span class="hljs-comment">// N 是一个正整数，并且不会超过15。</span><span class="hljs-keyword">var</span> countArrangement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) </span>&#123;<span class="hljs-comment">// visited[num]表示num是否被使用</span><span class="hljs-comment">// 每次循环都通过visited去找下一个符合要求的数字 找到后索引值加一</span><span class="hljs-comment">// 一个for循环中每个数字只使用一次 使用完成以后需要释放 即visited[num] = false</span><span class="hljs-comment">// arr.fill(value[, start[, end]])</span><span class="hljs-comment">// value 填充值</span><span class="hljs-keyword">let</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(N+<span class="hljs-number">1</span>).fill(<span class="hljs-literal">false</span>);<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> dfs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) </span>&#123;<span class="hljs-keyword">if</span> (index &gt; N) &#123;++res;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>; num &lt;= N; ++num) &#123;<span class="hljs-keyword">if</span> (!visited[num] &amp;&amp; (num % index === <span class="hljs-number">0</span> || index % num === <span class="hljs-number">0</span>)) &#123;visited[num] = <span class="hljs-literal">true</span>;dfs(index+<span class="hljs-number">1</span>)visited[num] = <span class="hljs-literal">false</span>;&#125;&#125;&#125; dfs(<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 9 优美的排列II 667</span><span class="hljs-comment">// 给你两个整数 n 和 k ，请你构造一个答案列表 answer ，该列表应当包含从 1 到 n 的 n 个不同正整数</span><span class="hljs-comment">// 并同时满足下述条件：</span><span class="hljs-comment">// 假设该列表是 answer = [a1, a2, a3, ... , an] </span><span class="hljs-comment">// 那么列表 [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] 中应该有且仅有 k 个不同整数。</span><span class="hljs-comment">// 返回列表 answer 。如果存在多种答案，只需返回其中 任意一种 。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：n = 3, k = 1</span><span class="hljs-comment">// 输出：[1, 2, 3]</span><span class="hljs-comment">// 解释：[1, 2, 3] 包含 3 个范围在 1-3 的不同整数，并且 [1, 1] 中有且仅有 1 个不同整数：1</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：n = 3, k = 2</span><span class="hljs-comment">// 输出：[1, 3, 2]</span><span class="hljs-comment">// 解释：[1, 3, 2] 包含 3 个范围在 1-3 的不同整数，并且 [2, 1] 中有且仅有 2 个不同整数：1 和 2</span><span class="hljs-comment">// 提示：</span><span class="hljs-comment">// 1 &lt;= k &lt; n &lt;= 104</span><span class="hljs-keyword">var</span> constructArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n, k</span>) </span>&#123;<span class="hljs-comment">// 寻找规律：</span><span class="hljs-comment">// 使用k+1个数字，即可组成k个差值，剩余的部分直接使用差值为1顺序填充即可</span><span class="hljs-comment">// [1, 1**+k**, 1+k**-(k-1), 1+k-(k-1)+(k-1-1)**,,,]</span><span class="hljs-keyword">let</span> result = [<span class="hljs-number">1</span>];<span class="hljs-keyword">let</span> i = k;<span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// true为正，false为负</span><span class="hljs-keyword">while</span> (result.length &lt;= k) &#123;num = flag ? num + i : num - i;result.push(num);i--;flag = !flag;&#125;<span class="hljs-comment">// 基数已经准备好，进行剩余部分的填充</span>num = result.length + <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (num &lt;= n) &#123;result.push(num++);&#125;<span class="hljs-keyword">return</span> result;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 10 电话号码的字母组合 17</span><span class="hljs-comment">// 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</span><span class="hljs-comment">// 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：digits = &quot;23&quot;</span><span class="hljs-comment">// 输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：digits = &quot;&quot;</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：digits = &quot;2&quot;</span><span class="hljs-comment">// 输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><span class="hljs-keyword">var</span> letterCombinations = <span class="hljs-function">(<span class="hljs-params">digits</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!digits.length) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">const</span> map = [<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;def&#x27;</span>, <span class="hljs-string">&#x27;ghi&#x27;</span>, <span class="hljs-string">&#x27;jkl&#x27;</span>, <span class="hljs-string">&#x27;mno&#x27;</span>, <span class="hljs-string">&#x27;pqrs&#x27;</span>, <span class="hljs-string">&#x27;tuv&#x27;</span>, <span class="hljs-string">&#x27;wxyz&#x27;</span>];<span class="hljs-keyword">let</span> result = [];<span class="hljs-keyword">const</span> backtrack = <span class="hljs-function">(<span class="hljs-params">str, index</span>) =&gt;</span> &#123;<span class="hljs-comment">// 1 如果单个字符串到底了，那就添加它</span><span class="hljs-keyword">if</span> (index === digits.length) &#123;result.push(str);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">// 2 获取当前数字对应的字母</span><span class="hljs-keyword">const</span> currentStr = map[<span class="hljs-built_in">Number</span>(digits[index])];<span class="hljs-comment">// 3 遍历这串字母，将其添加到下一次遍历中，同时位置向后挪一</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; currentStr.length; i++) &#123;backtrack(str + currentStr[i], index + <span class="hljs-number">1</span>);&#125;&#125;;<span class="hljs-comment">// 回溯</span>backtrack(<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">return</span> result;&#125;;<span class="hljs-comment">// 解法二： 暴力枚举</span><span class="hljs-keyword">var</span> letterCombinations = <span class="hljs-function">(<span class="hljs-params">digits</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!digits.length) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">const</span> map = [<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;def&#x27;</span>, <span class="hljs-string">&#x27;ghi&#x27;</span>, <span class="hljs-string">&#x27;jkl&#x27;</span>, <span class="hljs-string">&#x27;mno&#x27;</span>, <span class="hljs-string">&#x27;pqrs&#x27;</span>, <span class="hljs-string">&#x27;tuv&#x27;</span>, <span class="hljs-string">&#x27;wxyz&#x27;</span>];<span class="hljs-keyword">let</span> result = map[<span class="hljs-built_in">Number</span>(digits[<span class="hljs-number">0</span>])].split(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-keyword">const</span> backtrack = <span class="hljs-function">(<span class="hljs-params">prev, next</span>) =&gt;</span> &#123;<span class="hljs-comment">// 1 设置 temp 获取当前的组合</span><span class="hljs-keyword">let</span> temp = [];<span class="hljs-comment">// 2 暴力遍历添加</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; prev.length; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; next.length; j++) &#123;temp.push(prev[i] + next[j]);&#125;&#125;<span class="hljs-comment">// 3 返回拼接后的组合</span><span class="hljs-keyword">return</span> temp;&#125;;<span class="hljs-comment">// 遍历字符串</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; digits.length; i++) &#123;<span class="hljs-comment">// 1 获取下一项添加的</span><span class="hljs-keyword">const</span> next = map[<span class="hljs-built_in">Number</span>(digits[i])];<span class="hljs-comment">// 2 组合后返回给 result</span>result = backtrack(result, next);&#125;<span class="hljs-keyword">return</span> result;&#125;;</code></pre><h3 id="11-括号生成-22"><a href="#11-括号生成-22" class="headerlink" title="11 括号生成 22"></a>11 括号生成 22</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 11 括号生成 22</span><span class="hljs-comment">// 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：n = 3</span><span class="hljs-comment">// 输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><span class="hljs-comment">// 递归</span><span class="hljs-keyword">var</span> generateParenthesis = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<span class="hljs-keyword">let</span> list = []<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generate</span>(<span class="hljs-params">left, right, s</span>) </span>&#123;<span class="hljs-comment">//  终止条件：如果左右括弧都用完则结束</span><span class="hljs-keyword">if</span> (left === n &amp;&amp; right === n) &#123;list.push(s)<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 如果左括弧未用完则继续增加左括弧</span><span class="hljs-keyword">if</span> (left &lt; n) &#123;generate(left + <span class="hljs-number">1</span>, right, s + <span class="hljs-string">&quot;(&quot;</span>)&#125;<span class="hljs-comment">// 如果右括弧少于左括弧则继续增加右括弧</span><span class="hljs-keyword">if</span> (left &gt; right) &#123;generate(left, right + <span class="hljs-number">1</span>, s + <span class="hljs-string">&quot;)&quot;</span>)&#125;&#125;generate(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>)<span class="hljs-keyword">return</span> list&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 12 盛最多水的容器 11</span><span class="hljs-comment">// 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) </span><span class="hljs-comment">//在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)</span><span class="hljs-comment">// 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span><span class="hljs-comment">// 说明：你不能倾斜容器。</span><span class="hljs-comment">// 输入：[1,8,6,2,5,4,8,3,7]</span><span class="hljs-comment">// 输出：49 </span><span class="hljs-comment">// 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：height = [1,1]</span><span class="hljs-comment">// 输出：1</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：height = [4,3,2,1,4]</span><span class="hljs-comment">// 输出：16</span><span class="hljs-comment">// 示例 4：</span><span class="hljs-comment">// 输入：height = [1,2,1]</span><span class="hljs-comment">// 输出：2</span><span class="hljs-keyword">var</span> maxArea = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">height</span>) </span>&#123;<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> right = height.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (left &lt; right) &#123;<span class="hljs-keyword">const</span> area = <span class="hljs-built_in">Math</span>.min(height[left], height[right]) * (right - left);res = <span class="hljs-built_in">Math</span>.max(res, area);<span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;left++;&#125; <span class="hljs-keyword">else</span> &#123;right--;&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 13 三数之和 15</span><span class="hljs-comment">// 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c </span><span class="hljs-comment">// 使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</span><span class="hljs-comment">// 注意：答案中不可以包含重复的三元组。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [-1,0,1,2,-1,-4]</span><span class="hljs-comment">// 输出：[[-1,-1,2],[-1,0,1]]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：nums = []</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：nums = [0]</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-keyword">var</span> threeSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">3</span>) &#123;<span class="hljs-keyword">return</span> [];&#125;<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">let</span> arr = [...nums];arr = arr.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<span class="hljs-keyword">if</span>(arr[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> [];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">2</span>; i++) &#123;<span class="hljs-keyword">const</span> target = <span class="hljs-number">0</span> - arr[i];<span class="hljs-keyword">let</span> p1 = i + <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> p2 = arr.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (p1 &lt; p2) &#123;<span class="hljs-keyword">if</span> (arr[p1] + arr[p2] === target) &#123;<span class="hljs-keyword">const</span> subArr = [arr[i], arr[p1], arr[p2]];<span class="hljs-keyword">if</span> (!isIncludes(res, subArr)) &#123;res.push(subArr);&#125;p1++;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[p1] + arr[p2] &lt; target) &#123;p1++;&#125; <span class="hljs-keyword">else</span> &#123;p2--;&#125;&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">var</span> isIncludes = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr, subArr</span>) </span>&#123;<span class="hljs-keyword">if</span>(!arr.length) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">return</span> arr.some(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item[<span class="hljs-number">0</span>] === subArr[<span class="hljs-number">0</span>] &amp;&amp; item[<span class="hljs-number">1</span>] === subArr[<span class="hljs-number">1</span>] &amp;&amp; item[<span class="hljs-number">2</span>] === subArr[<span class="hljs-number">2</span>])&#125;<span class="hljs-comment">// 扩展:从长度为 n 的数组中找到 长度为 m 的所有子集</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSub</span>(<span class="hljs-params">nums, m</span>) </span>&#123;<span class="hljs-keyword">if</span> (nums.length &lt; m) <span class="hljs-keyword">return</span> []; <span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> backtrck = <span class="hljs-function">(<span class="hljs-params">arr, i</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (arr.length === m) &#123;res.push(arr);<span class="hljs-keyword">return</span>;&#125;nums.forEach(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (index &gt; i) &#123;backtrck([...arr, item], index);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span>;&#125;&#125;)&#125;backtrck([], -<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> res;&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 14 删除有序数组中的重复项 26</span><span class="hljs-comment">// 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</span><span class="hljs-comment">// 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</span><span class="hljs-comment">// 说明:</span><span class="hljs-comment">// 为什么返回数值是整数，但输出的答案是数组呢?</span><span class="hljs-comment">// 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</span><span class="hljs-comment">// 你可以想象内部操作如下:</span><span class="hljs-comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><span class="hljs-comment">// int len = removeDuplicates(nums);</span><span class="hljs-comment">// 在函数里修改输入数组对于调用者是可见的。</span><span class="hljs-comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><span class="hljs-comment">// for (int i = 0; i &lt; len; i++) &#123;</span><span class="hljs-comment">//     print(nums[i]);</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [1,1,2]</span><span class="hljs-comment">// 输出：2, nums = [1,2]</span><span class="hljs-comment">// 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 </span><span class="hljs-comment">// 不需要考虑数组中超出新长度后面的元素。</span><span class="hljs-keyword">var</span> removeDuplicates = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">let</span> p1 = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> p2 = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (p2 &lt; nums.length) &#123;<span class="hljs-keyword">if</span> (nums[p1] !== nums[p2]) &#123;p1++;nums[p1] = nums[p2];&#125;p2++;&#125;<span class="hljs-keyword">while</span>(nums.length &gt; p1 + <span class="hljs-number">1</span>)&#123;nums.length--;&#125;<span class="hljs-comment">// 返回的是实际的长度，因为下标是从0开始的</span><span class="hljs-keyword">return</span> p1 + <span class="hljs-number">1</span>;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 15 加一 66</span><span class="hljs-comment">// 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</span><span class="hljs-comment">// 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</span><span class="hljs-comment">// 你可以假设除了整数 0 之外，这个整数不会以零开头。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：digits = [1,2,3]</span><span class="hljs-comment">// 输出：[1,2,4]</span><span class="hljs-comment">// 解释：输入数组表示数字 123。</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：digits = [4,3,2,1]</span><span class="hljs-comment">// 输出：[4,3,2,2]</span><span class="hljs-comment">// 解释：输入数组表示数字 4321。</span><span class="hljs-keyword">var</span> plusOne = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">digits</span>) </span>&#123;<span class="hljs-keyword">let</span> carry = <span class="hljs-literal">false</span>;digits[digits.length - <span class="hljs-number">1</span>] ++;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = digits.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<span class="hljs-keyword">if</span>(carry) digits[i]++;carry = digits[i] &gt; <span class="hljs-number">9</span>;digits[i] %= <span class="hljs-number">10</span>;&#125;<span class="hljs-keyword">if</span>(carry) digits.unshift(<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> digits;&#125;;</code></pre><h3 id="16-移动零"><a href="#16-移动零" class="headerlink" title="16 移动零"></a>16 移动零</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 16 移动零 283</span><span class="hljs-comment">// 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</span><span class="hljs-comment">// 示例:</span><span class="hljs-comment">// 输入: [0,1,0,3,12]</span><span class="hljs-comment">// 输出: [1,3,12,0,0]</span><span class="hljs-comment">// 说明:</span><span class="hljs-comment">// 必须在原数组上操作，不能拷贝额外的数组。</span><span class="hljs-comment">// 尽量减少操作次数。</span><span class="hljs-keyword">var</span> moveZeroes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">let</span> p = <span class="hljs-number">0</span>;<span class="hljs-comment">// 把所有的非0移到前面</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 遇到非0项</span>nums[p] = nums[i]; <span class="hljs-comment">// 覆盖到p上</span>p++;    <span class="hljs-comment">// j后移</span>&#125;&#125;<span class="hljs-comment">// 剩下的位置赋为0</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = p; i &lt; nums.length; i++) &#123;nums[i] = <span class="hljs-number">0</span>;&#125;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 17 最小栈 155</span><span class="hljs-comment">// 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</span><span class="hljs-comment">// push(x) —— 将元素 x 推入栈中。</span><span class="hljs-comment">// pop() —— 删除栈顶的元素。</span><span class="hljs-comment">// top() —— 获取栈顶元素。</span><span class="hljs-comment">// getMin() —— 检索栈中的最小元素。</span><span class="hljs-keyword">var</span> MinStack = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">this</span>.stack = [];    <span class="hljs-built_in">this</span>.min_stack = [];&#125;;MinStack.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;    <span class="hljs-built_in">this</span>.stack.push(val);    <span class="hljs-keyword">if</span> (val &lt;= <span class="hljs-built_in">this</span>.getMin() || <span class="hljs-built_in">this</span>.min_stack.length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">this</span>.min_stack.push(val);    &#125;&#125;;MinStack.prototype.pop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> out = <span class="hljs-built_in">this</span>.stack.pop();    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.getMin() == out) &#123;        <span class="hljs-built_in">this</span>.min_stack.pop();    &#125;&#125;;MinStack.prototype.top = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stack[<span class="hljs-built_in">this</span>.stack.length - <span class="hljs-number">1</span>];&#125;;MinStack.prototype.getMin = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.min_stack[<span class="hljs-built_in">this</span>.min_stack.length - <span class="hljs-number">1</span>];&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 18 跳跃游戏 55</span><span class="hljs-comment">// 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</span><span class="hljs-comment">// 数组中的每个元素代表你在该位置可以跳跃的最大长度。</span><span class="hljs-comment">// 判断你是否能够到达最后一个下标。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [2,3,1,1,4]</span><span class="hljs-comment">// 输出：true</span><span class="hljs-comment">// 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：nums = [3,2,1,0,4]</span><span class="hljs-comment">// 输出：false</span><span class="hljs-comment">// 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><span class="hljs-comment">// 解法一： 贪心算法</span><span class="hljs-keyword">var</span> canJump = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-comment">// maxStep 代表跳到的最远的距离</span><span class="hljs-keyword">let</span> maxStep = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<span class="hljs-comment">// 如果遍历的到的索引已经比最远能到到的距离还要大</span><span class="hljs-comment">// 说明根本没有机会再继续走下去</span><span class="hljs-keyword">if</span> (i &gt; maxStep) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;maxStep = <span class="hljs-built_in">Math</span>.max(maxStep, i + nums[i]);&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;<span class="hljs-comment">// 解法二：</span><span class="hljs-comment">// 1、起跳点：当前位置</span><span class="hljs-comment">// 2、最大可能：跳一次能影响的最大长度</span><span class="hljs-comment">// 3、return 起跳点+最大可能 &gt;= 终点</span><span class="hljs-keyword">var</span> canJump = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">if</span>(nums.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>;) &#123;<span class="hljs-comment">// i: 起跳点</span><span class="hljs-keyword">if</span>(nums[i] === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><span class="hljs-keyword">let</span> n = nums[i];<span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= nums[i]; j++) &#123;<span class="hljs-keyword">let</span> m = j + nums[i+j];<span class="hljs-keyword">if</span>(m &gt; n) &#123;n = m;index = j; <span class="hljs-comment">// 最大可能时的位移长度</span>&#125;&#125;<span class="hljs-keyword">if</span>(i + n &gt;= nums.length - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;i += index;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 19 跳跃游戏 II 45</span><span class="hljs-comment">// 给定一个非负整数数组，你最初位于数组的第一个位置。</span><span class="hljs-comment">// 数组中的每个元素代表你在该位置可以跳跃的最大长度。</span><span class="hljs-comment">// 你的目标是使用最少的跳跃次数到达数组的最后一个位置。</span><span class="hljs-comment">// 假设你总是可以到达数组的最后一个位置。</span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 输入: [2,3,1,1,4]</span><span class="hljs-comment">// 输出: 2</span><span class="hljs-comment">// 解释: 跳到最后一个位置的最小跳跃数是 2。</span><span class="hljs-comment">//      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><span class="hljs-comment">// 示例 2:</span><span class="hljs-comment">// 输入: [2,3,0,1,4]</span><span class="hljs-comment">// 输出: 2</span><span class="hljs-comment">// 贪心算法 动态规划</span><span class="hljs-comment">// 从第一项出发，用最少的步数跳到最后一项</span><span class="hljs-comment">// (1)遍历一个可抵达的区间，从中选出能跳最远的点</span><span class="hljs-comment">// (2)就有了新的可抵达的区间，然后跳跃一次，进入新的区间继续遍历寻求最优解</span><span class="hljs-keyword">var</span> jump = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-comment">// 记录当前能去到的最远的位置</span><span class="hljs-comment">// 遍历每个点都会求能跳到的最远位置，与它比较，如果把它大就更新它</span><span class="hljs-keyword">let</span> p1 = <span class="hljs-number">0</span>; <span class="hljs-comment">// farthestPos</span><span class="hljs-keyword">let</span> p2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// endOfCanReach</span><span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;p1 = <span class="hljs-built_in">Math</span>.max(p1, i + nums[i]);<span class="hljs-keyword">if</span> (i === p2) &#123; <span class="hljs-comment">// 可抵达区间的右端位置</span>p2 = p1;res++;&#125;<span class="hljs-comment">// 一旦新的可抵达区间触碰到nums数组的边界，则直接break，不用对区间的点遍历了</span><span class="hljs-keyword">if</span> (p2 &gt;= nums.length - <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 20 最大子序和 53</span><span class="hljs-comment">// 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素）</span><span class="hljs-comment">// 返回其最大和。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><span class="hljs-comment">// 输出：6</span><span class="hljs-comment">// 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 </span><span class="hljs-comment">// 动态规划</span><span class="hljs-keyword">var</span> maxSubArray = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">let</span> ans = nums[<span class="hljs-number">0</span>];<span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) &#123;<span class="hljs-comment">// if(sum &gt; 0) &#123; 可以写成这样</span><span class="hljs-keyword">if</span>(sum + num &gt; num )&#123;sum = sum + num;&#125; <span class="hljs-keyword">else</span> &#123;sum = num;&#125;ans = <span class="hljs-built_in">Math</span>.max(ans, sum);&#125;;<span class="hljs-keyword">return</span> ans;&#125;;</code></pre><h3 id="21-最接近的三数之和"><a href="#21-最接近的三数之和" class="headerlink" title="21 最接近的三数之和"></a>21 最接近的三数之和</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 21 最接近的三数之和 16</span><span class="hljs-comment">// 给定一个包括 n 个整数的数组 nums 和 一个目标值 target,找出 nums 中的三个整数</span><span class="hljs-comment">// 使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</span><span class="hljs-comment">// 示例：</span><span class="hljs-comment">// 输入：nums = [-1,2,1,-4], target = 1</span><span class="hljs-comment">// 输出：2</span><span class="hljs-comment">// 解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</span><span class="hljs-keyword">var</span> threeSumClosest = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;nums = nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<span class="hljs-keyword">let</span> res = nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<span class="hljs-keyword">let</span> p1 = i + <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> p2 = nums.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (p1 &lt; p2) &#123;<span class="hljs-keyword">const</span> sum = nums[i] + nums[p1] + nums[p2];<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(target - sum) &lt; <span class="hljs-built_in">Math</span>.abs(target - res)) &#123;res = sum;&#125;<span class="hljs-keyword">if</span> (target &gt; sum) &#123;p1++;&#125; <span class="hljs-keyword">else</span> &#123;p2--;&#125;&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 22 四数之和 18</span><span class="hljs-comment">// 给定一个包含 n 个整数的数组 nums 和一个目标值 target</span><span class="hljs-comment">// 判断 nums 中是否存在四个元素 a，b，c 和 d </span><span class="hljs-comment">// 使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</span><span class="hljs-comment">// 注意：答案中不可以包含重复的四元组。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [1,0,-1,0,-2,2], target = 0</span><span class="hljs-comment">// 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：nums = [], target = 0</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-keyword">var</span> fourSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;    <span class="hljs-keyword">const</span> res = [&#123;&#125;, []];    nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = nums.length, key; i &lt; len - <span class="hljs-number">3</span>; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i + <span class="hljs-number">1</span>; j &lt; len - <span class="hljs-number">2</span>; j++) &#123;            <span class="hljs-keyword">let</span> l = j + <span class="hljs-number">1</span>;            <span class="hljs-keyword">let</span> r = len - <span class="hljs-number">1</span>;            <span class="hljs-keyword">const</span> sum = nums[i] + nums[j];            <span class="hljs-keyword">while</span> (l &lt; r) &#123;                <span class="hljs-keyword">if</span> (sum + nums[l] + nums[r] === target) &#123;                    <span class="hljs-keyword">const</span> key = <span class="hljs-string">&#x27;&#x27;</span> + nums[i] + nums[j] + nums[l] + nums[r];                    <span class="hljs-keyword">if</span> (!res[<span class="hljs-number">0</span>][key]) &#123;                        res[<span class="hljs-number">0</span>][key] = <span class="hljs-number">1</span>;                        res[<span class="hljs-number">1</span>].push([nums[i], nums[j], nums[l], nums[r]]);                    &#125;                    r--;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span> (!(sum + nums[l] + nums[r] &gt; target &amp;&amp; r--)) &#123;                        l++;                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res[<span class="hljs-number">1</span>];&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 23 字母异位词分组 49</span><span class="hljs-comment">// 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</span><span class="hljs-comment">// 示例:</span><span class="hljs-comment">// 输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><span class="hljs-comment">// 输出:</span><span class="hljs-comment">// [</span><span class="hljs-comment">//   [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><span class="hljs-comment">//   [&quot;nat&quot;,&quot;tan&quot;],</span><span class="hljs-comment">//   [&quot;bat&quot;]</span><span class="hljs-comment">// ]</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">strs</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[][]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> groupAnagrams = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">strs</span>) </span>&#123;<span class="hljs-keyword">const</span> hashTable = &#123;&#125;;<span class="hljs-comment">// 这个方法需要排序，因此不是很优，但是很直观，容易想到</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;<span class="hljs-keyword">const</span> str = strs[i];<span class="hljs-keyword">const</span> key = str.split(<span class="hljs-string">&quot;&quot;</span>).sort().join(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-keyword">if</span> (!hashTable[key]) &#123;hashTable[key] = [str];&#125; <span class="hljs-keyword">else</span> &#123;hashTable[key].push(str);&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.values(hashTable);&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 24 最长连续递增序列 674</span><span class="hljs-comment">// 给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</span><span class="hljs-comment">// 连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定</span><span class="hljs-comment">// 如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] </span><span class="hljs-comment">// 那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [1,3,5,4,7]</span><span class="hljs-comment">// 输出：3</span><span class="hljs-comment">// 解释：最长连续递增序列是 [1,3,5], 长度为3。</span><span class="hljs-comment">// 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 </span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：nums = [2,2,2,2,2]</span><span class="hljs-comment">// 输出：1</span><span class="hljs-comment">// 解释：最长连续递增序列是 [2], 长度为1。</span><span class="hljs-comment">// 解法一：贪心算法</span><span class="hljs-keyword">var</span> findLengthOfLCIS = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> n = nums.length;<span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> right = <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> res = <span class="hljs-number">1</span><span class="hljs-keyword">let</span> maxLen = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (right &lt; n) &#123;<span class="hljs-keyword">if</span> (nums[right] &gt; nums[left])&#123;maxLen++;&#125; <span class="hljs-keyword">else</span> &#123;maxLen = <span class="hljs-number">1</span>;&#125;left++;right++;res = <span class="hljs-built_in">Math</span>.max(res, maxLen);&#125;<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-comment">// 解法二：双指针</span><span class="hljs-comment">// var findLengthOfLCIS = function(nums) &#123;</span><span class="hljs-comment">// if(!nums.length) return 0;</span><span class="hljs-comment">// let res = 0;</span><span class="hljs-comment">// let left = 0;</span><span class="hljs-comment">// let right = 0;</span><span class="hljs-comment">// while(right &lt; nums.length) &#123;</span><span class="hljs-comment">// while(nums[right + 1] &gt; nums[right]) &#123;</span><span class="hljs-comment">// right++;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// const sub = nums.slice(left, right + 1);</span><span class="hljs-comment">// res = Math.max(res, sub.length);</span><span class="hljs-comment">// right++;</span><span class="hljs-comment">// left = right;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// return res;</span><span class="hljs-comment">// &#125;</span></code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 25 最长递增子序列 300</span><span class="hljs-comment">// 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</span><span class="hljs-comment">// 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [10,9,2,5,3,7,101,18]</span><span class="hljs-comment">// 输出：4</span><span class="hljs-comment">// 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：nums = [0,1,0,3,2,3]</span><span class="hljs-comment">// 输出：4</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：nums = [7,7,7,7,7,7,7]</span><span class="hljs-comment">// 输出：1</span><span class="hljs-comment">// 动态规划</span><span class="hljs-keyword">var</span> lengthOfLIS = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">if</span> (!nums.length) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> temArr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(nums.length);<span class="hljs-keyword">let</span> res = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(i &lt; nums.length) &#123;temArr[i] = <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">let</span> m = i - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(m &gt; -<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span> (nums[i] &gt; nums[m] &amp;&amp; temArr[m] + <span class="hljs-number">1</span> &gt; temArr[i]) &#123;temArr[i] = temArr[m] + <span class="hljs-number">1</span>;res = <span class="hljs-built_in">Math</span>.max(res, temArr[i])&#125;m--;&#125;&#125;i++;&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre><h3 id="26-寻找两个正序数组的中位数"><a href="#26-寻找两个正序数组的中位数" class="headerlink" title="26 寻找两个正序数组的中位数"></a>26 寻找两个正序数组的中位数</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 26 寻找两个正序数组的中位数 4</span><span class="hljs-comment">// 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2</span><span class="hljs-comment">// 请你找出并返回这两个正序数组的 中位数 。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums1 = [1,3], nums2 = [2]</span><span class="hljs-comment">// 输出：2.00000</span><span class="hljs-comment">// 解释：合并数组 = [1,2,3] ，中位数 2</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：nums1 = [1,2], nums2 = [3,4]</span><span class="hljs-comment">// 输出：2.50000</span><span class="hljs-comment">// 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：nums1 = [0,0], nums2 = [0,0]</span><span class="hljs-comment">// 输出：0.00000</span><span class="hljs-comment">// 示例 4：</span><span class="hljs-comment">// 输入：nums1 = [], nums2 = [1]</span><span class="hljs-comment">// 输出：1.00000</span><span class="hljs-comment">// 示例 5：</span><span class="hljs-comment">// 输入：nums1 = [2], nums2 = []</span><span class="hljs-comment">// 输出：2.00000</span><span class="hljs-comment">//  </span><span class="hljs-comment">// 提示：</span><span class="hljs-comment">// nums1.length == m</span><span class="hljs-comment">// nums2.length == n</span><span class="hljs-comment">// 0 &lt;= m &lt;= 1000</span><span class="hljs-comment">// 0 &lt;= n &lt;= 1000</span><span class="hljs-comment">// 1 &lt;= m + n &lt;= 2000</span><span class="hljs-comment">// -106 &lt;= nums1[i], nums2[i] &lt;= 106</span><span class="hljs-keyword">var</span> findMedianSortedArrays = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums1, nums2</span>) </span>&#123;<span class="hljs-keyword">let</span> m = nums1.length;<span class="hljs-keyword">let</span> n = nums2.length;<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> newArr = [];<span class="hljs-keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;<span class="hljs-keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;newArr.push(nums1[i++]);&#125; <span class="hljs-keyword">else</span> &#123;newArr.push(nums2[j++]);&#125;&#125;newArr = newArr.concat(i &lt; m ? nums1.slice(i) : nums2.slice(j));<span class="hljs-keyword">const</span> len = newArr.length;<span class="hljs-keyword">if</span> (len % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> (newArr[len / <span class="hljs-number">2</span>] + newArr[len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>]) / <span class="hljs-number">2</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> newArr[<span class="hljs-built_in">Math</span>.floor(len / <span class="hljs-number">2</span>)];&#125;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 27 和为K的子数组 560</span><span class="hljs-comment">// 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</span><span class="hljs-comment">// 示例 1 :</span><span class="hljs-comment">// 输入:nums = [1,1,1], k = 2</span><span class="hljs-comment">// 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><span class="hljs-comment">// 说明 :</span><span class="hljs-comment">// 数组的长度为 [1, 20,000]。</span><span class="hljs-comment">// 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</span><span class="hljs-keyword">var</span> subarraySum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> sum1 = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> sum2 = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();map.set(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= nums.length; i++) &#123;sum1 += nums[i];sum2 = sum1 - k;<span class="hljs-keyword">if</span> (map.has(sum2)) &#123;res += map.get(sum2);&#125;<span class="hljs-keyword">let</span> sumCnt = map.get(sum1) || <span class="hljs-number">0</span>;map.set(sum1, sumCnt + <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 28 两数之和 II - 输入有序数组 167</span><span class="hljs-comment">// 给定一个已按照 升序排列  的整数数组 numbers</span><span class="hljs-comment">// 请你从数组中找出两个数满足相加之和等于目标数 target 。</span><span class="hljs-comment">// 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。</span><span class="hljs-comment">// numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。</span><span class="hljs-comment">// 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：numbers = [2,7,11,15], target = 9</span><span class="hljs-comment">// 输出：[1,2]</span><span class="hljs-comment">// 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：numbers = [2,3,4], target = 6</span><span class="hljs-comment">// 输出：[1,3]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：numbers = [-1,0], target = -1</span><span class="hljs-comment">// 输出：[1,2]</span><span class="hljs-keyword">var</span> twoSum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">numbers, target</span>) </span>&#123;<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numbers.length; i++) &#123;<span class="hljs-keyword">let</span> tmp = target - numbers[i]<span class="hljs-keyword">if</span> (map.has(tmp)) &#123;<span class="hljs-keyword">return</span> [map.get(tmp) + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>]&#125;map.set(numbers[i], i)&#125;&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 29 合并区间 56</span><span class="hljs-comment">// 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi]</span><span class="hljs-comment">// 请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><span class="hljs-comment">// 输出：[[1,6],[8,10],[15,18]]</span><span class="hljs-comment">// 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：intervals = [[1,4],[4,5]]</span><span class="hljs-comment">// 输出：[[1,5]]</span><span class="hljs-comment">// 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><span class="hljs-keyword">var</span> merge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">intervals</span>) </span>&#123;<span class="hljs-keyword">if</span> (intervals.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];intervals.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<span class="hljs-keyword">const</span> mergeArr = [intervals[<span class="hljs-number">0</span>]];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;<span class="hljs-keyword">const</span> item = intervals[i];<span class="hljs-keyword">const</span> last = mergeArr[mergeArr.length - <span class="hljs-number">1</span>];<span class="hljs-keyword">if</span> (last[<span class="hljs-number">1</span>] &gt;= item[<span class="hljs-number">0</span>]) &#123;last[<span class="hljs-number">1</span>] = <span class="hljs-built_in">Math</span>.max(item[<span class="hljs-number">1</span>], last[<span class="hljs-number">1</span>]);&#125; <span class="hljs-keyword">else</span> &#123;mergeArr.push(item);&#125;&#125;<span class="hljs-keyword">return</span> mergeArr;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 30 插入区间 57</span><span class="hljs-comment">// 给你一个 无重叠的 ，按照区间起始端点排序的区间列表。</span><span class="hljs-comment">// 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：intervals = [[1,3],[6,9]], newInterval = [2,5]</span><span class="hljs-comment">// 输出：[[1,5],[6,9]]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]</span><span class="hljs-comment">// 输出：[[1,2],[3,10],[12,16]]</span><span class="hljs-comment">// 解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：intervals = [], newInterval = [5,7]</span><span class="hljs-comment">// 输出：[[5,7]]</span><span class="hljs-comment">// 示例 4：</span><span class="hljs-comment">// 输入：intervals = [[1,5]], newInterval = [2,3]</span><span class="hljs-comment">// 输出：[[1,5]]</span><span class="hljs-comment">// 示例 5：</span><span class="hljs-comment">// 输入：intervals = [[1,5]], newInterval = [2,7]</span><span class="hljs-comment">// 输出：[[1,7]]</span><span class="hljs-keyword">var</span> insert = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">intervals, newInterval</span>) </span>&#123;<span class="hljs-keyword">if</span> (intervals.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [newInterval];<span class="hljs-comment">// 最左侧</span><span class="hljs-keyword">if</span> (newInterval[<span class="hljs-number">1</span>] &lt; intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]) &#123;<span class="hljs-keyword">return</span> [newInterval, ...intervals];&#125;<span class="hljs-comment">// 最右侧</span><span class="hljs-keyword">if</span> (newInterval[<span class="hljs-number">0</span>] &gt; intervals[intervals.length - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) &#123;<span class="hljs-keyword">return</span> [...intervals, newInterval];&#125;<span class="hljs-keyword">let</span> leftSub = [];<span class="hljs-keyword">let</span> midSub = [];<span class="hljs-keyword">let</span> rifhtSub = [];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; intervals.length; i++) &#123;<span class="hljs-comment">// 左侧 有重叠</span><span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &lt;= newInterval[<span class="hljs-number">0</span>] &amp;&amp; newInterval[<span class="hljs-number">0</span>] &lt;= intervals[i][<span class="hljs-number">1</span>]) &#123;midSub[<span class="hljs-number">0</span>] = intervals[i][<span class="hljs-number">0</span>];leftSub = intervals.slice(<span class="hljs-number">0</span>, i);&#125;<span class="hljs-comment">// 右侧 有重叠</span><span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &lt;= newInterval[<span class="hljs-number">1</span>] &amp;&amp; newInterval[<span class="hljs-number">1</span>] &lt;= intervals[i][<span class="hljs-number">1</span>]) &#123;midSub[<span class="hljs-number">1</span>] = intervals[i][<span class="hljs-number">1</span>];rifhtSub = intervals.slice(i + <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 左侧 无重叠，在区间中</span><span class="hljs-keyword">if</span> (intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt; newInterval[<span class="hljs-number">0</span>] &amp;&amp; newInterval[<span class="hljs-number">0</span>] &lt; intervals[i][<span class="hljs-number">0</span>]) &#123;midSub[<span class="hljs-number">0</span>] = newInterval[<span class="hljs-number">0</span>];leftSub = intervals.slice(<span class="hljs-number">0</span>, i);&#125;<span class="hljs-comment">// 右侧 无重叠，在区间中</span><span class="hljs-keyword">if</span> (intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt; newInterval[<span class="hljs-number">1</span>] &amp;&amp;  newInterval[<span class="hljs-number">1</span>] &lt; intervals[i][<span class="hljs-number">0</span>]) &#123;midSub[<span class="hljs-number">1</span>] = newInterval[<span class="hljs-number">1</span>];rifhtSub = intervals.slice(i);&#125;&#125;<span class="hljs-comment">// 超出左侧边界</span><span class="hljs-keyword">if</span> (newInterval[<span class="hljs-number">0</span>] &lt; intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]) &#123;midSub[<span class="hljs-number">0</span>] = newInterval[<span class="hljs-number">0</span>];&#125;<span class="hljs-comment">// 超出右侧边界</span><span class="hljs-keyword">if</span> (i === intervals.length - <span class="hljs-number">1</span> &amp;&amp; newInterval[<span class="hljs-number">1</span>] &gt; intervals[i][<span class="hljs-number">1</span>]) &#123;midSub[<span class="hljs-number">1</span>] = newInterval[<span class="hljs-number">1</span>];&#125;&#125;<span class="hljs-keyword">return</span> [...leftSub, midSub, ...rifhtSub];&#125;;</code></pre><h3 id="31-搜索旋转排序数组"><a href="#31-搜索旋转排序数组" class="headerlink" title="31 搜索旋转排序数组"></a>31 搜索旋转排序数组</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 31 搜索旋转排序数组 I 33 / II 81</span><span class="hljs-comment">// 整数数组 nums 按升序排列，数组中的值 互不相同 。</span><span class="hljs-comment">// 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，</span><span class="hljs-comment">// 使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</span><span class="hljs-comment">// （下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</span><span class="hljs-comment">// 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，</span><span class="hljs-comment">// 则返回它的下标，否则返回 -1 。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [4,5,6,7,0,1,2], target = 0</span><span class="hljs-comment">// 输出：4</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：nums = [4,5,6,7,0,1,2], target = 3</span><span class="hljs-comment">// 输出：-1</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：nums = [1], target = 0</span><span class="hljs-comment">// 输出：-1</span><span class="hljs-keyword">var</span> search = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;<span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> end = nums.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(start &lt;= end) &#123;<span class="hljs-keyword">const</span> mid = start + <span class="hljs-built_in">Math</span>.floor((end - start) / <span class="hljs-number">2</span>);<span class="hljs-keyword">if</span> (nums[mid] === target) &#123;<span class="hljs-keyword">return</span> mid;&#125;<span class="hljs-keyword">if</span> (nums[mid] &gt;= nums[start]) &#123;<span class="hljs-keyword">if</span> (target &gt;= nums[start] &amp;&amp; target &lt; nums[mid]) &#123;end = mid - <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;start = mid + <span class="hljs-number">1</span>;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (target &lt;= nums[end] &amp;&amp; target &gt; nums[mid]) &#123;start = mid + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;end = mid - <span class="hljs-number">1</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;;<span class="hljs-comment">// 搜索旋转排序数组 II 81</span><span class="hljs-comment">// 已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。</span><span class="hljs-comment">// 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，</span><span class="hljs-comment">// 使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</span><span class="hljs-comment">// （下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] </span><span class="hljs-comment">// 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。</span><span class="hljs-comment">// 给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。</span><span class="hljs-comment">// 如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [2,5,6,0,0,1,2], target = 0</span><span class="hljs-comment">// 输出：true</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：nums = [2,5,6,0,0,1,2], target = 3</span><span class="hljs-comment">// 输出：false</span><span class="hljs-keyword">var</span> search = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;<span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span><span class="hljs-keyword">let</span> end = nums.length - <span class="hljs-number">1</span><span class="hljs-keyword">while</span> (start &lt;= end) &#123;<span class="hljs-comment">// let mid = start + ((end - start) &gt;&gt; 1)</span><span class="hljs-keyword">let</span> mid = start + <span class="hljs-built_in">Math</span>.floor((end - start) / <span class="hljs-number">2</span>);<span class="hljs-keyword">if</span> (nums[mid] === target) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-keyword">if</span> (nums[start] &gt; nums[mid]) &#123; <span class="hljs-comment">// 左大于中, 最大值在左边</span><span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; nums[end] &gt;= target) &#123; start = mid + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;end = mid - <span class="hljs-number">1</span>;&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[start] &lt; nums[mid]) &#123;<span class="hljs-comment">// 左小于中, 说明左边是非递减的</span><span class="hljs-keyword">if</span> (nums[start] &lt;= target &amp;&amp; nums[mid] &gt; target) &#123;end = mid - <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;start = mid + <span class="hljs-number">1</span>;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 左等于中, 无法判断</span>start++;<span class="hljs-keyword">if</span> (nums[end] === nums[mid]) &#123;end--;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 32 在排序数组中查找元素的第一个和最后一个位置</span><span class="hljs-comment">// 给定一个按照升序排列的整数数组 nums，和一个目标值 target。</span><span class="hljs-comment">// 找出给定目标值在数组中的开始位置和结束位置。</span><span class="hljs-comment">// 如果数组中不存在目标值 target，返回 [-1, -1]。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [5,7,7,8,8,10], target = 8</span><span class="hljs-comment">// 输出：[3,4]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：nums = [5,7,7,8,8,10], target = 6</span><span class="hljs-comment">// 输出：[-1,-1]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：nums = [], target = 0</span><span class="hljs-comment">// 输出：[-1,-1]</span><span class="hljs-keyword">var</span> searchRange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">search</span> (<span class="hljs-params">nums, target, flag</span>) </span>&#123;<span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> end = nums.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (start &lt;= end) &#123;<span class="hljs-keyword">let</span> mid = start + (<span class="hljs-built_in">Math</span>.floor((end - start) / <span class="hljs-number">2</span>));<span class="hljs-keyword">if</span> (nums[mid] === target) &#123;<span class="hljs-keyword">if</span> (flag) &#123;<span class="hljs-keyword">if</span> (mid === <span class="hljs-number">0</span> || nums[mid - <span class="hljs-number">1</span>] !== target) &#123;<span class="hljs-keyword">return</span> mid;&#125;end = mid - <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (mid === nums.length - <span class="hljs-number">1</span> || nums[mid + <span class="hljs-number">1</span>] !== target) &#123;<span class="hljs-keyword">return</span> mid;&#125;start = mid + <span class="hljs-number">1</span>;&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;end = mid - <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;start = mid + <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> [search(nums, target, <span class="hljs-literal">true</span>), search(nums, target, <span class="hljs-literal">false</span>)]&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 33 下一个排列 31</span><span class="hljs-comment">// 实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</span><span class="hljs-comment">// 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</span><span class="hljs-comment">// 必须 原地 修改，只允许使用额外常数空间。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：nums = [1,2,3]</span><span class="hljs-comment">// 输出：[1,3,2]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：nums = [3,2,1]</span><span class="hljs-comment">// 输出：[1,2,3]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：nums = [1,1,5]</span><span class="hljs-comment">// 输出：[1,5,1]</span><span class="hljs-comment">// 示例 4：</span><span class="hljs-comment">// 输入：nums = [1]</span><span class="hljs-comment">// 输出：[1]</span><span class="hljs-comment">// 示例 5：</span><span class="hljs-comment">// 输入 [4,2,3,1]</span><span class="hljs-comment">// 输出 [4,3,1,2]</span><span class="hljs-comment">// 1 从右往左，找到第一个小于 它右边的 数字</span><span class="hljs-comment">// 2 把这个数字 与 它右边 互换</span><span class="hljs-comment">// 3 把它右边所有的数 翻转</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nextPermutation</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-comment">// 从右向左遍历，i从倒数第二开始是为了nums[index1+1]要存在</span><span class="hljs-keyword">let</span> index1 = nums.length - <span class="hljs-number">2</span>;<span class="hljs-comment">// 寻找第一个小于右邻居的数</span><span class="hljs-keyword">while</span> (index1 &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[index1] &gt;= nums[index1 + <span class="hljs-number">1</span>]) &#123;index1--;&#125;<span class="hljs-comment">// 这个数在数组中存在，从它身后挑一个数，和它换</span><span class="hljs-keyword">if</span> (index1 &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 从最后一项，向左遍历                     </span><span class="hljs-keyword">let</span> index2 = nums.length - <span class="hljs-number">1</span>;   <span class="hljs-comment">// 寻找第一个大于 nums[index1] 的数             </span><span class="hljs-keyword">while</span> (index2 &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[index2] &lt;= nums[index1]) &#123;  index2--;&#125;<span class="hljs-comment">// 两数交换，实现变大</span>[nums[index1], nums[index2]] = [nums[index2], nums[index1]]; &#125;<span class="hljs-comment">// 抹平另外两种情况：</span><span class="hljs-comment">// 1、如果 index1 = -1，说明是递减排列，如 3 2 1，没有下一排列，直接翻转为最小排列：1 2 3</span><span class="hljs-comment">// 2、[4,2,3,1] 预期结果 [4,3,1,2], 结果却是[4,3,2,1]</span><span class="hljs-keyword">let</span> l = index1 + <span class="hljs-number">1</span>;           <span class="hljs-keyword">let</span> r = nums.length - <span class="hljs-number">1</span>;<span class="hljs-comment">// index1 右边的数进行翻转，使得变大的幅度小一些</span><span class="hljs-keyword">while</span> (l &lt; r) &#123;                            [nums[l], nums[r]] = [nums[r], nums[l]];l++;r--;&#125;&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 34 旋转图像 48</span><span class="hljs-comment">// 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</span><span class="hljs-comment">// 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><span class="hljs-comment">// 输出：[[7,4,1],[8,5,2],[9,6,3]]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><span class="hljs-comment">// 输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：matrix = [[1]]</span><span class="hljs-comment">// 输出：[[1]]</span><span class="hljs-comment">// 示例 4：</span><span class="hljs-comment">// 输入：matrix = [[1,2],[3,4]]</span><span class="hljs-comment">// 输出：[[3,1],[4,2]]</span><span class="hljs-keyword">var</span> rotate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>&#123;<span class="hljs-keyword">let</span> n = matrix.length<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i; j &lt; n - <span class="hljs-number">1</span> - i; j++) &#123;<span class="hljs-keyword">let</span> tmp = matrix[i][j];matrix[i][j] = matrix[n - <span class="hljs-number">1</span> - j][i];matrix[n - <span class="hljs-number">1</span> - j][i] = matrix[n - <span class="hljs-number">1</span> - i][n - <span class="hljs-number">1</span> - j];matrix[n - <span class="hljs-number">1</span> - i][n - <span class="hljs-number">1</span> -j] = matrix[j][n - <span class="hljs-number">1</span> - i];matrix[j][n - <span class="hljs-number">1</span> - i] = tmp;&#125;&#125;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 35 螺旋矩阵 54</span><span class="hljs-comment">// 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><span class="hljs-comment">// 输出：[1,2,3,6,9,8,7,4,5]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><span class="hljs-comment">// 输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><span class="hljs-keyword">var</span> spiralOrder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">matrix</span>) </span>&#123;<span class="hljs-keyword">if</span> (matrix.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> []<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">let</span> top = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> bottom = matrix.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> right = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = left; i &lt;= right; i++) &#123;res.push(matrix[top][i]);&#125;top++;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = top; i &lt;= bottom; i++) &#123;res.push(matrix[i][right]);&#125;right--;<span class="hljs-keyword">if</span> (top &gt; bottom || left &gt; right) <span class="hljs-keyword">break</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = right; i &gt;= left; i--) &#123;res.push(matrix[bottom][i]);&#125;bottom--;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = bottom; i &gt;= top; i--) &#123;res.push(matrix[i][left]);&#125;left++;&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre><h2 id="四-字符串"><a href="#四-字符串" class="headerlink" title="四 字符串"></a>四 字符串</h2><p>1 验证回文串 —— 给定一个字符串，验证它是否是回文串<br>2 爬楼梯 —— 每次你可以爬 1 或 2 个台阶。求有多少种方法<br>3 打家劫舍 —— 数组n的最大和，其中每一项不能相互连续<br>4 最长回文子串 —— 找到字符串 s 中最长的回文子串<br>5 编辑距离 —— 计算将 word1 转换成 word2 所使用的最少操作数<br>6 无重复字符的最长子串 —— 找出其中不含有重复字符的 最长子串 的长度<br>7 整数转罗马数字<br>8 罗马数字转整数<br>9 最小路径和 —— 从二位数组 的 第一个 到 最后一个 的最小路径和<br>10 最长公共前缀 —— 字符串数组中的最长公共前缀<br>11 最小覆盖子串 —— 找到字符串 s 中最小覆盖 字符串的 t<br>12 单词拆分 —— 判断 s 是否可以被空格拆分为一个或多个在字典中出现的单词<br>13 100层丢鸡蛋 —— 有2个鸡蛋，从100层中丢下，找到刚好破的那一层<br>14 较大分组的位置 —— 找到字符串中 最大连续(同样)的 子串<br>15 下划线与驼峰互换<br>16 Z 字形变换 —— 将字符串按照 从上往下、从左到右进行 Z 字形排列<br>17 不同的路径 —— 从 m*n 表格的左上角移动到右下角，有多少种路径</p><h3 id="1-验证回文串"><a href="#1-验证回文串" class="headerlink" title="1 验证回文串"></a>1 验证回文串</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 1 验证回文串 125</span><span class="hljs-comment">// 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</span><span class="hljs-comment">// 说明：本题中，我们将空字符串定义为有效的回文串。</span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 输入: &quot;A man, a plan, a canal: Panama&quot;</span><span class="hljs-comment">// 输出: true</span><span class="hljs-comment">// 示例 2:</span><span class="hljs-comment">// 输入: &quot;race a car&quot;</span><span class="hljs-comment">// 输出: false</span><span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<span class="hljs-keyword">const</span> strArr = s.toLocaleLowerCase().match(<span class="hljs-regexp">/[A-Za-z0-9]+/g</span>);<span class="hljs-keyword">if</span>(!strArr) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">const</span> str = strArr.join(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> right = str.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(left &lt; right)&#123;<span class="hljs-keyword">if</span>(str[left] === str[right])&#123;left++;right--;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 2 爬楼梯 70</span><span class="hljs-comment">// 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</span><span class="hljs-comment">// 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</span><span class="hljs-comment">// 注意：给定 n 是一个正整数。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入： 2</span><span class="hljs-comment">// 输出： 2</span><span class="hljs-comment">// 解释： 有两种方法可以爬到楼顶。</span><span class="hljs-comment">// 1.  1 阶 + 1 阶</span><span class="hljs-comment">// 2.  2 阶</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-comment">// 动态规划一： 时间复杂度 O(n) 空间复杂度：O(n)</span><span class="hljs-keyword">var</span> climbStairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">const</span> dp = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<span class="hljs-comment">// 斐波那契数列 f(n) = f(n-1) + f(n-2)</span>dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];&#125;<span class="hljs-keyword">return</span> dp[n];&#125;;<span class="hljs-comment">// 动态规划二： 时间复杂度 O(n) 空间复杂度 O(1)</span><span class="hljs-keyword">var</span> climbStairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">let</span> dp1 = <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录 n-2 的值</span><span class="hljs-keyword">let</span> dp2 = <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录 n-1 的值</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<span class="hljs-comment">// 将 n-1 的值赋值给 n-2</span><span class="hljs-comment">// 将 n-1 和 n-2 的和, 赋值给 n-1</span><span class="hljs-comment">// 即 完成了 f(n) = f(n-1) + f(n-2)</span><span class="hljs-keyword">const</span> tem = dp1;dp1 = dp2;dp2 = tem + dp1;&#125;<span class="hljs-keyword">return</span> dp2;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 3 打家劫舍 198</span><span class="hljs-comment">// 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金</span><span class="hljs-comment">// 影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统</span><span class="hljs-comment">// 如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</span><span class="hljs-comment">// 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：[1,2,3,1]</span><span class="hljs-comment">// 输出：4</span><span class="hljs-comment">// 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><span class="hljs-comment">//      偷窃到的最高金额 = 1 + 3 = 4 </span><span class="hljs-comment">// 动态规划解法一：</span><span class="hljs-keyword">var</span> rob = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-comment">// 解题步骤：</span><span class="hljs-comment">// 1. 用 fn1(k) 代表 前k个房屋中能偷窃到的最大金额</span><span class="hljs-comment">// 2. 用 fn2(k) 代表 第k个房屋中的金额</span><span class="hljs-comment">// 3. fn1(k) = Math.max(fn1(k-2) + fn2(k), fn1(k-1))</span><span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];&#125;<span class="hljs-comment">// dp[0]代表第0个房屋的金额, dp[1]代表第1个房屋的金额</span><span class="hljs-keyword">const</span> dp = [<span class="hljs-number">0</span>, nums[<span class="hljs-number">0</span>]];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= nums.length; i++) &#123;dp[i] = <span class="hljs-built_in">Math</span>.max(dp[i - <span class="hljs-number">2</span>] + nums[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>]);&#125;<span class="hljs-keyword">return</span> dp[dp.length - <span class="hljs-number">1</span>];&#125;;<span class="hljs-comment">// 动态规划解法二：</span><span class="hljs-keyword">var</span> rob = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];&#125;<span class="hljs-keyword">let</span> dp0 = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> dp1 = nums[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= nums.length; i++) &#123;<span class="hljs-keyword">const</span> tem = <span class="hljs-built_in">Math</span>.max(dp0 + nums[i - <span class="hljs-number">1</span>], dp1);dp0 = dp1;dp1 = tem;&#125;<span class="hljs-keyword">return</span> dp1;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 4 最长回文子串 5</span><span class="hljs-comment">// 给你一个字符串 s，找到 s 中最长的回文子串。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：s = &quot;babad&quot;</span><span class="hljs-comment">// 输出：&quot;bab&quot;</span><span class="hljs-comment">// 解释：&quot;aba&quot; 同样是符合题意的答案。</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：s = &quot;cbbd&quot;</span><span class="hljs-comment">// 输出：&quot;bb&quot;</span><span class="hljs-comment">// 解法一: 动态规划, 性能比较查</span><span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<span class="hljs-keyword">let</span> len = s.length;<span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-comment">// 创建二维数组</span><span class="hljs-keyword">let</span> dp = <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len),<span class="hljs-function">()=&gt;</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len).fill(<span class="hljs-number">0</span>)));<span class="hljs-comment">// 从字符串首部开始</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<span class="hljs-comment">// 从字符串i前开始依次向前查找</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i; j &gt;= <span class="hljs-number">0</span>; j--) &#123;dp[j][i] = s[i] == s[j] &amp;&amp; (i - j &lt; <span class="hljs-number">2</span> || dp[j + <span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>]);<span class="hljs-keyword">if</span>(dp[j][i] &amp;&amp; i - j + <span class="hljs-number">1</span> &gt; res.length) &#123;res = s.substring(j, i + <span class="hljs-number">1</span>);&#125;&#125;&#125;<span class="hljs-comment">// console.log(dp)</span><span class="hljs-keyword">return</span> res&#125;;<span class="hljs-comment">// 解法二: 从中间往两边寻找, 性能更好</span><span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<span class="hljs-keyword">if</span> (s.length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;<span class="hljs-keyword">let</span> maxRes = <span class="hljs-number">0</span>, maxStr = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<span class="hljs-comment">// str1 是为了防止 &quot;aba&quot; 的情况</span><span class="hljs-keyword">let</span> str1 = palindrome(s, i, i);<span class="hljs-comment">// str2 是为了防止 &quot;abba&quot; 的情况</span><span class="hljs-keyword">let</span> str2 = palindrome(s, i, i + <span class="hljs-number">1</span>);   <span class="hljs-keyword">if</span> (str1.length &gt; maxRes) &#123;maxStr = str1;maxRes = str1.length;&#125;<span class="hljs-keyword">if</span> (str2.length &gt; maxRes) &#123;maxStr = str2;maxRes = str2.length;&#125;&#125;<span class="hljs-keyword">return</span> maxStr;&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">palindrome</span>(<span class="hljs-params">s, l, r</span>) </span>&#123;<span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.length &amp;&amp; s[l] === s[r]) &#123;l--;r++;&#125;<span class="hljs-keyword">return</span> s.slice(l + <span class="hljs-number">1</span>, r);&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 5 编辑距离 72</span><span class="hljs-comment">// 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</span><span class="hljs-comment">// 你可以对一个单词进行如下三种操作：</span><span class="hljs-comment">//  - 插入一个字符</span><span class="hljs-comment">//  - 删除一个字符</span><span class="hljs-comment">//  - 替换一个字符</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><span class="hljs-comment">// 输出：3</span><span class="hljs-comment">// 解释：</span><span class="hljs-comment">// horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)</span><span class="hljs-comment">// rorse -&gt; rose (删除 &#x27;r&#x27;)</span><span class="hljs-comment">// rose -&gt; ros (删除 &#x27;e&#x27;)</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><span class="hljs-comment">// 输出：5</span><span class="hljs-comment">// 解释：</span><span class="hljs-comment">// intention -&gt; inention (删除 &#x27;t&#x27;)</span><span class="hljs-comment">// inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)</span><span class="hljs-comment">// enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)</span><span class="hljs-comment">// exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)</span><span class="hljs-comment">// exection -&gt; execution (插入 &#x27;u&#x27;)</span><span class="hljs-keyword">var</span> minDistance = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">word1, word2</span>) </span>&#123;<span class="hljs-keyword">let</span> m = word1.length + <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> n = word2.length + <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(m);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; m; k++) &#123;dp[k] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++ ) &#123;dp[i][<span class="hljs-number">0</span>] =  i;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++ ) &#123;dp[<span class="hljs-number">0</span>][j] =  j;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; m; i++ ) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; n; j++ ) &#123;<span class="hljs-keyword">if</span>(word1[i-<span class="hljs-number">1</span>] == word2[j-<span class="hljs-number">1</span>]) &#123;dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]&#125; <span class="hljs-keyword">else</span> &#123;dp[i][j] = <span class="hljs-number">1</span> + <span class="hljs-built_in">Math</span>.min(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>])&#125;&#125;&#125;<span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>]&#125;;</code></pre><h3 id="6-无重复字符的最长子串"><a href="#6-无重复字符的最长子串" class="headerlink" title="6 无重复字符的最长子串"></a>6 无重复字符的最长子串</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 6 无重复字符的最长子串 3</span><span class="hljs-comment">// 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 输入: s = &quot;abcabcbb&quot;</span><span class="hljs-comment">// 输出: 3 </span><span class="hljs-comment">// 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><span class="hljs-comment">// 示例 2:</span><span class="hljs-comment">// 输入: s = &quot;bbbbb&quot;</span><span class="hljs-comment">// 输出: 1</span><span class="hljs-comment">// 解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 解题思路：</span><span class="hljs-comment"> * 1、用双指针维护一个滑动窗口，从来剪切子串</span><span class="hljs-comment"> * 2、不断移动右指针，遇到重复字符串，就把左指针移动到重复字符串的下一位</span><span class="hljs-comment"> * 3、移动右指针的过程中，记录所有窗口的长度，并返回最大值</span><span class="hljs-comment"> * 时间复杂度： O(n)</span><span class="hljs-comment"> * 空间复杂度： O(m)  m是字符串s不重复字符的个数</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> lengthOfLongestSubstring = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<span class="hljs-keyword">if</span>(!s) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<span class="hljs-keyword">if</span> (m.has(s[i]) &amp;&amp; m.get(s[i]) &gt;= l) &#123;l = m.get(s[i]) + <span class="hljs-number">1</span>;&#125;m.set(s[i], i);res = <span class="hljs-built_in">Math</span>.max(res, i - l + <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 7 整数转罗马数字 12</span><span class="hljs-comment">// 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</span><span class="hljs-comment">// 字符          数值</span><span class="hljs-comment">// I             1</span><span class="hljs-comment">// V             5</span><span class="hljs-comment">// X             10</span><span class="hljs-comment">// L             50</span><span class="hljs-comment">// C             100</span><span class="hljs-comment">// D             500</span><span class="hljs-comment">// M             1000</span><span class="hljs-comment">// 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。</span><span class="hljs-comment">// 27 写做  XXVII, 即为 XX + V + II 。</span><span class="hljs-comment">// 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，</span><span class="hljs-comment">// 例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。</span><span class="hljs-comment">// 同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</span><span class="hljs-comment">//  - I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</span><span class="hljs-comment">//  - X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </span><span class="hljs-comment">//  - C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</span><span class="hljs-comment">// 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 输入: 3</span><span class="hljs-comment">// 输出: &quot;III&quot;</span><span class="hljs-comment">// 示例 2:</span><span class="hljs-comment">// 输入: 4</span><span class="hljs-comment">// 输出: &quot;IV&quot;</span><span class="hljs-comment">// 示例 3:</span><span class="hljs-comment">// 输入: 9</span><span class="hljs-comment">// 输出: &quot;IX&quot;</span><span class="hljs-comment">// 示例 4:</span><span class="hljs-comment">// 输入: 58</span><span class="hljs-comment">// 输出: &quot;LVIII&quot;</span><span class="hljs-comment">// 解释: L = 50, V = 5, III = 3.</span><span class="hljs-comment">// 示例 5:</span><span class="hljs-comment">// 输入: 1994</span><span class="hljs-comment">// 输出: &quot;MCMXCIV&quot;</span><span class="hljs-comment">// 解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><span class="hljs-comment">// var intToRoman = function (num) &#123;</span><span class="hljs-comment">//     let keys = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],</span><span class="hljs-comment">//         values = [&#x27;M&#x27;, &#x27;CM&#x27;, &#x27;D&#x27;, &#x27;CD&#x27;, &#x27;C&#x27;, &#x27;XC&#x27;, &#x27;L&#x27;, &#x27;XL&#x27;, &#x27;X&#x27;, &#x27;IX&#x27;, &#x27;V&#x27;, &#x27;IV&#x27;, &#x27;I&#x27;];</span><span class="hljs-comment">//     let res = &quot;&quot;;</span><span class="hljs-comment">//     for (let i = 0; i &lt; keys.length; i++) &#123;</span><span class="hljs-comment">//         while (num &gt;= keys[i]) &#123;</span><span class="hljs-comment">//             num -= keys[i];</span><span class="hljs-comment">//             res += values[i];</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">//     return res;</span><span class="hljs-comment">// &#125;;</span><span class="hljs-keyword">var</span> intToRoman = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) </span>&#123;<span class="hljs-keyword">let</span> keys = [<span class="hljs-number">1000</span>, <span class="hljs-number">900</span>, <span class="hljs-number">500</span>, <span class="hljs-number">400</span>, <span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">50</span>, <span class="hljs-number">40</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>];<span class="hljs-keyword">const</span> values = [<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-string">&#x27;CM&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;CD&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;XC&#x27;</span>,<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-string">&#x27;XL&#x27;</span>,<span class="hljs-string">&#x27;X&#x27;</span>,<span class="hljs-string">&#x27;IX&#x27;</span>,<span class="hljs-string">&#x27;V&#x27;</span>,<span class="hljs-string">&#x27;IV&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>];<span class="hljs-keyword">let</span> result = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-keyword">while</span>(num)&#123;<span class="hljs-keyword">if</span>(num &gt;= keys[<span class="hljs-number">0</span>])&#123;result += values[<span class="hljs-number">0</span>];num -= keys[<span class="hljs-number">0</span>];&#125;<span class="hljs-keyword">else</span>&#123;keys.shift();values.shift();&#125;&#125;<span class="hljs-keyword">return</span> result;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 8 罗马数字转整数 13</span><span class="hljs-keyword">var</span> romanToInt = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<span class="hljs-keyword">const</span> map = &#123;<span class="hljs-string">&quot;I&quot;</span>: <span class="hljs-number">1</span>,<span class="hljs-string">&quot;V&quot;</span>: <span class="hljs-number">5</span>,<span class="hljs-string">&quot;X&quot;</span>: <span class="hljs-number">10</span>,<span class="hljs-string">&quot;L&quot;</span>: <span class="hljs-number">50</span>,<span class="hljs-string">&quot;C&quot;</span>: <span class="hljs-number">100</span>,<span class="hljs-string">&quot;D&quot;</span>: <span class="hljs-number">500</span>,<span class="hljs-string">&quot;M&quot;</span>: <span class="hljs-number">1000</span>&#125;<span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++)&#123;map[s[i]] &lt; map[s[i+<span class="hljs-number">1</span>]] ?result -= map[s[i]] : result += map[s[i]];&#125;<span class="hljs-keyword">return</span> result;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 9 最小路径和 64</span><span class="hljs-comment">// 给定一个包含非负整数的 m x n 网格 grid ，</span><span class="hljs-comment">// 请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</span><span class="hljs-comment">// 说明：每次只能向下或者向右移动一步。</span><span class="hljs-comment">// 动态规划</span><span class="hljs-keyword">var</span> minPathSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">grid</span>) </span>&#123;<span class="hljs-keyword">let</span> m = grid.length;<span class="hljs-keyword">let</span> n = grid[<span class="hljs-number">0</span>].length;<span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(m);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-keyword">const</span> subArr = grid[i];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; subArr.length; j++) &#123;<span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>) &#123;arr[i][j] = j === <span class="hljs-number">0</span> ? subArr[<span class="hljs-number">0</span>] : arr[i][j - <span class="hljs-number">1</span>] + subArr[j];&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (j === <span class="hljs-number">0</span>) &#123;arr[i][j] = arr[i - <span class="hljs-number">1</span>][j] + subArr[j];&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">const</span> tem = <span class="hljs-built_in">Math</span>.min(arr[i - <span class="hljs-number">1</span>][j], arr[i][j - <span class="hljs-number">1</span>]);arr[i][j] = subArr[j] + tem;&#125;&#125;&#125;&#125;<span class="hljs-keyword">return</span> arr[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 10 最长公共前缀 14</span><span class="hljs-comment">// 编写一个函数来查找字符串数组中的最长公共前缀。</span><span class="hljs-comment">// 如果不存在公共前缀，返回空字符串 &quot;&quot;。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><span class="hljs-comment">// 输出：&quot;fl&quot;</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><span class="hljs-comment">// 输出：&quot;&quot;</span><span class="hljs-comment">// 解释：输入不存在公共前缀。</span><span class="hljs-keyword">var</span> longestCommonPrefix = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">strs</span>) </span>&#123;<span class="hljs-keyword">let</span> str = strs[<span class="hljs-number">0</span>]<span class="hljs-keyword">if</span>(!str) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++)&#123;<span class="hljs-keyword">let</span> flag = strs.every(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item[i] == str[i]);<span class="hljs-keyword">if</span> (flag) &#123;res += str[i];&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> res;&#125;&#125;<span class="hljs-keyword">return</span> res&#125;;</code></pre><h3 id="11-最小覆盖子串"><a href="#11-最小覆盖子串" class="headerlink" title="11 最小覆盖子串"></a>11 最小覆盖子串</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 11 最小覆盖子串 76</span><span class="hljs-comment">// 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串</span><span class="hljs-comment">// 如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。</span><span class="hljs-comment">// 注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><span class="hljs-comment">// 输出：&quot;BANC&quot;</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：s = &quot;a&quot;, t = &quot;a&quot;</span><span class="hljs-comment">// 输出：&quot;a&quot;</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 用双指针维护一个滑动窗口</span><span class="hljs-comment"> * 移动右指针，直到找到包含t的所有子串，此时再移动左指针，尽量减少包含t的子串的长度。</span><span class="hljs-comment"> * 时间复杂度:  O(m + n) ,m是t的长度,n是s的长度</span><span class="hljs-comment"> * 空间复杂度:  O(m) ,m是t中不同字符的个数</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> minWindow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>; <span class="hljs-comment">// 左指针</span><span class="hljs-keyword">let</span> r = <span class="hljs-number">0</span>; <span class="hljs-comment">// 右指针</span><span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(); <span class="hljs-comment">// 保存t的map对象</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> t) &#123;m.set(item, m.has(item) ? m.get(item) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span>; <span class="hljs-comment">// 结果值</span><span class="hljs-keyword">let</span> size = m.size; <span class="hljs-comment">// 记录</span><span class="hljs-keyword">while</span>(r &lt; s.length)&#123;<span class="hljs-keyword">const</span> ri = s[r];<span class="hljs-comment">// 记录右指针移动中对 m 和 size 的影响</span><span class="hljs-keyword">if</span> (m.has(ri)) &#123;m.set(ri, m.get(ri) - <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(m.get(ri) === <span class="hljs-number">0</span>) size-- ;&#125;<span class="hljs-comment">// 当 size = 0 表示 s 从 l 到 r 正好涵盖 t</span><span class="hljs-keyword">while</span> (size === <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 记录子串</span><span class="hljs-keyword">let</span> sub = s.substring(l, r + <span class="hljs-number">1</span>);res = !res || sub.length &lt; res.length ? sub : res;<span class="hljs-comment">// 记录左指针移动中对 m 和 size 的影响</span><span class="hljs-keyword">const</span> li = s[l];<span class="hljs-keyword">if</span> (m.has(li)) &#123;m.set(li, m.get(li) + <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(m.get(li) === <span class="hljs-number">1</span>) size ++;&#125;l++;&#125;r++;&#125;<span class="hljs-keyword">return</span> res; &#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 12 单词拆分 139</span><span class="hljs-comment">// 给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</span><span class="hljs-comment">// 说明：</span><span class="hljs-comment">// 1. 拆分时可以重复使用字典中的单词。</span><span class="hljs-comment">// 2. 你可以假设字典中没有重复的单词。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><span class="hljs-comment">// 输出: true</span><span class="hljs-comment">// 解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><span class="hljs-comment">// 输出: true</span><span class="hljs-comment">// 解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><span class="hljs-comment">//      注意你可以重复使用字典中的单词。</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><span class="hljs-comment">// 输出: false</span><span class="hljs-comment">// 动态规划， 从后往前扫描</span><span class="hljs-keyword">var</span> wordBreak = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s, wordDict</span>) </span>&#123;<span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(wordDict);<span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(s.length + <span class="hljs-number">1</span>).fill(<span class="hljs-literal">false</span>);dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= s.length; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<span class="hljs-keyword">if</span> (dp[i] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">const</span> subStr = s.slice(j, i);<span class="hljs-keyword">if</span> (set.has(subStr) &amp;&amp; dp[j]) &#123;dp[i] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> dp[s.length];&#125;;<span class="hljs-comment">// 解法二： DFS</span><span class="hljs-keyword">const</span> wordBreak = <span class="hljs-function">(<span class="hljs-params">s, wordDict</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> len = s.length;<span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(wordDict);<span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len);<span class="hljs-keyword">const</span> dfs = <span class="hljs-function"><span class="hljs-params">startIndex</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (startIndex == len) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">// memo中有，就用memo中的</span><span class="hljs-keyword">if</span> (buffer[startIndex] !== <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">return</span> buffer[startIndex];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = startIndex + <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;<span class="hljs-keyword">const</span> subStr = s.slice(startIndex, i);<span class="hljs-keyword">if</span> (set.has(subStr) &amp;&amp; dfs(i)) &#123;buffer[startIndex] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 当前递归的结果存一下</span><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;buffer[startIndex] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 当前递归的结果存一下</span><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;<span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>);&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 13 100层丢鸡蛋</span><span class="hljs-comment">// 有2个鸡蛋，可能在任意一层丢下刚好会摔破</span><span class="hljs-comment">// 现在假设有num层，找到最少尝试的次数m</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFlort</span>(<span class="hljs-params">num</span>) </span>&#123;<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(i &lt; num) &#123;<span class="hljs-keyword">let</span> t = i;<span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(t &gt; <span class="hljs-number">0</span> &amp;&amp; sum &lt; num) &#123;sum += t;<span class="hljs-keyword">if</span> (sum + (t - <span class="hljs-number">1</span>) &gt; num) &#123;<span class="hljs-keyword">return</span> i;&#125;t--;&#125;i++;&#125;&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 14 较大分组的位置 830</span><span class="hljs-comment">// 在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。</span><span class="hljs-comment">// 例如，在字符串 s = &quot;abbxxxxzyy&quot; 中，就含有 &quot;a&quot;, &quot;bb&quot;, &quot;xxxx&quot;, &quot;z&quot; 和 &quot;yy&quot; 这样的一些分组。</span><span class="hljs-comment">// 分组可以用区间 [start, end] 表示，其中 start 和 end </span><span class="hljs-comment">//    分别表示该分组的起始和终止位置的下标。上例中的 &quot;xxxx&quot; 分组用区间表示为 [3,6] 。</span><span class="hljs-comment">// 我们称所有包含大于或等于三个连续字符的分组为 较大分组 。</span><span class="hljs-comment">// 找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：s = &quot;abbxxxxzzy&quot;</span><span class="hljs-comment">// 输出：[[3,6]]</span><span class="hljs-comment">// 解释：&quot;xxxx&quot; 是一个起始于 3 且终止于 6 的较大分组。</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：s = &quot;abc&quot;</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-comment">// 解释：&quot;a&quot;,&quot;b&quot; 和 &quot;c&quot; 均不是符合要求的较大分组。</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：s = &quot;abcdddeeeeaabbbcd&quot;</span><span class="hljs-comment">// 输出：[[3,5],[6,9],[12,14]]</span><span class="hljs-comment">// 解释：较大分组为 &quot;ddd&quot;, &quot;eeee&quot; 和 &quot;bbb&quot;</span><span class="hljs-comment">// 示例 4：</span><span class="hljs-comment">// 输入：s = &quot;aba&quot;</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-comment">// 解法一: 双指针</span><span class="hljs-keyword">var</span> largeGroupPositions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">if</span> (!s) <span class="hljs-keyword">return</span> res;<span class="hljs-keyword">let</span> p1 = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(p1 &lt; s.length - <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">let</span> p2 = p1 + <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(s[p1] === s[p2]) &#123;p2++;&#125;<span class="hljs-keyword">if</span>(p2 - p1 &gt;= <span class="hljs-number">3</span> ) &#123;res.push([p1, p2 - <span class="hljs-number">1</span>]);p1 = p2;&#125; <span class="hljs-keyword">else</span> &#123;p1++;&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 解法二: 正则:matchAll —— ([a-z])捕获小写字母，\1反向引用刚才捕获的字母，&#123;2,&#125;该字母又出现&gt;=2次</span><span class="hljs-keyword">var</span> largeGroupPositions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">const</span> iterator = s.matchAll(<span class="hljs-regexp">/([a-z])\1&#123;2,&#125;/g</span>);<span class="hljs-keyword">let</span> ite = iterator.next();<span class="hljs-comment">// ite.done = false,表示迭代器还没有结束</span><span class="hljs-keyword">while</span> (!ite.done) &#123;<span class="hljs-comment">// res = &#123; done: false, value: &#123;0: &#x27;bbb&#x27;, 1: &#x27;b&#x27;, index: 2, input: &quot;aabbbcccdddddeeeeee&quot;&#125;&#125;</span>res.push([ite.value.index, ite.value.index + ite.value[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>])ite = iterator.next();&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 解法三 正则:replace  \1反向引用刚才捕获的字母，&#123;2,&#125;该字母又出现&gt;=2次</span><span class="hljs-keyword">var</span> largeGroupPositions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<span class="hljs-keyword">const</span> r = [];s.replace(<span class="hljs-regexp">/([a-z])\1&#123;2,&#125;/g</span>, <span class="hljs-function">(<span class="hljs-params">a, _, i</span>)=&gt;</span> r.push([i, i + a.length - <span class="hljs-number">1</span>]));<span class="hljs-keyword">return</span> r;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 15 下划线与驼峰互换</span><span class="hljs-comment">// 解法一 正则 replace</span><span class="hljs-comment">// 1-1.驼峰式转下横线：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerLine</span>(<span class="hljs-params">str</span>) </span>&#123;<span class="hljs-keyword">var</span> resStr = str.replace(<span class="hljs-regexp">/[A-Z]/g</span>, <span class="hljs-function"><span class="hljs-params">match</span> =&gt;</span> <span class="hljs-string">&quot;_&quot;</span> + match.toLowerCase());<span class="hljs-comment">//如果首字母是大写，执行replace时会多一个_ ,这里需要去掉</span>  <span class="hljs-keyword">if</span>(resStr.slice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) === <span class="hljs-string">&#x27;_&#x27;</span>) &#123; <span class="hljs-comment">// resStr.startsWith(&#x27;_&#x27;)</span>  resStr = resStr.slice(<span class="hljs-number">1</span>);  &#125;<span class="hljs-keyword">return</span> resStr;&#125;;<span class="hljs-comment">// test:</span>toLowerLine(<span class="hljs-string">&quot;TestToLowerLine&quot;</span>);  <span class="hljs-comment">//test_to_lower_line</span>toLowerLine(<span class="hljs-string">&quot;testToLowerLine&quot;</span>);  <span class="hljs-comment">//test_to_lower_line</span><span class="hljs-comment">// 1-2.下横线转驼峰式：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toCamel</span>(<span class="hljs-params">str</span>) </span>&#123;  <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/([^_])(?:_+([^_]))/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">match, $<span class="hljs-number">1</span>, $<span class="hljs-number">2</span></span>) </span>&#123;<span class="hljs-comment">// match=t_b, $1=t, $2=b</span><span class="hljs-comment">// match=e_c, $1=e, $2=c</span><span class="hljs-keyword">return</span> $<span class="hljs-number">1</span> + $<span class="hljs-number">2.</span>toUpperCase();  &#125;);&#125;<span class="hljs-comment">// test</span>toCamel(<span class="hljs-string">&#x27;test_be_camel&#x27;</span>) <span class="hljs-comment">// testBeCamel</span><span class="hljs-comment">// 解法二: reduce</span><span class="hljs-comment">// 2-1.驼峰式转下横线：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerLine</span>(<span class="hljs-params">str</span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.reduce.call(str, <span class="hljs-function">(<span class="hljs-params">pre, cur, index</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span>(<span class="hljs-regexp">/[A-Z]/</span>.test(cur))&#123;cur = cur.toLowerCase();<span class="hljs-keyword">return</span> index === <span class="hljs-number">0</span> ? pre + cur :  pre + <span class="hljs-string">&#x27;_&#x27;</span> + cur&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> pre + cur;&#125;&#125;, <span class="hljs-string">&#x27;&#x27;</span>)&#125;<span class="hljs-comment">// test</span>toLowerLine(<span class="hljs-string">&#x27;TestToLowerLine&#x27;</span>); <span class="hljs-comment">// test_to_lower_line</span><span class="hljs-comment">// 2-2.下横线转驼峰式：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toCamel</span>(<span class="hljs-params">str</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.reduce.call(str, <span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (pre.endsWith(<span class="hljs-string">&#x27;_&#x27;</span>)) &#123;<span class="hljs-keyword">return</span> pre.substring(<span class="hljs-number">0</span>, pre.length - <span class="hljs-number">1</span>) + cur.toUpperCase();&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> pre + cur;&#125;&#125;)&#125;<span class="hljs-comment">// test</span>toCamel(<span class="hljs-string">&#x27;test_to_camel&#x27;</span>); <span class="hljs-comment">// testToCamel</span><span class="hljs-comment">// 解法三: Array.map()</span><span class="hljs-comment">// 3-1.驼峰式转下横线：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerLine</span>(<span class="hljs-params">arr</span>)</span>&#123;<span class="hljs-comment">// return [].map.call(arr, doLowerLine).join(&#x27;&#x27;);</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.map.call(arr, <span class="hljs-function">(<span class="hljs-params">val, index</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span>(<span class="hljs-regexp">/[A-Z]/</span>.test(val))&#123;<span class="hljs-keyword">return</span> index === <span class="hljs-number">0</span> ? val.toLowerCase() : <span class="hljs-string">&#x27;_&#x27;</span> + val.toLowerCase();&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> val;&#125;&#125;).join(<span class="hljs-string">&#x27;&#x27;</span>);&#125;</code></pre><h3 id="16-Z-字形变换"><a href="#16-Z-字形变换" class="headerlink" title="16 Z 字形变换"></a>16 Z 字形变换</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 16 Z 字形变换 6</span><span class="hljs-comment">// 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</span><span class="hljs-comment">// 比如输入字符串为 &quot;PAYPALISHIRING&quot; 行数为 3 时，排列如下：</span><span class="hljs-comment">// P   A   H   N</span><span class="hljs-comment">// A P L S I I G</span><span class="hljs-comment">// Y   I   R</span><span class="hljs-comment">// 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;PAHNAPLSIIGYIR&quot;。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><span class="hljs-comment">// 输出：&quot;PAHNAPLSIIGYIR&quot;</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><span class="hljs-comment">// 输出：&quot;PINALSIGYAHRPI&quot;</span><span class="hljs-comment">// 解释：</span><span class="hljs-comment">// P     I    N</span><span class="hljs-comment">// A   L S  I G</span><span class="hljs-comment">// Y A   H R</span><span class="hljs-comment">// P     I</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：s = &quot;A&quot;, numRows = 1</span><span class="hljs-comment">// 输出：&quot;A&quot;</span><span class="hljs-keyword">var</span> convert = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, numRows</span>) </span>&#123;<span class="hljs-keyword">if</span> (numRows === <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(numRows).fill(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-keyword">const</span> n = <span class="hljs-number">2</span> * numRows - <span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<span class="hljs-keyword">const</span> index = <span class="hljs-built_in">Math</span>.min(i % n, n - i % n);arr[index] += s[i]&#125;<span class="hljs-keyword">return</span> arr.join(<span class="hljs-string">&#x27;&#x27;</span>);&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 17 不同的路径 62</span><span class="hljs-comment">// 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</span><span class="hljs-comment">// 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</span><span class="hljs-comment">// 问总共有多少条不同的路径？</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：m = 3, n = 7</span><span class="hljs-comment">// 输出：28</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：m = 3, n = 2</span><span class="hljs-comment">// 输出：3</span><span class="hljs-comment">// 解释：</span><span class="hljs-comment">// 从左上角开始，总共有 3 条路径可以到达右下角。</span><span class="hljs-comment">// 1. 向右 -&gt; 向下 -&gt; 向下</span><span class="hljs-comment">// 2. 向下 -&gt; 向下 -&gt; 向右</span><span class="hljs-comment">// 3. 向下 -&gt; 向右 -&gt; 向下</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：m = 7, n = 3</span><span class="hljs-comment">// 输出：28</span><span class="hljs-comment">// 示例 4：</span><span class="hljs-comment">// 输入：m = 3, n = 3</span><span class="hljs-comment">// 输出：6</span><span class="hljs-keyword">var</span> uniquePaths = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">m, n</span>) </span>&#123;<span class="hljs-comment">// 新建一个 m行 n列 的二维数组</span><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(m);   <span class="hljs-comment">// 每一列的第一个值 置为1</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n);arr[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;&#125;    <span class="hljs-comment">// 每一列的第一个值 置为1</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;arr[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;arr[i][j] = arr[i - <span class="hljs-number">1</span>][j] + arr[i][j - <span class="hljs-number">1</span>];&#125;&#125;<span class="hljs-keyword">return</span> arr[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];&#125;;<span class="hljs-comment">// var uniquePaths = function(m, n) &#123;</span><span class="hljs-comment">// let res = 1;</span><span class="hljs-comment">// for (let x = n, y = 1; y &lt; m; ++x, ++y) &#123;</span><span class="hljs-comment">// res = Math.floor(res * x / y);</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// return res;</span><span class="hljs-comment">// &#125;;</span></code></pre><h2 id="五-链表"><a href="#五-链表" class="headerlink" title="五 链表"></a>五 链表</h2><p>1 反转链表<br>2 两数相加<br>3 删除链表的倒数第 N 个结点<br>4 合并两个有序链表<br>5 两两交换链表中的节点 —— 给定一个链表，两两交换其中相邻的节点<br>6 相交链表 —— 找到两个单链表相交的起始节点<br>7 回文链表 —— 判断一个链表是否为回文链表<br>8 合并K个升序链表 —— 将n个升序链表合并的一个链表<br>9 排序链表 —— 将链表升序排列</p><h3 id="1-反转链表"><a href="#1-反转链表" class="headerlink" title="1 反转链表"></a>1 反转链表</h3><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1 反转链表 206</span><span class="hljs-comment">// 反转一个单链表。</span><span class="hljs-comment">// 示例:</span><span class="hljs-comment">// 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><span class="hljs-comment">// 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><span class="hljs-comment">// 进阶:</span><span class="hljs-comment">// 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</span><span class="hljs-keyword">var</span> reverseList = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;    <span class="hljs-keyword">let</span> p1 = head;    <span class="hljs-keyword">let</span> p2 = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">while</span>(p1) &#123;        <span class="hljs-keyword">const</span> tmp = p1.next; <span class="hljs-comment">// 1. 临时存储当前指针后续内容</span>        p1.next = p2;<span class="hljs-comment">// 2. 反转链表</span>        p2 = p1;<span class="hljs-comment">// 3. 接收反转结果</span>        p1 = tmp;<span class="hljs-comment">// 4. 接回临时存储的后续内容</span>    &#125;    <span class="hljs-keyword">return</span> p2;&#125;;<span class="hljs-comment">// 反转链表 II 92</span><span class="hljs-comment">// 给你单链表的头指针 head 和两个整数 left 和 right ，</span><span class="hljs-comment">// 其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 </span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：head = [1,2,3,4,5], left = 2, right = 4</span><span class="hljs-comment">// 输出：[1,4,3,2,5]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：head = [5], left = 1, right = 1</span><span class="hljs-comment">// 输出：[5]</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">left</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">right</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-comment">// 解法一: 把原链表 分割，再反转，再拼接</span><span class="hljs-keyword">var</span> reverseBetween = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head, left, right</span>) </span>&#123;<span class="hljs-keyword">if</span> (left === right) <span class="hljs-keyword">return</span> head;<span class="hljs-keyword">let</span> p = head;<span class="hljs-keyword">let</span> res;<span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> leftList = <span class="hljs-keyword">new</span> ListNode();<span class="hljs-keyword">let</span> p1 = leftList;<span class="hljs-keyword">let</span> midList = <span class="hljs-keyword">new</span> ListNode();<span class="hljs-keyword">let</span> p2 = midList;<span class="hljs-keyword">let</span> rightList = <span class="hljs-keyword">new</span> ListNode();<span class="hljs-keyword">let</span> p3 = rightList;<span class="hljs-comment">// 1 先找到 leftList、midList、rightList</span><span class="hljs-keyword">while</span>(p) &#123; <span class="hljs-keyword">if</span> (index &lt; left) &#123;  p1.next = <span class="hljs-keyword">new</span> ListNode(p.val);  p1 = p1.next; &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &gt; right) &#123;  p3.next = <span class="hljs-keyword">new</span> ListNode(p.val);  p3 = p3.next; &#125; <span class="hljs-keyword">else</span> &#123;  p2.next = <span class="hljs-keyword">new</span> ListNode(p.val);  p2 = p2.next; &#125; p = p.next; index++;&#125;leftList = leftList.next;midList = midList.next;rightList = rightList.next;<span class="hljs-comment">// 2 将 midList 反转</span><span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>;<span class="hljs-keyword">let</span> p4 = midList;<span class="hljs-keyword">while</span> (p4) &#123;<span class="hljs-keyword">let</span> tem = p4.next;p4.next = pre;pre = p4;p4 = tem;&#125;midList.next = rightList;<span class="hljs-comment">// 3 将 leftList、midList、rightList 组合 得到结果</span><span class="hljs-keyword">if</span> (leftList) &#123;res = leftList;p1.next = pre;&#125; <span class="hljs-keyword">else</span> &#123;res = pre;&#125;<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-comment">// 解法二: 找到反转的 位置，直接进行反转</span><span class="hljs-keyword">var</span> reverseBetween = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head, left, right</span>) </span>&#123;<span class="hljs-keyword">let</span> res = <span class="hljs-keyword">new</span> ListNode();res.next = head;<span class="hljs-keyword">let</span> pre = res;<span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (index &lt; left) &#123;pre = pre.next;index++;&#125;<span class="hljs-keyword">let</span> cur = pre.next;<span class="hljs-keyword">while</span>(index &lt; right) &#123;<span class="hljs-keyword">const</span> tem = cur.next;cur.next = tem.next;tem.next = pre.next;pre.next = tem;index++;&#125;<span class="hljs-keyword">return</span> res.next;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 2 两数相加 (链表) 2</span><span class="hljs-comment">// 给你两个 非空 的链表，表示两个非负的整数</span><span class="hljs-comment">// 它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</span><span class="hljs-comment">// 请你将两个数相加，并以相同形式返回一个表示和的链表。</span><span class="hljs-comment">// 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：l1 = [2,4,3], l2 = [5,6,4]</span><span class="hljs-comment">// 输出：[7,0,8]</span><span class="hljs-comment">// 解释：342 + 465 = 807.</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：l1 = [0], l2 = [0]</span><span class="hljs-comment">// 输出：[0]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><span class="hljs-comment">// 输出：[8,9,9,9,0,0,0,1]</span><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;<span class="hljs-keyword">const</span> l3 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<span class="hljs-keyword">let</span> p1 = l1;<span class="hljs-keyword">let</span> p2 = l2;<span class="hljs-keyword">let</span> p3 = l3;<span class="hljs-keyword">let</span> carry = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(p1 || p2) &#123;<span class="hljs-keyword">const</span> v1 = p1 ? p1.val : <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> v2 = p2 ? p2.val : <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> val = v1 + v2 + carry;carry = <span class="hljs-built_in">Math</span>.floor(val / <span class="hljs-number">10</span>);p3.next = <span class="hljs-keyword">new</span> ListNode(val % <span class="hljs-number">10</span>);<span class="hljs-keyword">if</span> (p1) p1 = p1.next;<span class="hljs-keyword">if</span> (p2) p2 = p2.next;p3 = p3.next;&#125;<span class="hljs-keyword">if</span> (carry) &#123;p3.next = <span class="hljs-keyword">new</span> ListNode(carry);&#125;<span class="hljs-keyword">return</span> l3.next;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 3 删除链表的倒数第 N 个结点  19</span><span class="hljs-comment">// 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</span><span class="hljs-comment">// 进阶：你能尝试使用一趟扫描实现吗？</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：head = [1,2,3,4,5], n = 2</span><span class="hljs-comment">// 输出：[1,2,3,5]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：head = [1], n = 1</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：head = [1,2], n = 1</span><span class="hljs-comment">// 输出：[1]]</span><span class="hljs-comment">// 找到删除节点的前一个节点</span><span class="hljs-keyword">var</span> removeNthFromEnd = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head, n</span>) </span>&#123;<span class="hljs-keyword">let</span> node = head;<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(node) &#123;node = node.next;count++;&#125;count = count - n - <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (count === -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> head.next;node = head;<span class="hljs-keyword">while</span>(count &gt; <span class="hljs-number">0</span>) &#123;node = node.next;count--;&#125;node.next = node.next.next;<span class="hljs-keyword">return</span> head;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 4 合并两个有序链表 21</span><span class="hljs-comment">// 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：l1 = [1,2,4], l2 = [1,3,4]</span><span class="hljs-comment">// 输出：[1,1,2,3,4,4]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：l1 = [], l2 = []</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：l1 = [], l2 = [0]</span><span class="hljs-comment">// 输出：[0]</span><span class="hljs-keyword">var</span> mergeTwoLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;<span class="hljs-keyword">let</span> l3 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-literal">null</span>);<span class="hljs-keyword">let</span> p1 = l1;<span class="hljs-keyword">let</span> p2 = l2;<span class="hljs-keyword">let</span> p3 = l3;<span class="hljs-keyword">while</span>(p1 &amp;&amp; p2) &#123;<span class="hljs-keyword">if</span> (p1.val &gt; p2.val) &#123;p3.next = p2;p2 = p2.next&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p1.val &lt;= p2.val) &#123;p3.next = p1;p1 = p1.next&#125;p3 = p3.next;&#125;p3.next = p1 ? p1 : p2;<span class="hljs-keyword">return</span> l3.next;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 5 两两交换链表中的节点 24</span><span class="hljs-comment">// 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</span><span class="hljs-comment">// 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：head = [1,2,3,4]</span><span class="hljs-comment">// 输出：[2,1,4,3]</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：head = []</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：head = [1]</span><span class="hljs-comment">// 输出：[1]</span><span class="hljs-keyword">const</span> swapPairs = <span class="hljs-function">(<span class="hljs-params">head</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> resNode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);resNode.next = head;<span class="hljs-keyword">let</span> prev = resNode;<span class="hljs-keyword">while</span> (head &amp;&amp; head.next) &#123;<span class="hljs-comment">// 临时保存head.next，因为head.next待会要改变</span><span class="hljs-keyword">const</span> next = head.next;head.next = next.next;next.next = head;prev.next = next;  prev = head;      <span class="hljs-comment">// 指针更新</span>head = head.next; <span class="hljs-comment">// 指针更新</span>&#125;<span class="hljs-keyword">return</span> resNode.next;&#125;;</code></pre><h3 id="6-相交链表"><a href="#6-相交链表" class="headerlink" title="6 相交链表"></a>6 相交链表</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 6 相交链表 160</span><span class="hljs-comment">// 编写一个程序，找到两个单链表相交的起始节点。</span><span class="hljs-comment">// 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><span class="hljs-comment">// 输出：Reference of the node with value = 8</span><span class="hljs-comment">// 输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><span class="hljs-comment">// 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。</span><span class="hljs-comment">// 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><span class="hljs-comment">// 输出：Reference of the node with value = 2</span><span class="hljs-comment">// 输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><span class="hljs-comment">// 从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><span class="hljs-keyword">var</span> getIntersectionNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">headA, headB</span>) </span>&#123;<span class="hljs-comment">// 解法一: 对headA打标记</span><span class="hljs-comment">// while(headA) &#123;</span><span class="hljs-comment">//     headA.flag = true;</span><span class="hljs-comment">//     headA = headA.next;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// while(headB) &#123;</span><span class="hljs-comment">//     if(headB.flag) return headB;</span><span class="hljs-comment">//     headB = headB.next;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// return null;</span><span class="hljs-comment">// 解法二: 嵌套循环</span><span class="hljs-comment">// let p1 = headA;</span><span class="hljs-comment">// while(p1) &#123;</span><span class="hljs-comment">//     let p2 = headB;</span><span class="hljs-comment">//     while(p2) &#123;</span><span class="hljs-comment">//         if (p1 === p2) &#123;</span><span class="hljs-comment">//             return p1</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//         p2 = p2.next;</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">//     p1 = p1.next;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// return null;</span><span class="hljs-comment">// 解法三: 消除多余</span><span class="hljs-keyword">let</span> p1 = headA;<span class="hljs-keyword">let</span> p2 = headB;<span class="hljs-keyword">while</span>(p1 || p2) &#123;<span class="hljs-keyword">if</span> (p1 === p2) &#123;<span class="hljs-keyword">return</span> p1;&#125;p1 = p1 === <span class="hljs-literal">null</span> ? headB : p1.next;p2 = p2 === <span class="hljs-literal">null</span> ? headA : p2.next;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 7  回文链表 234</span><span class="hljs-comment">// 请判断一个链表是否为回文链表。</span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 输入: 1-&gt;2</span><span class="hljs-comment">// 输出: false</span><span class="hljs-comment">// 示例 2:</span><span class="hljs-comment">// 输入: 1-&gt;2-&gt;2-&gt;1</span><span class="hljs-comment">// 输出: true</span><span class="hljs-comment">// 解法一</span><span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;<span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-keyword">let</span> b = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-keyword">let</span> p = head;<span class="hljs-keyword">while</span>(p)&#123;a = a + p.val;b = p.val + b;p = p.next;&#125;  <span class="hljs-keyword">return</span> a === b;&#125;;<span class="hljs-comment">// 解法二</span><span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;<span class="hljs-keyword">let</span> left = head;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverse</span>(<span class="hljs-params">right</span>) </span>&#123;<span class="hljs-keyword">if</span> (right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">let</span> res = traverse(right.next);res = res &amp;&amp; (right.val === left.val);left = left.next;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">return</span> traverse(head);&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 8 合并K个升序链表 23</span><span class="hljs-comment">// 给你一个链表数组，每个链表都已经按升序排列。</span><span class="hljs-comment">// 请你将所有链表合并到一个升序链表中，返回合并后的链表。</span><span class="hljs-comment">//  </span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><span class="hljs-comment">// 输出：[1,1,2,3,4,4,5,6]</span><span class="hljs-comment">// 解释：链表数组如下：</span><span class="hljs-comment">// [</span><span class="hljs-comment">//   1-&gt;4-&gt;5,</span><span class="hljs-comment">//   1-&gt;3-&gt;4,</span><span class="hljs-comment">//   2-&gt;6</span><span class="hljs-comment">// ]</span><span class="hljs-comment">// 将它们合并到一个有序链表中得到。</span><span class="hljs-comment">// 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：lists = []</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：lists = [[]]</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-comment">/*</span><span class="hljs-comment">解法一：</span><span class="hljs-comment">reduce，将链表数组中的每一个值放入新数组</span><span class="hljs-comment">sort，以链表的val作参考冒泡排序</span><span class="hljs-comment">reduceRight，从右向左遍历，将数组连成链表</span><span class="hljs-comment">*/</span><span class="hljs-comment">// 解法一：</span><span class="hljs-keyword">var</span> mergeKLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lists</span>) </span>&#123;<span class="hljs-keyword">return</span> lists.reduce(<span class="hljs-function">(<span class="hljs-params">p, n</span>) =&gt;</span> &#123;<span class="hljs-keyword">while</span> (n) &#123;p.push(n), n = n.next&#125;<span class="hljs-keyword">return</span> p&#125;, []).sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.val - b.val).reduceRight(<span class="hljs-function">(<span class="hljs-params">p, n</span>) =&gt;</span> (n.next = p, p = n, p), <span class="hljs-literal">null</span>)&#125;;<span class="hljs-comment">// 解法二：</span><span class="hljs-keyword">var</span> mergeKLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lists</span>) </span>&#123;<span class="hljs-keyword">let</span> mergeTwoLists = <span class="hljs-function">(<span class="hljs-params">l1, l2</span>) =&gt;</span> &#123;<span class="hljs-keyword">let</span> preHead = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<span class="hljs-keyword">let</span> preNode = preHead;<span class="hljs-keyword">while</span>(l1 &amp;&amp; l2)&#123;<span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;preNode.next = l1;l1 = l1.next;&#125; <span class="hljs-keyword">else</span> &#123;preNode.next = l2;l2 = l2.next;&#125;preNode = preNode.next;&#125;preNode.next = l1 ? l1 : l2;<span class="hljs-keyword">return</span> preHead.next;&#125;<span class="hljs-keyword">let</span> n = lists.length;<span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-keyword">let</span> res = lists[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<span class="hljs-keyword">if</span>(lists[i])&#123;res = mergeTwoLists(res, lists[i]);&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 9 排序链表148</span><span class="hljs-comment">// 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</span><span class="hljs-comment">// 解法一: 将对链表进行归并排序  比解法二更好、更快</span><span class="hljs-keyword">var</span> sortList = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;<span class="hljs-keyword">if</span> (!head || !head.next) <span class="hljs-keyword">return</span> head;<span class="hljs-keyword">let</span> p = head;<span class="hljs-keyword">return</span> mergeList(p);&#125;;<span class="hljs-comment">// 归并排序 =&gt; o(n logn)</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeList</span>(<span class="hljs-params">head</span>) </span>&#123;<span class="hljs-keyword">if</span> (head.next) &#123;<span class="hljs-comment">// 找到中间节点</span><span class="hljs-keyword">let</span> p1 = head;<span class="hljs-keyword">let</span> p2 = head.next;<span class="hljs-keyword">while</span>(p1 &amp;&amp; p2 &amp;&amp; p2.next) &#123;p1 = p1.next;p2 = p2.next.next;&#125;<span class="hljs-keyword">let</span> rightPart = p1.next;p1.next = <span class="hljs-literal">null</span>;<span class="hljs-keyword">const</span> left = mergeList(head);<span class="hljs-keyword">const</span> right = mergeList(rightPart);head = sortMerge(left, right);&#125;<span class="hljs-keyword">return</span> head;&#125;<span class="hljs-comment">// 合并两个有序链表</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sortMerge</span>(<span class="hljs-params">left, right</span>) </span>&#123;<span class="hljs-keyword">let</span> head = <span class="hljs-literal">null</span>;<span class="hljs-keyword">let</span> p = <span class="hljs-literal">null</span>;<span class="hljs-keyword">while</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">if</span> (left.val &lt; right.val) &#123;<span class="hljs-keyword">if</span> (!head) &#123;head = left;p = head;&#125; <span class="hljs-keyword">else</span> &#123;p.next = left;p = p.next;&#125;left = left.next;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (!head) &#123;head = right;p = head;&#125; <span class="hljs-keyword">else</span> &#123;p.next = right;p = p.next;&#125;right = right.next;&#125;&#125;p.next = left ? left : right;<span class="hljs-keyword">return</span> head;&#125;<span class="hljs-comment">// 解法二: 将链表转为数组,进行归并排序, 然后再转为链表</span><span class="hljs-keyword">var</span> sortList = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;<span class="hljs-keyword">if</span> (!head || !head.next) <span class="hljs-keyword">return</span> head;<span class="hljs-keyword">let</span> p = head;<span class="hljs-keyword">let</span> arr = [];<span class="hljs-keyword">while</span>(p) &#123;arr.push(p);p = p.next;&#125;arr.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;item.next = <span class="hljs-literal">null</span>;&#125;)arr = mergeSort(arr);<span class="hljs-keyword">const</span> newHead = arr[<span class="hljs-number">0</span>];<span class="hljs-keyword">let</span> p1 = newHead;<span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(index &lt; arr.length) &#123;p1.next = arr[index];p1 = p1.next;index++;&#125;<span class="hljs-keyword">return</span> newHead;&#125;;<span class="hljs-keyword">var</span> mergeSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) </span>&#123;<span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-keyword">const</span> mid = arr.length / <span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> left = arr.slice(<span class="hljs-number">0</span>, mid);<span class="hljs-keyword">const</span> right = arr.slice(mid);<span class="hljs-keyword">let</span> leftPart = mergeSort(left);<span class="hljs-keyword">let</span> rightPart = mergeSort(right);<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">while</span>(leftPart.length || rightPart.length) &#123;<span class="hljs-keyword">if</span> (leftPart.length &amp;&amp; rightPart.length) &#123;<span class="hljs-keyword">const</span> item = leftPart[<span class="hljs-number">0</span>].val &lt; rightPart[<span class="hljs-number">0</span>].val ? leftPart.shift() : rightPart.shift();res.push(item);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (leftPart.length) &#123;res.push(leftPart.shift());&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rightPart.length) &#123;res.push(rightPart.shift());&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre><h2 id="六-堆"><a href="#六-堆" class="headerlink" title="六 堆"></a>六 堆</h2><p>1 数组中的第K个最大元素<br>2 前K个高频元素<br>3 合并K个升序链表</p><p>堆是一种特殊的完全二叉树，所有的节点都大于等于（最大堆）或者 小于等于（最小堆）它的子节点。<br>堆的应用：</p><ul><li>堆能高效、快速的找出最大值和最小值——之间复杂度是 O(1)</li><li>找出第 K 个最大（小）值<ul><li>构建一个最小堆，并将元素一次插入堆中</li><li>当堆的容量超过 K，就删除堆顶</li><li>插入结束后，堆顶就是第 K 个最大元素</li></ul></li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// 1 数组中的第K个最大元素 215</span><span class="hljs-comment">// 在未排序的数组中找到第 k 个最大的元素</span><span class="hljs-comment">// 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 输入: [3,2,1,5,6,4] 和 k = 2</span><span class="hljs-comment">// 输出: 5</span><span class="hljs-comment">// 示例 2:</span><span class="hljs-comment">// 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span><span class="hljs-comment">// 输出: 4</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 解题思路：</span><span class="hljs-comment"> * 1、构建一个最小堆，并依次把数组的值插入堆中</span><span class="hljs-comment"> * 2、当堆的容量超过K， 就删除堆顶</span><span class="hljs-comment"> * 3、插入结束后，堆顶就是第K个最大元素</span><span class="hljs-comment"> * 时间复杂度： O(n * log(k))</span><span class="hljs-comment"> * 空间复杂度： O(k)</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinHead</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.heap = [];&#125;<span class="hljs-function"><span class="hljs-title">insert</span>(<span class="hljs-params">value</span>)</span> &#123; <span class="hljs-comment">// 插入</span><span class="hljs-built_in">this</span>.heap.push(value); <span class="hljs-comment">// 插入到底部</span><span class="hljs-built_in">this</span>.shiftUp(<span class="hljs-built_in">this</span>.heap.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">// 删除堆顶</span><span class="hljs-function"><span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>] = <span class="hljs-built_in">this</span>.heap.pop();<span class="hljs-built_in">this</span>.shiftDown(<span class="hljs-number">0</span>); <span class="hljs-comment">// 下移操作</span>&#125;<span class="hljs-comment">// 获取堆顶</span><span class="hljs-function"><span class="hljs-title">peek</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>];&#125;<span class="hljs-comment">// 获取堆的大小</span><span class="hljs-function"><span class="hljs-title">size</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap.length;&#125;<span class="hljs-comment">// 获取父节点</span><span class="hljs-function"><span class="hljs-title">getParentIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-comment">// return Math.floor((i - 1) / 2);</span><span class="hljs-keyword">return</span> (i - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 把二进制的数字右移一位</span>&#125;<span class="hljs-comment">// 获取左侧子节点</span><span class="hljs-function"><span class="hljs-title">getLeftIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 获取右侧子节点</span><span class="hljs-function"><span class="hljs-title">getRightIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;&#125;<span class="hljs-comment">// 将两个节点的位置进行交换</span><span class="hljs-function"><span class="hljs-title">swap</span>(<span class="hljs-params">i1, i2</span>)</span> &#123;<span class="hljs-keyword">const</span> temp = <span class="hljs-built_in">this</span>.heap[i1];<span class="hljs-built_in">this</span>.heap[i1] = <span class="hljs-built_in">this</span>.heap[i2];<span class="hljs-built_in">this</span>.heap[i2] = temp;&#125;<span class="hljs-comment">// 上移</span><span class="hljs-function"><span class="hljs-title">shiftUp</span>(<span class="hljs-params">index</span>)</span> &#123;<span class="hljs-comment">// 递归的终点: 到达堆顶</span><span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">const</span> parentIndex = <span class="hljs-built_in">this</span>.getParentIndex(index);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.heap[parentIndex] &gt; <span class="hljs-built_in">this</span>.heap[index]) &#123;<span class="hljs-built_in">this</span>.swap(parentIndex, index);<span class="hljs-built_in">this</span>.shiftUp(parentIndex);&#125;&#125;<span class="hljs-comment">// 下移</span><span class="hljs-function"><span class="hljs-title">shiftDown</span>(<span class="hljs-params">index</span>)</span> &#123;<span class="hljs-keyword">const</span> leftIndex = <span class="hljs-built_in">this</span>.getLeftIndex(index);<span class="hljs-keyword">const</span> rightIndex = <span class="hljs-built_in">this</span>.getRightIndex(index);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[leftIndex] &lt; <span class="hljs-built_in">this</span>.heap[index]) &#123;<span class="hljs-built_in">this</span>.swap(leftIndex, index);<span class="hljs-built_in">this</span>.shiftDown(leftIndex);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[rightIndex] &lt; <span class="hljs-built_in">this</span>.heap[index]) &#123;<span class="hljs-built_in">this</span>.swap(rightIndex, index);<span class="hljs-built_in">this</span>.shiftDown(rightIndex);&#125;&#125;&#125;<span class="hljs-keyword">var</span> findKthLargest = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;<span class="hljs-keyword">const</span> h1 = <span class="hljs-keyword">new</span> MinHead();nums.forEach(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> &#123;h1.insert(n);<span class="hljs-keyword">if</span>(h1.size() &gt; k) &#123;h1.pop();&#125;&#125;)<span class="hljs-keyword">return</span> h1.peek();&#125;;<span class="hljs-comment">// 解法二：排序</span><span class="hljs-keyword">let</span> findKthLargest = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a).slice(<span class="hljs-number">0</span>, k);<span class="hljs-keyword">return</span> nums[k-<span class="hljs-number">1</span>]&#125;;<span class="hljs-comment">// 时间复杂度: O(n^2 log n) [Array.sort =&gt; O(n log n), Array.slice =&gt; O(n)]</span></code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 2 前 K 个高频元素 347</span><span class="hljs-comment">// 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 输入: nums = [1,1,1,2,2,3], k = 2</span><span class="hljs-comment">// 输出: [1,2]</span><span class="hljs-comment">// 示例 2:</span><span class="hljs-comment">// 输入: nums = [1], k = 1</span><span class="hljs-comment">// 输出: [1]</span><span class="hljs-comment">// 提示：</span><span class="hljs-comment">// 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</span><span class="hljs-comment">// 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</span><span class="hljs-comment">// 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</span><span class="hljs-comment">// 你可以按任意顺序返回答案。</span><span class="hljs-keyword">var</span> topKFrequent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment">    解法一：</span><span class="hljs-comment">        1、建立最小堆</span><span class="hljs-comment">  2、当堆的容量超过K， 就删除堆顶</span><span class="hljs-comment">  3、插入结束后，堆顶就是第K个最大元素</span><span class="hljs-comment"></span><span class="hljs-comment">    时间复杂度： </span><span class="hljs-comment">        1、nums.forEach =&gt; O(n)</span><span class="hljs-comment">        2、map.forEach =&gt; O(n) 而 嵌套的 insert 和 pop 都是 logK, 结合起来就是 O(n log k)</span><span class="hljs-comment">        所以结合起来， 时间复杂度 就是 O(n log K) ，由于 k &lt; n 所有符合题目要求的</span><span class="hljs-comment">   */</span><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();nums.forEach(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> &#123;map.set(n, map.has(n) ? map.get(n) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);&#125;);<span class="hljs-keyword">const</span> h = <span class="hljs-keyword">new</span> MinHead();map.forEach(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;h.insert(&#123;value, key&#125;);<span class="hljs-keyword">if</span> (h.size() &gt; k) &#123;h.pop();&#125;&#125;)<span class="hljs-keyword">return</span> h.heap.map(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a.key)    &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinHead</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.heap = [];&#125;<span class="hljs-function"><span class="hljs-title">insert</span>(<span class="hljs-params">value</span>)</span> &#123; <span class="hljs-comment">// 插入</span><span class="hljs-built_in">this</span>.heap.push(value); <span class="hljs-comment">// 插入到底部</span><span class="hljs-built_in">this</span>.shiftUp(<span class="hljs-built_in">this</span>.heap.length - <span class="hljs-number">1</span>); <span class="hljs-comment">// 上移</span>&#125;<span class="hljs-function"><span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 删除堆顶</span><span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>] = <span class="hljs-built_in">this</span>.heap.pop(); <span class="hljs-built_in">this</span>.shiftDown(<span class="hljs-number">0</span>); <span class="hljs-comment">// 下移</span>&#125;<span class="hljs-function"><span class="hljs-title">peek</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 获取堆顶</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-title">size</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 获取堆的大小</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap.length;&#125;<span class="hljs-comment">// 获取父节点</span><span class="hljs-function"><span class="hljs-title">getParentIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-comment">// return Math.floor((i - 1) / 2);</span><span class="hljs-keyword">return</span> (i - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 获取左侧子节点</span><span class="hljs-function"><span class="hljs-title">getLeftIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 获取右侧子节点</span><span class="hljs-function"><span class="hljs-title">getRightIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;&#125;<span class="hljs-comment">// 将两个节点的位置进行交换</span><span class="hljs-function"><span class="hljs-title">swap</span>(<span class="hljs-params">i1, i2</span>)</span> &#123;<span class="hljs-keyword">const</span> temp = <span class="hljs-built_in">this</span>.heap[i1];<span class="hljs-built_in">this</span>.heap[i1] = <span class="hljs-built_in">this</span>.heap[i2];<span class="hljs-built_in">this</span>.heap[i2] = temp;&#125;<span class="hljs-function"><span class="hljs-title">shiftUp</span>(<span class="hljs-params">index</span>)</span> &#123; <span class="hljs-comment">// 上移</span><span class="hljs-comment">// 递归的终点: 到达堆顶</span><span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">const</span> parentIndex = <span class="hljs-built_in">this</span>.getParentIndex(index);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.heap[parentIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[parentIndex].value &gt; <span class="hljs-built_in">this</span>.heap[index].value) &#123;<span class="hljs-built_in">this</span>.swap(parentIndex, index); <span class="hljs-comment">// 实现交换的方法</span><span class="hljs-built_in">this</span>.shiftUp(parentIndex); <span class="hljs-comment">// 如果还是需要上移，则递归</span>&#125;&#125;<span class="hljs-function"><span class="hljs-title">shiftDown</span>(<span class="hljs-params">index</span>)</span> &#123; <span class="hljs-comment">// 下移</span><span class="hljs-keyword">const</span> leftIndex = <span class="hljs-built_in">this</span>.getLeftIndex(index);<span class="hljs-keyword">const</span> rightIndex = <span class="hljs-built_in">this</span>.getRightIndex(index);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[leftIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[leftIndex].value &lt; <span class="hljs-built_in">this</span>.heap[index].value) &#123;<span class="hljs-built_in">this</span>.swap(leftIndex, index);<span class="hljs-built_in">this</span>.shiftDown(leftIndex);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[rightIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[rightIndex].value &lt; <span class="hljs-built_in">this</span>.heap[index].value) &#123;<span class="hljs-built_in">this</span>.swap(rightIndex, index);<span class="hljs-built_in">this</span>.shiftDown(rightIndex);&#125;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">解法二：</span><span class="hljs-comment">1、将输入的数组进行统计，得到每个元素出现次数的二维数组（二维数组的第一项是元素，第二项是元素出现的次数）</span><span class="hljs-comment">2、再将元素按照统计次数进行降序排列，数组的前K个就是所需要的结果</span><span class="hljs-comment">3、但是这个解法 不符合 题目时间复杂度的要求</span><span class="hljs-comment"></span><span class="hljs-comment">时间复杂度： </span><span class="hljs-comment">1、nums.forEach =&gt; O(n)</span><span class="hljs-comment">2、Array.sort =&gt; O(n log n)</span><span class="hljs-comment">所以结合起来， 时间复杂度 就是 O(n log n) ，不符合题目要求的 时间复杂度必须优于 O(n log n)</span><span class="hljs-comment">*/</span><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();nums.forEach(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> &#123;map.set(n, map.has(n) ? map.get(n) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);&#125;);<span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>.from(map).sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b[<span class="hljs-number">1</span>] - a[<span class="hljs-number">1</span>]);<span class="hljs-keyword">return</span> arr.slice(<span class="hljs-number">0</span>, k).map(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n[<span class="hljs-number">0</span>]);</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 3合并K个升序链表 23</span><span class="hljs-comment">// 给你一个链表数组，每个链表都已经按升序排列。</span><span class="hljs-comment">// 请你将所有链表合并到一个升序链表中，返回合并后的链表。</span><span class="hljs-comment">//  </span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><span class="hljs-comment">// 输出：[1,1,2,3,4,4,5,6]</span><span class="hljs-comment">// 解释：链表数组如下：</span><span class="hljs-comment">// [</span><span class="hljs-comment">//   1-&gt;4-&gt;5,</span><span class="hljs-comment">//   1-&gt;3-&gt;4,</span><span class="hljs-comment">//   2-&gt;6</span><span class="hljs-comment">// ]</span><span class="hljs-comment">// 将它们合并到一个有序链表中得到。</span><span class="hljs-comment">// 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：lists = []</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：lists = [[]]</span><span class="hljs-comment">// 输出：[]</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 时间复杂度： O(n) * logK // n是所有链表树的和，k是链表的数</span><span class="hljs-comment"> * 空间复杂度： O(k) // 中间遍历是 堆，堆的大小是K，k是链表的数</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> mergeKLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lists</span>) </span>&#123;<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<span class="hljs-keyword">let</span> p = res;<span class="hljs-keyword">const</span> h = <span class="hljs-keyword">new</span> MinHead();lists.forEach(<span class="hljs-function"><span class="hljs-params">l</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span>(l) h.insert(l);&#125;)<span class="hljs-keyword">while</span>(h.size()) &#123;<span class="hljs-keyword">const</span> n = h.pop(); <span class="hljs-comment">// 弹出堆顶（即lists中最小的那个链表节点）</span>p.next = n;p = p.next;<span class="hljs-keyword">if</span>(n.next) h.insert(n.next); <span class="hljs-comment">// 再把最小节点的下一个节点加到堆中</span>&#125;<span class="hljs-keyword">return</span> res.next;    &#125;;<span class="hljs-comment">// 构建一个最小堆（堆中的元素时 链表的节点）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinHead</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.heap = [];&#125;<span class="hljs-comment">// 插入方法</span><span class="hljs-function"><span class="hljs-title">insert</span>(<span class="hljs-params">value</span>)</span> &#123;<span class="hljs-built_in">this</span>.heap.push(value); <span class="hljs-comment">// 插入到底部</span><span class="hljs-built_in">this</span>.shiftUp(<span class="hljs-built_in">this</span>.heap.length - <span class="hljs-number">1</span>); <span class="hljs-comment">// 上移操作</span>&#125;<span class="hljs-function"><span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 删除堆顶</span><span class="hljs-comment">// 与原生的最小堆相比，需要做修改。 需要记住 top 的元素，并返回</span><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.size() === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap.shift();<span class="hljs-keyword">const</span> top = <span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 把原来heap中最末尾的推出来, 并赋值给堆顶</span><span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>] = <span class="hljs-built_in">this</span>.heap.pop();<span class="hljs-built_in">this</span>.shiftDown(<span class="hljs-number">0</span>); <span class="hljs-comment">// 下移操作</span><span class="hljs-keyword">return</span> top;&#125;<span class="hljs-comment">// 获取堆顶</span><span class="hljs-function"><span class="hljs-title">peek</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>];&#125;<span class="hljs-comment">// 获取堆的大小</span><span class="hljs-function"><span class="hljs-title">size</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap.length;&#125;<span class="hljs-comment">// 获取父节点</span><span class="hljs-function"><span class="hljs-title">getParentIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-comment">// 二进制操作，把二进制的数字右移一位</span><span class="hljs-comment">// return Math.floor((i - 1) / 2);</span><span class="hljs-keyword">return</span> (i - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 获取左侧子节点</span><span class="hljs-function"><span class="hljs-title">getLeftIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 获取右侧子节点</span><span class="hljs-function"><span class="hljs-title">getRightIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;&#125;<span class="hljs-comment">// 将两个节点的位置进行交换</span><span class="hljs-function"><span class="hljs-title">swap</span>(<span class="hljs-params">i1, i2</span>)</span> &#123;<span class="hljs-keyword">const</span> temp = <span class="hljs-built_in">this</span>.heap[i1];<span class="hljs-built_in">this</span>.heap[i1] = <span class="hljs-built_in">this</span>.heap[i2];<span class="hljs-built_in">this</span>.heap[i2] = temp;&#125;<span class="hljs-function"><span class="hljs-title">shiftUp</span>(<span class="hljs-params">index</span>)</span> &#123; <span class="hljs-comment">// 上移</span><span class="hljs-comment">// 递归的终点: 到达堆顶</span><span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">const</span> parentIndex = <span class="hljs-built_in">this</span>.getParentIndex(index);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.heap[parentIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[parentIndex].val &gt; <span class="hljs-built_in">this</span>.heap[index].val) &#123;<span class="hljs-built_in">this</span>.swap(parentIndex, index); <span class="hljs-comment">// 实现交换的方法</span><span class="hljs-built_in">this</span>.shiftUp(parentIndex); <span class="hljs-comment">// 如果还是需要上移，则递归</span>&#125;&#125;<span class="hljs-function"><span class="hljs-title">shiftDown</span>(<span class="hljs-params">index</span>)</span> &#123; <span class="hljs-comment">// 下移</span><span class="hljs-keyword">const</span> leftIndex = <span class="hljs-built_in">this</span>.getLeftIndex(index);<span class="hljs-keyword">const</span> rightIndex = <span class="hljs-built_in">this</span>.getRightIndex(index);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[leftIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[leftIndex].val &lt; <span class="hljs-built_in">this</span>.heap[index].val) &#123;<span class="hljs-built_in">this</span>.swap(leftIndex, index);<span class="hljs-built_in">this</span>.shiftDown(leftIndex);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[rightIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[rightIndex].val &lt; <span class="hljs-built_in">this</span>.heap[index].val) &#123;<span class="hljs-built_in">this</span>.swap(rightIndex, index);<span class="hljs-built_in">this</span>.shiftDown(rightIndex);&#125;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">解法二：</span><span class="hljs-comment">reduce，将链表数组中的每一个值放入新数组</span><span class="hljs-comment">sort，以链表的val作参考冒泡排序</span><span class="hljs-comment">reduceRight，从右向左遍历，将数组连成链表</span><span class="hljs-comment">*/</span><span class="hljs-keyword">var</span> mergeKLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lists</span>) </span>&#123;<span class="hljs-keyword">return</span> lists.reduce(<span class="hljs-function">(<span class="hljs-params">p, n</span>) =&gt;</span> &#123;<span class="hljs-keyword">while</span> (n) &#123;p.push(n), n = n.next&#125;<span class="hljs-keyword">return</span> p&#125;, []).sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.val - b.val).reduceRight(<span class="hljs-function">(<span class="hljs-params">p, n</span>) =&gt;</span> (n.next = p, p = n, p), <span class="hljs-literal">null</span>)&#125;;<span class="hljs-comment">/*</span><span class="hljs-comment">解法三：</span><span class="hljs-comment">*/</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * function ListNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.next = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode[]&#125;</span> <span class="hljs-variable">lists</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> mergeKLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lists</span>) </span>&#123;<span class="hljs-keyword">let</span> mergeTwoLists = <span class="hljs-function">(<span class="hljs-params">l1, l2</span>) =&gt;</span> &#123;<span class="hljs-keyword">let</span> preHead = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<span class="hljs-keyword">let</span> preNode = preHead;<span class="hljs-keyword">while</span>(l1 &amp;&amp; l2)&#123;<span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;preNode.next = l1;l1 = l1.next;&#125; <span class="hljs-keyword">else</span> &#123;preNode.next = l2;l2 = l2.next;&#125;preNode = preNode.next;&#125;preNode.next = l1 ? l1 : l2;<span class="hljs-keyword">return</span> preHead.next;&#125;<span class="hljs-keyword">let</span> n = lists.length;<span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-keyword">let</span> res = lists[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<span class="hljs-keyword">if</span>(lists[i])&#123;res = mergeTwoLists(res, lists[i]);&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre><h2 id="七-买卖股票"><a href="#七-买卖股票" class="headerlink" title="七 买卖股票"></a>七 买卖股票</h2><p>1 不限制交易次数，多次买卖一只股票<br>2 最多交易两次<br>3 可以交易k次<br>4 最佳买卖股票时机含冷冻期<br>5 买卖股票的最佳时机含手续费</p><pre><code class="hljs javaScript"><span class="hljs-comment">// 1 买卖股票的最佳时机 II 122</span><span class="hljs-comment">// 给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。</span><span class="hljs-comment">// 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</span><span class="hljs-comment">// 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 输入: prices = [7,1,5,3,6,4]</span><span class="hljs-comment">// 输出: 7</span><span class="hljs-comment">// 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><span class="hljs-comment">//      随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><span class="hljs-comment">// 示例 2:</span><span class="hljs-comment">// 输入: prices = [1,2,3,4,5]</span><span class="hljs-comment">// 输出: 4</span><span class="hljs-comment">// 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><span class="hljs-comment">//      注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><span class="hljs-comment">// 示例 3:</span><span class="hljs-comment">// 输入: prices = [7,6,4,3,1]</span><span class="hljs-comment">// 输出: 0</span><span class="hljs-comment">// 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;<span class="hljs-comment">// 解法一: 统计找到最大利润</span><span class="hljs-comment">// var min = prices[0];</span><span class="hljs-comment">// var resArr = [];</span><span class="hljs-comment">// var tem = 0;</span><span class="hljs-comment">// for (let i = 1 ; i &lt; prices.length ; i++) &#123;</span><span class="hljs-comment">//     if (prices[i] &gt; prices[i - 1]) &#123;</span><span class="hljs-comment">//         tem = prices[i] - min</span><span class="hljs-comment">//         if (i === prices.length - 1) &#123;</span><span class="hljs-comment">//             resArr.push(tem)</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//     &#125; else &#123;</span><span class="hljs-comment">//         resArr.push(tem)</span><span class="hljs-comment">//         min = prices[i];</span><span class="hljs-comment">//         tem = 0</span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// return resArr.reduce((x, y) =&gt; &#123;</span><span class="hljs-comment">//     return x + y</span><span class="hljs-comment">// &#125;, 0)</span><span class="hljs-comment">// 解法二：贪心算法，只要有利润就赚</span><span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;<span class="hljs-keyword">if</span>(prices[i] &gt; prices[i - <span class="hljs-number">1</span>]) &#123;res += prices[i] - prices[i - <span class="hljs-number">1</span>];&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 2 买卖股票的最佳时机 III 123</span><span class="hljs-comment">// 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</span><span class="hljs-comment">// 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</span><span class="hljs-comment">// 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 输入：prices = [3,3,5,0,0,3,1,4]</span><span class="hljs-comment">// 输出：6</span><span class="hljs-comment">// 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。</span><span class="hljs-comment">//      随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：prices = [1,2,3,4,5]</span><span class="hljs-comment">// 输出：4</span><span class="hljs-comment">// 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   </span><span class="hljs-comment">//      注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span><span class="hljs-comment">//      因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><span class="hljs-comment">// 示例 3：</span><span class="hljs-comment">// 输入：prices = [7,6,4,3,1] </span><span class="hljs-comment">// 输出：0 </span><span class="hljs-comment">// 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</span><span class="hljs-comment">// 示例 4：</span><span class="hljs-comment">// 输入：prices = [1]</span><span class="hljs-comment">// 输出：0]</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">prices</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;<span class="hljs-keyword">if</span>(prices.length === <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// 第一次 买入， 卖出的利润</span><span class="hljs-keyword">let</span> firIn = -prices[<span class="hljs-number">0</span>];<span class="hljs-keyword">let</span> firOut = <span class="hljs-number">0</span>;<span class="hljs-comment">// 继第一次之后，第二次买入卖出的利润</span><span class="hljs-keyword">let</span> secIn = -prices[<span class="hljs-number">0</span>];<span class="hljs-keyword">let</span> secOut = <span class="hljs-number">0</span>;<span class="hljs-comment">// 卖出时利润：求最大值（上次交易卖出时利润，本次交易卖出时利润）</span><span class="hljs-comment">// 买入时利润：求最大值（上次买入时利润，本次买入时利润）</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;secOut = <span class="hljs-built_in">Math</span>.max(secOut, secIn + prices[i]);<span class="hljs-comment">// 第二次买入后的利润: 第一次卖出的利润 - prices[i]</span>secIn = <span class="hljs-built_in">Math</span>.max(secIn, firOut - prices[i]);firOut = <span class="hljs-built_in">Math</span>.max(firOut, firIn + prices[i]);<span class="hljs-comment">// 第一次买入后: 利润为 -prices[i]</span>firIn = <span class="hljs-built_in">Math</span>.max(firIn, -prices[i]);&#125;<span class="hljs-keyword">return</span> secOut&#125;;<span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;<span class="hljs-keyword">if</span> (prices.length === <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">let</span> firIn = -prices[<span class="hljs-number">0</span>];<span class="hljs-keyword">let</span> firOut = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> secIn = -prices[<span class="hljs-number">0</span>];<span class="hljs-keyword">let</span> secOut = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;<span class="hljs-comment">// 第1次交易前 分支：什么都不做 或 买入 → 第1次交易后</span>firIn = <span class="hljs-built_in">Math</span>.max(firIn, -prices[i]);<span class="hljs-comment">// 第1次交易后 分支：什么都不做 或 卖出 → 第2次交易前</span>firOut = <span class="hljs-built_in">Math</span>.max(firOut, firIn + prices[i]);<span class="hljs-comment">// 第2次交易前 分支：什么都不做 或 买入 → 第2次交易后</span>secIn = <span class="hljs-built_in">Math</span>.max(secIn, firOut - prices[i]);<span class="hljs-comment">// 第2次交易后 分支：什么都不做 或 卖出 → 第3次交易前</span>secOut = <span class="hljs-built_in">Math</span>.max(secOut, secIn + prices[i]);&#125;<span class="hljs-keyword">return</span> secOut&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 3 买卖股票的最佳时机 IV 188</span><span class="hljs-comment">// 给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</span><span class="hljs-comment">// 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</span><span class="hljs-comment">// 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><span class="hljs-comment">// 示例 1：</span><span class="hljs-comment">// 输入：k = 2, prices = [2,4,1]</span><span class="hljs-comment">// 输出：2</span><span class="hljs-comment">// 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</span><span class="hljs-comment">// 示例 2：</span><span class="hljs-comment">// 输入：k = 2, prices = [3,2,6,5,0,3]</span><span class="hljs-comment">// 输出：7</span><span class="hljs-comment">// 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。</span><span class="hljs-comment">//      随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</span><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k, prices</span>) </span>&#123;<span class="hljs-keyword">let</span> n = prices.length;<span class="hljs-keyword">if</span> (k &gt; n / <span class="hljs-number">2</span>) &#123;k = <span class="hljs-built_in">Math</span>.floor(n / <span class="hljs-number">2</span>);&#125;<span class="hljs-comment">// 记录每次交易的利润</span><span class="hljs-keyword">let</span> profit = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(k);<span class="hljs-comment">//初始化买入卖出时的利润</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt;= k; j++)&#123;profit[j] = &#123;<span class="hljs-keyword">in</span>: -prices[<span class="hljs-number">0</span>],out: <span class="hljs-number">0</span>&#125;;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= k; j++)&#123;profit[j] = &#123;out: <span class="hljs-built_in">Math</span>.max(profit[j].out, profit[j].in + prices[i]), <span class="hljs-keyword">in</span>: <span class="hljs-built_in">Math</span>.max(profit[j].in, profit[j - <span class="hljs-number">1</span>].out - prices[i])&#125;&#125;&#125;<span class="hljs-keyword">return</span> profit[k].out;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 4 最佳买卖股票时机含冷冻期 309</span><span class="hljs-comment">// 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</span><span class="hljs-comment">// 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</span><span class="hljs-comment">// 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><span class="hljs-comment">// 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</span><span class="hljs-comment">// 示例:</span><span class="hljs-comment">// 输入: [1,2,3,0,2]</span><span class="hljs-comment">// 输出: 3 </span><span class="hljs-comment">// 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;<span class="hljs-keyword">let</span> n = prices.length;<span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">let</span> dp = <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n),<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">2</span>));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)&#123;dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[i];<span class="hljs-keyword">continue</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) &#123;dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">Math</span>.max(dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]+prices[i]);dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">Math</span>.max(dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], - prices[i]);<span class="hljs-keyword">continue</span>;&#125; <span class="hljs-keyword">else</span> &#123;dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">Math</span>.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">Math</span>.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] - prices[i]);&#125;&#125;<span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];&#125;;<span class="hljs-comment">// 解法二</span><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;<span class="hljs-keyword">if</span>(prices.length == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">let</span> inProfit = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> outProfit = -<span class="hljs-literal">Infinity</span>;<span class="hljs-keyword">let</span> pre = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i++)&#123;<span class="hljs-keyword">let</span> tmp = inProfit;inProfit = <span class="hljs-built_in">Math</span>.max(inProfit, outProfit + prices[i]);outProfit = <span class="hljs-built_in">Math</span>.max(outProfit, pre - prices[i]);pre = tmp;&#125;<span class="hljs-keyword">return</span> inProfit;&#125;;</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// 5 买卖股票的最佳时机含手续费 714</span><span class="hljs-comment">// 给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；</span><span class="hljs-comment">// 非负整数 fee 代表了交易股票的手续费用。</span><span class="hljs-comment">// 你可以无限次地完成交易，但是你每笔交易都需要付手续费。</span><span class="hljs-comment">// 如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</span><span class="hljs-comment">// 返回获得利润的最大值。</span><span class="hljs-comment">// 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</span><span class="hljs-comment">// 示例 1:</span><span class="hljs-comment">// 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2</span><span class="hljs-comment">// 输出: 8</span><span class="hljs-comment">// 解释: 能够达到的最大利润:  </span><span class="hljs-comment">// 在此处买入 prices[0] = 1</span><span class="hljs-comment">// 在此处卖出 prices[3] = 8</span><span class="hljs-comment">// 在此处买入 prices[4] = 4</span><span class="hljs-comment">// 在此处卖出 prices[5] = 9</span><span class="hljs-comment">// 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</span><span class="hljs-comment">// 解法一 动态规划</span><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee</span>) </span>&#123;<span class="hljs-keyword">const</span> dp = [<span class="hljs-number">0</span>, -prices[<span class="hljs-number">0</span>]];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>, t; i &lt; prices.length; i++) &#123;t = dp[<span class="hljs-number">0</span>] <span class="hljs-comment">// 中间变量可省略，因为当天买入卖出不影响结果</span>dp[<span class="hljs-number">0</span>] = <span class="hljs-built_in">Math</span>.max(dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>] + prices[i] - fee)dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">Math</span>.max(dp[<span class="hljs-number">1</span>], t - prices[i])&#125;<span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>] <span class="hljs-comment">// 最后一天，无股票 利润 &gt; 有股票时 利润</span>&#125;;<span class="hljs-comment">// 解法二：动态规划</span><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee</span>) </span>&#123;<span class="hljs-comment">// 初始利润</span><span class="hljs-keyword">var</span> getIn = <span class="hljs-number">0</span> - prices[<span class="hljs-number">0</span>];<span class="hljs-keyword">var</span> getOut = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++)&#123;<span class="hljs-comment">// 卖出： 当前买入状态时的利润 + 卖出的股票 - 手续费</span>getOut = <span class="hljs-built_in">Math</span>.max(getOut, getIn + prices[i] - fee); <span class="hljs-comment">//买入： 当前卖出时的利润 - 买进的股票</span>getIn = <span class="hljs-built_in">Math</span>.max(getIn, getOut - prices[i]);     &#125;<span class="hljs-keyword">return</span> getOut;&#125;;<span class="hljs-comment">// 解法三：贪心算法</span><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee</span>) </span>&#123;<span class="hljs-keyword">let</span> min = prices[<span class="hljs-number">0</span>];<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(i &lt; prices.length) &#123;<span class="hljs-keyword">let</span> profit;<span class="hljs-keyword">if</span> (prices[i] &lt; min) &#123;min = prices[i];&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((profit = prices[i] - min - fee) &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 两种情况：</span><span class="hljs-comment">// 1 无股票时：profit = 今天价格 - 最低买入价格min - 手续费 &gt; 0，即有利润就卖</span><span class="hljs-comment">// 2 有股票时：今天价格大于昨天价格。改今天卖。手续费昨天扣过，不再扣</span><span class="hljs-comment">//profit = pricep[i] - price[i - 1] = price[i] - (prices[i-1] - fee) - fee</span><span class="hljs-comment">//    profit = 昨天利润 + 今天价格 - 新最低买入价格 - 手续费</span><span class="hljs-comment">//     = 昨天利润 + 今天价格 - （昨天价格 - 手续费） - 手续费</span><span class="hljs-comment">//     = 昨天利润 + 今天价格 - 昨天价格</span>res += profit;min = prices[i] - fee;&#125;i++;&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre><h2 id="八-算法总结"><a href="#八-算法总结" class="headerlink" title="八 算法总结"></a>八 算法总结</h2><h3 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h3><p>分而治之是将一个问题<strong>分</strong>成多个和原问题相似的小问题，通过<strong>递归</strong>解决这些小问题，再将小问题的结果<strong>合并</strong>以解决原来的问题。</p><p>例题：反转二叉树、相同的树</p><p>场景一： 归并排序</p><ul><li>分：先把数组从中间一分为二</li><li>解：递归的对两个子数组进行归并排序</li><li>合：合并有序子数组</li></ul><p>场景二： 快速排序</p><ul><li>分：选基准，按基准把数组分成两个子数组</li><li>解：递归的对两个子数组进行快速排序</li><li>合：对两个子数组进行合并</li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动态规划是将一个问题分解为<strong>相互重叠</strong>的子问题，通过反复求解子问题，来解决原来的问题。</p><p>例题：斐波那契数列、连续子数组的最大和</p><p><strong>动态规划</strong> 与 <strong>分而治之</strong> 的区别：</p><ul><li>动态规划: 它们的子问题是<strong>相互重叠</strong>的</li><li>分而治之: 它们的子问题是<strong>完全独立</strong>的</li></ul><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><p>回溯算法是一种<strong>渐进式</strong>寻找并构建问题解决方式的策略<br>回溯算法会先从一个可能的动作开始解决问题，如果不行，就回溯并选择另一个动作，直到将问题解决</p><p>例题：数组子集的全排列</p><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>期盼通过每个阶段的<strong>局部最优</strong>选择，从而达到全局的最优<br>结果并<strong>一定是最优</strong></p><p>例题：分发饼干、买卖股票的最佳时机</p>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打印结果</title>
    <link href="/2021/02/25/interview/js-consoleRes/"/>
    <url>/2021/02/25/interview/js-consoleRes/</url>
    
    <content type="html"><![CDATA[<h3 id="1-打印结果-Object再次赋值"><a href="#1-打印结果-Object再次赋值" class="headerlink" title="1. 打印结果 (Object再次赋值)"></a>1. 打印结果 (Object再次赋值)</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeObjProperty</span>(<span class="hljs-params">o</span>) </span>&#123;    o.siteUrl = <span class="hljs-string">&quot;http://www.baidu.com&quot;</span>;    o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();    o.siteUrl = <span class="hljs-string">&quot;http://www.google.com&quot;</span>;&#125;<span class="hljs-keyword">let</span> webSite = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();changeObjProperty(webSite);<span class="hljs-built_in">console</span>.log(webSite.siteUrl);</code></pre><p>解答: <code>webSite</code> 属于复合数据类型，函数参数中以地址传递，修改值会影响到原始值， 但如果将其完全替换成另一个值，则原来的值不会受到影响.<br>因为当执行到 <code>o = new Object();</code> 时，相当于执行 <code>var o = new Object();</code>，即从新定义了一个对象，函数参数传递的对象不受影响。 因此打印结果是<code>&quot;http://www.baidu.com&quot;</code>;</p><h3 id="2-执行结果"><a href="#2-执行结果" class="headerlink" title="2. 执行结果"></a>2. 执行结果</h3><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> a = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">3</span> &#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">obj</span>) </span>&#123;    obj.b = <span class="hljs-number">5</span>;    <span class="hljs-keyword">return</span> obj;&#125;<span class="hljs-keyword">const</span> aa = foo(a);<span class="hljs-built_in">console</span>.log(a.b);<span class="hljs-built_in">console</span>.log(aa.b);<span class="hljs-built_in">console</span>.log(a === aa);</code></pre><p>解答:  函数参数中以地址传递，修改值会影响到原始值, 因此 a 与 aa 都指向同一个对象</p><h3 id="3-执行结果"><a href="#3-执行结果" class="headerlink" title="3. 执行结果"></a>3. 执行结果</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Ofo</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Bick</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;mybick&#x27;</span>;&#125;<span class="hljs-keyword">var</span> m1 = <span class="hljs-keyword">new</span> Ofo();Ofo.prototype = <span class="hljs-keyword">new</span> Bick();<span class="hljs-keyword">var</span> m2 = <span class="hljs-keyword">new</span> Bick();<span class="hljs-keyword">var</span> m3 = <span class="hljs-keyword">new</span> Ofo();<span class="hljs-built_in">console</span>.log(m1.name);<span class="hljs-built_in">console</span>.log(m2.name);<span class="hljs-built_in">console</span>.log(m3.name);</code></pre><p>解答:<br>m1 = new Ofo() =&gt; m1.construetor = function Ofo() {}, 因此 m1.name = undefined<br>m2 = new Bick() =&gt; m1.construetor = function Bick() { this.name = ‘mybick’}, 因此 m2.name = ‘mybick’<br>m3 = new Ofo() =&gt; 由于 Ofo.prototype = new Bick(), 因此 m3.<strong>proto</strong> = Bink {name: ‘mybick’}, m3.name = ‘mybick’</p><h3 id="4-执行结果"><a href="#4-执行结果" class="headerlink" title="4. 执行结果"></a>4. 执行结果</h3><pre><code class="hljs javaScript"><span class="hljs-meta">&#x27;use strict&#x27;</span><span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.x = <span class="hljs-number">3</span>;&#125;<span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x); &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.x = <span class="hljs-number">4</span>;&#125;method = <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x); &#125;&#125;<span class="hljs-keyword">const</span> a = &#123; x: <span class="hljs-number">1</span>,<span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x); &#125;&#125;<span class="hljs-keyword">const</span> b = &#123;x: <span class="hljs-number">2</span>,<span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x); &#125;&#125;<span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> C();<span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> D();<span class="hljs-keyword">const</span> e = &#123;x: <span class="hljs-number">5</span>,<span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-built_in">console</span>.log(x); &#125;&#125;a.method();b.method = a.method;b.method();<span class="hljs-keyword">const</span> fc = c.method.bind(a);fc();<span class="hljs-keyword">const</span> fd = d.method.bind(a);fd();<span class="hljs-keyword">const</span> fe = e.method.bind(a);fe();</code></pre><p>解答： 1 2 1 4 0</p><h3 id="5-执行结果"><a href="#5-执行结果" class="headerlink" title="5. 执行结果"></a>5. 执行结果</h3><pre><code class="hljs javaScript">fun();<span class="hljs-keyword">var</span> fun;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">var</span> fun = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);&#125;fun();</code></pre><p>解答： 1 2</p><h3 id="6-执行结果"><a href="#6-执行结果" class="headerlink" title="6. 执行结果"></a>6. 执行结果</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Page</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.hosts;&#125;Page.hosts = [<span class="hljs-string">&#x27;h1&#x27;</span>];Page.prototype.hosts = [<span class="hljs-string">&#x27;h2&#x27;</span>];<span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> Page();<span class="hljs-keyword">var</span> p2 = Page();<span class="hljs-built_in">console</span>.log(p1.hosts);<span class="hljs-built_in">console</span>.log(p2.hosts);</code></pre><p>p1: new 的时候首先判断构造函数是否有返回值<br>  如果返回值是 Object Array Function，则实例对象就是这个返回对象.<br>  因此 var p1 = new Page() 时，Page构造函数返回的是 this.hosts<br>  构造函数没有 hosts，沿着原型链找到了 [‘h2’], 因此 p1 = [‘h2’]<br>  结论是：p1 = [‘h2’], p1.hosts = undefined<br>p2: p2 = Page() = this.hosts, 此时this = window<br>  因此 p2 = p2 = Page() = this.hosts = undefined<br>  结论是：p2 = undefined, p2.hosts = Uncaught TypeError: Cannot read property ‘hosts’ of undefined</p><h3 id="7-执行结果"><a href="#7-执行结果" class="headerlink" title="7. 执行结果"></a>7. 执行结果</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params"></span>) </span>&#123;    getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;&#125;foo.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);&#125;foo.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);&#125;<span class="hljs-keyword">var</span> getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>);&#125;foo.getName();getName();foo().getName();getName();<span class="hljs-keyword">new</span> foo().getName();<span class="hljs-keyword">new</span> <span class="hljs-keyword">new</span> foo().getName();</code></pre><p>题解：</p><ol><li>foo.getName(): 给 function foo 赋值了一个属性,该属性的key是 getName, value是一个function(){console.log(2)}<br>因此 执行结果是 2</li><li>getName(): 这里由于遍历提升, var getName = function() { console.log(4)} 比 function getName () {console.log(5) } 后提升<br>因此最后执行的是 var getName = function() { console.log(4)}, 执行结果是 4</li><li>foo().getName(): 执行了foo(), 该函数中的getName 没有用 var/let/const 定义，因此是覆盖了全局的 getName 方法<br>此时全局的 getName = function(){console.log(1)}, 因此执行结果是 1</li><li>getName(): 经过foo().getName()之后，全局的 getName 已经被覆盖，因此执行结果是 1</li><li>new foo().getName(): new foo() 返回一个空的实例对象, 执行该对象的getName() 需要沿着原型链查找<br>因此执行了 foo.prototype.getName = function () {console.log(3)}, 执行结果是 3</li><li>new new foo().getName(): 这一部比较复杂，需要拆分为3步<ol><li>执行 new foo() —— 返回一个foo构造函数的实例对象(空对象)，并且该实例对象的原型链上有个属性 foo.prototype.getName = function () {console.log(3)}</li><li>执行 new foo().getName —— 返回该实例对象原型链上的getName属性: function () {console.log(3)}</li><li>执行 new new foo().getName() —— 等同于 new function () {console.log(3)}, 返回该构造函数的实例对象(一个空对象)，但是却执行了 console.log(3), <strong>因此输出 3</strong></li></ol></li></ol><h3 id="8-执行结果"><a href="#8-执行结果" class="headerlink" title="8. 执行结果"></a>8. 执行结果</h3><pre><code class="hljs javaScript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>)<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);<span class="hljs-keyword">await</span> async2()<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>);&#125;async1()<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5 - setTimeOut&#x27;</span>)&#125;, <span class="hljs-number">0</span>)requestAnimationFrame(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;10&#x27;</span>));requestIdleCallback(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;11&#x27;</span>));<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;6&#x27;</span>)resolve()&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;7&#x27;</span>)&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;8&#x27;</span>)&#125;)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;12&#x27;</span>)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;13&#x27;</span>)&#125;, <span class="hljs-number">0</span>)<span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;14&#x27;</span>))&#125;, <span class="hljs-number">0</span>)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;9&#x27;</span>)<span class="hljs-comment">// 1 2 4 6 9 3 7 8 undefined 10 5 12 14 11 13</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>js</tag>
      
      <tag>consoleResult</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React step 1 —— React初级使用</title>
    <link href="/2021/02/19/%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%B8%B8%E8%A7%81web%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E8%A7%A3%E6%9E%90/"/>
    <url>/2021/02/19/%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%B8%B8%E8%A7%81web%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="一、XSS"><a href="#一、XSS" class="headerlink" title="一、XSS"></a>一、XSS</h2><p><code>XSS（Cross-site Scripting）</code>，跨站脚本攻击是指通过存在安全漏洞的web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。<br>XSS的原理是恶意攻击者通过向Web页面插入恶意可执行的网页脚本代码，当用户浏览该页时，嵌入其Web里面的脚本代码会被执行，从而达到窃取用户信息或侵犯用户安全隐私的目的。</p><p>XSS的攻击方式大致分为非持久型XSS（反射型XSS）和持久型XSS（存储型XSS）</p><h3 id="1-反射型XSS-非持久型XSS"><a href="#1-反射型XSS-非持久型XSS" class="headerlink" title="(1) 反射型XSS (非持久型XSS)"></a>(1) 反射型XSS (非持久型XSS)</h3><p>反射型XSS 一般是通过给别人发送带有恶意脚本代码参数的URL，当URL地址被打开时，特有的恶意代码参数会被HTML解析并执行。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 攻击方式一： 通过执行URL上注入的脚本，盗取用户敏感信息：</span><span class="hljs-comment">// 比如：通过UTL  `https://xxx.com/xxx?default=&lt;script&gt;alert(document.cookie)&lt;/script&gt;` </span><span class="hljs-comment">// 注入可执行的脚本代码, 获取用户的cookie</span><span class="hljs-comment">// 攻击方式二：通过用户请求 注入在URL上的链接，将攻击者提供的脚本将在用户的浏览器中执行：</span><span class="hljs-comment">// 某网站具有搜索功能，该功能通过 URL 参数接收用户提供的搜索词：</span><span class="hljs-comment">// https: //xxx.com/search?query=123</span><span class="hljs-comment">// 服务器在对此 URL 的响应中回显提供的搜索词：</span><span class="hljs-comment">// &lt;p&gt;您搜索的是: 123&lt;/p&gt;</span><span class="hljs-comment">// 如果服务器不对数据进行转义等处理，则攻击者可以构造如下链接进行攻击：</span><span class="hljs-comment">// https://xxx.com/search?query=&lt;img src=&quot;empty.png&quot; onerror =&quot;alert(&#x27;xss&#x27;)&quot;&gt;</span><span class="hljs-comment">// 该 URL 将导致以下响应，并运行 alert(&#x27;xss&#x27;)：</span><span class="hljs-comment">// &lt;p&gt;您搜索的是: &lt;img src=&quot;empty.png&quot; onerror =&quot;alert(&#x27;xss&#x27;)&quot;&gt;&lt;/p&gt;</span><span class="hljs-comment">// 如果有用户请求攻击者的 URL ，则攻击者提供的脚本将在用户的浏览器中执行。</span></code></pre><p>不过大部分的浏览器如Chrome内置了一些XSS过滤器，可以防止大部分的反射型XSS攻击。</p><p>非持久性XSS有以下几个特征：</p><ul><li>XSS 脚本来自当前 HTTP 请求，不经过服务器存储，直接通过一次HTTP的请求完成攻击</li><li>攻击者需要诱骗用户点击链接才能发起攻击</li></ul><h3 id="2-持久型XSS（存储型XSS）"><a href="#2-持久型XSS（存储型XSS）" class="headerlink" title="(2)持久型XSS（存储型XSS）"></a>(2)持久型XSS（存储型XSS）</h3><p>持久型XSS（存储型XSS）一般存在于form表单提交等交互功能，如文章留言、评论、提交文本信息等，攻击者将带有可执行的HTML代码或script代码通过表单内容经正常功能提交进入数据库持久保存，当前端页面通过后端从数据库读出注入的代码时，浏览器恰好将其渲染执行。<br>持久型XSS（存储型XSS）不需要诱骗点击，只需要在提交表单的地方完成注入即可，但是这种XSS攻击的成本相对还是很高。</p><p>攻击成功需要满足以下几点：</p><ul><li>POST请求提交表单后端没有做转义直接入库</li><li>后端从数据库取出数据后没做转义直接输出给前端</li><li>前端拿到后端的数据没做转义直接渲染成 DOM</li></ul><h3 id="3-如何防御-XSS"><a href="#3-如何防御-XSS" class="headerlink" title="(3) 如何防御 XSS"></a>(3) 如何防御 XSS</h3><ul><li><p>服务端防御措施：</p><p>  1）CSP</p><p>  CSP的本质上是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配合规则，如何拦截是由浏览器自己实现的。</p><p>  通常可以通过两种方式开启CSP：</p><p>  1.设置 HTTP的Header中Content-Security-Policy<br>  2.设置meta标签的方式</p><p>  比如设置HTTP Header：</p>  <pre><code class="hljs text">// 只允许加载本站资源Content-Security-Policy: default-src &#x27;self&#x27;// 只允许加载HTTPS协议图片Content-Security-Policy: img-src https://* // 允许加载任何来源框架Content-Security-Policy: child-src &#x27;none&#x27;</code></pre><p>  对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行他的攻击代码，并且CSP的兼容性也很好。</p><p>  2）转义字符</p><p>  用户的输入永远不可信任，最普遍的做法是转义输入输出内容，对引号、尖括号、斜杠进行转义。</p>  <pre><code class="hljs javascript">str.replace(<span class="hljs-regexp">/&gt;/g</span>, <span class="hljs-string">&#x27;&amp;gt;&#x27;</span>)str.replace(<span class="hljs-regexp">/&lt;/g</span>), <span class="hljs-string">&#x27;$lt;&#x27;</span>)<span class="hljs-comment">// 但是对于显示富文本来说，不能通过上面的方法转义所有字符，因为这样会把需要的格式也过滤掉。</span><span class="hljs-comment">// 这是需要通过白名单过滤的方法（黑名单也可以，但是需要过滤的的标签和标签属性太多，推荐使用白名单）</span><span class="hljs-comment">// 实例用js-xss来实现</span><span class="hljs-keyword">const</span> jsXSs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;xss&#x27;</span>)<span class="hljs-keyword">let</span> html = jsXss(<span class="hljs-string">&#x27;&lt;h1 id=&#x27;</span>title<span class="hljs-string">&#x27;&gt;XSS Code&lt;/h1&gt;&lt;script&gt;alert(&#x27;</span>xss<span class="hljs-string">&#x27;)&lt;/script&gt;&#x27;</span>)</code></pre><p>  3）httpOnly cookie<br>  这是预防xss攻击最有效的防御手段，可以避免网页的cookie被JavaScript代码恶意窃取。</p></li><li><p>非持久型XSS防御措施：</p><ul><li>Web 页面渲染的所有内容和和渲染的所有数据必须来自服务端</li><li>尽量不要从URL、document.referrer（上一个页面的URL）、document.forms等这种DOM API中获取数据直接渲染</li><li>尽量不要使用eval、new Function()、document.write()、innerHTML、window.setTimeout、document.createElement()等可执行字符串的方法</li><li>如果做不到以上几点，也必须对涉及DOM渲染的方法传入的字符串参数做escape转义</li><li>前端渲染的时候对任何的字段都需要做escape转义编码</li></ul></li></ul><h2 id="二、CSRF"><a href="#二、CSRF" class="headerlink" title="二、CSRF"></a>二、CSRF</h2><p><code>CSRF（Cross Site Request Forgery）</code> 即跨站伪造请求，是一种常见的web攻击。它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。</p><p>完成CSRF需要满足三个条件：</p><ul><li>1)用户已经登录了站点A，并在本地记录了cookie</li><li>2)用户在没有登出站点A的情况下（也就是Cookie生效的情况下），从该网站访问了恶意攻击者提供的引诱危险站点B（B站点要求访问站点A）</li><li>3)站点A没有做任何CSRF攻击</li></ul><p>防范CSRF攻击可以遵循以下几种原则：</p><ul><li>Get请求不对数据进行修改</li><li>不让第三方网站访问用户cookie</li><li>阻止第三方网站请求接口</li><li>请求时附带验证信息，比如验证码或者token</li></ul><p>如何防御：</p><ul><li><p>1）SameSite<br>可以对Cookie设置SameSite属性。该属性表示Cookie不能随着跨域请求发送，可以很大程度上减少CSRF攻击，但是该属性不是所有浏览器都兼容。</p></li><li><p>2）Referer Check<br>HTTP Referer 是header的一部分，当浏览器向web服务器发送请求时，一般会带上Referer信息告诉服务器是从哪个页面链接过来的，用来获取请求者的信息。<br>服务器可以通过检查请求者的来源来防御CSRF攻击。通过检查HTTP包中的头Referer的值是不是这个页面，来判断是不是CSRF攻击。<br>但是某些情况下，如从https跳转到http，浏览器处于安全考虑，不会发送referer，此时服务器就无法check了，因此不能完全依赖Referer Check作为防御CSRF的主要手段。</p></li><li><p>3）Anti CSRF Token<br>Token可以在用户登陆后产生并存在session或cookie中，然后每次    请求时，服务器验证token的有效性和真实性。由于token的存在，攻击者无法再构造出一个完整的 URL实施CSRF攻击。</p></li><li><p>4）验证码<br>应用程序与用户交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成请求。验证码可以很好的遏制CSRF攻击，但是验证码降低了用户体验，只能在关键业务点设置验证码。</p></li></ul><h2 id="三、SQL注入"><a href="#三、SQL注入" class="headerlink" title="三、SQL注入"></a>三、SQL注入</h2><p>一次SQL注入包括以下几个过程：</p><ul><li>获取用户请求参数</li><li>拼接到代码中</li><li>SQL语句按照我们构造参数的语义执行成功</li></ul><p>SQL注入必备的条件：1、可以控制输入的数据；2、服务器要执行的代码拼接了控制的数据。<br>SQL注入的本质是：数据和代码未分离，即数据当作代码来执行。</p><p>如何防御：</p><ul><li>1）严格限制Web应用的数据库的操作权限；</li><li>2）后台代码检查输入的数据是否符合预期；</li><li>3）对进入数据库的特殊字符（如*&lt;&gt;&amp;|等）进行转义处理，或编码转换；</li><li>4）所有的检查语句建议使用数据库提供的参数化查询接口，即不要直接拼接SQL语句</li></ul><h2 id="四、OS命令注入攻击"><a href="#四、OS命令注入攻击" class="headerlink" title="四、OS命令注入攻击"></a>四、OS命令注入攻击</h2><p>OS命令注入与 SQL注入差不多，只不过OS命令注入是针对操作系统的。<br>OS命令注入攻击是指通过web应用，执行非法的操作系统命令达到攻击的目的，只要能调用shell函数的地方就存在被攻击的风险。<br>比如：黑客构造命令提交到web应用程序，web应用程序提取命令并且拼接到被执行的命令中，因黑客构造的命令打破了原有命令结构，导致web应用执行了黑客构造的命令。</p><p>如何防御：</p><ul><li>1）后端对前端提交内容进行规则检查（比如正则表达式）</li><li>2）在调用系统命令前对所有传入参数进行转义过滤</li><li>3）不要直接拼接命令语句，借助一些工具做拼接、转义处理，例如NodeJS的 shell-escape npm包</li></ul><h2 id="五、点击劫持"><a href="#五、点击劫持" class="headerlink" title="五、点击劫持"></a>五、点击劫持</h2><p>点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过iframe嵌套的方式嵌入自己的网页中，并将iframe设置为透明，在页面中透出一个按钮诱惑用户点击。  </p><p>特点：</p><ul><li>隐蔽性高，骗取用户操作</li><li>UI-覆盖攻击</li><li>利用iframe或其他标签的属性</li></ul><p>如何防御：</p><ul><li><p>1）X-Frame-Options<br>X-Frame-Options是一个Http相应头，这个相应头就是为了防御iframe嵌套的点击劫持攻击，在现在浏览器中有一个很好的支持。<br>X-Frame-Options有3个值可选：</p><ul><li>Deny：表示页面不允许通过iframe的方式展示</li><li>SameOrion：表示页面允许通过相同的域名下通过iframe的方式展示</li><li>AllowFrom：表示页面可以在指定来源的iframe中展示</li></ul></li><li><p>2）JavaScript防御<br>对于不支持X-Frame-Options的远古浏览器来说，只能通过JS的方式来防御点击劫持了。</p></li></ul><h2 id="六、URL跳转漏洞"><a href="#六、URL跳转漏洞" class="headerlink" title="六、URL跳转漏洞"></a>六、URL跳转漏洞</h2><p>借助未验证的URL跳转，将应用程序引导到不安全的第三方区域，从而导致安全问题。<br>其原理是黑客构造恶意链接（链接需要进行伪装，尽可能迷惑），发布到QQ群或者贴吧、论坛中，当用户点击后经过服务器或者浏览器解析后，跳转到恶意的网站中。<br>恶意链接一般是在熟悉的链接后面加上一个恶意的网站，这样才能迷惑用户。<br>一般通过Header头跳转、JavaScript跳转、META标签跳转等方式实现。</p><p>例如：<br><code>http://www.baidu.com?act=go&amp;url=http://t.cn/RVTatrd</code><br><code>http://www.qq.com?flag=1&amp; jumpTo=http://t.cn/RVTatrd</code><br><code>http://www.taobao.com?jumpUrl= http://t.cn/RVTatrd</code></p><p>如何防御：</p><ul><li><p>1）Referer限制<br>保证跳转来源地址的可靠性和有效性，避免恶意用户自己生成跳转链接</p></li><li><p>2）加入有效的token<br>通过在URL中加入用户不可控的token对生成的链接进行校验，从而避免恶意用户生成自己的链接而被利用。缺点：如果功能本身要求比较开放，可能导致有一定的限制。</p></li></ul><h2 id="七、React-如何防止-XSS-攻击"><a href="#七、React-如何防止-XSS-攻击" class="headerlink" title="七、React 如何防止 XSS 攻击"></a>七、React 如何防止 XSS 攻击</h2><p>无论使用哪种攻击方式，其本质就是将恶意代码注入到应用中，浏览器去默认执行。<br>React 官方中提到了 React DOM 在渲染所有输入内容之前，默认会进行转义。<br>它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串，因此恶意代码无法成功注入，从而有效地防止了 XSS 攻击。</p><h3 id="1、React-的防止措施"><a href="#1、React-的防止措施" class="headerlink" title="1、React 的防止措施"></a>1、React 的防止措施</h3><h4 id="1-自动转义"><a href="#1-自动转义" class="headerlink" title="(1) 自动转义"></a>(1) 自动转义</h4><p>React 在渲染 HTML 内容和渲染 DOM 属性时都会将 “‘&amp;&lt;&gt; 这几个字符进行转义，转义部分源码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (index = match.index; index &lt; str.length; index++) &#123;  <span class="hljs-keyword">switch</span> (str.charCodeAt(index)) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-number">34</span>: <span class="hljs-comment">// &quot;</span>      <span class="hljs-built_in">escape</span> = <span class="hljs-string">&#x27;&amp;quot;&#x27;</span>;      <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">38</span>: <span class="hljs-comment">// &amp;</span>      <span class="hljs-built_in">escape</span> = <span class="hljs-string">&#x27;&amp;amp;&#x27;</span>;      <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">39</span>: <span class="hljs-comment">// &#x27;</span>      <span class="hljs-built_in">escape</span> = <span class="hljs-string">&#x27;&amp;#x27;&#x27;</span>;      <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">60</span>: <span class="hljs-comment">// &lt;</span>      <span class="hljs-built_in">escape</span> = <span class="hljs-string">&#x27;&amp;lt;&#x27;</span>;      <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">62</span>: <span class="hljs-comment">// &gt;</span>      <span class="hljs-built_in">escape</span> = <span class="hljs-string">&#x27;&amp;gt;&#x27;</span>;      <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">default</span>:      <span class="hljs-keyword">continue</span>;    &#125;  &#125;</code></pre><p>这段代码是 React 在渲染到浏览器前进行的转义，可以看到对浏览器有特殊含义的字符都被转义了，恶意代码在渲染到 HTML 前都被转成了字符串，如下：</p><pre><code class="hljs html">一段恶意代码:<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;empty.png&quot;</span> <span class="hljs-attr">onerror</span> =<span class="hljs-string">&quot;alert(&#x27;xss&#x27;)&quot;</span>&gt;</span> 转义后输出到 html 中:<span class="hljs-symbol">&amp;lt;</span>img src=<span class="hljs-symbol">&amp;quot;</span>empty.png<span class="hljs-symbol">&amp;quot;</span> onerror =<span class="hljs-symbol">&amp;quot;</span>alert(<span class="hljs-symbol">&amp;#x27;</span>xss<span class="hljs-symbol">&amp;#x27;</span>)<span class="hljs-symbol">&amp;quot;</span><span class="hljs-symbol">&amp;gt;</span></code></pre><p>这样就有效的防止了 XSS 攻击。</p><h4 id="2-JSX-语法"><a href="#2-JSX-语法" class="headerlink" title="(2) JSX 语法"></a>(2) JSX 语法</h4><p><code>JSX</code> 实际上是一种语法糖，<code>Babel</code> 会把 <code>JSX</code> 编译成 <code>React.createElement()</code> 的函数调用，最终返回一个 <code>ReactElement</code>，以下为这几个步骤对应的代码：</p><pre><code class="hljs javaScript"><span class="hljs-comment">// JSX</span><span class="hljs-keyword">const</span> element = (  &lt;h1 className=<span class="hljs-string">&quot;greeting&quot;</span>&gt;    Hello, world!  &lt;/h1&gt;);<span class="hljs-comment">// 通过 babel 编译后的代码</span><span class="hljs-keyword">const</span> element = React.createElement(  <span class="hljs-string">&#x27;h1&#x27;</span>,  &#123;<span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;greeting&#x27;</span>&#125;,  <span class="hljs-string">&#x27;Hello, world!&#x27;</span>);<span class="hljs-comment">// React.createElement() 方法返回的 ReactElement</span><span class="hljs-keyword">const</span> element = &#123;  $$typeof: <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;react.element&#x27;</span>),  type: <span class="hljs-string">&#x27;h1&#x27;</span>,  key: <span class="hljs-literal">null</span>,  props: &#123;    children: <span class="hljs-string">&#x27;Hello, world!&#x27;</span>,      className: <span class="hljs-string">&#x27;greeting&#x27;</span>     &#125;  ...&#125;</code></pre><p>我们可以看到，最终渲染的内容是在 Children 属性中，那了解了 JSX 的原理后，我们来试试能否通过构造特殊的 Children 进行 XSS 注入，来看下面一段代码：</p><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> storedData = <span class="hljs-string">`&#123;</span><span class="hljs-string">  &quot;ref&quot;:null,</span><span class="hljs-string">  &quot;type&quot;:&quot;body&quot;,</span><span class="hljs-string">  &quot;props&quot;:&#123;</span><span class="hljs-string">  &quot;dangerouslySetInnerHTML&quot;:&#123;</span><span class="hljs-string">  &quot;__html&quot;:&quot;&lt;img src=\&quot;empty.png\&quot; onerror =\&quot;alert(&#x27;xss&#x27;)\&quot;/&gt;&quot;</span><span class="hljs-string">      &#125;</span><span class="hljs-string">  &#125;</span><span class="hljs-string">&#125;`</span>;<span class="hljs-comment">// 转成 JSON</span><span class="hljs-keyword">const</span> parsedData = <span class="hljs-built_in">JSON</span>.parse(storedData);<span class="hljs-comment">// 将数据渲染到页面</span>render () &#123;  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> &#123;parsedData&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>; &#125;</code></pre><p>这段代码中， 运行后会报以下错误，提示不是有效的 ReactChild</p><pre><code class="hljs javaScript">Uncaught (<span class="hljs-keyword">in</span> promise) <span class="hljs-built_in">Error</span>: Objects are not valid <span class="hljs-keyword">as</span> a React child (found: object <span class="hljs-keyword">with</span> keys &#123;ref, type, props&#125;). If you meant to render a collection <span class="hljs-keyword">of</span> children, use an array instead.</code></pre><p>那究竟是哪里出问题了？我们看一下 ReactElement 的源码：</p><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> symbolFor = <span class="hljs-built_in">Symbol</span>.for;REACT_ELEMENT_TYPE = symbolFor(<span class="hljs-string">&#x27;react.element&#x27;</span>);<span class="hljs-keyword">const</span> ReactElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, key, ref, self, source, owner, props</span>) </span>&#123;  <span class="hljs-keyword">const</span> element = &#123;    <span class="hljs-comment">// 这个 tag 唯一标识了此为 ReactElement</span>    $$typeof: REACT_ELEMENT_TYPE,    <span class="hljs-comment">// 元素的内置属性</span>    type: type,    key: key,    ref: ref,    props: props,    <span class="hljs-comment">// 记录创建此元素的组件</span>    _owner: owner,  &#125;;  ...  <span class="hljs-keyword">return</span> element;&#125;</code></pre><p>注意到其中有个属性是 <code>$$typeof</code>，它是用来标记此对象是一个 <code>ReactElement</code>，<code>React</code> 在进行渲染前会通过此属性进行校验，校验不通过将会抛出上面的错误。<br><code>React</code> 利用这个属性来防止通过构造特殊的 <code>Children</code> 来进行的 <code>XSS</code> 攻击，原因是 <code>$$typeof</code> 是个 <code>Symbol</code> 类型，进行 <code>JSON</code> 转换后会 <code>Symbol</code> 值会丢失，无法在前后端进行传输。<br>如果用户提交了特殊的 <code>Children</code>，也无法进行渲染，利用此特性，可以防止存储型的 <code>XSS</code> 攻击。</p><h3 id="2、React-中可能引起漏洞的一些写法"><a href="#2、React-中可能引起漏洞的一些写法" class="headerlink" title="2、React 中可能引起漏洞的一些写法"></a>2、React 中可能引起漏洞的一些写法</h3><h4 id="1-使用-dangerouslySetInnerHTML"><a href="#1-使用-dangerouslySetInnerHTML" class="headerlink" title="(1) 使用 dangerouslySetInnerHTML"></a>(1) 使用 dangerouslySetInnerHTML</h4><p>dangerouslySetInnerHTML 是 React 为浏览器 DOM 提供 innerHTML 的替换方案。通常来讲，使用代码直接设置 HTML 存在风险，因为很容易使用户暴露在 XSS 攻击下，因为当使用 dangerouslySetInnerHTML 时，React 将不会对输入进行任何处理并直接渲染到 HTML 中，如果攻击者在 dangerouslySetInnerHTML 传入了恶意代码，那么浏览器将会运行恶意代码。看下源码：</p><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNonChildrenInnerMarkup</span>(<span class="hljs-params">props</span>) </span>&#123;<span class="hljs-comment">// 有dangerouslySetInnerHTML属性，会不经转义就渲染__html的内容</span>  <span class="hljs-keyword">const</span> innerHTML = props.dangerouslySetInnerHTML;   <span class="hljs-keyword">if</span> (innerHTML != <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">if</span> (innerHTML.__html != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">return</span> innerHTML.__html;    &#125;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">const</span> content = props.children;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> content === <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> content === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;      <span class="hljs-keyword">return</span> escapeTextForBrowser(content);    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;</code></pre><p>所以平时开发时最好避免使用 dangerouslySetInnerHTML，如果不得不使用的话，前端或服务端必须对输入进行相关验证，例如对特殊输入进行过滤、转义等处理。<br>前端这边处理的话，推荐使用白名单过滤 <code>(https://jsxss.com/zh/index.html)</code>，通过白名单控制允许的 HTML 标签及各标签的属性。</p><h4 id="2-通过用户提供的对象来创建-React-组件"><a href="#2-通过用户提供的对象来创建-React-组件" class="headerlink" title="(2) 通过用户提供的对象来创建 React 组件"></a>(2) 通过用户提供的对象来创建 React 组件</h4><p>举个例子：</p><pre><code class="hljs javaScript"><span class="hljs-comment">// 用户的输入</span><span class="hljs-keyword">const</span> userProvidePropsString = <span class="hljs-string">`&#123;&quot;dangerouslySetInnerHTML&quot;:&#123;&quot;__html&quot;:&quot;&lt;img onerror=&#x27;alert(\&quot;xss\&quot;);&#x27; src=&#x27;empty.png&#x27; /&gt;&quot;&#125;&#125;&quot;`</span>;<span class="hljs-comment">// 经过 JSON 转换</span><span class="hljs-keyword">const</span> userProvideProps = <span class="hljs-built_in">JSON</span>.parse(userProvidePropsString);<span class="hljs-comment">// userProvideProps = &#123;</span><span class="hljs-comment">//   dangerouslySetInnerHTML: &#123;</span><span class="hljs-comment">//     &quot;__html&quot;: `&lt;img onerror=&#x27;alert(&quot;xss&quot;);&#x27; src=&#x27;empty.png&#x27; /&gt;`</span><span class="hljs-comment">//      &#125;</span><span class="hljs-comment">// &#125;;</span><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;     <span class="hljs-comment">// 出于某种原因解析用户提供的 JSON 并将对象作为 props 传递</span>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> &#123;<span class="hljs-attr">...userProvideProps</span>&#125; /&gt;</span></span> &#125;</code></pre><p>这段代码将用户提供的数据进行 JSON 转换后直接当做 div 的属性，当用户构造了类似例子中的特殊字符串时，页面就会被注入恶意代码，所以要注意平时在开发中不要直接使用用户的输入作为属性。</p><h4 id="3-使用用户输入的值来渲染-a-标签的-href-属性，或类似-img-标签的-src-属性等"><a href="#3-使用用户输入的值来渲染-a-标签的-href-属性，或类似-img-标签的-src-属性等" class="headerlink" title="(3) 使用用户输入的值来渲染 a 标签的 href 属性，或类似 img 标签的 src 属性等"></a>(3) 使用用户输入的值来渲染 a 标签的 href 属性，或类似 img 标签的 src 属性等</h4><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> userWebsite = <span class="hljs-string">&quot;javascript:alert(&#x27;xss&#x27;);&quot;</span>;&lt;a href=&#123;userWebsite&#125;&gt;&lt;/a&gt;</code></pre><p>如果没有对该 URL 进行过滤以防止通过 javascript: 或 data: 来执行 JavaScript，则攻击者可以构造 XSS 攻击，此处会有潜在的安全问题。用户提供的 URL 需要在前端或者服务端在入库之前进行验证并过滤。</p><blockquote><p><a href="https://github.com/ljianshu/Blog/issues/56">常见六大Web安全攻防解析</a><br><a href="https://mp.weixin.qq.com/s/yf0jhXiCXw8oTbjoUI3tYw">浅谈 React 中的 XSS 攻击</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js-优化方案</title>
    <link href="/2021/01/19/interview/%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
    <url>/2021/01/19/interview/%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="一、代码层面"><a href="#一、代码层面" class="headerlink" title="一、代码层面"></a>一、代码层面</h2><h3 id="1、使用懒加载和预加载"><a href="#1、使用懒加载和预加载" class="headerlink" title="1、使用懒加载和预加载"></a>1、使用懒加载和预加载</h3><h4 id="1、懒加载"><a href="#1、懒加载" class="headerlink" title="1、懒加载"></a>1、懒加载</h4><p>懒加载：懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种很好优化网页性能的方式。</p><p>目的：</p><ul><li>能提升用户的体验</li><li>减少无效资源的加载</li><li>防止并发加载的资源过多会阻塞js的加载</li></ul><p>原理：首先将页面上的图片的 src 属性设为空字符串，而图片的真实路径则设置在data-original属性中，<br>当页面滚动的时候需要去监听scroll事件，在scroll事件的回调中，判断我们的懒加载的图片是否进入可视区域,如果图片在可视区内将图片的 src 属性设置为data-original 的值，这样就可以实现延迟加载。</p><p>监听页面滚动的方法：<br>1、<code>document.addEventListener(&quot;scroll&quot;, () =&gt; &#123; &#125;)</code><br>2、<code>IntersectionObserver</code></p><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 实现方式一: document.addEventListener(&quot;scroll&quot;, () =&gt; &#123; &#125;) --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Lazyload<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"><span class="hljs-selector-class">.image-item</span> &#123;</span>display: block;margin-bottom: 50px;<span class="css"><span class="hljs-selector-tag">height</span>: 200<span class="hljs-selector-tag">px</span>; <span class="hljs-comment">/* 一定记得设置图片高度 */</span></span>&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;image-item&quot;</span> <span class="hljs-attr">lazyload</span>=<span class="hljs-string">&quot;true&quot;</span>  <span class="hljs-attr">data-original</span>=<span class="hljs-string">&quot;images/1.png&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;image-item&quot;</span> <span class="hljs-attr">lazyload</span>=<span class="hljs-string">&quot;true&quot;</span>  <span class="hljs-attr">data-original</span>=<span class="hljs-string">&quot;images/2.png&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!-- &lt;img src=&quot;&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot;  data-original=&quot;images/3.png&quot;/&gt;</span><span class="hljs-comment">img4、img5、img6...</span><span class="hljs-comment">&lt;img src=&quot;&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot;  data-original=&quot;images/12.png&quot;/&gt; --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">   <span class="hljs-comment">// 获取可视区高度</span></span><span class="javascript"><span class="hljs-keyword">var</span> viewHeight = <span class="hljs-built_in">document</span>.documentElement.clientHeight</span><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyload</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript"><span class="hljs-keyword">var</span> eles = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;img[data-original][lazyload]&#x27;</span>)</span><span class="javascript"><span class="hljs-built_in">Array</span>.prototype.forEach.call(eles, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item,index</span>)</span>&#123;</span><span class="javascript"><span class="hljs-keyword">var</span> rect</span><span class="javascript"><span class="hljs-keyword">if</span> (item.dataset.original === <span class="hljs-string">&quot;&quot;</span>) <span class="hljs-keyword">return</span>;</span><span class="javascript"><span class="hljs-comment">// 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置</span></span>rect = item.getBoundingClientRect()<span class="javascript"><span class="hljs-keyword">if</span> (rect.bottom &gt;= <span class="hljs-number">0</span> &amp;&amp; rect.top &lt; viewHeight) &#123;</span><span class="javascript">!<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript"><span class="hljs-keyword">var</span> img = <span class="hljs-keyword">new</span> Image();</span>img.src = item.dataset.original;<span class="javascript">img.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span>item.src = img.src;&#125;<span class="javascript"><span class="hljs-comment">// 移除属性，下次不再遍历</span></span><span class="javascript">item.removeAttribute(<span class="hljs-string">&quot;data-original&quot;</span>)</span><span class="javascript">item.removeAttribute(<span class="hljs-string">&quot;lazyload&quot;</span>)</span>&#125;()&#125;&#125;)&#125;<span class="javascript"><span class="hljs-comment">// 刚开始还没滚动屏幕时，要先触发一次函数，初始化首页的页面图片</span></span>lazyload()<span class="javascript"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&quot;scroll&quot;</span>, lazyload)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 实现方式二: IntersectionObserver （伪代码，未做测试）</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">entry</span>) </span>&#123;  <span class="hljs-keyword">if</span>(entry[<span class="hljs-number">0</span>].isIntersecting) &#123;   <span class="hljs-comment">// 出现在可视区内(默认 viewport)</span>    entry[<span class="hljs-number">0</span>].target.src = entry[<span class="hljs-number">0</span>].target.dataset.original;    observer.unobserve(entry[<span class="hljs-number">0</span>].target);  &#125;&#125;<span class="hljs-keyword">var</span> observer = <span class="hljs-keyword">new</span> IntersectionObserver(callback); <span class="hljs-comment">// 这里可以指定第二个参数做些定制化配置</span><span class="hljs-keyword">var</span> img = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;img&#x27;</span>);observer.observe(img);</code></pre><hr><p>扩展 MutationObserver、IntersectionObserver、ResizeObserver：</p><ul><li><p><code>MutationObserver</code>: 监控DOM节点的变化，如 属性变化、子节点增删改、子树的变化等</p><pre><code class="hljs javascript"><span class="hljs-comment">// 1、选择需要观察变动的节点</span><span class="hljs-keyword">const</span> targetNode = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;some-id&#x27;</span>);<span class="hljs-comment">// 2、观察器的配置（需要观察什么变动）</span><span class="hljs-keyword">const</span> config = &#123; <span class="hljs-attr">attributes</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">childList</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">subtree</span>: <span class="hljs-literal">true</span> &#125;;<span class="hljs-comment">// 3、当观察到变动时执行的回调函数</span><span class="hljs-keyword">const</span> callback = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mutationsList, observer</span>) </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> mutation <span class="hljs-keyword">of</span> mutationsList) &#123;<span class="hljs-keyword">if</span> (mutation.type === <span class="hljs-string">&#x27;childList&#x27;</span>) &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;A child node has been added or removed.&#x27;</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mutation.type === <span class="hljs-string">&#x27;attributes&#x27;</span>) &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The &#x27;</span> + mutation.attributeName + <span class="hljs-string">&#x27; attribute was modified.&#x27;</span>);&#125;&#125;&#125;;<span class="hljs-comment">// 4、创建一个观察器实例并传入回调函数</span><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> MutationObserver(callback);<span class="hljs-comment">// 5、以上述配置开始观察目标节点</span>observer.observe(targetNode, config);<span class="hljs-comment">// 6、之后，可停止观察</span>observer.disconnect();</code></pre></li><li><p><code>IntersectionObserver</code>: 目标A是否与目标B相交</p><pre><code class="hljs javascript"><span class="hljs-comment">// 图片懒加载的例子</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">entry</span>) </span>&#123;<span class="hljs-keyword">if</span>(entry[<span class="hljs-number">0</span>].isIntersecting) &#123;   <span class="hljs-comment">// 出现在可视区内(默认 viewport)</span>entry[<span class="hljs-number">0</span>].target.src = entry[<span class="hljs-number">0</span>].target.dataset.src;observer.unobserve(entry[<span class="hljs-number">0</span>].target);&#125;&#125;<span class="hljs-keyword">var</span> observer = <span class="hljs-keyword">new</span> IntersectionObserver(callback); <span class="hljs-comment">// 这里可以指定第二个参数做些定制化配置</span><span class="hljs-keyword">var</span> img = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;img&#x27;</span>);observer.observe(img);</code></pre><p>  详细解释：<a href="https://letswrite.tw/intersection-oserver-basic/">IntersectionObserver：上篇-基本介绍及使用</a></p></li><li><p><code>ResizeObserver</code>: 专门用来观察DOM元素的尺寸是否发生了变化，不光是窗体resize</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> ro = <span class="hljs-keyword">new</span> ResizeObserver( <span class="hljs-function"><span class="hljs-params">entries</span> =&gt;</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> entries) &#123;<span class="hljs-keyword">const</span> cr = entry.contentRect;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Element:&#x27;</span>, entry.target);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Element size: <span class="hljs-subst">$&#123;cr.width&#125;</span>px x <span class="hljs-subst">$&#123;cr.height&#125;</span>px`</span>);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Element padding: <span class="hljs-subst">$&#123;cr.top&#125;</span>px ; <span class="hljs-subst">$&#123;cr.left&#125;</span>px`</span>);&#125;&#125;);<span class="hljs-comment">// 观察一个或多个元素</span>ro.observe(eleZxx);<span class="hljs-comment">/*</span><span class="hljs-comment">注意：观测的是 contentRect，只有 content 改变（margin,padding不行）才会触发回调</span><span class="hljs-comment">用途：</span><span class="hljs-comment">  1、原生resize行为的检测，如 textarea 的拉升</span><span class="hljs-comment">  2、感知交互行为的发生（无埋点方案）</span><span class="hljs-comment">  3、感知元素是否显示或隐藏（ MutationObserver 有时做不到）</span><span class="hljs-comment">*/</span></code></pre><p>  详细解释: <a href="https://www.zhangxinxu.top/wordpress/2020/03/dom-resize-api-resizeobserver/">检测DOM尺寸变化JS API ResizeObserver简介</a></p></li></ul><h4 id="2、预加载"><a href="#2、预加载" class="headerlink" title="2、预加载"></a>2、预加载</h4><p>预加载：预加载简单来说就是将所有所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。</p><p>目的：在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。</p><p>实现方法：</p><ol><li><p>使用HTML标签<br> <code>&lt;img src=&quot;http://pic26.nipic.com/20121213/61681830044449030002.jpg&quot; style=&quot;display:none&quot;/&gt;</code></p></li><li><p>使用Image对象</p> <pre><code class="hljs javascript"><span class="hljs-comment">// 预加载</span>  &lt;script src=<span class="hljs-string">&quot;./myPreload.js&quot;</span>&gt;&lt;/script&gt;<span class="hljs-comment">// myPreload.js文件</span><span class="hljs-keyword">var</span> image= <span class="hljs-keyword">new</span> Image()image.src=<span class="hljs-string">&quot;http://pic26.nipic.com/20121213/61681830044449030002.jpg&quot;</span></code></pre></li><li><p>使用XMLHttpRequest对象,虽然存在跨域问题，但会精细控制预加载过程</p> <pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xmlhttprequest = <span class="hljs-keyword">new</span> XMLHttpRequest();xmlhttprequest.onreadystatechange = callback;xmlhttprequest.onprogress = progressCallback;xmlhttprequest.open(<span class="hljs-string">&quot;GET&quot;</span>,<span class="hljs-string">&quot;http://image.baidu.com/mouse,jpg&quot;</span>,<span class="hljs-literal">true</span>);xmlhttprequest.send();<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">if</span>(xmlhttprequest.readyState == <span class="hljs-number">4</span> &amp;&amp; xmlhttprequest.status == <span class="hljs-number">200</span>)&#123;<span class="hljs-keyword">var</span> responseText = xmlhttprequest.responseText;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Request was unsuccessful:&quot;</span> + xmlhttprequest.status);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">progressCallback</span>(<span class="hljs-params">e</span>)</span>&#123;e = e || event;<span class="hljs-keyword">if</span>(e.lengthComputable)&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Received&quot;</span>+e.loaded+<span class="hljs-string">&quot;of&quot;</span>+e.total+<span class="hljs-string">&quot;bytes&quot;</span>)&#125;&#125;</code></pre></li><li><p>使用PreloadJS库<br>reloadJS提供了一种预加载内容的一致方式，以便在HTML应用程序中使用。预加载可以使用HTML标签以及XHR来完成。默认情况下，PreloadJS会尝试使用XHR加载内容，因为它提供了对进度和完成事件的更好支持，但是由于跨域问题，使用基于标记的加载可能更好.</p> <pre><code class="hljs javascript"><span class="hljs-comment">//使用preload.js</span><span class="hljs-comment">// 默认是xhr对象，如果是new createjs.LoadQueue(false)是指使用HTML标签，可以跨域</span><span class="hljs-keyword">var</span> queue = <span class="hljs-keyword">new</span> createjs.LoadQueue();queue.on(<span class="hljs-string">&quot;complete&quot;</span>, handleComplete, <span class="hljs-built_in">this</span>);queue.loadManifest([&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&quot;myImage&quot;</span>,<span class="hljs-attr">src</span>:<span class="hljs-string">&quot;http://pic26.nipic.com/20121213/6168183  0044449030002.jpg&quot;</span>&#125;,&#123;id：<span class="hljs-string">&quot;myImage2&quot;</span>，src:<span class="hljs-string">&quot;http://pic9.nipic.com/20100814/2839526  1931471581702.jpg&quot;</span>&#125;]);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleComplete</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">var</span> image=queue.getResuLt(<span class="hljs-string">&quot;myImage&quot;</span>);<span class="hljs-built_in">document</span>.body.appendChild(image);&#125;</code></pre></li></ol><h4 id="3、懒加载和预加载的对比"><a href="#3、懒加载和预加载的对比" class="headerlink" title="3、懒加载和预加载的对比"></a>3、懒加载和预加载的对比</h4><p>两者都是提高页面性能有效的办法，<strong>两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力</strong>。</p><h2 id="二、打包层面"><a href="#二、打包层面" class="headerlink" title="二、打包层面"></a>二、打包层面</h2><blockquote><p><a href="https://juejin.cn/post/6844903614138286094">懒加载和预加载</a><br><a href="https://www.jianshu.com/p/666ede29d5a9">MutationObserver、IntersectionObserver、ResizeObserver</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>js</tag>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js-手写代码</title>
    <link href="/2021/01/15/interview/js-Code/"/>
    <url>/2021/01/15/interview/js-Code/</url>
    
    <content type="html"><![CDATA[<h2 id="一-JS"><a href="#一-JS" class="headerlink" title="一 JS"></a>一 JS</h2><p>1 手写 new Object.create<br>2 获取JS类型<br>3 instanceOf<br>4 深拷贝<br>5 call/apply/bind<br>6 防抖节流<br>7 JSONP<br>8 sum(2,3) === sum(2)(3)<br>9 图片懒加载<br>10 每隔一秒打印 1,2,3,4</p><h3 id="1-new-Object-create"><a href="#1-new-Object-create" class="headerlink" title="1 new/Object.create"></a>1 new/Object.create</h3><p>new 实现的原理:<br>(1) 创建一个新对象<br>(2) 将构造函数的作用域赋给新对象（将新对象的 <strong>proto</strong> 指向构造函数的prototype对象）<br>(3) 为这个新对象添加属性（将构造函数的this通过call/apply指向这个新对象，并执行了构造函数中的方法）<br>(4) 如果构造函数没有返回其他方法，那么 this 指向这个对象，否则 this 指向构造函数中返回的对象</p><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name;<span class="hljs-built_in">this</span>.setName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>&#123; <span class="hljs-built_in">this</span>.name = name &#125;;<span class="hljs-built_in">this</span>.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name &#125;;&#125;<span class="hljs-comment">// 第一步:创建一个新对象</span><span class="hljs-keyword">let</span> p1 = &#123;&#125;;<span class="hljs-comment">// 第二步:将构造函数的作用域赋给新对象（</span><span class="hljs-comment">// 将新对象的 __proto__ 指向构造函数的prototype对象）</span>p1.__proto__ = Person.prototype;<span class="hljs-comment">// 第三步:为这个新对象添加属性</span><span class="hljs-comment">//（将构造函数的this通过call/apply指向这个新对象，并执行了构造函数中的方法）</span>Person.call(p1);<span class="hljs-comment">// 手写一个 new 函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNew</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">// 1、创建一个新的空对象</span><span class="hljs-keyword">let</span> target = &#123;&#125;;<span class="hljs-comment">// 获取构造函数</span><span class="hljs-keyword">let</span> [<span class="hljs-title">constructor</span>, ...<span class="hljs-title">args</span>] = [...<span class="hljs-title">arguments</span>]// 2、将构造函数的作用域赋值给这个新对象<span class="hljs-title">target</span>.<span class="hljs-title">__proto__</span> = <span class="hljs-title">constructor</span>.<span class="hljs-title">prototype</span>;<span class="hljs-comment">// 3、执行构造函数，将属性或方法添加到这个空对象上</span><span class="hljs-keyword">let</span> result = <span class="hljs-title">constructor</span>.<span class="hljs-title">apply</span>(<span class="hljs-params">target, args</span>);<span class="hljs-comment">// 4、如果构造函数执行的结构返回的是一个对象，那么返回这个对象；</span><span class="hljs-comment">//如果构造函数返回的不是一个对象，返回创建的新对象</span><span class="hljs-keyword">if</span> (result &amp;&amp; (<span class="hljs-keyword">typeof</span> (result) == <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> (result) == <span class="hljs-string">&quot;function&quot;</span>)) &#123;<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-keyword">return</span> target;&#125;<span class="hljs-comment">// 测试用例 ---- start</span><span class="hljs-keyword">const</span> person = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name;&#125;person.prototype.getName = <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;&#125;person.prototype.setName = <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> &#123;<span class="hljs-built_in">this</span>.name = name;&#125;<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> person(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);p1.setName(<span class="hljs-string">&#x27;lisi&#x27;</span>);</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// Object.create方法</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params">proto</span>) </span>&#123;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;F.prototype = proto;F.prototype.constructor = F;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F();&#125;<span class="hljs-comment">//官方版Polyfill</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>.create !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-built_in">Object</span>.create = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">proto, propertiesObject</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> proto !== <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> proto !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Object prototype may only be an Object: &#x27;</span> + proto);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (proto === <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;This browser&#x27;s implementation of Object.create is a shim and doesn&#x27;t support &#x27;null&#x27; as the first argument.&quot;</span>);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> propertiesObject !== <span class="hljs-string">&#x27;undefined&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;This browser&#x27;s implementation of Object.create is a shim and doesn&#x27;t support a second argument.&quot;</span>);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;F.prototype = proto;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F();&#125;;&#125;</code></pre><h3 id="2-获取JS类型"><a href="#2-获取JS类型" class="headerlink" title="2 获取JS类型"></a>2 获取JS类型</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 获取JavaScript类型的函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getType</span>(<span class="hljs-params">obj</span>) </span>&#123;<span class="hljs-comment">// 因为 typeof null = &#x27;object&#x27;</span><span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">return</span> obj + <span class="hljs-string">&#x27;&#x27;</span>;&#125;<span class="hljs-comment">// 判断是引用类型还是基本类型</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<span class="hljs-comment">// const objClass = Object.prototype.toString.call(obj);</span><span class="hljs-comment">// let type = objClass.split(&#x27; &#x27;)[1].replace(&#x27;]&#x27;, &#x27;&#x27;);</span><span class="hljs-comment">// return type.toLowerCase();</span><span class="hljs-keyword">const</span> typeStr = <span class="hljs-built_in">Object</span>.prototype.toString.call(obj);<span class="hljs-comment">// [object Array]</span><span class="hljs-keyword">return</span> typeStr.substring(<span class="hljs-number">8</span>, typeStr.length - <span class="hljs-number">1</span>).toLowerCase();&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> obj;&#125;&#125;</code></pre><h3 id="3-instanceOf"><a href="#3-instanceOf" class="headerlink" title="3 instanceOf"></a>3 instanceOf</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">instanceOf</span>(<span class="hljs-params">left, right</span>) </span>&#123;<span class="hljs-keyword">let</span> proto = left.__proto__; <span class="hljs-keyword">let</span> prototype = right.prototype<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<span class="hljs-keyword">if</span>(proto == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><span class="hljs-keyword">if</span>(proto == prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>proto = proto.__proto__;&#125;&#125;</code></pre><h3 id="4-深拷贝-浅拷贝"><a href="#4-深拷贝-浅拷贝" class="headerlink" title="4 深拷贝/浅拷贝"></a>4 深拷贝/浅拷贝</h3><p>深拷贝和浅拷贝是针对复杂数据类型来说的，浅拷贝只拷贝一层，而深拷贝是层层拷贝。</p><ul><li><strong>深拷贝</strong>：深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。</li><li><strong>浅拷贝</strong>：浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。</li></ul><p>浅拷贝的实现方式：</p><ul><li>Object.assign()</li><li>函数库 lodash 的 lodash.clone 方法</li><li>展开运算符…</li><li>Array.prototype.concat()</li><li>Array.prototype.slice()</li></ul><pre><code class="hljs javaScript"><span class="hljs-comment">// 浅拷贝实现过程</span><span class="hljs-keyword">let</span> obj = &#123;name: <span class="hljs-string">&#x27;Yvette&#x27;</span>,age: <span class="hljs-number">18</span>,hobbies: [<span class="hljs-string">&#x27;reading&#x27;</span>, <span class="hljs-string">&#x27;photography&#x27;</span>]&#125;<span class="hljs-comment">// 浅拷贝实现方式一: Object.assign()</span><span class="hljs-keyword">let</span> obj2 = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, obj);<span class="hljs-comment">// 浅拷贝实现方式二: 函数库lodash的_.clone方法</span><span class="hljs-keyword">let</span> lodash = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>);<span class="hljs-keyword">let</span> obj3 = lodash.clone(obj);<span class="hljs-comment">// 浅拷贝实现方式三: 展开运算符...</span><span class="hljs-keyword">let</span> obj4 = &#123;...obj&#125;;<span class="hljs-comment">// 浅拷贝实现方式四: Array.prototype.concat()</span><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, &#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;kobe&#x27;</span> &#125;];<span class="hljs-keyword">let</span> arr2 = arr.concat();  <span class="hljs-comment">// 浅拷贝实现方式五: Array.prototype.concat()</span><span class="hljs-keyword">let</span> arr3 = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, &#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;kobe&#x27;</span> &#125;];<span class="hljs-keyword">let</span> arr4 = arr3.slice();</code></pre><p>可以看出，浅拷贝<strong>只对第一层属性</strong>进行了拷贝，当第一层的属性值是基本数据类型时，新的对象和原对象互不影响，但是如果第一层的属性值是复杂数据类型，那么<em>新对象和原对象的属性值其指向的是同一块内存地址</em>。</p><p>深拷贝的实现方式：</p><ul><li><p>JSON.parse(JSON.stringify(obj))</p></li><li><p>函数库 lodash 的 lodash.cloneDeep 方法</p></li><li><p>jQuery.extend()方法</p></li><li><p>手写递归方法</p>  <pre><code class="hljs javascript"><span class="hljs-comment">// 方法一: JSON.parse(JSON.stringify(obj))</span><span class="hljs-comment">/*</span><span class="hljs-comment">缺陷：</span><span class="hljs-comment">1、对象属性是函数时，无法拷贝</span><span class="hljs-comment">2、原型链上的属性无法拷贝</span><span class="hljs-comment">3、不能正确处理 Date 了类型的数据</span><span class="hljs-comment">4、不能处理 RegExp</span><span class="hljs-comment">5、会忽略 Symbol 和 undefined</span><span class="hljs-comment">*/</span><span class="hljs-comment">// 方法二: 函数库 lodash 的 lodash.cloneDeep 方法</span><span class="hljs-keyword">let</span> lodash = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>);<span class="hljs-keyword">let</span> obj = &#123;a: <span class="hljs-number">1</span>,b: &#123; <span class="hljs-attr">f</span>: &#123; <span class="hljs-attr">g</span>: <span class="hljs-number">1</span> &#125; &#125;,c: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&#125;;<span class="hljs-keyword">let</span> obj2 = lodash.cloneDeep(obj);<span class="hljs-comment">// 方法三: .jQuery.extend()方法</span><span class="hljs-keyword">var</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jquery&#x27;</span>);<span class="hljs-keyword">var</span> obj3 = &#123;a: <span class="hljs-number">1</span>,b: &#123; <span class="hljs-attr">f</span>: &#123; <span class="hljs-attr">g</span>: <span class="hljs-number">1</span> &#125; &#125;,c: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&#125;;<span class="hljs-keyword">var</span> obj4 = $.extend(<span class="hljs-literal">true</span>, &#123;&#125;, obj3); <span class="hljs-comment">//第一个参数为true,就是深拷贝</span><span class="hljs-comment">// 方法四: 实现一个 deepClone 函数</span><span class="hljs-comment">/*</span><span class="hljs-comment">步骤:</span><span class="hljs-comment">1、如果是基本数据类型，直接返回</span><span class="hljs-comment">2、如果是 RegExp 或者 Date 类型，返回对应类型</span><span class="hljs-comment">3、如果是复杂数据类型，递归</span><span class="hljs-comment">4、考虑循环引用的问题</span><span class="hljs-comment">*/</span><span class="hljs-comment">// 深拷贝</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) </span>&#123;<span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<span class="hljs-comment">//如果不是复杂数据类型 或者是 Null ，直接返回</span><span class="hljs-keyword">return</span> obj;&#125;<span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(obj);<span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(obj);<span class="hljs-comment">// 考虑循环引用的问题</span><span class="hljs-keyword">if</span> (hash.has(obj)) &#123;<span class="hljs-keyword">return</span> hash.get(obj);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 如果obj是数组，那么 obj.constructor 是 [Function: Array]</span><span class="hljs-comment"> * 如果obj是对象，那么 obj.constructor 是 [Function: Object]</span><span class="hljs-comment"> */</span><span class="hljs-keyword">let</span> cloneObj = <span class="hljs-keyword">new</span> obj.constructor();hash.set(obj, cloneObj);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<span class="hljs-comment">//递归</span><span class="hljs-keyword">if</span> (obj.hasOwnProperty(key)) &#123; <span class="hljs-comment">// 是否是自身的属性</span>cloneObj[key] = deepClone(obj[key], hash);&#125;&#125;<span class="hljs-keyword">return</span> cloneObj;&#125;</code></pre>  <pre><code class="hljs javaScript"><span class="hljs-comment">// 满分答案</span><span class="hljs-comment">// https://github.com/ConardLi/ConardLi.github.io/blob/master/demo/deepClone/src/clone_6.js</span><span class="hljs-keyword">const</span> mapTag = <span class="hljs-string">&#x27;[object Map]&#x27;</span>;<span class="hljs-keyword">const</span> setTag = <span class="hljs-string">&#x27;[object Set]&#x27;</span>;<span class="hljs-keyword">const</span> arrayTag = <span class="hljs-string">&#x27;[object Array]&#x27;</span>;<span class="hljs-keyword">const</span> objectTag = <span class="hljs-string">&#x27;[object Object]&#x27;</span>;<span class="hljs-keyword">const</span> argsTag = <span class="hljs-string">&#x27;[object Arguments]&#x27;</span>;<span class="hljs-keyword">const</span> boolTag = <span class="hljs-string">&#x27;[object Boolean]&#x27;</span>;<span class="hljs-keyword">const</span> dateTag = <span class="hljs-string">&#x27;[object Date]&#x27;</span>;<span class="hljs-keyword">const</span> numberTag = <span class="hljs-string">&#x27;[object Number]&#x27;</span>;<span class="hljs-keyword">const</span> stringTag = <span class="hljs-string">&#x27;[object String]&#x27;</span>;<span class="hljs-keyword">const</span> symbolTag = <span class="hljs-string">&#x27;[object Symbol]&#x27;</span>;<span class="hljs-keyword">const</span> errorTag = <span class="hljs-string">&#x27;[object Error]&#x27;</span>;<span class="hljs-keyword">const</span> regexpTag = <span class="hljs-string">&#x27;[object RegExp]&#x27;</span>;<span class="hljs-keyword">const</span> funcTag = <span class="hljs-string">&#x27;[object Function]&#x27;</span>;<span class="hljs-keyword">const</span> deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEach</span>(<span class="hljs-params">array, iteratee</span>) </span>&#123;<span class="hljs-keyword">let</span> index = -<span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> length = array.length;<span class="hljs-keyword">while</span> (++index &lt; length) &#123;iteratee(array[index], index);&#125;<span class="hljs-keyword">return</span> array;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isObject</span>(<span class="hljs-params">target</span>) </span>&#123;<span class="hljs-keyword">const</span> type = <span class="hljs-keyword">typeof</span> target;<span class="hljs-keyword">return</span> target !== <span class="hljs-literal">null</span> &amp;&amp; (type === <span class="hljs-string">&#x27;object&#x27;</span> || type === <span class="hljs-string">&#x27;function&#x27;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getType</span>(<span class="hljs-params">target</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(target);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getInit</span>(<span class="hljs-params">target</span>) </span>&#123;<span class="hljs-keyword">const</span> Ctor = target.constructor;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Ctor();&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneSymbol</span>(<span class="hljs-params">targe</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>(<span class="hljs-built_in">Symbol</span>.prototype.valueOf.call(targe));&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneReg</span>(<span class="hljs-params">targe</span>) </span>&#123;<span class="hljs-keyword">const</span> reFlags = <span class="hljs-regexp">/\w*$/</span>;<span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> targe.constructor(targe.source, reFlags.exec(targe));result.lastIndex = targe.lastIndex;<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneFunction</span>(<span class="hljs-params">func</span>) </span>&#123;<span class="hljs-keyword">const</span> bodyReg = <span class="hljs-regexp">/(?&lt;=&#123;)(.|\n)+(?=&#125;)/m</span>;<span class="hljs-keyword">const</span> paramReg = <span class="hljs-regexp">/(?&lt;=\().+(?=\)\s+&#123;)/</span>;<span class="hljs-keyword">const</span> funcString = func.toString();<span class="hljs-keyword">if</span> (func.prototype) &#123;<span class="hljs-keyword">const</span> param = paramReg.exec(funcString);<span class="hljs-keyword">const</span> body = bodyReg.exec(funcString);<span class="hljs-keyword">if</span> (body) &#123;<span class="hljs-keyword">if</span> (param) &#123;<span class="hljs-keyword">const</span> paramArr = param[<span class="hljs-number">0</span>].split(<span class="hljs-string">&#x27;,&#x27;</span>);<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(...paramArr, body[<span class="hljs-number">0</span>]);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(body[<span class="hljs-number">0</span>]);&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(funcString);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneOtherType</span>(<span class="hljs-params">targe, type</span>) </span>&#123;<span class="hljs-keyword">const</span> Ctor = targe.constructor;<span class="hljs-keyword">switch</span> (type) &#123;<span class="hljs-keyword">case</span> boolTag:<span class="hljs-keyword">case</span> numberTag:<span class="hljs-keyword">case</span> stringTag:<span class="hljs-keyword">case</span> errorTag:<span class="hljs-keyword">case</span> dateTag:<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Ctor(targe);<span class="hljs-keyword">case</span> regexpTag:<span class="hljs-keyword">return</span> cloneReg(targe);<span class="hljs-keyword">case</span> symbolTag:<span class="hljs-keyword">return</span> cloneSymbol(targe);<span class="hljs-keyword">case</span> funcTag:<span class="hljs-keyword">return</span> cloneFunction(targe);<span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clone</span>(<span class="hljs-params">target, map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) </span>&#123;<span class="hljs-comment">// 克隆原始类型</span><span class="hljs-keyword">if</span> (!isObject(target)) &#123;<span class="hljs-keyword">return</span> target;&#125;<span class="hljs-comment">// 初始化</span><span class="hljs-keyword">const</span> type = getType(target);<span class="hljs-keyword">let</span> cloneTarget;<span class="hljs-keyword">if</span> (deepTag.includes(type)) &#123;cloneTarget = getInit(target, type);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> cloneOtherType(target, type);&#125;<span class="hljs-comment">// 防止循环引用</span><span class="hljs-keyword">if</span> (map.get(target)) &#123;<span class="hljs-keyword">return</span> map.get(target);&#125;map.set(target, cloneTarget);<span class="hljs-comment">// 克隆set</span><span class="hljs-keyword">if</span> (type === setTag) &#123;target.forEach(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;cloneTarget.add(clone(value, map));&#125;);<span class="hljs-keyword">return</span> cloneTarget;&#125;<span class="hljs-comment">// 克隆map</span><span class="hljs-keyword">if</span> (type === mapTag) &#123;target.forEach(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;cloneTarget.set(key, clone(value, map));&#125;);<span class="hljs-keyword">return</span> cloneTarget;&#125;<span class="hljs-comment">// 克隆对象和数组</span><span class="hljs-keyword">const</span> keys = type === arrayTag ? <span class="hljs-literal">undefined</span> : <span class="hljs-built_in">Object</span>.keys(target);forEach(keys || target, <span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (keys) &#123;key = value;&#125;cloneTarget[key] = clone(target[key], map);&#125;);<span class="hljs-keyword">return</span> cloneTarget;&#125;<span class="hljs-built_in">module</span>.exports = &#123;clone&#125;;</code></pre></li></ul><h3 id="5-call-apply-bind"><a href="#5-call-apply-bind" class="headerlink" title="5 call/apply/bind"></a>5 call/apply/bind</h3><p>call 和 apply 的功能相同，都是改变 this 指向，并立即执行函数。区别在于传参方式不同：</p><ul><li>func.call(this, arg1, arg2, …)</li><li>func.apply(this, [arg1, arg2, …])</li></ul><p>实现步骤：</p><ol><li>如果第一个参数没有传入，那么默认指向 window / global(非严格模式)</li><li>传入 call 的第一个参数是 this 指向的对象，根据隐式绑定的规则，我们知道 obj.foo(), foo() 中的 this 指向 obj; 因此我们可以这样调用函数 thisArgs.func(…args)</li><li>返回执行结果</li></ol><pre><code class="hljs javaScript"><span class="hljs-comment">// call</span><span class="hljs-built_in">Function</span>.prototype.call2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">let</span> [thisArg, ...args] = [...arguments];<span class="hljs-keyword">if</span> (!thisArg) &#123;<span class="hljs-comment">// context 为null 或者是 undefined</span>thisArg = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> === <span class="hljs-string">&#x27;undefined&#x27;</span> ? <span class="hljs-built_in">global</span> : <span class="hljs-built_in">window</span>;&#125;<span class="hljs-comment">// this 就是当前函数 func(func.call)</span>thisArg.func = <span class="hljs-built_in">this</span>;<span class="hljs-comment">// 执行函数</span><span class="hljs-keyword">let</span> result = thisArg.func(...args);<span class="hljs-comment">// 由于thisArg 上原本没有 func，因此执行完后需要删除</span><span class="hljs-keyword">delete</span> thisArg.func;<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-comment">// 测试用例 --------start</span><span class="hljs-comment">// test1</span><span class="hljs-keyword">const</span> c = &#123;name: <span class="hljs-string">&#x27;c罗&#x27;</span>,age: <span class="hljs-string">&#x27;34&#x27;</span>,func: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;:&#x27;</span> + <span class="hljs-built_in">this</span>.age + <span class="hljs-string">&#x27;-&#x27;</span> + arg1 + <span class="hljs-string">&#x27;-&#x27;</span> + arg2);&#125;&#125;<span class="hljs-keyword">const</span> n = &#123;name: <span class="hljs-string">&#x27;梅西&#x27;</span>,age: <span class="hljs-string">&#x27;32&#x27;</span>,&#125;c.func.call2(n, <span class="hljs-string">&#x27;t1&#x27;</span>, <span class="hljs-string">&#x27;t2&#x27;</span>); <span class="hljs-comment">// 梅西:32-t1-t2</span>c.func(<span class="hljs-string">&#x27;t3&#x27;</span>, <span class="hljs-string">&#x27;t4&#x27;</span>); <span class="hljs-comment">// c罗:34-t3-t4</span><span class="hljs-comment">// 测试用例 --------end</span><span class="hljs-comment">// apply 与 call 区别就是传参的不同</span><span class="hljs-comment">// apply</span><span class="hljs-built_in">Function</span>.prototype.apply2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, rest</span>) </span>&#123;<span class="hljs-keyword">if</span> (!thisArg) &#123;<span class="hljs-comment">// context 为null 或者是 undefined</span>thisArg = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> === <span class="hljs-string">&#x27;undefined&#x27;</span> ? <span class="hljs-built_in">global</span> : <span class="hljs-built_in">window</span>;&#125;<span class="hljs-keyword">let</span> result; <span class="hljs-comment">// 函数执行结果</span>thisArg.func = <span class="hljs-built_in">this</span>;<span class="hljs-keyword">if</span> (!rest) &#123;result = thisArg.func();&#125; <span class="hljs-keyword">else</span> &#123;result = thisArg.func(...rest);&#125;<span class="hljs-keyword">delete</span> thisArg.func;<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-comment">// 测试用例 --------start</span><span class="hljs-comment">// test1</span><span class="hljs-keyword">const</span> c = &#123;name: <span class="hljs-string">&#x27;c罗&#x27;</span>,age: <span class="hljs-string">&#x27;34&#x27;</span>,func: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;:&#x27;</span> + <span class="hljs-built_in">this</span>.age + <span class="hljs-string">&#x27;-&#x27;</span> + arg1 + <span class="hljs-string">&#x27;-&#x27;</span> + arg2);&#125;&#125;<span class="hljs-keyword">const</span> n = &#123;name: <span class="hljs-string">&#x27;梅西&#x27;</span>,age: <span class="hljs-string">&#x27;32&#x27;</span>,&#125;c.func.apply(n, [<span class="hljs-string">&#x27;t1&#x27;</span>, <span class="hljs-string">&#x27;t2&#x27;</span>]); <span class="hljs-comment">// 梅西:32-t1-t2</span>c.func(<span class="hljs-string">&#x27;t3&#x27;</span>, <span class="hljs-string">&#x27;t4&#x27;</span>); <span class="hljs-comment">// c罗:34-t3-t4</span><span class="hljs-comment">// 测试用例 --------end</span></code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// bind:</span><span class="hljs-built_in">Function</span>.prototype.bind2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">content</span>) </span>&#123;<span class="hljs-comment">// 若没问参数类型则从这开始写</span><span class="hljs-keyword">const</span> fn = <span class="hljs-built_in">this</span>;<span class="hljs-keyword">const</span> args = [...arguments].slice(<span class="hljs-number">1</span>);<span class="hljs-keyword">const</span> resFn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> resFn ?<span class="hljs-built_in">this</span> : content, args.concat(...arguments) );&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tmp</span>(<span class="hljs-params"></span>) </span>&#123;&#125;tmp.prototype = <span class="hljs-built_in">this</span>.prototype;resFn.prototype = <span class="hljs-keyword">new</span> tmp();<span class="hljs-keyword">return</span> resFn;&#125;<span class="hljs-comment">// 测试用例 --------start</span><span class="hljs-comment">// test 1</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a, b, c</span>) </span>&#123;  <span class="hljs-keyword">return</span> a + b + c;&#125;<span class="hljs-keyword">var</span> _fn = fn.bind2(<span class="hljs-literal">null</span>, <span class="hljs-number">10</span>);<span class="hljs-built_in">console</span>.log(_fn(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>)); <span class="hljs-comment">// 60</span><span class="hljs-comment">// test2</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;  <span class="hljs-built_in">this</span>.name = name;  <span class="hljs-built_in">this</span>.age = age;&#125;<span class="hljs-keyword">const</span> _Person = Person.bind(<span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;beike&#x27;</span>);<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> _Person(<span class="hljs-number">30</span>);<span class="hljs-built_in">console</span>.log(p1); <span class="hljs-comment">// Person &#123;name: &quot;hanzichi&quot;, age: 30&#125;</span><span class="hljs-comment">// test4</span><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;梅西&#x27;</span>;<span class="hljs-keyword">var</span> age = <span class="hljs-number">33</span>;<span class="hljs-keyword">var</span> obj = &#123;name: <span class="hljs-string">&#x27;坎特&#x27;</span>,age: <span class="hljs-built_in">this</span>.age,myFun: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-keyword">from</span>,to</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;name:&#x27;</span> + <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;, Age:&#x27;</span> + <span class="hljs-built_in">this</span>.age)&#125;&#125;<span class="hljs-keyword">var</span> db = &#123;name: <span class="hljs-string">&#x27;德布劳内&#x27;</span>,age: <span class="hljs-number">29</span>&#125;<span class="hljs-keyword">var</span> rm = &#123;name: <span class="hljs-string">&#x27;里克尔梅&#x27;</span>,age: <span class="hljs-number">42</span>&#125;obj.myFun(); <span class="hljs-comment">// name:坎特, Age:33</span>obj.myFun.apply2(rm); <span class="hljs-comment">// name:里克尔梅, Age:42</span>obj.myFun.call2(db); <span class="hljs-comment">// name:德布劳内, Age:29</span>obj.myFun.bind2(db)(); <span class="hljs-comment">// name:德布劳内, Age:29</span><span class="hljs-comment">// 测试用例 --------end</span></code></pre><h3 id="6-防抖-节流"><a href="#6-防抖-节流" class="headerlink" title="6 防抖/节流"></a>6 防抖/节流</h3><p>考点：闭包、防抖、节流</p><p>统计按钮一秒点击次数</p><pre><code class="hljs javaScript">button.onclick = debounce(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;点击一次&#x27;</span>);&#125;,<span class="hljs-number">1000</span>);<span class="hljs-comment">// 统计一秒点击次数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, time</span>) </span>&#123;<span class="hljs-keyword">let</span> number = <span class="hljs-number">0</span> , timer  = <span class="hljs-literal">null</span><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...arg</span>) </span>&#123; fn.apply(<span class="hljs-built_in">this</span>, arg)number++<span class="hljs-keyword">if</span> (timer) <span class="hljs-keyword">return</span>timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log( <span class="hljs-string">&#x27;点击&#x27;</span>+ number + <span class="hljs-string">&#x27;次&#x27;</span> )number = <span class="hljs-number">0</span>timer = <span class="hljs-literal">null</span>&#125;, time)&#125;&#125;<span class="hljs-comment">//- 防抖意clk延迟时间。</span><span class="hljs-comment">// 防抖</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, time = <span class="hljs-number">500</span></span>) </span>&#123;<span class="hljs-keyword">let</span> timeout = <span class="hljs-literal">null</span>;<span class="hljs-comment">// 创建一个标记用来存放定时器的返回值</span><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">clearTimeout</span>(timeout);<span class="hljs-comment">// 每当用户输入的时候把前一个 setTimeout clear 掉</span>timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// 然后又创建一个新的 setTimeout</span><span class="hljs-comment">// 这样就能保证输入字符后的interval </span><span class="hljs-comment">// 间隔内如果还有字符输入的话，就不会执行 fn 函数 </span>fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)&#125;, time) &#125; &#125;<span class="hljs-comment">// - 节流: 高频事件触发，但在 n 秒内只会执行一次(第一次)，所以节流会稀释函数的执行频率。</span><span class="hljs-comment">// 节流</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, time = <span class="hljs-number">500</span></span>) </span>&#123; <span class="hljs-keyword">let</span> canRun = <span class="hljs-literal">true</span> <span class="hljs-comment">//</span><span class="hljs-comment">// 通过闭包保存一个标记</span><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">if</span> (!canRun) <span class="hljs-keyword">return</span><span class="hljs-comment">// 在函数开头判断标记是否为 true，不为 true 则 return</span>canRun = <span class="hljs-literal">false</span> <span class="hljs-comment">// 立即设置为 false</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)<span class="hljs-comment">// 最后在 setTimeout 执行完毕后再把标记设置为 true(关键)</span><span class="hljs-comment">// 表示可以执行下一次循环了。</span><span class="hljs-comment">// 当定时器没有执行的时候标记永远是 false，在开头被return</span>canRun = <span class="hljs-literal">true</span>&#125;, time)&#125;&#125;</code></pre><p>防抖的应用场景:</p><ul><li>搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。</li><li>表单验证</li><li>按钮提交事件。</li><li>浏览器窗口缩放，resize事件(如窗口停止改变大小之后重新计算布局)等。</li></ul><p>节流的应用场景</p><ul><li>按钮点击事件</li><li>拖拽事件</li><li>onScoll</li><li>计算鼠标移动的距离(mousemove)</li></ul><h3 id="7-JSONP"><a href="#7-JSONP" class="headerlink" title="7 JSONP"></a>7 JSONP</h3><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> jsonp = <span class="hljs-function">(<span class="hljs-params">&#123; url, params, callbackName &#125;</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> generateUrl = <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">let</span> dataSrc = <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> params) &#123;<span class="hljs-keyword">if</span> (params.hasOwnProperty(key)) &#123;dataSrc += <span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;params[key]&#125;</span>&amp;`</span>&#125;&#125;dataSrc += <span class="hljs-string">`callback=<span class="hljs-subst">$&#123;callbackName&#125;</span>`</span><span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?<span class="hljs-subst">$&#123;dataSrc&#125;</span>`</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> scriptEle = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>)scriptEle.src = generateUrl();<span class="hljs-built_in">document</span>.body.appendChild(scriptEle)<span class="hljs-built_in">window</span>[callbackName] = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;resolve(data)<span class="hljs-built_in">document</span>.removeChild(scriptEle)&#125;&#125;)&#125;</code></pre><h3 id="8-sum-2-3-sum-2-3"><a href="#8-sum-2-3-sum-2-3" class="headerlink" title="8 sum(2,3) === sum(2)(3)"></a>8 sum(2,3) === sum(2)(3)</h3><pre><code class="hljs javaScript"><span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>));   <span class="hljs-comment">// Outputs 5</span><span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>));  <span class="hljs-comment">// Outputs 5</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> fir = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>];<span class="hljs-keyword">if</span>(<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span>) &#123;re&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sec</span>) </span>&#123;<span class="hljs-keyword">return</span> fir + sec;&#125;&#125;&#125;</code></pre><h3 id="9-图片懒加载"><a href="#9-图片懒加载" class="headerlink" title="9 图片懒加载"></a>9 图片懒加载</h3><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> imgList = [...document.querySelectorAll(<span class="hljs-string">&#x27;img&#x27;</span>)]<span class="hljs-keyword">let</span> length = imgList.length<span class="hljs-comment">// 修正错误，需要加上自执行</span><span class="hljs-keyword">const</span> imgLazyLoad = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;   <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">let</span> deleteIndexList = [];imgList.forEach(<span class="hljs-function">(<span class="hljs-params">img, index</span>) =&gt;</span> &#123;<span class="hljs-keyword">let</span> rect = img.getBoundingClientRect()<span class="hljs-keyword">if</span> (rect.top &lt; <span class="hljs-built_in">window</span>.innerHeight) &#123;img.src = img.dataset.src;deleteIndexList.push(index);count++;<span class="hljs-keyword">if</span> (count === length) &#123;<span class="hljs-built_in">document</span>.removeEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, imgLazyLoad);&#125;&#125;&#125;)imgList = imgList.filter(<span class="hljs-function">(<span class="hljs-params">img, index</span>) =&gt;</span> !deleteIndexList.includes(index));   &#125;&#125;)()<span class="hljs-comment">// 这里最好加上防抖处理</span><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, imgLazyLoad)</code></pre><h3 id="10-闭包-作用域链"><a href="#10-闭包-作用域链" class="headerlink" title="10 闭包/作用域链"></a>10 闭包/作用域链</h3><p>JavaScript代码的整个执行过程，分为两个阶段，代码<strong>编译阶段</strong>与代码<strong>执行阶段</strong>。</p><ul><li>编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。</li><li>执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。</li></ul><img src="https://i.loli.net/2021/06/07/SYyLVzKbrEBIo2e.png" ><p>执行上下文的生命周期：</p><img src="https://i.loli.net/2021/06/07/L4pMAozZuyDtwv7.png" ><p>作用域:<br>ES5 中只存在两种作用域：<strong>全局作用域</strong>和<strong>函数作用域</strong>。<br>在 JavaScript 中，我们将作用域定义为一套规则，这套规则用来管理引擎如何在当前作用域<br>以及嵌套子作用域中根据标识符名称进行变量（变量名或者函数名）查找</p><p>作用域链:<br>当访问一个变量，编译器在执行这段代码时，会首先从当前的作用域中查找是否有这个标识符，<br>如果没有找到，就会去父作用域查找，如果父作用域还没找到继续向上查找，直到全局作用域为止.<br>作用域链 —— 就是有当前作用域与上层作用域的一系列变量对象组成，它保证了当前执行的作用域对符合访问权限的变量和函数的有序访问。</p><pre><code class="hljs javaScript"><span class="hljs-comment">// 使用闭包实现每隔一秒打印 1,2,3,4</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i</span>) </span>&#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(i), <span class="hljs-number">1000</span> * i)&#125;)(i)&#125;</code></pre><h2 id="二-字符串"><a href="#二-字符串" class="headerlink" title="二 字符串"></a>二 字符串</h2><p>1 判断是不是回文字符串<br>2 JSON.stringify<br>3 解析 URL 参数为对象<br>4 字符串模板<br>5 转驼峰<br>6 找到出现次数最多的字符和个数<br>7 切花字符串大小写<br>8 去掉字符串中的空格</p><h3 id="1-判断一个字符串是不是回文字符串"><a href="#1-判断一个字符串是不是回文字符串" class="headerlink" title="1 判断一个字符串是不是回文字符串"></a>1 判断一个字符串是不是回文字符串</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPalindrome</span>(<span class="hljs-params">str</span>) </span>&#123;    str = str.replace(<span class="hljs-regexp">/\W/g</span>, <span class="hljs-string">&#x27;&#x27;</span>).toLowerCase();    <span class="hljs-keyword">return</span> (str == str.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>));&#125;</code></pre><h3 id="2-JSON-stringify"><a href="#2-JSON-stringify" class="headerlink" title="2 JSON.stringify"></a>2 JSON.stringify</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonStringify</span>(<span class="hljs-params">obj</span>) </span>&#123;<span class="hljs-keyword">let</span> type = <span class="hljs-keyword">typeof</span> obj;<span class="hljs-keyword">if</span> (type !== <span class="hljs-string">&quot;object&quot;</span> || type === <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/string|undefined|function/</span>.test(type)) &#123;obj = <span class="hljs-string">&#x27;&quot;&#x27;</span> + obj + <span class="hljs-string">&#x27;&quot;&#x27;</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(obj);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">let</span> json = [];<span class="hljs-keyword">let</span> arr = (obj &amp;&amp; obj.constructor === <span class="hljs-built_in">Array</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> obj) &#123;<span class="hljs-keyword">let</span> v = obj[k];<span class="hljs-keyword">let</span> type = <span class="hljs-keyword">typeof</span> v;<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/string|undefined|function/</span>.test(type)) &#123;v = <span class="hljs-string">&#x27;&quot;&#x27;</span> + v + <span class="hljs-string">&#x27;&quot;&#x27;</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&quot;object&quot;</span>) &#123;v = jsonStringify(v);&#125;json.push((arr ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&#x27;&quot;&#x27;</span> + k + <span class="hljs-string">&#x27;&quot;:&#x27;</span>) + <span class="hljs-built_in">String</span>(v));&#125;<span class="hljs-keyword">return</span> (arr ? <span class="hljs-string">&quot;[&quot;</span> : <span class="hljs-string">&quot;&#123;&quot;</span>) + <span class="hljs-built_in">String</span>(json) + (arr ? <span class="hljs-string">&quot;]&quot;</span> : <span class="hljs-string">&quot;&#125;&quot;</span>)&#125;&#125;<span class="hljs-comment">// var json = &#x27;&#123;&quot;a&quot;:&quot;1&quot;, &quot;b&quot;:2&#125;&#x27;;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonEval</span>(<span class="hljs-params">json</span>) </span>&#123;<span class="hljs-comment">// obj 就是 json 反序列化之后得到的对象</span><span class="hljs-keyword">var</span> rx_one = <span class="hljs-regexp">/^[\],:&#123;&#125;\s]*$/</span>;<span class="hljs-keyword">var</span> rx_two = <span class="hljs-regexp">/\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]&#123;4&#125;)/g</span>;<span class="hljs-keyword">var</span> rx_three = <span class="hljs-regexp">/&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g</span>;<span class="hljs-keyword">var</span> rx_four = <span class="hljs-regexp">/(?:^|:|,)(?:\s*\[)+/g</span>;<span class="hljs-keyword">if</span> (rx_one.test(json.replace(rx_two, <span class="hljs-string">&quot;@&quot;</span>).replace(rx_three, <span class="hljs-string">&quot;]&quot;</span>).replace(rx_four, <span class="hljs-string">&quot;&quot;</span>))) &#123;<span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;(&quot;</span> +json + <span class="hljs-string">&quot;)&quot;</span>);&#125;<span class="hljs-comment">// 或者直接 return eval(&quot;(&quot; +json + &quot;)&quot;);</span><span class="hljs-comment">// 但是会造成XSS攻击</span>&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonParse</span>(<span class="hljs-params">opt</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;(&#x27;</span> + opt + <span class="hljs-string">&#x27;)&#x27;</span>);&#125;<span class="hljs-comment">// 它会执行JS代码，有XSS漏洞。</span><span class="hljs-comment">// 如果你只想记这个方法，就得对参数json做校验</span><span class="hljs-keyword">var</span> rx_one = <span class="hljs-regexp">/^[],:&#123;&#125;s]*$/</span>;<span class="hljs-keyword">var</span> rx_two = <span class="hljs-regexp">/(?:[&quot;/bfnrt]|u[0-9a-fA-F]&#123;4&#125;)/g</span>;<span class="hljs-keyword">var</span> rx_three = <span class="hljs-regexp">/&quot;[^&quot;nr]*&quot;|true|false|null|-?d+(?:.d*)?(?:[eE][+-]?d+)?/g</span>;<span class="hljs-keyword">var</span> rx_four = <span class="hljs-regexp">/(?:^|:|,)(?:s*[)+/g;</span><span class="hljs-regexp">if (</span><span class="hljs-regexp">    rx_one.test(</span><span class="hljs-regexp">        json</span><span class="hljs-regexp"> .replace(rx_two, &quot;@&quot;)</span><span class="hljs-regexp"> .replace(rx_three, &quot;]&quot;)</span><span class="hljs-regexp"> .replace(rx_four, &quot;&quot;)</span><span class="hljs-regexp"> )</span><span class="hljs-regexp">) &#123;</span><span class="hljs-regexp"> var obj = eval(&quot;(&quot; +json + &quot;)&quot;);</span><span class="hljs-regexp">&#125;</span></code></pre><h3 id="3-解析-URL-参数为对象"><a href="#3-解析-URL-参数为对象" class="headerlink" title="3 解析 URL 参数为对象"></a>3 解析 URL 参数为对象</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseParam</span>(<span class="hljs-params">url</span>) </span>&#123;<span class="hljs-comment">// 将 ? 后面的字符串取出来</span><span class="hljs-keyword">const</span> paramsStr = <span class="hljs-regexp">/.+\?(.+)$/</span>.exec(url)[<span class="hljs-number">1</span>];<span class="hljs-comment">// 将字符串以 &amp; 分割后存到数组中</span><span class="hljs-keyword">const</span> paramsArr = paramsStr.split(<span class="hljs-string">&#x27;&amp;&#x27;</span>);<span class="hljs-keyword">let</span> paramsObj = &#123;&#125;;<span class="hljs-comment">// 将 params 存到对象中</span>paramsArr.forEach(<span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/=/</span>.test(param)) &#123; <span class="hljs-comment">// 处理有 value 的参数</span> <span class="hljs-comment">// 分割 key 和 value</span><span class="hljs-keyword">let</span> [key, val] = param.split(<span class="hljs-string">&#x27;=&#x27;</span>);val = <span class="hljs-built_in">decodeURIComponent</span>(val); <span class="hljs-comment">// 解码</span><span class="hljs-comment">// 判断是否转为数字</span>val = <span class="hljs-regexp">/^\d+$/</span>.test(val) ? <span class="hljs-built_in">parseFloat</span>(val) : val; <span class="hljs-comment">// 如果对象有 key，则添加一个值</span><span class="hljs-keyword">if</span> (paramsObj.hasOwnProperty(key)) &#123;paramsObj[key] = [].concat(paramsObj[key], val);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 如果对象没有这个 key，创建 key 并设置值</span>paramsObj[key] = val;&#125;&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 处理没有 value 的参数</span>paramsObj[param] = <span class="hljs-literal">true</span>;&#125;&#125;)<span class="hljs-keyword">return</span> paramsObj;&#125;parseParam(<span class="hljs-string">&#x27;www.baidu.com?name=Ronaldo&amp;age=45&amp;contry&#x27;</span>)<span class="hljs-comment">// &#123;</span><span class="hljs-comment">// age: 45</span><span class="hljs-comment">// contry: true</span><span class="hljs-comment">// name: &quot;Ronaldo&quot;</span><span class="hljs-comment">// &#125;</span><span class="hljs-keyword">let</span> url = <span class="hljs-string">&#x27;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&#x27;</span>;parseParam(url)<span class="hljs-comment">/* 结果</span><span class="hljs-comment">&#123; user: &#x27;anonymous&#x27;,</span><span class="hljs-comment">  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span><span class="hljs-comment">  city: &#x27;北京&#x27;, // 中文需解码</span><span class="hljs-comment">  enabled: true, // 未指定值得 key 约定为 true</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span></code></pre><h3 id="4-字符串模板"><a href="#4-字符串模板" class="headerlink" title="4 字符串模板"></a>4 字符串模板</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">template, data</span>) </span>&#123;<span class="hljs-comment">// 模板字符串正则</span><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span>;<span class="hljs-comment">// 判断模板里是否有模板字符串</span><span class="hljs-keyword">if</span> (reg.test(template)) &#123;<span class="hljs-comment">// 查找当前模板里第一个模板字符串的字段</span><span class="hljs-keyword">const</span> name = reg.exec(template)[<span class="hljs-number">1</span>];<span class="hljs-comment">// 将第一个模板字符串渲染</span>template = template.replace(reg, data[name]); <span class="hljs-comment">// 递归的渲染并返回渲染后的结构</span><span class="hljs-keyword">return</span> render(template, data); &#125;<span class="hljs-keyword">return</span> template; <span class="hljs-comment">// 如果模板没有模板字符串直接返回</span>&#125;<span class="hljs-comment">// test</span><span class="hljs-keyword">let</span> template = <span class="hljs-string">&#x27;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&#x27;</span>;<span class="hljs-keyword">let</span> person = &#123;    name: <span class="hljs-string">&#x27;布兰&#x27;</span>,    age: <span class="hljs-number">12</span>&#125;render(template, person); <span class="hljs-comment">// 我是布兰，年龄12，性别undefined</span></code></pre><h3 id="5-转驼峰"><a href="#5-转驼峰" class="headerlink" title="5 转驼峰"></a>5 转驼峰</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 解法一 正则 replace</span><span class="hljs-comment">// 1-1.驼峰式转下横线：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerLine</span>(<span class="hljs-params">str</span>) </span>&#123;<span class="hljs-keyword">var</span> resStr = str.replace(<span class="hljs-regexp">/[A-Z]/g</span>, <span class="hljs-function"><span class="hljs-params">match</span> =&gt;</span> <span class="hljs-string">&quot;_&quot;</span> + match.toLowerCase());<span class="hljs-comment">//如果首字母是大写，执行replace时会多一个_ ,这里需要去掉</span>  <span class="hljs-keyword">if</span>(resStr.slice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) === <span class="hljs-string">&#x27;_&#x27;</span>) &#123; <span class="hljs-comment">// resStr.startsWith(&#x27;_&#x27;)</span>  resStr = resStr.slice(<span class="hljs-number">1</span>);  &#125;<span class="hljs-keyword">return</span> resStr;&#125;;<span class="hljs-comment">// test:</span>toLowerLine(<span class="hljs-string">&quot;TestToLowerLine&quot;</span>);  <span class="hljs-comment">//test_to_lower_line</span>toLowerLine(<span class="hljs-string">&quot;testToLowerLine&quot;</span>);  <span class="hljs-comment">//test_to_lower_line</span><span class="hljs-comment">// 1-2.下横线转驼峰式：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toCamel</span>(<span class="hljs-params">str</span>) </span>&#123;  <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/([^_])(?:_+([^_]))/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">match, $<span class="hljs-number">1</span>, $<span class="hljs-number">2</span></span>) </span>&#123;<span class="hljs-comment">// match=t_b, $1=t, $2=b</span><span class="hljs-comment">// match=e_c, $1=e, $2=c</span><span class="hljs-keyword">return</span> $<span class="hljs-number">1</span> + $<span class="hljs-number">2.</span>toUpperCase();  &#125;);&#125;<span class="hljs-comment">// test</span>toCamel(<span class="hljs-string">&#x27;test_be_camel&#x27;</span>) <span class="hljs-comment">// testBeCamel</span><span class="hljs-comment">// 解法二: reduce</span><span class="hljs-comment">// 2-1.驼峰式转下横线：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerLine</span>(<span class="hljs-params">str</span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.reduce.call(str, <span class="hljs-function">(<span class="hljs-params">pre, cur, index</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span>(<span class="hljs-regexp">/[A-Z]/</span>.test(cur))&#123;cur = cur.toLowerCase();<span class="hljs-keyword">return</span> index === <span class="hljs-number">0</span> ? pre + cur :  pre + <span class="hljs-string">&#x27;_&#x27;</span> + cur&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> pre + cur;&#125;&#125;, <span class="hljs-string">&#x27;&#x27;</span>)&#125;<span class="hljs-comment">// test</span>toLowerLine(<span class="hljs-string">&#x27;TestToLowerLine&#x27;</span>); <span class="hljs-comment">// test_to_lower_line</span><span class="hljs-comment">// 2-2.下横线转驼峰式：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toCamel</span>(<span class="hljs-params">str</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.reduce.call(str, <span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (pre.endsWith(<span class="hljs-string">&#x27;_&#x27;</span>)) &#123;<span class="hljs-keyword">return</span> pre.substring(<span class="hljs-number">0</span>, pre.length - <span class="hljs-number">1</span>) + cur.toUpperCase();&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> pre + cur;&#125;&#125;)&#125;<span class="hljs-comment">// test</span>toCamel(<span class="hljs-string">&#x27;test_to_camel&#x27;</span>); <span class="hljs-comment">// testToCamel</span><span class="hljs-comment">// 解法三: Array.map()</span><span class="hljs-comment">// 3-1.驼峰式转下横线：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerLine</span>(<span class="hljs-params">arr</span>)</span>&#123;<span class="hljs-comment">// return [].map.call(arr, doLowerLine).join(&#x27;&#x27;);</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.map.call(arr, <span class="hljs-function">(<span class="hljs-params">val, index</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span>(<span class="hljs-regexp">/[A-Z]/</span>.test(val))&#123;<span class="hljs-keyword">return</span> index === <span class="hljs-number">0</span> ? val.toLowerCase() : <span class="hljs-string">&#x27;_&#x27;</span> + val.toLowerCase();&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> val;&#125;&#125;).join(<span class="hljs-string">&#x27;&#x27;</span>);&#125;</code></pre><h3 id="6-找到出现次数最多的字符和个数"><a href="#6-找到出现次数最多的字符和个数" class="headerlink" title="6 找到出现次数最多的字符和个数"></a>6 找到出现次数最多的字符和个数</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMore</span>(<span class="hljs-params">str</span>) </span>&#123;<span class="hljs-comment">// str = &quot;abcabcabcbbccccc&quot;</span><span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> char = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-comment">// 使其按照一定的次序排列</span>str = str.split(<span class="hljs-string">&#x27;&#x27;</span>).sort().join(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-comment">// str = &quot;aaabbbbbcccccccc&quot;</span><span class="hljs-comment">// 定义正则表达式</span><span class="hljs-keyword">let</span> re = <span class="hljs-regexp">/(\w)\1+/g</span>;str.replace(re,<span class="hljs-function">(<span class="hljs-params">$<span class="hljs-number">0</span>,$<span class="hljs-number">1</span></span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span>(num &lt; $<span class="hljs-number">0.</span>length)&#123;num = $<span class="hljs-number">0.</span>length;char = $<span class="hljs-number">1</span>;        &#125;&#125;);<span class="hljs-keyword">return</span> &#123;num,char,&#125;&#125;</code></pre><h3 id="7-切花字符串大小写"><a href="#7-切花字符串大小写" class="headerlink" title="7 切花字符串大小写"></a>7 切花字符串大小写</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">caseConvert</span>(<span class="hljs-params">str</span>)</span>&#123;   <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/([a-z]*)([A-Z]*)/g</span>, <span class="hljs-function">(<span class="hljs-params">m, s1, s2</span>)=&gt;</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;s1.toUpperCase()&#125;</span><span class="hljs-subst">$&#123;s2.toLowerCase()&#125;</span>`</span>   &#125;)&#125;caseConvert(<span class="hljs-string">&#x27;AsA33322A2aa&#x27;</span>) <span class="hljs-comment">//aSa33322a2AA</span></code></pre><h3 id="8-去掉字符串中的空格"><a href="#8-去掉字符串中的空格" class="headerlink" title="8 去掉字符串中的空格"></a>8 去掉字符串中的空格</h3><pre><code class="hljs javaScript"> <span class="hljs-keyword">const</span> POSITION = <span class="hljs-built_in">Object</span>.freeze(&#123;  left: <span class="hljs-built_in">Symbol</span>(), <span class="hljs-comment">// 左</span>  right: <span class="hljs-built_in">Symbol</span>(), <span class="hljs-comment">// 右</span>  both: <span class="hljs-built_in">Symbol</span>(), <span class="hljs-comment">// 左右</span>  center: <span class="hljs-built_in">Symbol</span>(), <span class="hljs-comment">// 中间</span>  all: <span class="hljs-built_in">Symbol</span>(), <span class="hljs-comment">// 全部</span>&#125;) <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trim</span>(<span class="hljs-params">str, position = POSITION.both</span>) </span>&#123;<span class="hljs-keyword">if</span> (!!POSITION[position]) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;unexpected position value&#x27;</span>)<span class="hljs-keyword">switch</span>(position) &#123;<span class="hljs-keyword">case</span>(POSITION.left):str = str.replace(<span class="hljs-regexp">/^\s+/</span>, <span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span>(POSITION.right):str = str.replace(<span class="hljs-regexp">/\s+$/</span>, <span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span>(POSITION.both):str = str.replace(<span class="hljs-regexp">/^\s+/</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-regexp">/\s+$/</span>, <span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span>(POSITION.center):<span class="hljs-keyword">while</span> (str.match(<span class="hljs-regexp">/\w\s+\w/</span>)) &#123;str = str.replace(<span class="hljs-regexp">/(\w)(\s+)(\w)/</span>, <span class="hljs-string">`$1$3`</span>)&#125;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span>(POSITION.all):str = str.replace(<span class="hljs-regexp">/\s/g</span>, <span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>: &#125;<span class="hljs-keyword">return</span> str;&#125;<span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;  s t  r  &#x27;</span><span class="hljs-keyword">const</span> result = trim(str)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`|<span class="hljs-subst">$&#123;result&#125;</span>|`</span>) <span class="hljs-comment">//  |s t  r| </span></code></pre><h2 id="三-Object"><a href="#三-Object" class="headerlink" title="三 Object"></a>三 Object</h2><p>1 Symbol（for…in/of）<br>2 继承<br>3 双向绑定<br>4 发布订阅模式<br>5 观察者模式<br>6 Object.assign<br>7 EventEmitter</p><h3 id="1-Symbol（for…in-of）"><a href="#1-Symbol（for…in-of）" class="headerlink" title="1 Symbol（for…in/of）"></a>1 Symbol（for…in/of）</h3><p>Symbol: 可以用来表示一个独一无二的变量防止命名冲突.</p><p>Symbol作用：</p><ol><li>还可以利用 symbol 不会被常规的方法（除了 <code>Object.getOwnPropertySymbols</code> 外）遍历到，所以可以用来模拟私有变量。</li><li>用来提供遍历接口，布置了 <code>symbol.iterator</code> 的对象才可以使用 <code>for···of</code> 循环，可以统一处理数据结构。<br>调用之后回返回一个遍历器对象，包含有一个 next 方法，使用 next 方法后有两个返回值 value 和 done 分别表示函数当前执行位置的值和是否遍历完毕。</li></ol><p><code>Symbol.for()</code> 可以在全局访问 symbol</p><ul><li>for……in : 遍历 key,</li><li>for……of : 遍历 value,</li></ul><p>ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性。或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。<br>Symbol.iterator 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。</p><p>因为object 没有 Symbol.iterator 属性，所以不能被 for…of 遍历。</p><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> text = &#123;a: <span class="hljs-number">1</span>,b: <span class="hljs-number">2</span>,c:<span class="hljs-number">3</span>&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> text)&#123;<span class="hljs-built_in">console</span>.log(i) <span class="hljs-comment">// 报错：Uncaught TypeError: text is not iterable</span>&#125;</code></pre><p>所以，object想要被 for…of遍历 ，必须在原来的基础上加上 Symbol.iterator 接口属性。</p><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> text = &#123;a: <span class="hljs-number">1</span>,b: <span class="hljs-number">2</span>,c: <span class="hljs-number">3</span>,&#125;;<span class="hljs-comment">// 给对象加上 iterator 接口,使之能被 for…of 遍历</span>text[<span class="hljs-built_in">Symbol</span>.iterator] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">const</span> _this = <span class="hljs-built_in">this</span>;<span class="hljs-keyword">return</span> &#123;index: -<span class="hljs-number">1</span>,<span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Object</span>.keys(_this);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.index &lt; arr.length)&#123;<span class="hljs-built_in">this</span>.index++;<span class="hljs-keyword">return</span> &#123;value: _this[arr[<span class="hljs-built_in">this</span>.index]],done: <span class="hljs-literal">false</span>,&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> &#123;value: <span class="hljs-literal">undefined</span>,done: <span class="hljs-literal">true</span>,&#125;&#125;&#125;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> text)&#123;<span class="hljs-built_in">console</span>.log(i) <span class="hljs-comment">// 1 2 3 undefined</span>&#125;</code></pre><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2 继承"></a>2 继承</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 1 原型链继承</span><span class="hljs-comment">// 缺点：</span><span class="hljs-comment">// 问题1：原型中包含的引用类型属性将被所有实例共享；</span><span class="hljs-comment">// 问题2：子类在实例化的时候不能给父类构造函数传参；</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&#x27;black&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>]&#125;Animal.prototype.getColor = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.colors&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dog</span>(<span class="hljs-params"></span>) </span>&#123;&#125;Dog.prototype =  <span class="hljs-keyword">new</span> Animal()<span class="hljs-keyword">let</span> dog1 = <span class="hljs-keyword">new</span> Dog()dog1.colors.push(<span class="hljs-string">&#x27;brown&#x27;</span>)<span class="hljs-keyword">let</span> dog2 = <span class="hljs-keyword">new</span> Dog()<span class="hljs-built_in">console</span>.log(dog2.colors)  <span class="hljs-comment">// [&#x27;black&#x27;, &#x27;white&#x27;, &#x27;brown&#x27;]</span><span class="hljs-comment">// 2 借用构造函数实现继承</span><span class="hljs-comment">// 借用构造函数实现继承解决了原型链继承的 2 个问题:</span><span class="hljs-comment">// 引用类型共享问题以及传参问题。</span><span class="hljs-comment">// 但是由于方法必须定义在构造函数中，所以会导致每次创建子类实例都会创建一遍方法。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span>(<span class="hljs-params">name</span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name<span class="hljs-built_in">this</span>.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dog</span>(<span class="hljs-params">name</span>) </span>&#123;Animal.call(<span class="hljs-built_in">this</span>, name)&#125;Dog.prototype =  <span class="hljs-keyword">new</span> Animal()<span class="hljs-comment">// 3 组合继承</span><span class="hljs-comment">// 组合继承结合了原型链和盗用构造函数，将两者的优点集中了起来。</span><span class="hljs-comment">// 基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。</span><span class="hljs-comment">// 这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span>(<span class="hljs-params">name</span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name<span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&#x27;black&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>]&#125;Animal.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dog</span>(<span class="hljs-params">name, age</span>) </span>&#123;Animal.call(<span class="hljs-built_in">this</span>, name)<span class="hljs-built_in">this</span>.age = age&#125;Dog.prototype = <span class="hljs-keyword">new</span> Animal()Dog.prototype.constructor = Dog<span class="hljs-keyword">let</span> dog1 = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&#x27;奶昔&#x27;</span>, <span class="hljs-number">2</span>)dog1.colors.push(<span class="hljs-string">&#x27;brown&#x27;</span>)<span class="hljs-keyword">let</span> dog2 = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&#x27;哈赤&#x27;</span>, <span class="hljs-number">1</span>)<span class="hljs-built_in">console</span>.log(dog2) <span class="hljs-comment">// &#123; name: &quot;哈赤&quot;, colors: [&quot;black&quot;, &quot;white&quot;], age: 1 &#125;</span><span class="hljs-comment">// 4 寄生式组合继承</span><span class="hljs-comment">// 组合继承已经相对完善了，但还是存在问题:</span><span class="hljs-comment">// 它的问题就是调用了 2 次父类构造函数，第一次是在 new Animal()，第二次是在 Animal.call() 这里。</span><span class="hljs-comment">// 所以解决方案就是不直接调用父类构造函数给子类原型赋值，而是通过创建空函数 F 获取父类原型的副本。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span>(<span class="hljs-params">name</span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name<span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&#x27;black&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>]&#125;Animal.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dog</span>(<span class="hljs-params">name, age</span>) </span>&#123;Animal.call(<span class="hljs-built_in">this</span>, name)<span class="hljs-built_in">this</span>.age = age&#125;Dog.prototype =  <span class="hljs-built_in">Object</span>.create(Animal.prototype)Dog.prototype.constructor = Dog<span class="hljs-keyword">let</span> dog1 = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&#x27;奶昔&#x27;</span>, <span class="hljs-number">2</span>)dog1.colors.push(<span class="hljs-string">&#x27;brown&#x27;</span>)<span class="hljs-keyword">let</span> dog2 = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&#x27;哈赤&#x27;</span>, <span class="hljs-number">1</span>)<span class="hljs-built_in">console</span>.log(dog2) <span class="hljs-comment">// &#123; name: &quot;哈赤&quot;, colors: [&quot;black&quot;, &quot;white&quot;], age: 1 &#125;</span></code></pre><h3 id="3-双向绑定"><a href="#3-双向绑定" class="headerlink" title="3 双向绑定"></a>3 双向绑定</h3><pre><code class="hljs javaScript">&lt;body&gt;&lt;input type=<span class="hljs-string">&quot;text&quot;</span> id=<span class="hljs-string">&quot;model&quot;</span> /&gt;&lt;div id=<span class="hljs-string">&quot;modelText&quot;</span>&gt;&lt;/div&gt;&lt;/body&gt;<span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> user = &#123;name: <span class="hljs-string">&#x27;aaaa&#x27;</span>&#125;;<span class="hljs-keyword">var</span> input = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#model&quot;</span>);<span class="hljs-keyword">var</span> text = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#modelText&quot;</span>);input.value = user.name;text.textContent = user.name;<span class="hljs-comment">// 数据到视图 model =&gt; view</span><span class="hljs-built_in">Object</span>.defineProperty(user, <span class="hljs-string">&quot;name&quot;</span>, &#123;get:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;获取user&#x27;</span>)&#125;,set:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;修改user&#x27;</span>)input.value = val;text.textContent = val;&#125;&#125;)<span class="hljs-comment">// 视图到数据 view =&gt; model (可以监听 input 和 keyup)</span>input.addEventListener(<span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;user.name = input.value;&#125;)<span class="hljs-comment">// 输入框发生的事件流程依次为</span><span class="hljs-comment">// focus -&gt; keydown -&gt; input -&gt; keyup -&gt; change -&gt; blur</span>&#125;</code></pre><blockquote><p><a href="https://blog.csdn.net/weixin_39516865/article/details/111388183">手写bind_手写JavaScript几个方法</a><br><a href="https://github.com/YvetteLau/Blog/issues/35">github-blog</a></p></blockquote><h3 id="4-发布订阅模式"><a href="#4-发布订阅模式" class="headerlink" title="4 发布订阅模式"></a>4 发布订阅模式</h3><pre><code class="hljs javaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventEmitter</span> </span>&#123;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-built_in">this</span>.cache = &#123;&#125;;    &#125;    <span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">name, fn</span>)</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.cache[name]) &#123;            <span class="hljs-built_in">this</span>.cache[name].push(fn);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">this</span>.cache[name] = [fn];        &#125;    &#125;    <span class="hljs-function"><span class="hljs-title">off</span>(<span class="hljs-params">name, fn</span>)</span> &#123;        <span class="hljs-keyword">let</span> tasks = <span class="hljs-built_in">this</span>.cache[name];        <span class="hljs-keyword">if</span> (tasks) &#123;            <span class="hljs-keyword">const</span> index = tasks.findIndex(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> f === fn || f.callback === fn)            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;                tasks.splice(index, <span class="hljs-number">1</span>)            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-title">emit</span>(<span class="hljs-params">name, once = <span class="hljs-literal">false</span>, ...args</span>)</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.cache[name]) &#123;            <span class="hljs-comment">// 创建副本，如果回调函数内继续注册相同事件，会造成死循环</span>            <span class="hljs-keyword">let</span> tasks = <span class="hljs-built_in">this</span>.cache[name].slice()            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> fn <span class="hljs-keyword">of</span> tasks) &#123;               fn(...args)            &#125;            <span class="hljs-keyword">if</span> (once) &#123;               <span class="hljs-keyword">delete</span> <span class="hljs-built_in">this</span>.cache[name]            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">// 测试</span><span class="hljs-keyword">let</span> eventBus = <span class="hljs-keyword">new</span> EventEmitter()<span class="hljs-keyword">let</span> fn1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, age</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span> <span class="hljs-subst">$&#123;age&#125;</span>`</span>)&#125;<span class="hljs-keyword">let</span> fn2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, age</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`hello, <span class="hljs-subst">$&#123;name&#125;</span> <span class="hljs-subst">$&#123;age&#125;</span>`</span>)&#125;eventBus.on(<span class="hljs-string">&#x27;aaa&#x27;</span>, fn1)eventBus.on(<span class="hljs-string">&#x27;aaa&#x27;</span>, fn2)eventBus.emit(<span class="hljs-string">&#x27;aaa&#x27;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&#x27;布兰&#x27;</span>, <span class="hljs-number">12</span>)<span class="hljs-comment">// &#x27;布兰 12&#x27;</span><span class="hljs-comment">// &#x27;hello, 布兰 12&#x27;</span></code></pre><h3 id="5-观察者模式"><a href="#5-观察者模式" class="headerlink" title="5 观察者模式"></a>5 观察者模式</h3><pre><code class="hljs javaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span></span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span>&#123;<span class="hljs-built_in">this</span>.name = name<span class="hljs-built_in">this</span>.observers = []<span class="hljs-built_in">this</span>.state = <span class="hljs-string">&#x27;XXXX&#x27;</span>&#125;<span class="hljs-comment">// 被观察者要提供一个接受观察者的方法</span><span class="hljs-function"><span class="hljs-title">attach</span>(<span class="hljs-params">observer</span>)</span>&#123;<span class="hljs-built_in">this</span>.observers.push(observer)&#125;<span class="hljs-comment">// 改变被观察着的状态</span><span class="hljs-function"><span class="hljs-title">setState</span>(<span class="hljs-params">newState</span>)</span>&#123;<span class="hljs-built_in">this</span>.state = newState<span class="hljs-built_in">this</span>.observers.forEach(<span class="hljs-function"><span class="hljs-params">o</span>=&gt;</span>&#123;o.update(newState)&#125;)&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span></span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span>&#123;<span class="hljs-built_in">this</span>.name = name&#125;<span class="hljs-function"><span class="hljs-title">update</span>(<span class="hljs-params">newState</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>say:<span class="hljs-subst">$&#123;newState&#125;</span>`</span>)&#125;&#125;<span class="hljs-comment">// 被观察者 灯</span><span class="hljs-keyword">let</span> sub = <span class="hljs-keyword">new</span> Subject(<span class="hljs-string">&#x27;灯&#x27;</span>)<span class="hljs-keyword">let</span> mm = <span class="hljs-keyword">new</span> Observer(<span class="hljs-string">&#x27;小明&#x27;</span>)<span class="hljs-keyword">let</span> jj = <span class="hljs-keyword">new</span> Observer(<span class="hljs-string">&#x27;小健&#x27;</span>) <span class="hljs-comment">// 订阅 观察者</span>sub.attach(mm)sub.attach(jj) sub.setState(<span class="hljs-string">&#x27;灯亮了来电了&#x27;</span>)</code></pre><h3 id="6-Object-assign"><a href="#6-Object-assign" class="headerlink" title="6 Object.assign"></a>6 Object.assign</h3><pre><code class="hljs javaScript"><span class="hljs-built_in">Object</span>.assign2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, ...source</span>) </span>&#123;<span class="hljs-keyword">if</span> (target == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Cannot convert undefined or null to object&#x27;</span>)&#125;<span class="hljs-keyword">let</span> ret = <span class="hljs-built_in">Object</span>(target);source.forEach(<span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (obj != <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<span class="hljs-keyword">if</span> (obj.hasOwnProperty(key)) &#123;ret[key] = obj[key]&#125;&#125;&#125;&#125;)<span class="hljs-keyword">return</span> ret;&#125;</code></pre><h3 id="7-EventEmitter"><a href="#7-EventEmitter" class="headerlink" title="7 EventEmitter"></a>7 EventEmitter</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 发布订阅模式</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventEmitter</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-comment">// 事件对象，存放订阅的名字和事件  如:  &#123; click: [ handle1, handle2 ]  &#125;</span><span class="hljs-built_in">this</span>.events = &#123;&#125;;&#125;<span class="hljs-comment">// 订阅事件的方法</span><span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">eventName, callback</span>)</span> &#123;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.events[eventName]) &#123;<span class="hljs-comment">// 一个名字可以订阅多个事件函数</span><span class="hljs-built_in">this</span>.events[eventName] = [callback];&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 存在则push到指定数组的尾部保存</span><span class="hljs-built_in">this</span>.events[eventName].push(callback);&#125;&#125;<span class="hljs-comment">// 触发事件的方法</span><span class="hljs-function"><span class="hljs-title">emit</span>(<span class="hljs-params">eventName, ...rest</span>)</span> &#123;<span class="hljs-comment">// 遍历执行所有订阅的事件</span><span class="hljs-built_in">this</span>.events[eventName] &amp;&amp;<span class="hljs-built_in">this</span>.events[eventName].forEach(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> f.apply(<span class="hljs-built_in">this</span>, rest));&#125;<span class="hljs-comment">// 移除订阅事件</span><span class="hljs-function"><span class="hljs-title">remove</span>(<span class="hljs-params">eventName, callback</span>)</span> &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.events[eventName]) &#123;<span class="hljs-built_in">this</span>.events[eventName] = <span class="hljs-built_in">this</span>.events[eventName].filter(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> f != callback);&#125;&#125;<span class="hljs-comment">// 只执行一次订阅的事件，然后移除</span><span class="hljs-function"><span class="hljs-title">once</span>(<span class="hljs-params">eventName, callback</span>)</span> &#123;<span class="hljs-comment">// 绑定的时fn, 执行的时候会触发fn函数</span><span class="hljs-keyword">const</span> fn = <span class="hljs-function">(<span class="hljs-params">...rest</span>) =&gt;</span> &#123;callback.apply(<span class="hljs-built_in">this</span>, rest) <span class="hljs-comment">// fn函数中调用原有的callback</span><span class="hljs-built_in">this</span>.remove(eventName, fn) <span class="hljs-comment">// 删除fn, 再次执行的时候之后执行一次</span>&#125;<span class="hljs-built_in">this</span>.on(eventName, fn)&#125;&#125;<span class="hljs-comment">// test1</span><span class="hljs-keyword">const</span> event = <span class="hljs-keyword">new</span> EventEmitter()<span class="hljs-keyword">const</span> handle = <span class="hljs-function">(<span class="hljs-params">...pyload</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(pyload)event.on(<span class="hljs-string">&#x27;click&#x27;</span>, handle)event.emit(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">100</span>)event.remove(<span class="hljs-string">&#x27;click&#x27;</span>, handle)event.once(<span class="hljs-string">&#x27;dbclick&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;click&#x27;</span>)&#125;)event.emit(<span class="hljs-string">&#x27;dbclick&#x27;</span>, <span class="hljs-number">100</span>);<span class="hljs-comment">// test 2</span><span class="hljs-keyword">let</span> event = <span class="hljs-keyword">new</span> EventEmitter();event.on(<span class="hljs-string">&#x27;say&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(str);&#125;);event.once(<span class="hljs-string">&#x27;say&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;这是once:&#x27;</span> + str)&#125;)event.emit(<span class="hljs-string">&#x27;say&#x27;</span>,<span class="hljs-string">&#x27;visa&#x27;</span>);event.emit(<span class="hljs-string">&#x27;say&#x27;</span>,<span class="hljs-string">&#x27;visa222&#x27;</span>);event.emit(<span class="hljs-string">&#x27;say&#x27;</span>,<span class="hljs-string">&#x27;visa333&#x27;</span>);</code></pre><h2 id="四-Promise"><a href="#四-Promise" class="headerlink" title="四 Promise"></a>四 Promise</h2><p>1 手写promise<br>2 实现promise串行<br>3 实现Promise并发调度<br>4 JavaScript并发控制<br>5 手写generator<br>6 用 setTimeout 模拟 setInterval</p><h3 id="1-Promise"><a href="#1-Promise" class="headerlink" title="1 Promise"></a>1 Promise</h3><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> STATUS = &#123;PENDING: <span class="hljs-string">&#x27;pending&#x27;</span>,FULFILLED: <span class="hljs-string">&#x27;fulfilled&#x27;</span>,REJECTED: <span class="hljs-string">&#x27;rejected&#x27;</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">executor</span>)</span> &#123;<span class="hljs-built_in">this</span>._status = STATUS.PENDING; <span class="hljs-comment">// Promise初始状态</span><span class="hljs-built_in">this</span>._value = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// then回调的值</span><span class="hljs-built_in">this</span>._resolveQueue = []; <span class="hljs-comment">// resolve时触发的成功队列</span><span class="hljs-built_in">this</span>._rejectQueue = []; <span class="hljs-comment">// reject时触发的失败队列</span><span class="hljs-comment">// 使用箭头函数固定this（resolve函数在executor中触发，不然找不到this）</span><span class="hljs-keyword">const</span> resolve = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<span class="hljs-keyword">const</span> run = <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// Promise/A+ 规范规定的Promise状态只能从pending触发，变成fulfilled</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._status === STATUS.PENDING) &#123;<span class="hljs-built_in">this</span>._status = STATUS.FULFILLED; <span class="hljs-comment">// 更改状态</span><span class="hljs-built_in">this</span>._value = value; <span class="hljs-comment">// 储存当前值，用于then回调</span><span class="hljs-comment">// 执行resolve回调</span><span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>._resolveQueue.length) &#123;<span class="hljs-keyword">const</span> callback = <span class="hljs-built_in">this</span>._resolveQueue.shift();callback(value);&#125;&#125;&#125;<span class="hljs-comment">// 把resolve执行回调的操作封装成一个函数,放进setTimeout里</span><span class="hljs-comment">// 以实现promise异步调用的特性（规范上是微任务，这里是宏任务）</span><span class="hljs-built_in">setTimeout</span>(run);&#125;<span class="hljs-comment">// 同 resolve</span><span class="hljs-keyword">const</span> reject = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<span class="hljs-keyword">const</span> run = <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._status === STATUS.PENDING) &#123;<span class="hljs-built_in">this</span>._status = STATUS.REJECTED;<span class="hljs-built_in">this</span>._value = value;<span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>._rejectQueue.length) &#123;<span class="hljs-keyword">const</span> callback = <span class="hljs-built_in">this</span>._rejectQueue.shift();callback(value);&#125;&#125;&#125;<span class="hljs-built_in">setTimeout</span>(run);&#125;<span class="hljs-comment">// new Promise()时立即执行executor,并传入resolve和reject</span>executor(resolve, reject);&#125; <span class="hljs-comment">// then方法,接收一个成功的回调和一个失败的回调</span><span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>)</span> &#123;<span class="hljs-comment">// 根据规范，如果then的参数不是function，则忽略它, 让值继续往下传递，链式调用继续往下执行</span><span class="hljs-keyword">typeof</span> onFulfilled !== <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value : <span class="hljs-literal">null</span>;<span class="hljs-keyword">typeof</span> onRejected !== <span class="hljs-string">&#x27;function&#x27;</span> ? onRejected = <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> error : <span class="hljs-literal">null</span>;<span class="hljs-comment">// then 返回一个新的promise</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> resolveFn = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">const</span> res = onFulfilled(value);<span class="hljs-comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span>res <span class="hljs-keyword">instanceof</span> MyPromise ? res.then(resolve, reject) : resolve(res);&#125; <span class="hljs-keyword">catch</span> (error) &#123;reject(error);&#125;&#125;<span class="hljs-keyword">const</span> rejectFn = <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">const</span> res = onRejected(error);res <span class="hljs-keyword">instanceof</span> MyPromise ? res.then(resolve, reject) : resolve(res);&#125; <span class="hljs-keyword">catch</span> (error) &#123;reject(error);&#125;&#125;<span class="hljs-keyword">switch</span> (<span class="hljs-built_in">this</span>._status) &#123;<span class="hljs-keyword">case</span> STATUS.PENDING:<span class="hljs-built_in">this</span>._resolveQueue.push(resolveFn);<span class="hljs-built_in">this</span>._rejectQueue.push(rejectFn);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> STATUS.FULFILLED:resolveFn(<span class="hljs-built_in">this</span>._value);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> STATUS.REJECTED:rejectFn(<span class="hljs-built_in">this</span>._value);<span class="hljs-keyword">break</span>;&#125;&#125;)&#125; <span class="hljs-keyword">catch</span>(rejectFn) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<span class="hljs-literal">undefined</span>, rejectFn);&#125; <span class="hljs-function"><span class="hljs-title">finally</span>(<span class="hljs-params">callback</span>)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> MyPromise.resolve(callback()).then(<span class="hljs-function">() =&gt;</span> value), <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;MyPromise.resolve(callback()).then(<span class="hljs-function">() =&gt;</span> error);  &#125;)&#125; <span class="hljs-comment">// 静态resolve方法</span><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>)</span> &#123;<span class="hljs-keyword">return</span> value <span class="hljs-keyword">instanceof</span> MyPromise ? value : <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> resolve(value));&#125; <span class="hljs-comment">// 静态reject方法</span><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">reject</span>(<span class="hljs-params">error</span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> reject(error));&#125; <span class="hljs-comment">// 静态all方法</span><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">all</span>(<span class="hljs-params">promiseArr</span>)</span> &#123;<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> result = [];<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!promiseArr.length) &#123;<span class="hljs-keyword">return</span> resolve(result);&#125;promiseArr.forEach(<span class="hljs-function">(<span class="hljs-params">p, i</span>) =&gt;</span> &#123;MyPromise.resolve(p).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;count++;result[i] = value;<span class="hljs-keyword">if</span> (count === promiseArr.length) &#123;resolve(result);&#125;&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;reject(error);&#125;)&#125;)&#125;)&#125; <span class="hljs-comment">// 静态race方法</span><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">race</span>(<span class="hljs-params">promiseArr</span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;promiseArr.forEach(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> &#123;MyPromise.resolve(p).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;resolve(value);&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;reject(error);&#125;)&#125;)&#125;)&#125;&#125;</code></pre><pre><code class="hljs javaScript"><span class="hljs-built_in">Promise</span>.all = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">iterator</span>) </span>&#123;<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> iterator)&#123;<span class="hljs-comment">// 先转化为Promise对象</span><span class="hljs-built_in">Promise</span>.resolve(iterator[i]).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;res[i] = data;<span class="hljs-keyword">if</span>(++count === iterator.length)&#123;resolve(res);&#125;&#125;).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;reject(e);&#125;)&#125;&#125;)&#125;<span class="hljs-built_in">Promise</span>.all = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">iterators</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!iterators || iterators.length === <span class="hljs-number">0</span>) &#123;resolve([]);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 计数器，用于判断所有任务是否执行完成</span><span class="hljs-keyword">let</span> result = []; <span class="hljs-comment">// 结果数组</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; iterators.length; i++) &#123;<span class="hljs-comment">// 考虑到iterators[i]可能是普通对象，则统一包装为Promise对象</span><span class="hljs-built_in">Promise</span>.resolve(iterators[i]).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;result[i] = data; <span class="hljs-comment">// 按顺序保存对应的结果</span><span class="hljs-comment">// 当所有任务都执行完成后，再统一返回结果</span><span class="hljs-keyword">if</span> (++count === iterators.length) &#123;resolve(result);&#125;&#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;reject(err); <span class="hljs-comment">// 任何一个Promise对象执行失败，则调用reject()方法</span><span class="hljs-keyword">return</span>;&#125;);&#125;&#125;&#125;);&#125;;<span class="hljs-built_in">Promise</span>.race = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">iterators</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> p <span class="hljs-keyword">of</span> iterators) &#123;<span class="hljs-built_in">Promise</span>.resolve(p).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;resolve(res)&#125;).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;reject(e)&#125;)&#125;&#125;)&#125;<span class="hljs-comment">// 1 空数组或者所有 Promise 都是 rejected</span><span class="hljs-comment">// 则返回状态是 rejected 的新 Promsie，且值为 AggregateError 的错误；</span><span class="hljs-comment">// 2 只要有一个是 fulfilled 状态的，则返回第一个是 fulfilled 的新实例；</span><span class="hljs-comment">// 3 其他情况都会返回一个 pending 的新实例</span><span class="hljs-built_in">Promise</span>.any = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promiseArr</span>) </span>&#123;    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (promiseArr.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>         promiseArr.forEach(<span class="hljs-function">(<span class="hljs-params">p, i</span>) =&gt;</span> &#123;            <span class="hljs-built_in">Promise</span>.resolve(p).then(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;                resolve(val)                            &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;                index++                <span class="hljs-keyword">if</span> (index === promiseArr.length) &#123;                  reject(<span class="hljs-keyword">new</span> AggregateError(<span class="hljs-string">&#x27;All promises were rejected&#x27;</span>))                &#125;            &#125;)        &#125;)    &#125;)&#125;<span class="hljs-comment">// 1 所有 Promise 的状态都变化了，那么新返回一个状态是 fulfilled 的 Promise</span><span class="hljs-comment">//   且它的值是一个数组，数组的每项由所有 Promise 的值和状态组成的对象；</span><span class="hljs-comment">// 2 如果有一个是 pending 的 Promise，则返回一个状态是 pending 的新实例；</span><span class="hljs-built_in">Promise</span>.allSettled = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promiseArr</span>) </span>&#123;<span class="hljs-keyword">let</span> result = []<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;promiseArr.forEach(<span class="hljs-function">(<span class="hljs-params">p, i</span>) =&gt;</span> &#123;<span class="hljs-built_in">Promise</span>.resolve(p).then(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;result.push(&#123;status: <span class="hljs-string">&#x27;fulfilled&#x27;</span>,value: val&#125;)<span class="hljs-keyword">if</span> (result.length === promiseArr.length) &#123;resolve(result) &#125;&#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;result.push(&#123;status: <span class="hljs-string">&#x27;rejected&#x27;</span>,reason: err&#125;)<span class="hljs-keyword">if</span> (result.length === promiseArr.length) &#123;resolve(result) &#125;&#125;)&#125;)  &#125;)   &#125;<span class="hljs-comment">// promise 串行</span><span class="hljs-comment">// create Promise</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPromise</span>(<span class="hljs-params">time</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;time in&#x27;</span> + time)            resolve();        &#125;, time * <span class="hljs-number">1000</span>)    &#125;)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iteratorPromise</span>(<span class="hljs-params">arr</span>) </span>&#123;arr.reduce(<span class="hljs-function">(<span class="hljs-params">pre, next, index, carr</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> pre.then(next)&#125;, <span class="hljs-built_in">Promise</span>.resolve())&#125;<span class="hljs-keyword">var</span> arr = [createPromise(<span class="hljs-number">1</span>), createPromise(<span class="hljs-number">3</span>), createPromise(<span class="hljs-number">2</span>), createPromise(<span class="hljs-number">4</span>)]iteratorPromise(arr);</code></pre><h3 id="2-实现一个串行promise"><a href="#2-实现一个串行promise" class="headerlink" title="2 实现一个串行promise"></a>2 实现一个串行promise</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPromise</span>(<span class="hljs-params">time</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;time in&#x27;</span> + time)            resolve();        &#125;, time * <span class="hljs-number">1000</span>)    &#125;)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iteratorPromise</span>(<span class="hljs-params">arr</span>) </span>&#123;arr.reduce(<span class="hljs-function">(<span class="hljs-params">pre, next, index, carr</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> pre.then(next)&#125;, <span class="hljs-built_in">Promise</span>.resolve())&#125;<span class="hljs-keyword">var</span> arr = [createPromise(<span class="hljs-number">1</span>), createPromise(<span class="hljs-number">3</span>), createPromise(<span class="hljs-number">2</span>), createPromise(<span class="hljs-number">4</span>)]iteratorPromise(arr);</code></pre><h3 id="3-promise-并发调度"><a href="#3-promise-并发调度" class="headerlink" title="3 promise 并发调度"></a>3 promise 并发调度</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 实现一个并发请求的函数</span><span class="hljs-keyword">var</span> jsonArr = [<span class="hljs-string">&#x27;api1.json&#x27;</span>, <span class="hljs-string">&#x27;api2.json&#x27;</span>, <span class="hljs-string">&#x27;api3.json&#x27;</span>, <span class="hljs-string">&#x27;api4.json&#x27;</span>, <span class="hljs-string">&#x27;api5.json&#x27;</span>, <span class="hljs-string">&#x27;api6.json&#x27;</span>]fetchAll(jsonArr, <span class="hljs-number">2</span>).then(<span class="hljs-function">(<span class="hljs-params">[res1, res2, res3, res4, res5, res6]</span>) =&gt;</span> &#123;&#125;)<span class="hljs-comment">// 其中 jsonArr 为包含需要请求接口名的数组，limit 为最大并发请求数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchAll</span>(<span class="hljs-params">jsonArr, limit</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<span class="hljs-comment">// 结果</span><span class="hljs-keyword">let</span> resList = [];<span class="hljs-comment">// 当前正在执行的并发任务队列</span><span class="hljs-keyword">const</span> currPList = [];<span class="hljs-keyword">let</span> i = jsonArr.length - <span class="hljs-number">1</span>;<span class="hljs-comment">// 调度任务队列</span><span class="hljs-keyword">const</span> fetcher = <span class="hljs-keyword">async</span> () =&gt; &#123;<span class="hljs-keyword">while</span>(jsonArr.length &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">let</span> j = i = i - <span class="hljs-number">1</span>;resList[j] = <span class="hljs-keyword">await</span> fetch(jsonArr.shift());&#125;&#125;<span class="hljs-comment">// 线程池</span><span class="hljs-keyword">while</span>(limit) &#123;--limit;<span class="hljs-comment">// 控制当前并发调度队列只有2个</span>currPList.push(fetcher());&#125;<span class="hljs-comment">// 让2个并发队列同时执行</span><span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(currPList);resolve(resList);&#125;);&#125;</code></pre><h3 id="4-JavaScript-并发调度"><a href="#4-JavaScript-并发调度" class="headerlink" title="4 JavaScript 并发调度"></a>4 JavaScript 并发调度</h3><p>该函数接收 3 个参数：</p><ul><li>poolLimit（数字类型）：表示限制的并发数；</li><li>array（数组类型）：表示任务数组；</li><li>iteratorFn（函数类型）：表示迭代函数，用于实现对每个任务项进行处理，该函数会返回一个 Promise 对象或异步函数。</li></ul><pre><code class="hljs javaScript"><span class="hljs-comment">// ES6 版本实现</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncPool</span>(<span class="hljs-params">poolLimit, array, iteratorFn</span>) </span>&#123;<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> ret = []; <span class="hljs-comment">// 存储所有的异步任务</span><span class="hljs-keyword">const</span> executing = []; <span class="hljs-comment">// 存储正在执行的异步任务</span><span class="hljs-keyword">const</span> enqueue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">if</span> (i === array.length) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve();&#125;<span class="hljs-keyword">const</span> item = array[i++]; <span class="hljs-comment">// 获取新的任务项</span><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> iteratorFn(item, array));ret.push(p);<span class="hljs-keyword">let</span> r = <span class="hljs-built_in">Promise</span>.resolve();<span class="hljs-comment">// 当poolLimit值小于或等于总任务个数时，进行并发控制</span><span class="hljs-keyword">if</span> (poolLimit &lt;= array.length) &#123;<span class="hljs-comment">// 当任务完成后，从正在执行的任务数组中移除已完成的任务</span><span class="hljs-keyword">const</span> e = p.then(<span class="hljs-function">() =&gt;</span> executing.splice(executing.indexOf(e), <span class="hljs-number">1</span>));executing.push(e);<span class="hljs-keyword">if</span> (executing.length &gt;= poolLimit) &#123;r = <span class="hljs-built_in">Promise</span>.race(executing); &#125;&#125;<span class="hljs-comment">// 正在执行任务列表 中较快的任务执行完成之后，才会从array数组中获取新的待办任务</span><span class="hljs-keyword">return</span> r.then(<span class="hljs-function">() =&gt;</span> enqueue());&#125;;<span class="hljs-keyword">return</span> enqueue().then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">Promise</span>.all(ret));&#125;<span class="hljs-comment">// ES7 版本实现</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncPool</span>(<span class="hljs-params">poolLimit, array, iteratorFn</span>) </span>&#123;<span class="hljs-keyword">const</span> ret = []; <span class="hljs-comment">// 存储所有的异步任务</span><span class="hljs-keyword">const</span> executing = []; <span class="hljs-comment">// 存储正在执行的异步任务</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> array) &#123;<span class="hljs-comment">// 调用iteratorFn函数创建异步任务</span><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> iteratorFn(item, array));ret.push(p); <span class="hljs-comment">// 保存新的异步任务</span><span class="hljs-comment">// 当poolLimit值小于或等于总任务个数时，进行并发控制</span><span class="hljs-keyword">if</span> (poolLimit &lt;= array.length) &#123;<span class="hljs-comment">// 当任务完成后，从正在执行的任务数组中移除已完成的任务</span><span class="hljs-keyword">const</span> e = p.then(<span class="hljs-function">() =&gt;</span> executing.splice(executing.indexOf(e), <span class="hljs-number">1</span>));executing.push(e); <span class="hljs-comment">// 保存正在执行的异步任务</span><span class="hljs-keyword">if</span> (executing.length &gt;= poolLimit) &#123;<span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.race(executing); <span class="hljs-comment">// 等待较快的任务执行完成</span>&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(ret);&#125;</code></pre><h3 id="5-简易版generator"><a href="#5-简易版generator" class="headerlink" title="5 简易版generator"></a>5 简易版generator</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myGenerator</span>(<span class="hljs-params">list</span>) </span>&#123;<span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;<span class="hljs-keyword">var</span> len = list.length;<span class="hljs-keyword">return</span> &#123;next: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> done = index &gt;= len;<span class="hljs-keyword">var</span> value = !done ? list[index++] : <span class="hljs-literal">undefined</span>; <span class="hljs-keyword">return</span> &#123;done: done,value: value&#125;&#125;&#125;&#125;<span class="hljs-keyword">var</span> gen = myGenerator([<span class="hljs-string">&#x27;大罗&#x27;</span>, <span class="hljs-string">&#x27;小罗&#x27;</span>, <span class="hljs-string">&#x27;C罗&#x27;</span>]);gen.next(); <span class="hljs-comment">// &#123;done: false, value: &quot;大罗&quot;&#125;</span>gen.next(); <span class="hljs-comment">// &#123;done: false, value: &quot;小罗&quot;&#125;</span>gen.next(); <span class="hljs-comment">// &#123;done: false, value: &quot;C罗&quot;&#125;</span>gen.next(); <span class="hljs-comment">// &#123;done: true, value: undefined&#125;</span></code></pre><h3 id="6-用-setTimeout-模拟-setInterval"><a href="#6-用-setTimeout-模拟-setInterval" class="headerlink" title="6 用 setTimeout 模拟 setInterval"></a>6 用 setTimeout 模拟 setInterval</h3><p>题目：用 setTimeout 函数 模拟 setInterval</p><p>前置条件：</p><ol><li>假设 setTimeout 里执行的目标函数返回的是一个 Promise</li><li>假设 interval 的值为 3000, 单位为 ms</li></ol><p>要求：</p><ol><li>不能使用 setInterval 函数</li><li>调用 mockInterval 函数时，确保能够立即执行一次目标函数，无需等待 3000ms</li><li>当 Promise 执行的时间小于 3000ms 时，需要确保过了 3000ms 之后才能执行下一次 callback</li><li>当 Promise 执行的时间超出 3000ms 时，需要等待 Promise 执行完成，才能走回想下一次 callBack </li></ol><pre><code class="hljs javaScript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mockInterval</span>(<span class="hljs-params">callBack, time=<span class="hljs-number">3000</span></span>) </span>&#123;<span class="hljs-comment">// 为了防止传入的 callBack 是一个异步函数</span><span class="hljs-keyword">await</span> callBack();setIntervalFn(callBack, time);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setIntervalFn</span>(<span class="hljs-params">callBack, time</span>) </span>&#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">resolve</span>)</span>&#123;<span class="hljs-comment">// 为了防止传入的 callBack 是一个异步函数</span><span class="hljs-keyword">await</span> callBack();setIntervalFn(callBack, time);&#125;)&#125;, time)&#125;<span class="hljs-comment">// test</span>mockInterval(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;call Back fn&#x27;</span>);&#125;, <span class="hljs-number">3000</span>)</code></pre><h2 id="五-函数-数组"><a href="#五-函数-数组" class="headerlink" title="五 函数/数组"></a>五 函数/数组</h2><p>1 函数柯里化<br>2 偏函数<br>3 compose 函数<br>4 LRU 函数<br>5 loadsh -&gt; get<br>6 sleep函数<br>7 数组随机打乱<br>8 数组扁平化<br>9 Array.prototype.fill<br>10 Array.prototype.map<br>11 Array.prototype.reduce<br>12 Array.prototype.forEach<br>13 Array.prototype.filter<br>14 Array.prototype.some<br>15 两数相加<br>16 两数相减<br>17 两数相乘<br>18 两数相除<br>19 Math.pow()</p><h3 id="1-函数柯里化"><a href="#1-函数柯里化" class="headerlink" title="1 函数柯里化"></a>1 函数柯里化</h3><p>函数柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b, c</span>) </span>&#123;    <span class="hljs-keyword">return</span> a + b + c&#125;add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<span class="hljs-keyword">let</span> addCurry = curry(add)addCurry(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)<span class="hljs-comment">// 现在就是要实现 curry 这个函数</span><span class="hljs-comment">// 使函数从一次调用传入多个参数变成多次调用每次传一个参数。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fn</span>) </span>&#123;<span class="hljs-keyword">let</span> judge = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (args.length == fn.length) <span class="hljs-keyword">return</span> fn(...args)<span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...arg</span>) =&gt;</span> judge(...args, ...arg)&#125;<span class="hljs-keyword">return</span> judge&#125;<span class="hljs-comment">// 函数柯里化</span><span class="hljs-keyword">const</span> curry = <span class="hljs-function">(<span class="hljs-params">fn, ...args</span>) =&gt;</span>args.length &lt; fn.length<span class="hljs-comment">//参数长度不足时，重新柯里化该函数，等待接受新参数</span>? <span class="hljs-function">(<span class="hljs-params">...<span class="hljs-built_in">arguments</span></span>) =&gt;</span> curry(fn, ...args, ...arguments)<span class="hljs-comment">//参数长度满足时，执行函数</span>: fn(...args);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumFn</span>(<span class="hljs-params">a, b, c</span>) </span>&#123;<span class="hljs-keyword">return</span> a + b + c;&#125;<span class="hljs-keyword">var</span> sum = curry(sumFn);<span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">5</span>));<span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>));<span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>));<span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)(<span class="hljs-number">5</span>));<span class="hljs-comment">//10</span></code></pre><h3 id="2-偏函数"><a href="#2-偏函数" class="headerlink" title="2 偏函数"></a>2 偏函数</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 偏函数就是将一个 n 参的函数转换成固定 x 参的函数</span><span class="hljs-comment">// 剩余参数（n - x）将在下次调用全部传入</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b, c</span>) </span>&#123;    <span class="hljs-keyword">return</span> a + b + c&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partial</span>(<span class="hljs-params">fn, ...args</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...arg</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> fn(...args, ...arg)&#125;&#125;<span class="hljs-keyword">let</span> partialAdd = partial(add, <span class="hljs-number">1</span>)partialAdd(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</code></pre><h3 id="3-手写-compose-函数"><a href="#3-手写-compose-函数" class="headerlink" title="3 手写 compose 函数"></a>3 手写 compose 函数</h3><p>compose就是执行一系列的任务（函数），比如有以下任务队列，</p><p><code>let tasks = [step1, step2, step3, step4]</code><br>每一个step都是一个步骤，按照步骤一步一步的执行到结尾，这就是一个compose<br>compose在函数式编程中是一个很重要的工具函数，在这里实现的compose有三点说明</p><p>1 第一个函数是多元的（接受多个参数），后面的函数都是单元的（接受一个参数）<br>2 执行顺序的自右向左的<br>3 所有函数的执行都是同步的（异步的后面文章会讲到）</p><p>例如<br>let init = (…args) =&gt; args.reduce((ele1, ele2) =&gt; ele1 + ele2, 0)<br>let step2 = (val) =&gt; val + 2<br>let step3 = (val) =&gt; val + 3<br>let step4 = (val) =&gt; val + 4</p><p>pipe 函数与 compose函数的共同点是都返回“组合函数”，区别则是执行的顺序不同，前者是从左向右执行，后者则是从右向左执行。 实现 pipe函数非常简单，只需要对 compose 函数的包裹顺序进行调整一下即可。</p><pre><code class="hljs javaScript"><span class="hljs-comment">// 解法一 面向过程</span><span class="hljs-keyword">const</span> compose = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;<span class="hljs-keyword">let</span> length = args.length<span class="hljs-keyword">let</span> count = length - <span class="hljs-number">1</span><span class="hljs-keyword">let</span> result<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span> (<span class="hljs-params">...arg1</span>) </span>&#123;result = args[count].apply(<span class="hljs-built_in">this</span>, arg1)<span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;count = length - <span class="hljs-number">1</span><span class="hljs-keyword">return</span> result&#125;count--<span class="hljs-keyword">return</span> f1.call(<span class="hljs-literal">null</span>, result)&#125;&#125;<span class="hljs-comment">// 解法二</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compose</span>(<span class="hljs-params">...funcs</span>) </span>&#123;<span class="hljs-keyword">if</span> (funcs.length === <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> arg;&#125;<span class="hljs-keyword">if</span> (funcs.length === <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> funcs[<span class="hljs-number">0</span>];&#125;<span class="hljs-keyword">return</span> funcs.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> a(b(...args)));&#125;<span class="hljs-keyword">const</span> compose = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> args.reduceRight(<span class="hljs-function">(<span class="hljs-params">res, cb</span>) =&gt;</span> cb(res), x);<span class="hljs-keyword">const</span> pipe = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> args.reduce(<span class="hljs-function">(<span class="hljs-params">res, cb</span>) =&gt;</span> cb(res), x)<span class="hljs-comment">// 解法三 promise</span><span class="hljs-keyword">const</span> compose = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;<span class="hljs-keyword">let</span> init = args.pop()<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...arg</span>) </span>&#123;<span class="hljs-keyword">return</span> args.reverse().reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sequence, func</span>) </span>&#123;<span class="hljs-keyword">return</span> sequence.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>&#123;<span class="hljs-keyword">return</span> func.call(<span class="hljs-literal">null</span>, result)&#125;)&#125;, <span class="hljs-built_in">Promise</span>.resolve(init.apply(<span class="hljs-literal">null</span>, arg)))&#125;&#125;<span class="hljs-comment">// 解法三 Generator</span><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">iterateSteps</span>(<span class="hljs-params">steps</span>) </span>&#123;<span class="hljs-keyword">let</span> n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; steps.length; i++) &#123;<span class="hljs-keyword">if</span> (n) &#123;n = <span class="hljs-keyword">yield</span> steps[i].call(<span class="hljs-literal">null</span>, n)&#125; <span class="hljs-keyword">else</span> &#123;n = <span class="hljs-keyword">yield</span>&#125;&#125;&#125;<span class="hljs-keyword">const</span> compose = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...steps</span>) </span>&#123;<span class="hljs-keyword">let</span> g = iterateSteps(steps)<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;<span class="hljs-keyword">let</span> val = steps.pop().apply(<span class="hljs-literal">null</span>, args)<span class="hljs-comment">// 这里是第一个值</span><span class="hljs-built_in">console</span>.log(val)<span class="hljs-comment">// 因为无法传参数 所以无所谓执行 就是空耗一个yield</span>g.next()<span class="hljs-keyword">return</span> steps.reverse.reduce(<span class="hljs-function">(<span class="hljs-params">val, val1</span>) =&gt;</span> g.next(val).value, val)  &#125;&#125;<span class="hljs-comment">// 解法四</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compose</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> fns = [].slice.call(<span class="hljs-built_in">arguments</span>)<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">initialArg</span>) </span>&#123;<span class="hljs-keyword">var</span> res = initialArg<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = fns.length - <span class="hljs-number">1</span>; i &gt; -<span class="hljs-number">1</span>; i--) &#123;res = fns[i](res);&#125;<span class="hljs-keyword">return</span> res&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pipe</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> fns = [].slice.call(<span class="hljs-built_in">arguments</span>)    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">initialAgr</span>) </span>&#123;        <span class="hljs-keyword">var</span> res = initialAgr        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; fns.length; i++) &#123;            res = fns[i](res)        &#125;        <span class="hljs-keyword">return</span> res    &#125;&#125;<span class="hljs-keyword">var</span> greet = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hi:&#x27;</span> + name &#125;<span class="hljs-keyword">var</span> exclaim = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">statement</span>) </span>&#123; <span class="hljs-keyword">return</span> statement.toUpperCase() + <span class="hljs-string">&#x27;!&#x27;</span> &#125;<span class="hljs-keyword">var</span> transform = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>&#123; <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/[dD]/</span>, <span class="hljs-string">&#x27;DDDDD&#x27;</span>) &#125;<span class="hljs-keyword">var</span> welcome1 = compose(greet, exclaim, transform)<span class="hljs-keyword">var</span> welcome2 = pipe(greet, exclaim, transform)<span class="hljs-built_in">console</span>.log(welcome1(<span class="hljs-string">&#x27;dot&#x27;</span>))<span class="hljs-comment">//hi:DDDDDOT!</span><span class="hljs-built_in">console</span>.log(welcome2(<span class="hljs-string">&#x27;dolb&#x27;</span>))<span class="hljs-comment">//HI:DDDDDOLB!</span></code></pre><h3 id="4-手写-LRU-函数"><a href="#4-手写-LRU-函数" class="headerlink" title="4 手写 LRU 函数"></a>4 手写 LRU 函数</h3><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p><p>1 LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存<br>2 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>3 void put(int key, int value) 如果关键字已经存在，则变更其数据值；<br>    如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，<br>    它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><p>进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><pre><code class="hljs text">输入[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]输出[null, null, null, 1, null, -1, null, -1, 3, 4]解释LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;lRUCache.get(1);    // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;lRUCache.get(2);    // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;lRUCache.get(1);    // 返回 -1 (未找到)lRUCache.get(3);    // 返回 3lRUCache.get(4);    // 返回 4</code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">capacity</span></span></span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">capacity</span>)</span> &#123;<span class="hljs-built_in">this</span>.capacity = capacity<span class="hljs-built_in">this</span>.map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();&#125;<span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">key</span>)</span> &#123;<span class="hljs-keyword">let</span> val = <span class="hljs-built_in">this</span>.map.get(key);<span class="hljs-keyword">if</span> (val === <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<span class="hljs-built_in">this</span>.map.delete(key); <span class="hljs-comment">// 因为被用过一次，原有位置删除</span><span class="hljs-built_in">this</span>.map.set(key, val); <span class="hljs-comment">// 放入最下面表示最新使用</span><span class="hljs-keyword">return</span> val;&#125;<span class="hljs-function"><span class="hljs-title">put</span>(<span class="hljs-params">key, val</span>)</span> &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.map.has(key)) <span class="hljs-built_in">this</span>.map.delete(key); <span class="hljs-comment">// 如果有，删除</span><span class="hljs-built_in">this</span>.map.set(key, val); <span class="hljs-comment">// 放到最下面表示最新使用</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.map.size &gt; <span class="hljs-built_in">this</span>.capacity) &#123;<span class="hljs-comment">// 这里有个知识点</span><span class="hljs-comment">// map的entries方法，还有keys方法(可以看mdn))，会返回一个迭代器</span><span class="hljs-comment">// 迭代器调用next也是顺序返回，所以返回第一个的值就是最老的，找到并删除即可</span><span class="hljs-built_in">this</span>.map.delete(<span class="hljs-built_in">this</span>.map.entries().next().value[<span class="hljs-number">0</span>])&#125;&#125;&#125;</code></pre><h3 id="5-loadsh-gt-get"><a href="#5-loadsh-gt-get" class="headerlink" title="5 loadsh -&gt; get"></a>5 loadsh -&gt; get</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 题目描述</span><span class="hljs-keyword">var</span> obj = &#123;selector: &#123; to: &#123; toutiao: <span class="hljs-string">&#x27;FE coder&#x27;</span> &#125; &#125;,target: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;byted&#x27;</span> &#125;] &#125;;<span class="hljs-comment">// 运行代码</span><span class="hljs-keyword">var</span> res = getValsByKeys(obj, <span class="hljs-string">&#x27;selector.to.toutiao&#x27;</span>, <span class="hljs-string">&#x27;selector.feishu.toutiao&#x27;</span>, <span class="hljs-string">&#x27;target[0]&#x27;</span>, <span class="hljs-string">&#x27;target[2].name&#x27;</span>, <span class="hljs-string">&#x27;select.to.douyin&#x27;</span>)<span class="hljs-built_in">console</span>.log(res);<span class="hljs-comment">//  输出结果</span><span class="hljs-comment">// [&#x27;FE coder&#x27;, &#x27;&#x27;,  1, &#x27;byted&#x27;, &#x27;&#x27;]</span><span class="hljs-comment">// 解答：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getValsByKeys</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;arguments error&#x27;</span>);&#125;<span class="hljs-keyword">const</span> [obj, ...args] = [...arguments];<span class="hljs-keyword">const</span> res = [];args.forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;key = key.replaceAll(<span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>).replaceAll(<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>);res.push(getValByKey(obj, key));&#125;);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getValByKey</span>(<span class="hljs-params">obj, key</span>) </span>&#123;<span class="hljs-keyword">const</span> arr = key.split(<span class="hljs-string">&#x27;.&#x27;</span>);<span class="hljs-keyword">if</span> (arr.length &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> obj[arr[<span class="hljs-number">0</span>]] ? getValByKey(obj[arr[<span class="hljs-number">0</span>]], arr.slice(<span class="hljs-number">1</span>).join(<span class="hljs-string">&#x27;.&#x27;</span>)) : <span class="hljs-string">&#x27;&#x27;</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> obj[key] ? obj[key] : <span class="hljs-string">&#x27;&#x27;</span>;&#125;&#125;</code></pre><h3 id="6-sleep函数"><a href="#6-sleep函数" class="headerlink" title="6 sleep函数"></a>6 sleep函数</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">delay</span>) </span>&#123;<span class="hljs-keyword">var</span> start = (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()).getTime();<span class="hljs-keyword">while</span> ((<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()).getTime() - start &lt; delay) &#123;<span class="hljs-keyword">continue</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;111&#x27;</span>);  sleep(<span class="hljs-number">2000</span>);  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;222&#x27;</span>);&#125;test()</code></pre><h3 id="7-数组随机打乱"><a href="#7-数组随机打乱" class="headerlink" title="7 数组随机打乱"></a>7 数组随机打乱</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randArr</span>(<span class="hljs-params">arr</span>)</span>&#123;<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Array</span>.isArray(arr)) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;type error&#x27;</span>);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<span class="hljs-keyword">const</span> randIndex = <span class="hljs-built_in">Math</span>.floor(arr.length * <span class="hljs-built_in">Math</span>.random());<span class="hljs-keyword">if</span> (i !== randIndex) &#123;[arr[i], arr[randIndex]] = [arr[randIndex], arr[i]];&#125;&#125;<span class="hljs-keyword">return</span> arr;&#125;</code></pre><h3 id="8-数组扁平化"><a href="#8-数组扁平化" class="headerlink" title="8 数组扁平化"></a>8 数组扁平化</h3><p>ES6 为数组实例新增了 flat 方法 用于将数组扁平化。<br><code>var newArray = arr.flat(Infinity)</code></p><pre><code class="hljs javaScript"><span class="hljs-comment">// 手动实现 一个 flat函数：</span><span class="hljs-comment">// 方式一: ES6 递归 —— reduce</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatArray</span>(<span class="hljs-params">arr</span>) </span>&#123;<span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function">(<span class="hljs-params">acc, val</span>) =&gt;</span> <span class="hljs-built_in">Array</span>.isArray(val) ? acc.concat(flatArray(val)) : acc.concat(val), [])&#125;<span class="hljs-comment">// 方式二: 利用栈(stack) </span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatArray</span>(<span class="hljs-params">arr</span>) </span>&#123;<span class="hljs-keyword">const</span> stack = [...arr];<span class="hljs-keyword">const</span> newArr = [];<span class="hljs-keyword">while</span> (stack.length) &#123;<span class="hljs-keyword">const</span> item = stack.pop();<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(item)) &#123;stack.push(...item);&#125; <span class="hljs-keyword">else</span> &#123;newArr.unshift(item);&#125;&#125;<span class="hljs-keyword">return</span> newArr;&#125;<span class="hljs-comment">// 方法三: ES5 递归</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatArray</span>(<span class="hljs-params">arr</span>) </span>&#123;<span class="hljs-keyword">var</span> result = [];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(arr[i])) &#123;result = result.concat(flatArray(arr[i]))<span class="hljs-comment">// result = [...result, ...flatArray(arr[i])];</span>&#125; <span class="hljs-keyword">else</span> &#123;result.push(arr[i])&#125;&#125;<span class="hljs-keyword">return</span> result;&#125;</code></pre><h3 id="9-Array-fill"><a href="#9-Array-fill" class="headerlink" title="9 Array.fill"></a>9 Array.fill</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// arr.fill(value [,start [,end]])</span><span class="hljs-built_in">Array</span>.prototype.myFill = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val, start = <span class="hljs-number">0</span>, end = <span class="hljs-built_in">this</span>.length</span>)</span>&#123;<span class="hljs-keyword">if</span> (start &lt; end) &#123;<span class="hljs-built_in">this</span>[start] = val;<span class="hljs-built_in">this</span>.myFill(val, start + <span class="hljs-number">1</span>, end)&#125;&#125;<span class="hljs-built_in">Array</span>.prototype.myFill2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val, start = <span class="hljs-number">0</span>, end = <span class="hljs-built_in">this</span>.length</span>) </span>&#123;<span class="hljs-keyword">while</span> (start &lt; end) &#123;<span class="hljs-built_in">this</span>[start] = val;start++;&#125;&#125;</code></pre><h3 id="10-Array-map"><a href="#10-Array-map" class="headerlink" title="10 Array.map"></a>10 Array.map</h3><p>核心要点:<br>1.回调函数的参数有哪些，返回值如何处理。<br>2.不修改原来的数组。</p><pre><code class="hljs javaScript"><span class="hljs-comment">/*</span><span class="hljs-comment">var new_array = arr.map(function callback(currentValue[, index[, array]]) &#123;</span><span class="hljs-comment">Return element for new_array </span><span class="hljs-comment">&#125;[, thisArg])</span><span class="hljs-comment">callback - 生成新数组元素的函数，使用三个参数 currentValue, index(可选), array(可选)</span><span class="hljs-comment">thisArg - 执行 callback 函数时值被用作this</span><span class="hljs-comment">*/</span><span class="hljs-built_in">Array</span>.prototype.MyMap = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, thisArg</span>)</span>&#123;<span class="hljs-keyword">var</span> arr = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">this</span>);<span class="hljs-comment">//由于是ES5所以就不用...展开符了</span><span class="hljs-keyword">var</span> mappedArr = [];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++ )&#123;mappedArr.push(fn.call(thisArg, arr[i], i, <span class="hljs-built_in">this</span>));&#125;<span class="hljs-keyword">return</span> mappedArr;&#125;</code></pre><h3 id="11-Array-reduce"><a href="#11-Array-reduce" class="headerlink" title="11 Array.reduce"></a>11 Array.reduce</h3><p>核心要点:<br>1、初始值不传怎么处理<br>2、回调函数的参数有哪些，返回值如何处理。</p><pre><code class="hljs javaScript"><span class="hljs-comment">// arr.reduce(callback(accumulator, currentValue [,index [,array]])  [,initialValue])</span><span class="hljs-comment">// 简单版本</span><span class="hljs-built_in">Array</span>.prototype.myReduce = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, initialValue</span>) </span>&#123;<span class="hljs-comment">// 判断调用对象是否为数组</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-built_in">this</span>) !== <span class="hljs-string">&#x27;[object Array]&#x27;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;not a array&#x27;</span>);&#125;<span class="hljs-comment">// 判断传入的第一个参数是否为函数</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;fn&#125;</span> is not a function`</span>);&#125;<span class="hljs-comment">// 判断调用数组是否为空数组</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.length === <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (initialValue) &#123;<span class="hljs-keyword">return</span> initialValue;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;empty array&#x27;</span>);&#125;&#125;<span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">this</span>);<span class="hljs-keyword">const</span> startIndex = initialValue ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> res = initialValue ? initialValue : arr[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = startIndex; i &lt; arr.length; i++) &#123;res = fn.call(<span class="hljs-literal">null</span>, res, arr[i], i, <span class="hljs-built_in">this</span>);&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-built_in">Array</span>.prototype.myReduceRight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, initialValue</span>) </span>&#123;<span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">this</span>);<span class="hljs-keyword">let</span> startIndex = initialValue ? arr.length - <span class="hljs-number">1</span> : arr.length - <span class="hljs-number">2</span>;<span class="hljs-keyword">let</span> res = initialValue ? initialValue : arr[arr.length - <span class="hljs-number">1</span>];<span class="hljs-keyword">while</span>(startIndex &gt; -<span class="hljs-number">1</span>) &#123;res = fn.call(<span class="hljs-literal">null</span>, res, arr[startIndex], startIndex, <span class="hljs-built_in">this</span>);startIndex--;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 完美版本</span><span class="hljs-comment">// 思路</span><span class="hljs-comment">// 1 常规判断 这里我们主要要判断的是调用数组、传入参数</span><span class="hljs-comment">// 2 初始化各个变量，为第一次执行函数做准备</span><span class="hljs-comment">// 这里我们需要准备的变量有需要传入回调函数的4个参数</span><span class="hljs-comment">// callback的4个参数: accumulator, currentValue, currentIndex, sourceArray</span><span class="hljs-comment">// accumulator: 累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue</span><span class="hljs-comment">// currentValue: 数组中正在处理的元素</span><span class="hljs-comment">//currentIndex(可选): 数组中正在处理的当前元素的索引.如果提供了initialValue，则起始索引号为0，否则从索引1起始</span><span class="hljs-comment">//sourceArray(可选): 调用reduce()的数组</span><span class="hljs-comment">//initialValue(可选): 作为第一次调用 callback函数时的第一个参数的值.如果没有提供初始值，则将使用数组中的第一个元素.在没有初始值的空数组上调用 reduce 将报错</span><span class="hljs-comment">// 3 开始循环 同时记得更新几个参数和返回结果</span><span class="hljs-comment">// 4 返回结果</span><span class="hljs-built_in">Array</span>.prototype.myreduce = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn, initialValue</span>) </span>&#123;<span class="hljs-comment">// 判断调用对象是否为数组</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-built_in">this</span>) !== <span class="hljs-string">&#x27;[object Array]&#x27;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;not a array&#x27;</span>);&#125;<span class="hljs-comment">// 判断调用数组是否为空数组</span><span class="hljs-keyword">const</span> sourceArray = <span class="hljs-built_in">this</span>;<span class="hljs-keyword">if</span> (sourceArray.length === <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;empty array&#x27;</span>);&#125;<span class="hljs-comment">// 判断传入的第一个参数是否为函数</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;fn&#125;</span> is not a function`</span>);&#125;<span class="hljs-comment">// 第二步 回调函数参数初始化</span><span class="hljs-keyword">let</span> accumulator;<span class="hljs-keyword">let</span> currentValue;<span class="hljs-keyword">let</span> currentIndex;<span class="hljs-keyword">if</span> (initialValue) &#123;accumulator = initialValue;currentIndex = <span class="hljs-number">0</span>;&#125; <span class="hljs-keyword">else</span> &#123;accumulator = arr[<span class="hljs-number">0</span>];currentIndex = <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 第三步 开始循环</span><span class="hljs-keyword">while</span> (currentIndex &lt; sourceArray.length) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(sourceArray, currentIndex)) &#123;currentValue = sourceArray[currentIndex];accumulator = fn(accumulator, currentValue, currentIndex, sourceArray);&#125;currentIndex++;&#125;<span class="hljs-comment">// 第四步 返回结果</span><span class="hljs-keyword">return</span> accumulator;&#125;<span class="hljs-comment">// test</span><span class="hljs-keyword">const</span> rReduce = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>, , <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">3</span>)<span class="hljs-keyword">const</span> mReduce = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>, , <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].myreduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">3</span>)<span class="hljs-built_in">console</span>.log(rReduce); <span class="hljs-comment">// 31nullundefined34</span><span class="hljs-built_in">console</span>.log(mReduce); <span class="hljs-comment">// 31nullundefined34</span></code></pre><h3 id="12-Array-forEach"><a href="#12-Array-forEach" class="headerlink" title="12 Array.forEach"></a>12 Array.forEach</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// arr.forEach(callback(currentValue [,index [,array]])  [,thisArg])</span><span class="hljs-built_in">Array</span>.prototype.forEach2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback, thisArg</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;this is null or not defined&#x27;</span>)&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&#x27; is not a function&#x27;</span>)&#125;<span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Object</span>(<span class="hljs-built_in">this</span>)  <span class="hljs-comment">// this 就是当前的数组</span><span class="hljs-keyword">const</span> len = arr.length &gt;&gt;&gt; <span class="hljs-number">0</span>  <span class="hljs-comment">// 后面有解释(非number 转成 number 类型)</span><span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> (index &lt; len) &#123;<span class="hljs-keyword">if</span> (index <span class="hljs-keyword">in</span> arr) &#123;callback.call(thisArg, arr[index], index, arr);&#125;index++;&#125;&#125;<span class="hljs-comment">// O.length &gt;&gt;&gt; 0 是什么操作？就是无符号右移 0 位</span><span class="hljs-comment">/// 就是为了保证转换后的值为正整数。其实底层做了 2 层转换</span><span class="hljs-comment">// 第一是非 number 转成 number 类型</span><span class="hljs-comment">// 第二是将 number 转成 Uint32 类型。</span><span class="hljs-comment">// &gt;&gt;&gt; 1 : 无符号右移 1 位，意思是 除二取整</span></code></pre><h3 id="13-Array-filter"><a href="#13-Array-filter" class="headerlink" title="13 Array.filter"></a>13 Array.filter</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// var newArray = arr.filter(callback(element [,index [,array]])  [,thisArg])</span><span class="hljs-built_in">Array</span>.prototype.filter2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback, thisArg</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;this is null or not defined&#x27;</span>)&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&#x27; is not a function&#x27;</span>)&#125;<span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Object</span>(<span class="hljs-built_in">this</span>)<span class="hljs-keyword">const</span> len = arr.length &gt;&gt;&gt; <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> res = []<span class="hljs-keyword">while</span> (index &lt; len) &#123;<span class="hljs-keyword">if</span> (index <span class="hljs-keyword">in</span> arr) &#123;<span class="hljs-keyword">if</span> (callback.call(thisArg, arr[index], index, arr)) &#123;res.push(arr[index])                &#125;&#125;index++;&#125;   <span class="hljs-keyword">return</span> res;&#125;</code></pre><h3 id="14-Array-some"><a href="#14-Array-some" class="headerlink" title="14 Array.some"></a>14 Array.some</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// arr.some(callback(element [,index [,array]]) [,thisArg])</span><span class="hljs-built_in">Array</span>.prototype.some2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback, thisArg</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;this is null or not defined&#x27;</span>)&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&#x27; is not a function&#x27;</span>)&#125;<span class="hljs-keyword">const</span> O = <span class="hljs-built_in">Object</span>(<span class="hljs-built_in">this</span>)<span class="hljs-keyword">const</span> len = O.length &gt;&gt;&gt; <span class="hljs-number">0</span><span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> (k &lt; len) &#123;<span class="hljs-keyword">if</span> (k <span class="hljs-keyword">in</span> O) &#123;<span class="hljs-keyword">if</span> (callback.call(thisArg, O[k], k, O)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;&#125;k++;&#125;   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre><h3 id="15-两数相加"><a href="#15-两数相加" class="headerlink" title="15 两数相加"></a>15 两数相加</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 考虑 正负数的情况</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preciseAdd</span>(<span class="hljs-params">str1, str2</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length !== <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;arguments is error&#x27;</span>);&#125;<span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-keyword">let</span> s1 = str1.split(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-keyword">let</span> s2 = str2.split(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-keyword">if</span> ((str1.startsWith(<span class="hljs-string">&#x27;-&#x27;</span>) &amp;&amp; !str2.startsWith(<span class="hljs-string">&#x27;-&#x27;</span>)) || (!str1.startsWith(<span class="hljs-string">&#x27;-&#x27;</span>) &amp;&amp; str2.startsWith(<span class="hljs-string">&#x27;-&#x27;</span>))) &#123;<span class="hljs-comment">// 一正一负</span><span class="hljs-keyword">const</span> str1LessZero = str1.startsWith(<span class="hljs-string">&#x27;-&#x27;</span>); <span class="hljs-comment">// 表示前面数字是负数，后面是正数</span><span class="hljs-keyword">if</span> (str1LessZero) &#123;s1.shift();&#125; <span class="hljs-keyword">else</span> &#123;s2.shift();&#125;<span class="hljs-comment">// 判断两个数字大小</span><span class="hljs-keyword">let</span> s1LagerS2 = s1.length &gt; s2.length;<span class="hljs-keyword">if</span> (s1.length === s2.length) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; s1.length; i++) &#123;<span class="hljs-keyword">if</span>(s1[i] === s2[i]) <span class="hljs-keyword">continue</span>;s1LagerS2 = s1[i] &gt; s2[i];<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-comment">// 如果 s1 比 s2 小，则互换</span><span class="hljs-keyword">if</span> (!s1LagerS2) &#123;<span class="hljs-comment">// s1 = [s2, s2 = s1][0] // 快速互换</span><span class="hljs-keyword">const</span> tem = [...s1];s1 = [...s2];s2 = [...tem];&#125;<span class="hljs-keyword">while</span>(s1.length) &#123;<span class="hljs-keyword">const</span> val = ~~s1.pop() - ~~s2.pop();<span class="hljs-keyword">if</span> (val &gt;= <span class="hljs-number">0</span>) &#123;res = val + res;&#125; <span class="hljs-keyword">else</span> &#123;res = val + <span class="hljs-number">10</span> + res;<span class="hljs-comment">// 不够减，需要把前一个值减一</span>s1[s1.length - <span class="hljs-number">1</span>]--;&#125;&#125;res = res.replace(<span class="hljs-regexp">/^0*/g</span>, <span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-comment">// 去掉前面的无效0</span><span class="hljs-comment">// (前正后负，前比后小) || (前负后正，前比后大)</span>res = (str1LessZero &amp;&amp; s1LagerS2) || (!str1LessZero &amp;&amp; !s1LagerS2) ? <span class="hljs-string">&#x27;-&#x27;</span> + res : res;<span class="hljs-comment">// 如果 两数相等，则 res = &#x27;&#x27;或者 res = &#x27;-&#x27;</span><span class="hljs-keyword">if</span>(res === <span class="hljs-string">&#x27;-&#x27;</span> || !res) &#123;res = <span class="hljs-string">&#x27;0&#x27;</span>;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 两正数 或者 两负数</span><span class="hljs-comment">// 两个负数</span><span class="hljs-keyword">const</span> twoF = str1.startsWith(<span class="hljs-string">&#x27;-&#x27;</span>) &amp;&amp; str2.startsWith(<span class="hljs-string">&#x27;-&#x27;</span>);<span class="hljs-keyword">if</span> (twoF) &#123;s1.shift();s2.shift();&#125;<span class="hljs-keyword">let</span> carry = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (s1.length || s2.length || carry) &#123;<span class="hljs-keyword">const</span> val = ~~s1.pop() + ~~s2.pop() + carry;res = val % <span class="hljs-number">10</span> + res;carry = <span class="hljs-built_in">Math</span>.floor(val / <span class="hljs-number">10</span>);&#125;res = twoF ? <span class="hljs-string">&#x27;-&#x27;</span> + res : res;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 简易版 只考虑正数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preciseAdd</span>(<span class="hljs-params">str1, str2</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length !== <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;arguments is error&#x27;</span>);&#125;<span class="hljs-keyword">const</span> arr1 = str1.split(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-keyword">const</span> arr2 = str2.split(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-keyword">let</span> carry = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(arr1.length || arr2.length || carry) &#123;<span class="hljs-keyword">const</span> val = ~~arr1.pop() + ~~arr2.pop() + carry;res = val % <span class="hljs-number">10</span> + res;carry = <span class="hljs-built_in">Math</span>.floor(val / <span class="hljs-number">10</span>);&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre><h3 id="16-两数相减"><a href="#16-两数相减" class="headerlink" title="16 两数相减"></a>16 两数相减</h3><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minus</span>(<span class="hljs-params">a, b</span>) </span>&#123;<span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-keyword">let</span> arr1 = a.split(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-keyword">let</span> arr2 = b.split(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-comment">// 判断 a 和 b 的大小</span><span class="hljs-keyword">let</span> aLagerB = arr1.length &gt; arr2.length;<span class="hljs-keyword">if</span> (arr1.length === arr2.length) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;<span class="hljs-keyword">if</span>(arr1[i] === arr2[i]) &#123;<span class="hljs-keyword">continue</span>;&#125;aLagerB = arr1[i] &gt; arr2[i];<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-comment">// 如果 a 比 b 小，则互换位置</span><span class="hljs-keyword">if</span> (!aLagerB) &#123;<span class="hljs-comment">// arr1 = [arr2, arr2 = arr1][0]</span><span class="hljs-keyword">const</span> tem = arr1;arr1 = arr2;arr2 = tem;&#125;<span class="hljs-keyword">while</span> (arr1.length) &#123;<span class="hljs-keyword">const</span> val = ~~arr1.pop() - ~~arr2.pop();<span class="hljs-keyword">if</span> (val &gt;= <span class="hljs-number">0</span>) &#123;res = val + res;&#125; <span class="hljs-keyword">else</span> &#123;res = val + <span class="hljs-number">10</span> + res;arr1[arr1.length - <span class="hljs-number">1</span>]--;&#125;&#125;res = res.replace(<span class="hljs-regexp">/^0*/g</span>, <span class="hljs-string">&#x27;&#x27;</span>);res = !aLagerB ? <span class="hljs-string">&#x27;-&#x27;</span>  + res : res;<span class="hljs-comment">// 如果出现两数相等，则 res = &#x27;-&#x27;</span>res = res === <span class="hljs-string">&#x27;-&#x27;</span> ? <span class="hljs-string">&#x27;0&#x27;</span> : res;<span class="hljs-keyword">return</span> res;&#125;</code></pre><h3 id="17-两数相乘"><a href="#17-两数相乘" class="headerlink" title="17 两数相乘"></a>17 两数相乘</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 普通乘法</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cheng</span>(<span class="hljs-params">str1, str2</span>) </span>&#123;<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> s1 = ~~str1;<span class="hljs-keyword">const</span> s2 = ~~str2;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s2; i++) &#123;res += s1;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 大数相乘 a b 都是字符串</span><span class="hljs-keyword">var</span> multiply = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<span class="hljs-keyword">if</span> (num1 === <span class="hljs-string">&#x27;0&#x27;</span> || num2 === <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span>;&#125;<span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(num1.length + num2.length).fill(<span class="hljs-number">0</span>);<span class="hljs-comment">// 得到乘积的数组</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; num1.length; i++) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; num2.length; j++) &#123;arr[i + j + <span class="hljs-number">1</span>] += ~~num1[i] * ~~num2[j];&#125;&#125;<span class="hljs-comment">// 处理进位</span><span class="hljs-keyword">let</span> i = arr.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">const</span> carry = <span class="hljs-built_in">Math</span>.trunc(arr[i] / <span class="hljs-number">10</span>);<span class="hljs-keyword">if</span> (carry) &#123;arr[i - <span class="hljs-number">1</span>] += carry;&#125;arr[i] = arr[i] % <span class="hljs-number">10</span>;i--;&#125;<span class="hljs-comment">// 去掉前面多余的0</span><span class="hljs-keyword">while</span>(arr[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;arr.shift();&#125;<span class="hljs-keyword">return</span> arr.join(<span class="hljs-string">&#x27;&#x27;</span>);&#125;;</code></pre><h3 id="18-两数相除"><a href="#18-两数相除" class="headerlink" title="18 两数相除"></a>18 两数相除</h3><p>给定两个整数，被除数 dividend和除数divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。<br>返回被除数 dividend 除以除数divisor 得到的商。</p><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> divide = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dividend, divisor</span>) </span>&#123;<span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> flag = (dividend &gt; <span class="hljs-number">0</span> &amp;&amp; divisor &gt; <span class="hljs-number">0</span>) || (dividend &lt; <span class="hljs-number">0</span> &amp;&amp; divisor &lt; <span class="hljs-number">0</span>);<span class="hljs-keyword">let</span> mul = <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">Math</span>.abs(dividend);<span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">Math</span>.abs(divisor);<span class="hljs-keyword">let</span> s3 = s2;<span class="hljs-keyword">while</span> (s1 &gt;= s3) &#123;<span class="hljs-keyword">if</span> (s1 &gt; (s3 + s3)) &#123;s3 += s3;mul += mul;&#125;s1 -= s3;result += mul;&#125;<span class="hljs-keyword">while</span> (s1 &gt;= s2) &#123;s1 -= s2;result += <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">if</span> (flag &amp;&amp; result &gt; (<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">31</span>) - <span class="hljs-number">1</span>)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">31</span>) - <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!flag &amp;&amp; result &lt; -<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">31</span>)) &#123;<span class="hljs-keyword">return</span> -<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">31</span>);&#125;<span class="hljs-keyword">return</span> !flag ? -result : result;&#125;;</code></pre><h3 id="19-Math-pow"><a href="#19-Math-pow" class="headerlink" title="19 Math.pow()"></a>19 Math.pow()</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 解法一: 迭代</span><span class="hljs-comment">// res 变量的值由 奇次or偶次幂 决定，如果是奇次幂，res 值为 num，反之，为1</span><span class="hljs-comment">// res 最后乘上累乘后的 num，返回</span><span class="hljs-keyword">var</span> myPow = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num, power</span>) </span>&#123;<span class="hljs-keyword">if</span> (power &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / num * myPow(<span class="hljs-number">1</span> / num, -(power + <span class="hljs-number">1</span>));<span class="hljs-keyword">if</span> (power === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (power === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> num;<span class="hljs-comment">// 以上分别为power小于0 等于0 等于1 的情况</span><span class="hljs-keyword">let</span> res = <span class="hljs-number">1</span><span class="hljs-keyword">while</span> (power &gt; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// power大于1</span><span class="hljs-keyword">if</span> (power % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) &#123;res = res * num;power--;&#125;num = num * num;power = power / <span class="hljs-number">2</span>;&#125;<span class="hljs-keyword">return</span> res * num;&#125;;<span class="hljs-comment">// 解法二: 递归</span><span class="hljs-comment">// 递归版似乎更好理解一些，奇次幂的话，幂次-1，转成偶次幂</span><span class="hljs-comment">// 只需要写好偶次幂下的调用就好：myPow(num * num, power / 2)</span><span class="hljs-keyword">var</span> myPow = <span class="hljs-function">(<span class="hljs-params">num, power</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (power &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / (num * myPow(num, -(power + <span class="hljs-number">1</span>)));<span class="hljs-keyword">if</span> (power === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (power === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> num;<span class="hljs-keyword">return</span> power % <span class="hljs-number">2</span> === <span class="hljs-number">1</span> ?num * myPow(num, power - <span class="hljs-number">1</span>) :myPow(num * num, power / <span class="hljs-number">2</span>);&#125;</code></pre><h2 id="六-开放题"><a href="#六-开放题" class="headerlink" title="六 开放题"></a>六 开放题</h2><p>1 实现一个简单路由<br>2 手写时钟<br>3 手写红绿灯</p><h3 id="1-实现一个简单路由"><a href="#1-实现一个简单路由" class="headerlink" title="1 实现一个简单路由"></a>1 实现一个简单路由</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// hash路由</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Route</span></span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-comment">// 路由存储对象</span><span class="hljs-built_in">this</span>.routes = &#123;&#125;;<span class="hljs-comment">// 当前hash</span><span class="hljs-built_in">this</span>.currentHash = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-comment">// 绑定this，避免监听时this指向改变</span><span class="hljs-built_in">this</span>.freshRoute = <span class="hljs-built_in">this</span>.freshRoute.bind(<span class="hljs-built_in">this</span>);<span class="hljs-comment">// 监听</span><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-built_in">this</span>.freshRoute, <span class="hljs-literal">false</span>);<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;hashchange&#x27;</span>, <span class="hljs-built_in">this</span>.freshRoute, <span class="hljs-literal">false</span>);&#125;<span class="hljs-comment">// 存储</span>storeRoute (path, cb) &#123;<span class="hljs-built_in">this</span>.routes[path] = cb || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;&#125;<span class="hljs-comment">// 更新</span>freshRoute () &#123;<span class="hljs-built_in">this</span>.currentHash = location.hash.slice(<span class="hljs-number">1</span>) || <span class="hljs-string">&#x27;/&#x27;</span>;<span class="hljs-built_in">this</span>.routes[<span class="hljs-built_in">this</span>.currentHash]();&#125;&#125;</code></pre><h3 id="2-手写时钟"><a href="#2-手写时钟" class="headerlink" title="2 手写时钟"></a>2 手写时钟</h3><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>*&#123;padding: 0;margin: 0;&#125;html, body &#123;height: 100%;&#125;<span class="css"><span class="hljs-selector-class">.warp</span>&#123;</span>width: 230px;height: 230px;margin: 50px auto;&#125;<span class="css"><span class="hljs-selector-class">.clock</span>&#123;</span>width: 200px;height: 200px;border-radius: 115px;<span class="css"><span class="hljs-selector-tag">border</span>: 15<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#ccc</span>;</span><span class="css"><span class="hljs-selector-tag">background</span>: <span class="hljs-selector-id">#fff</span>;</span>position: relative;&#125;<span class="css"><span class="hljs-selector-class">.number</span> <span class="hljs-selector-tag">div</span>&#123;</span>position: absolute;width: 20px;height: 200px;left: 90px;&#125;<span class="css"><span class="hljs-selector-class">.number</span> <span class="hljs-selector-tag">span</span>&#123;</span>display: block;width: 20px;height: 20px;text-align: center;&#125;<span class="css"><span class="hljs-selector-class">.pointer</span>&#123;</span>position: absolute;bottom: 90px;transform-origin: 50% 90%;-webkit-transform-origin: 50% 90%;&#125;<span class="css"><span class="hljs-selector-class">.houre</span>&#123;</span>width: 4px;height: 60px;left: 100px;<span class="css"><span class="hljs-selector-tag">background</span>: <span class="hljs-selector-id">#000</span>;</span>&#125;<span class="css"><span class="hljs-selector-class">.minute</span>&#123;</span>width: 2px;height: 80px;left: 100px;<span class="css"><span class="hljs-selector-tag">background</span>: <span class="hljs-selector-id">#777</span>;</span>&#125;<span class="css"><span class="hljs-selector-class">.second</span>&#123;</span>width: 1px;height: 90px;left: 100px;<span class="css"><span class="hljs-selector-tag">background</span>: <span class="hljs-selector-id">#ff0000</span>;</span>&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript"><span class="hljs-keyword">var</span> domNumber = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;number&quot;</span>);</span><span class="javascript"><span class="hljs-keyword">var</span> domDiv = domNumber.getElementsByTagName(<span class="hljs-string">&quot;div&quot;</span>);</span><span class="javascript"><span class="hljs-keyword">var</span> domSpan = domNumber.getElementsByTagName(<span class="hljs-string">&quot;span&quot;</span>);</span><span class="javascript"><span class="hljs-comment">// 布局 =&gt; 让数字旋转到相应的位置并调整方向</span></span><span class="javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; domDiv.length; i++)&#123;</span><span class="javascript">domDiv[i].style.WebkitTransform=<span class="hljs-string">&quot;rotate(&quot;</span> + (i + <span class="hljs-number">1</span>) * <span class="hljs-number">30</span> + <span class="hljs-string">&quot;deg)&quot;</span>;</span>&#125;<span class="javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; domSpan.length; j++)&#123;</span><span class="javascript">domSpan[j].style.WebkitTransform=<span class="hljs-string">&quot;rotate(&quot;</span>+ (j + <span class="hljs-number">1</span>) * -<span class="hljs-number">30</span> + <span class="hljs-string">&quot;deg)&quot;</span>;</span>&#125;<span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clockRun</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript"><span class="hljs-keyword">var</span> domHour = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;houre&quot;</span>);</span><span class="javascript"><span class="hljs-keyword">var</span> domMinute = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;minute&quot;</span>);</span><span class="javascript"><span class="hljs-keyword">var</span> domSecond = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;second&quot;</span>);</span><span class="javascript"><span class="hljs-keyword">var</span> nowTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();</span><span class="javascript"><span class="hljs-keyword">var</span> nowHour = nowTime.getHours();</span><span class="javascript"><span class="hljs-keyword">var</span> nowMinute = nowTime.getMinutes();</span><span class="javascript"><span class="hljs-keyword">var</span> nowSecond = nowTime.getSeconds();</span><span class="javascript"><span class="hljs-comment">// 计算指针的角度，其中最重要的是在不满一小时或不满一分钟时，时针或分针应该转多少度</span></span><span class="javascript"><span class="hljs-keyword">var</span> houreDeg = (nowMinute/<span class="hljs-number">60</span>) * <span class="hljs-number">30</span>; <span class="hljs-comment">// 每小时是30度(1h = 60min, 1h =&gt;  360°/12h = 30 °/h)</span></span><span class="javascript"><span class="hljs-keyword">var</span> minuteDeg = (nowSecond/<span class="hljs-number">60</span>) * <span class="hljs-number">6</span>; <span class="hljs-comment">// 每分钟是6度(1min = 60sec, 1min =&gt; 360°/60min = 6 °/h)</span></span><span class="javascript">domHour.style.WebkitTransform = <span class="hljs-string">&quot;rotate(&quot;</span> + (nowHour * <span class="hljs-number">30</span> + houreDeg) + <span class="hljs-string">&quot;deg)&quot;</span>;</span><span class="javascript">domMinute.style.WebkitTransform = <span class="hljs-string">&quot;rotate(&quot;</span> + (nowMinute * <span class="hljs-number">6</span> + minuteDeg) + <span class="hljs-string">&quot;deg)&quot;</span>;</span><span class="javascript">domSecond.style.WebkitTransform = <span class="hljs-string">&quot;rotate(&quot;</span> + (nowSecond * <span class="hljs-number">6</span>) + <span class="hljs-string">&quot;deg)&quot;</span>;</span>&#125;clockRun();<span class="javascript"><span class="hljs-built_in">setInterval</span>(clockRun, <span class="hljs-number">1000</span>);</span>&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;warp&quot;</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;clock&quot;</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;number&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>9<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>12<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;houre&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pointer houre&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;minute&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pointer minute&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;second&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pointer second&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="3-手写红绿灯"><a href="#3-手写红绿灯" class="headerlink" title="3 手写红绿灯"></a>3 手写红绿灯</h3><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"><span class="hljs-selector-class">.light-content</span> &#123;</span>width: 400px;height: 150px;<span class="css"><span class="hljs-selector-tag">border</span>: 1<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#666</span>;</span>border-radius: 20px;<span class="css"><span class="hljs-selector-tag">background</span>: <span class="hljs-selector-id">#f7f7f7</span>;</span>display: flex;justify-content: space-around;align-items: center;&#125;<span class="css"><span class="hljs-selector-id">#red-light</span>, <span class="hljs-selector-id">#yellow-light</span>, <span class="hljs-selector-id">#green-light</span> &#123;</span>width: 100px;height: 100px;border-radius: 50px;display: flex;align-items: center;justify-content: center;font-size: 35px;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript"><span class="hljs-keyword">let</span> red = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;red-light&#x27;</span>);</span><span class="javascript"><span class="hljs-keyword">let</span> yellow= <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;yellow-light&#x27;</span>);</span><span class="javascript"><span class="hljs-keyword">let</span> green = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;green-light&#x27;</span>);</span><span class="javascript"><span class="hljs-keyword">let</span> colorsChange = <span class="hljs-function">(<span class="hljs-params">color, duration</span>) =&gt;</span> &#123;</span><span class="javascript"><span class="hljs-keyword">if</span>(color === <span class="hljs-string">&#x27;red&#x27;</span>) &#123;</span><span class="javascript"><span class="hljs-comment">// 设置灯的颜色变化</span></span>red.style.background = color;<span class="javascript">green.style.background = <span class="hljs-string">&#x27;#E2DCDC&#x27;</span>;</span><span class="javascript">yellow.style.background = <span class="hljs-string">&#x27;#E2DCDC&#x27;</span>;</span><span class="javascript"><span class="hljs-comment">// 设置倒计时</span></span>green.innerText = 0;yellow.innerText = 0;<span class="javascript"><span class="hljs-keyword">let</span> timeOut = duration;</span>red.innerText = timeOut / 1000;<span class="javascript"><span class="hljs-keyword">let</span> times = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;</span>red.innerText = (timeOut - 1000) / 1000;timeOut -= 1000;<span class="javascript"><span class="hljs-keyword">if</span> (timeOut === <span class="hljs-number">0</span>) &#123;</span><span class="javascript"><span class="hljs-built_in">clearInterval</span>(times);</span>&#125;&#125;, 1000);&#125;<span class="javascript"><span class="hljs-keyword">if</span>(color === <span class="hljs-string">&#x27;yellow&#x27;</span>) &#123;</span><span class="javascript"><span class="hljs-comment">// 设置灯的颜色变化</span></span>yellow.style.background = color;<span class="javascript">green.style.background = <span class="hljs-string">&#x27;#E2DCDC&#x27;</span>;</span><span class="javascript">red.style.background = <span class="hljs-string">&#x27;#E2DCDC&#x27;</span>;</span><span class="javascript"><span class="hljs-comment">// 设置倒计时</span></span>red.innerText = 0;green.innerText = 0;<span class="javascript"><span class="hljs-keyword">let</span> timeOut = duration;</span>yellow.innerText = timeOut / 1000;<span class="javascript"><span class="hljs-keyword">let</span> times = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;</span>yellow.innerText = (timeOut - 1000) / 1000;timeOut -= 1000;<span class="javascript"><span class="hljs-keyword">if</span> (timeOut === <span class="hljs-number">0</span>) &#123;</span><span class="javascript"><span class="hljs-built_in">clearInterval</span>(times);</span>&#125;&#125;, 1000);&#125;<span class="javascript"><span class="hljs-keyword">if</span>(color === <span class="hljs-string">&#x27;green&#x27;</span>) &#123;</span><span class="javascript"><span class="hljs-comment">// 设置灯的颜色变化</span></span>green.style.background = color;<span class="javascript">red.style.background = <span class="hljs-string">&#x27;#E2DCDC&#x27;</span>;</span><span class="javascript">yellow.style.background = <span class="hljs-string">&#x27;#E2DCDC&#x27;</span>;</span><span class="javascript"><span class="hljs-comment">// 设置倒计时</span></span>yellow.innerText = 0;red.innerText = 0;<span class="javascript"><span class="hljs-keyword">let</span> timeOut = duration;</span>green.innerText = timeOut / 1000;<span class="javascript"><span class="hljs-keyword">let</span> times = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;</span>green.innerText = (timeOut - 1000) / 1000;timeOut -= 1000;<span class="javascript"><span class="hljs-keyword">if</span> (timeOut === <span class="hljs-number">0</span>) &#123;</span><span class="javascript"><span class="hljs-built_in">clearInterval</span>(times);</span>&#125;&#125;, 1000);&#125;&#125;;<span class="javascript"><span class="hljs-keyword">let</span> setColor = <span class="hljs-function">(<span class="hljs-params">color, duration</span>) =&gt;</span> &#123;</span><span class="javascript"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res,rej</span>) =&gt;</span> &#123;</span>colorsChange(color, duration);<span class="javascript"><span class="hljs-built_in">setTimeout</span>(res, duration);</span>&#125;)&#125;<span class="javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setLight</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript"><span class="hljs-keyword">await</span> setColor(<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-number">7000</span>);</span><span class="javascript"><span class="hljs-keyword">await</span> setColor(<span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-number">3000</span>);</span><span class="javascript"><span class="hljs-keyword">await</span> setColor(<span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-number">5000</span>);</span><span class="javascript"><span class="hljs-keyword">await</span> setLight();</span>&#125;setLight();&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;light-content&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;red-light&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;yellow-light&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;green-light&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>js</tag>
      
      <tag>手写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>interView - React</title>
    <link href="/2021/01/07/interview/React%E7%81%B5%E9%AD%8223%E9%97%AE/"/>
    <url>/2021/01/07/interview/React%E7%81%B5%E9%AD%8223%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="1、setState"><a href="#1、setState" class="headerlink" title="1、setState"></a>1、<code>setState</code></h3><h4 id="1、异步还是同步"><a href="#1、异步还是同步" class="headerlink" title="1、异步还是同步"></a>1、异步还是同步</h4><ul><li>合成事件和钩子函数中 是异步的</li><li>原生事件 和 setTimeout 中是同步<br>相关链接：<a href="https://juejin.cn/post/6844903636749778958">你真的理解setState吗？</a></li></ul><h4 id="2、调用-setState-后的过程"><a href="#2、调用-setState-后的过程" class="headerlink" title="2、调用 setState 后的过程"></a>2、调用 setState 后的过程</h4><p>在 <code>setState</code> 的时候，<code>React</code> 会为当前节点创建一个 <code>updateQueue</code> 的更新列队。<br>然后会触发 <code>reconciliation</code> 过程，在这个过程中，会使用名为 <code>Fiber</code> 的调度算法，开始生成新的 <code>Fiber</code> 树， <code>Fiber</code> 算法的最大特点是可以做到异步可中断的执行。<br>然后 <code>React Scheduler</code> 会根据优先级高低，先执行优先级高的节点，具体是执行 <code>doWork</code> 方法。<br>在 <code>doWork</code> 方法中，<code>React</code> 会执行一遍 <code>updateQueue</code> 中的方法，以获得新的节点。然后对比新旧节点，为老节点打上 更新、插入、替换 等 <code>Tag</code>。<br>当前节点 <code>doWork</code> 完成后，会执行 <code>performUnitOfWork</code> 方法获得新节点，然后再重复上面的过程。<br>当所有节点都 <code>doWork</code> 完成后，会触发 <code>commitRoot</code> 方法，<code>React</code> 进入 <code>commit</code> 阶段。<br>在 <code>commit</code> 阶段中，<code>React</code> 会根据前面为各个节点打的 <code>Tag</code>，一次性更新整个 <code>dom</code> 元素。</p><h3 id="2、生命周期"><a href="#2、生命周期" class="headerlink" title="2、生命周期"></a>2、生命周期</h3><h4 id="1、钩子函数"><a href="#1、钩子函数" class="headerlink" title="1、钩子函数"></a>1、钩子函数</h4><blockquote><p><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">生命周期图谱</a></p></blockquote><ul><li>v16.0 之前:<ul><li>第一阶段: 组件挂载阶段 <code>constructor</code> =&gt; <code>componentWillMount</code> =&gt; <code>render</code> =&gt; <code>componentDidMount</code></li><li>第二阶段: 组件更新阶段 分为两种情况：<ul><li>New props: <code>componentWillReceiveProps</code> =&gt; <code>shouldComponentUpdate</code> =&gt; <code>componentWillUpdate</code> =&gt; <code>render</code> =&gt; <code>componentDidUpdate</code></li><li>set­State(): <code>shouldComponentUpdate</code> =&gt; <code>componentWillUpdate</code> =&gt; <code>render</code> =&gt; <code>componentDidUpdate</code></li></ul></li><li>第三阶段: 组件卸载阶段 <code>componentWillUnmount</code></li></ul></li><li>v16.0 - v16.3 :<ul><li>第一阶段: 组件挂载阶段 <code>constructor =&gt; getDerivedStateFromProps =&gt; render =&gt; componentDidMount</code></li><li>第二阶段: 组件更新阶段<ul><li>New props: <code>getDerivedStateFromProps =&gt; shouldComponentUpdate =&gt; render =&gt; getSnapshotBeforeUpdate =&gt; componentDidUpdate</code></li><li>set­State(): <code>shouldComponentUpdate =&gt; render =&gt; getSnapshotBeforeUpdate =&gt; componentDidUpdate</code></li><li>force­Update(): <code>render =&gt; getSnapshotBeforeUpdate =&gt; componentDidUpdate</code></li></ul></li><li>第三阶段: 组件卸载阶段 <code>componentWillUnmount</code></li></ul></li><li>v16.4 之后:<ul><li>第一阶段: 组件挂载阶段 <code>constructor =&gt; getDerivedStateFromProps =&gt; render =&gt; componentDidMount</code></li><li>第二阶段: 组件更新阶段 <code>getDerivedStateFromProps =&gt; shouldComponentUpdate =&gt; render =&gt; getSnapshotBeforeUpdate =&gt; componentDidUpdate</code></li><li>第三阶段: 组件卸载阶段 <code>componentWillUnmount</code></li></ul></li></ul><p><strong><code>React &lt; V16.0</code>的生命周期为</strong><br><img src="https://i.loli.net/2021/03/01/oxNYw1WzvXpcLym.png" alt="React _ 14 lifeCycle.png"></p><p><strong><code>React V16.0 - V16.3</code>的生命周期为</strong><br><img src="https://i.loli.net/2021/03/01/bdk62qIZhVNPDvn.png" alt="React 16.3lifeCycle.png"></p><p><strong><code>React V16.4+</code>的生命周期为</strong><br><img src="https://i.loli.net/2020/12/09/gEyt6U785HqOIVd.png" alt="React V16.4+生命周期"></p><h4 id="2、新增-删除哪些钩子"><a href="#2、新增-删除哪些钩子" class="headerlink" title="2、新增/删除哪些钩子"></a>2、新增/删除哪些钩子</h4><p>废弃了三个钩子函数: <del><code>componentWillMount</code></del>、<del><code>componentWillReceiveProps</code></del>、<del><code>componentWillUpdate</code></del><br>新增了两个钩子函数: <code>static getDerivedStateFromProps</code>、<code>getSnapshotBeforeUpdate</code></p><ul><li><code>static getDerivedStateFromProps</code>: 这个生命周期的功能实际上就是将传入的 <code>props</code> 映射到 <code>state</code> 上面, 为了替代<code>componentWillReceiveProps</code>而存在, 静态方法, 所以不能通过 <code>this</code> 访问到 <code>class</code> 的属性。</li></ul><pre><code class="hljs javaScript"><span class="hljs-comment">// 它返回一个对象表示新的 state。如果不需要更新组件，返回 null 即可</span><span class="hljs-comment">// 参数是组件接收到的新的 props(nextProps) 和组件当前的state数据(prevState)</span><span class="hljs-keyword">static</span> getDerivedStateFromProps (nextProps, prevState) &#123;    <span class="hljs-comment">// 当 props 的值 发生变化时，更新state</span>    <span class="hljs-keyword">if</span> (nextProps.color !== prevState.color) &#123;        <span class="hljs-keyword">return</span> &#123;            color: nextProps.color,        &#125;;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 否则，对于state不进行任何操作</span>&#125;<span class="hljs-comment">// 与 componentWillReceiveProps 触发机制的区别:</span><span class="hljs-comment">// 自身组件 setState 时, getDerivedStateFromProps 会被调用,而 componentWillReceiveProps 不会</span><span class="hljs-comment">//  - getDerivedStateFromProps: 在每次组件被重新渲染前被调用.</span><span class="hljs-comment">//     这意味着无论是父组件的更新, props 的变化, 或是组件内部执行了 setState(), 它都会被调用.</span><span class="hljs-comment">//  - componentWillReceiveProps: 接收到新的参数时被触发</span><span class="hljs-comment">//     当父组件导致子组件更新的时候, 即使接收的 props 并没有变化, 这个函数也会被调用</span></code></pre><ul><li><code>getSnapshotBeforeUpdate</code>: 在 <code>React</code> 对视图做出实际改动（如 DOM 更新）发生前被调用，返回值将作为 <code>componentDidUpdate</code> 的第三个参数。<br><code>getSnapshotBeforeUpdate</code> 配合 <code>componentDidUpdate</code> 可以取代 <code>componentWillUpdate</code>.</li></ul><p>废除三个钩子函数的原因：</p><ul><li>为何移除 <del><code>componentWillReceiveProps</code></del> : 并不是因为功能问题，而是性能问题。当外部多个属性在很短的时间间隔之内多次变化，就会导致<code>componentWillReceiveProps</code>被多次调用。这个调用并不会被合并，如果这次内容都会触发异步请求，那么可能会导致多个异步请求阻塞。</li><li>为何移除 <del><code>componentWillMount</code></del>: 更新后 React 的异步渲染机制可能会导致单个组件实例可以多次调用该方法,很多开发者目前会将事件绑定、异步请求等写在 <code>componentWillMount</code> 中，一旦异步渲染时 <code>componentWillMount</code> 被多次调用<ul><li>进行重复的时间监听，无法正常取消重复的 <code>Listener</code>，更有可能导致内存泄漏</li><li>发出重复的异步网络请求，导致 IO 资源被浪费</li><li>在服务端渲染时,<code>componentWillMount</code> 会被调用，但是会因忽略异步获取的数据而浪费 IO 资源</li></ul></li><li>为何移除 <del><code>componentWillUpdate</code></del>: 大多数开发者使用 <code>componentWillUpdate</code> 的场景是配合 <code>componentDidUpdate</code>,分别获取 <code>rerender</code> 前后的视图状态，进行必要的处理。但随着 React 新的 <code>suspense</code>、<code>time slicing</code>、异步渲染等机制的到来，<code>render</code> 过程可以被分割成多次完成，还可以被暂停甚至回溯，这导致 <code>componentWillUpdate</code> 和 <code>componentDidUpdate</code> 执行前后可能会间隔很长时间，足够使用户进行交互操作更改当前组件的状态. 而 <code>getSnapshotBeforeUpdate</code> 方法是在 <code>componentWillUpdate</code> 后，并且它调用的结果会作为第三个参数传入 <code>componentDidUpdate</code>，数据用完即被销毁，效率更高。</li></ul><p><a href="https://juejin.cn/post/6844903655372488712">React 生命周期 我对 React v16.4 生命周期的理解</a><br><a href="https://imweb.io/topic/5b8cacaa7cd95ea863193572">谈谈新的 React 新的生命周期钩子</a></p><h3 id="3、Hooks"><a href="#3、Hooks" class="headerlink" title="3、Hooks"></a>3、Hooks</h3><h4 id="1-useEffect-fn-和-componentDidMount-的什么差异"><a href="#1-useEffect-fn-和-componentDidMount-的什么差异" class="headerlink" title="1 useEffect(fn, []) 和 componentDidMount 的什么差异"></a>1 <code>useEffect(fn, [])</code> 和 <code>componentDidMount</code> 的什么差异</h4><p><code>useEffect</code> 会捕获 <code>props</code> 和 <code>state</code>，形成闭包。所以即便在回调函数里，你拿到的还是初始的 <code>props</code> 和 <code>state</code>。<br>如果想得到“最新”的值，可以使用 <code>ref</code>（<code>useRef</code>）。</p><h4 id="2、为什么不能放在条件判断里？"><a href="#2、为什么不能放在条件判断里？" class="headerlink" title="2、为什么不能放在条件判断里？"></a>2、为什么不能放在条件判断里？</h4><p>以 <code>setState</code> 为例，在 <code>react</code> 内部，每个组件(<code>Fiber</code>)的 <code>hooks</code> 都是以链表的形式存在 <code>memoizeState</code> 属性中：</p><img src="https://i.loli.net/2021/02/02/Rvz1y4EKVZwGCM6.jpg" ><p><code>update</code> 阶段，每次调用 <code>setState</code>，链表就会执行 <code>next</code> 向后移动一步。如果将 <code>setState</code> 写在条件判断中，假设条件判断不成立，没有执行里面的 <code>setState</code> 方法，会导致接下来所有的 <code>setState</code> 的取值出现偏移，从而导致异常发生。</p><p>参考链接：<a href="https://juejin.cn/post/6867745889184972814">烤透 React Hook</a></p><h3 id="4、组件"><a href="#4、组件" class="headerlink" title="4、组件"></a>4、组件</h3><h4 id="（1）函数组件"><a href="#（1）函数组件" class="headerlink" title="（1）函数组件"></a>（1）函数组件</h4><ul><li>纯函数： 输入props，输出JSX</li><li>没有实例，没有生命周期，因此没有state</li><li>不能扩展其他方法</li></ul><h4 id="（2）受控组件-和-非受控组件"><a href="#（2）受控组件-和-非受控组件" class="headerlink" title="（2）受控组件 和 非受控组件"></a>（2）受控组件 和 非受控组件</h4><p>  1&gt; 在 constructor 中创建 ref<br>  <code>this.fileInputRef = React.createRef();</code><br>  2&gt; 非受控组件<br>  <code>&lt;input type=&quot;file&quot; ref=&#123;this.fileInputRef&#125; /&gt;</code><br>  3&gt; 通过ref获得DOM节点，完成需要的操作<br>  <code>const elem = this.fileInputRef.current;</code><br>  <code>alert(elem.files[0].name);</code></p><p>使用场景：</p><ul><li>必须手动操作DOM元素，setState实现不了</li><li>比如文件上传 <code>&lt;input type=file&gt;</code></li><li>某些富文本编辑器，需要传入DOM元素</li></ul><p>如何选择：</p><ul><li>优先使用受控组件，符合React设计原则 （数据驱动视图）</li><li>必须操作DOM的时候，再使用非受控组件</li></ul><h4 id="（3）Portals"><a href="#（3）Portals" class="headerlink" title="（3）Portals"></a>（3）Portals</h4><p>Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。<br><code>ReactDOM.createPortal(child, container)</code></p><p>Portals 使用场景</p><ul><li>overflow: hidden</li><li>父组件 z-index 值太小</li><li>fixed 需要放在body的第一层</li></ul><h4 id="（4）异步组件"><a href="#（4）异步组件" class="headerlink" title="（4）异步组件"></a>（4）异步组件</h4><ol><li>import()</li><li>React.lazy<br>通过React.lazy()方法 对import引入的组件进行懒加载<br><code>const ContextDemo = React.lazy(() =&gt; import(&#39;./ContextDemo&#39;))</code></li><li>React.Suspense<br>React.Suspense 使用懒加载引入的组件<br><code>&lt;React.Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;</code><br> <code>&lt;ContextDemo/&gt;</code><br><code>&lt;/React.Suspense&gt;</code></li></ol><h3 id="5、-高阶组件"><a href="#5、-高阶组件" class="headerlink" title="5、 高阶组件"></a>5、 高阶组件</h3><p>高阶组件不是一种功能，而是一种模式 HOC、Render Props、redux connect</p><p>（1）HOC （使用了高阶函数的思想）</p><p>（2）Render Props</p>  <img src="https://i.loli.net/2020/12/30/iLBsy15Y6ZTP9Gu.png" ><p>  HOC与 Render Props 的对比：</p><ul><li>HOC： 模式简单，但是会增加组件层级</li><li>Render Props： 代码简洁，学习成本较高</li></ul><p>（3）redux connect</p><p>  react-redux 的核心组件只有两个：Provider组件 和 connect<br>  <strong><code>Provider</code></strong> 存放 Redux 里 store 的数据到 context 里，通过 connect 从 context 拿数据，通过 props 传递给 connect 所包裹的组件。<br> <code>connect([mapStateToProps], [mapDispatchToProps], [mergeProps],[options])</code><br>  作用：连接React组件与 Redux store。<br>  <strong><code>connect</code></strong> 是一个高阶函数，首先传入 <code>mapStateToProps</code>、<code>mapDispatchToProps</code>，然后返回一个生产<code>Component</code>的函数(<code>wrapWithConnect</code>)，然后再将真正的<code>Component</code>作为参数传入<code>wrapWithConnect</code>，这样就生产出一个经过包裹的<code>Connect</code>组件</p><h3 id="6、Redux"><a href="#6、Redux" class="headerlink" title="6、Redux"></a>6、Redux</h3><p>（1）单向数据流：</p><ol><li>dispatch(action): 通过 dispatch 一个 action 改变 state 的值（组件改变state的唯一方法）</li><li>reducer-&gt;newState: 通过 reducer 生成一个新的 state</li><li>subscribe 触发通知: 通过 subscribe 触发通知，进行视图的更新</li></ol><img src="https://i.loli.net/2020/12/30/1XfzRaJ8dYcnT6x.png" ><p>中间件的调用顺序：</p><img src="https://i.loli.net/2020/12/30/luqEbTaCHQL3Iwf.png" ><p>redux-saga基本用法总结：</p><ol><li>使用 createSagaMiddleware 方法创建 saga 的 Middleware ，然后在创建的 redux 的 store 时，使用 applyMiddleware 函数将创建的 saga Middleware 实例绑定到 store 上，最后可以调用 saga Middleware 的 run 函数来执行某个或者某些 Middleware 。</li><li>在 saga 的 Middleware 中，可以使用 takeEvery 或者 takeLatest 等 API 来监听某个 action ，当某个 action 触发后， saga 可以使用 call 发起异步操作，操作完成后使用 put 函数触发 action ，同步更新 state ，从而完成整个 State 的更新。</li></ol><p>redux 有哪些异步中间件:</p><ol><li><p>redux-thunk - 源代码简短优雅，上手简单</p></li><li><p>redux-saga - 借助 JS 的 generator 来处理异步，避免了回调的问题</p></li><li><p>redux-observable - 借助了 RxJS 流的思想以及其各种强大的操作符，来处理异步问题</p></li></ol><p>（2）Redux 的发布订阅模式：</p><ol><li>subscribe 订阅：Redux 通过 subscribe 接口注册订阅函数，并将这些用户提供的订阅函数添加到闭包中的 nextListeners 中</li><li>dispatch 发布：通过 Redux 的 dispatch 接口，我们可以发布一个 action 对象，去通知状态需要做一些改变</li></ol><p>Redux 与 发布订阅模式的区别：<br>redux 其实也是一个发布订阅，但是 redux 可以做到数据的可预测和可回溯</p><p>（3）redux 与 react 关联</p><p>react-redux 的核心组件只有两个，Provider 和 connect，Provider 存放 Redux 里 store 的数据到 context 里，通过 connect 从 context 拿数据，通过 props 传递给 connect 所包裹的组件。</p><p>（4）Redux、mobx、Vuex：</p><p>Redux 与 Mobx：</p><ul><li>Redux面向函数式编程，Mobx面向对象</li><li>Redux单一数据源（只有一个store），而 Mobx 容许多个</li><li>Redux的状态对象不可直接修改，而Mobx可以</li><li>Mobx更自由，更容易上手，Redux约束更多，有一定学习成本</li><li>自由需要代价，Mobx在更复杂的应用中将难管理，更难维护</li></ul><p>Redux 与 Vuex：</p><ul><li>Redux： view——&gt;actions——&gt;reducer——&gt;state变化——&gt;view变化（同步异步一样）</li><li>Vuex-同步： view——&gt;commit——&gt;mutations——&gt;state变化——&gt;view变化（同步操作）</li><li>Vuex-异步：view——&gt;dispatch——&gt;actions——&gt;mutations——&gt;state变化——&gt;view变化（异步操作）</li></ul><h3 id="7、fiber"><a href="#7、fiber" class="headerlink" title="7、fiber"></a>7、fiber</h3><p>react 在进行组件渲染时，从setState 开始到渲染完成整个过程是同步的。<br>如果需要渲染的组件比较庞大，js执行会占据主线程时间较长，会导致页面响应度变差，使得react在动画、手势等应用中效果比较差，出现卡顿的效果。</p><p>为了解决这个问题，React团队重写了react中核心算法。之前的reconciler[‘rekənsailə] 称为stack reconciler，重写后的称为fiber reconciler，简称为Fiber。</p><p><code>React Fiber</code> 是一种基于浏览器的单线程调度算法。</p><p>将 客户端线程执行任务 以帧的形式划分（切片），大部分设备控制在30-60帧是不会影响用户体验；在两个执行帧之间，主线程通常会有一小段空闲时间，<code>requestIdleCallback</code>可以在这个空闲期（<code>Idle Period</code>）调用空闲期回调（<code>Idle Callback</code>），执行一些任务.</p><ul><li>低优先级任务由 <code>requestIdleCallback</code> 处理；</li><li>高优先级任务，如动画相关的由 <code>requestAnimationFrame</code> 处理；</li><li><code>requestIdleCallback</code> 可以在多个空闲期调用空闲期回调，执行任务；</li><li><code>requestIdleCallback</code> 方法提供 <code>deadline</code> ，即任务执行限制时间，以切分任务，避免长时间执行，阻塞UI渲染而导致掉帧；</li></ul><p>这就可能会产生两个问题：</p><ul><li>饿死：正在实验中的方案是重用，也就是说高优先级的操作如果没有修改低优先级操作已经完成的节点，那么这部分工作是可以重用的。</li><li>一次渲染可能会调用多次声明周期函数</li></ul><p><code>React Fiber</code> 用类似 <code>requestIdleCallback</code> 的机制来做异步 <code>diff</code>。但是之前数据结构不支持这样的实现异步 <code>diff</code>，于是 <code>React</code> 实现了一个类似链表的数据结构，将原来的 <strong>递归diff</strong> 变成了现在的 <strong>遍历diff</strong>，这样就能做到异步可更新了。</p><img src="https://i.loli.net/2021/02/02/gweAjQS5osflqX1.jpg" ><p>相关链接：<a href="https://github.com/WangYuLue/react-in-deep/blob/main/02.React%20Fiber%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.md">React Fiber 是什么？</a><br><a href="https://juejin.cn/post/6844903582622285831">React Fiber</a></p><h3 id="8、diff-算法"><a href="#8、diff-算法" class="headerlink" title="8、diff 算法"></a>8、diff 算法</h3><p>将两颗树中所有的节点一一对比需要<code>O(n^2)</code>的复杂度。<br>再紧接着找到不同之后，再计算最短修改距离然后修改（添加、删除）节点，复杂度是<code>O(n)</code>.<br>合起来diff两个树的复杂度就是<code>O(n^3)</code></p><p>传统 <code>diff</code> 算法的时间复杂度是 <code>O(n^3)</code>，这在前端 <code>render</code> 中是不可接受的。<br>为了降低时间复杂度，<code>react</code> 的 <code>diff</code> 算法做了一些妥协，放弃了最优解，最终将时间复杂度降低到了 <code>O(n)</code>。</p><p><code>vue</code> 的更新策略就是：深度优先、同层比较。就是只比较同层级，也就是 <code>O(n)</code></p><p>那么 <code>react diff</code> 算法做了哪些妥协呢？，参考如下：</p><p>1、<code>tree diff</code>：只对比同一层的 <code>dom</code> 节点，忽略 <code>dom</code> 节点的跨层级移动</p><p>如下图，<code>react</code> 只会对相同颜色方框内的 <code>DOM</code> 节点进行比较，即同一个父节点下的所有子节点。当发现节点不存在时，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。</p><p>这样只需要对树进行一次遍历，便能完成整个 <code>DOM</code> 树的比较。</p><img src="https://i.loli.net/2021/02/02/j79gK3iQVwWyENr.jpg" ><p>这就意味着，如果 <code>dom</code> 节点发生了跨层级移动，<code>react</code> 会删除旧的节点，生成新的节点，而不会复用。</p><p>2、<code>component diff</code>：如果不是同一类型的组件，会删除旧的组件，创建新的组件</p><p>因此， React 允许用户通过 <code>shouldComponentUpdate()</code> 来判断该组件是否需要大量 <code>diff</code> 算法分析。</p><img src="https://i.loli.net/2021/02/02/YSNq9gemUvCKV5G.jpg" ><p>3、<code>element diff</code>：对于同一层级的一组子节点，需要通过唯一 <code>id</code>(即<code>key</code>‘) 进行来区分<br>当节点处于同一层级时，diff 提供三种节点操作：插入、移动、删除<br>如果没有 <code>id</code> 来进行区分，一旦有插入动作，会导致插入位置之后的列表全部重新渲染。</p><p>这也是为什么渲染列表时为什么要使用唯一的 <code>key</code>。</p><p>Vue 和 React 的 diff 算法有什么区别：<br>(1) Vue进行diff时，调用patch打补丁函数，一边比较一边给真实的DOM打补丁<br>(2) 当对比 <code>element</code> (元素) 发现 <code>className</code> 不同时，Vue 认为是不同类型元素，删除重建；React 认为是同类型节点，只修改节点属性<br>(3) 遍历同一层级的元素进行比较的方式不同：<br>  Vue 采用从两端到中间的方式，旧集合和新集合两端各存在两个指针，两两进行比较，如果匹配上了就按照新集合去调整旧集合，每次对比结束后，指针向队列中间移动。<br>  React 是从左往右依次对比，利用元素的index和标识lastIndex进行比较，如果满足index &lt; lastIndex就移动元素，删除和添加则各自按照规则调整；<br>  当一个集合把最后一个节点移动到最前面，react会把前面的节点依次向后移动，而Vue只会把最后一个节点放在最前面，这样的操作来看，Vue的diff性能是高于react的</p><p>Vue 2.x vs Vue 3.x：<br>（1）Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。<br>（2）Vue3.x借鉴了 ivi算法和 inferno算法（运用了动态规划的思想求解 最长递归子序列 ）。在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。</p><h3 id="9、-React性能优化"><a href="#9、-React性能优化" class="headerlink" title="9、 React性能优化"></a>9、 React性能优化</h3><p>1、shouldComponentUpdate</p><p>2、PureComponent 和 memo</p><ul><li>PureComponent(纯组件) shouldComponentUpdate 中实现了浅比较</li><li>memo 函数组件中的 PureComponent</li><li>浅比较已经适用大部分场景（尽量不要做深度比较）</li></ul><p>3、immutable.js</p><ul><li>彻底拥抱<strong>不可变值</strong></li><li>基于共享数据（不是深拷贝），速度好</li><li>缺点是 有一定的学习和迁移成本，按需使用</li></ul><h3 id="10、错误边界是什么？它有什么用？"><a href="#10、错误边界是什么？它有什么用？" class="headerlink" title="10、错误边界是什么？它有什么用？"></a>10、错误边界是什么？它有什么用？</h3><p>在 <code>React</code> 中，如果任何一个组件发生错误，它将破坏整个组件树，导致整页白屏。这时候我们可以用错误边界优雅地降级处理这些错误。</p><p>例如下面封装的组件：</p><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;<span class="hljs-title">IProps</span>, <span class="hljs-title">IState</span>&gt; </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props: IProps</span>)</span> &#123;    <span class="hljs-built_in">super</span>(props);    <span class="hljs-built_in">this</span>.state = &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> &#125;;  &#125;  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getDerivedStateFromError</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> &#125;;  &#125;  <span class="hljs-function"><span class="hljs-title">componentDidCatch</span>(<span class="hljs-params">error, errorInfo</span>)</span> &#123;    <span class="hljs-comment">// 可以将错误日志上报给服务器</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;组件奔溃 Error&#x27;</span>, error);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;组件奔溃 Info&#x27;</span>, errorInfo);  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state.hasError) &#123;      <span class="hljs-comment">// 你可以自定义降级后的 UI 并渲染</span>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.props.content;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.props.children;  &#125;&#125;</code></pre><h3 id="10、什么是-Portals？"><a href="#10、什么是-Portals？" class="headerlink" title="10、什么是 Portals？"></a>10、什么是 Portals？</h3><p><code>Portal</code> 提供了一种将子节点渲染到存在于父组件以外的 <code>DOM</code> 节点的优秀的方案。</p><p><code>ReactDOM.createPortal(child, container)</code></p><h3 id="11、React-组件间有那些通信方式"><a href="#11、React-组件间有那些通信方式" class="headerlink" title="11、React 组件间有那些通信方式?"></a>11、React 组件间有那些通信方式?</h3><p>父组件向子组件通信<br>1、 通过 <code>props</code> 传递</p><p>子组件向父组件通信<br>1、 主动调用通过 <code>props</code> 传过来的方法，并将想要传递的信息，作为参数，传递到父组件的作用域中</p><p>跨层级通信<br>1、 使用 <code>react</code> 自带的 <code>Context</code> 进行通信，<code>createContext</code> 创建上下文， <code>useContext</code> 使用上下文。</p><p>参考下面代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; createContext, useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> themes = &#123;  light: &#123;    foreground: <span class="hljs-string">&quot;#000000&quot;</span>,    background: <span class="hljs-string">&quot;#eeeeee&quot;</span>  &#125;,  dark: &#123;    foreground: <span class="hljs-string">&quot;#ffffff&quot;</span>,    background: <span class="hljs-string">&quot;#222222&quot;</span>  &#125;&#125;;<span class="hljs-keyword">const</span> ThemeContext = createContext(themes.light);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> (    &lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt;      &lt;Toolbar /&gt;    &lt;/ThemeContext.Provider&gt;  );&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Toolbar</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> (    &lt;div&gt;      &lt;ThemedButton /&gt;    &lt;/div&gt;  );&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ThemedButton</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> theme = useContext(ThemeContext);  <span class="hljs-keyword">return</span> (    &lt;button style=&#123;&#123; <span class="hljs-attr">background</span>: theme.background, <span class="hljs-attr">color</span>: theme.foreground &#125;&#125;&gt;      I am styled by theme context!    &lt;/button&gt;  );&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;</code></pre><p>2、使用 <code>Redux</code> 或者 <code>Mobx</code> 等状态管理库</p><p>3、使用订阅发布模式</p><p>相关链接：<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext">React Docs</a></p><h3 id="12、React-父组件如何调用子组件中的方法？"><a href="#12、React-父组件如何调用子组件中的方法？" class="headerlink" title="12、React 父组件如何调用子组件中的方法？"></a>12、React 父组件如何调用子组件中的方法？</h3><p>1、如果是在方法组件中调用子组件（&gt;= <a href="mailto:&#x72;&#x65;&#97;&#99;&#x74;&#64;&#x31;&#54;&#x2e;&#x38;">&#x72;&#x65;&#97;&#99;&#x74;&#64;&#x31;&#54;&#x2e;&#x38;</a>），可以使用 useRef 和 useImperativeHandle:</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; forwardRef, useRef, useImperativeHandle &#125; = React;<span class="hljs-keyword">const</span> Child = forwardRef(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> &#123;  useImperativeHandle(ref, <span class="hljs-function">() =&gt;</span> (&#123;    <span class="hljs-function"><span class="hljs-title">getAlert</span>(<span class="hljs-params"></span>)</span> &#123;      alert(<span class="hljs-string">&quot;getAlert from Child&quot;</span>);    &#125;  &#125;));  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hi<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;&#125;);<span class="hljs-keyword">const</span> Parent = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> childRef = useRef();  <span class="hljs-keyword">return</span> (    &lt;div&gt;      &lt;Child ref=&#123;childRef&#125; /&gt;      &lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> childRef.current.getAlert()&#125;&gt;Click&lt;/button&gt;    &lt;/div&gt;  );&#125;;</code></pre><p>2、如果是在类组件中调用子组件（&gt;= <a href="mailto:&#x72;&#x65;&#97;&#x63;&#x74;&#x40;&#x31;&#54;&#46;&#52;">&#x72;&#x65;&#97;&#x63;&#x74;&#x40;&#x31;&#54;&#46;&#52;</a>），可以使用 createRef:</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; Component &#125; = React;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;    <span class="hljs-built_in">super</span>(props);    <span class="hljs-built_in">this</span>.child = React.createRef();  &#125;  onClick = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">this</span>.child.current.getAlert();  &#125;;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> (      &lt;div&gt;        &lt;Child ref=&#123;<span class="hljs-built_in">this</span>.child&#125; /&gt;        &lt;button onClick=&#123;<span class="hljs-built_in">this</span>.onClick&#125;&gt;Click&lt;/button&gt;      &lt;/div&gt;    );  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">getAlert</span>(<span class="hljs-params"></span>)</span> &#123;    alert(<span class="hljs-string">&#x27;getAlert from Child&#x27;</span>);  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;  &#125;&#125;</code></pre><p>参考阅读：<a href="https://stackoverflow.com/questions/37949981/call-child-method-from-parent">Call child method from parent</a></p><h3 id="13、React有哪些优化性能的手段"><a href="#13、React有哪些优化性能的手段" class="headerlink" title="13、React有哪些优化性能的手段?"></a>13、React有哪些优化性能的手段?</h3><p>类组件中的优化手段<br>1、使用纯组件 PureComponent 作为基类。</p><p>2、使用 React.memo 高阶函数包装组件。</p><p>3、使用 shouldComponentUpdate 生命周期函数来自定义渲染逻辑。</p><p>方法组件中的优化手段<br>1、使用 useMemo。</p><p>2、使用 useCallBack。</p><p>其他方式<br>1、在列表需要频繁变动时，使用唯一 id 作为 key，而不是数组下标。</p><p>2、必要时通过改变 CSS 样式隐藏显示组件，而不是通过条件判断显示隐藏组件。</p><p>3、使用 Suspense 和 lazy 进行懒加载，例如：<br>/ [səˈspens]/ 悬念；悬疑；焦虑；悬而不决</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; lazy, Suspense &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallingLazyComponents</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">var</span> ComponentToLazyLoad = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.props.name == <span class="hljs-string">&quot;Mayank&quot;</span>) &#123;      ComponentToLazyLoad = lazy(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./mayankComponent&quot;</span>));    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.props.name == <span class="hljs-string">&quot;Anshul&quot;</span>) &#123;      ComponentToLazyLoad = lazy(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./anshulComponent&quot;</span>));    &#125;    <span class="hljs-keyword">return</span> (      &lt;div&gt;        &lt;h1&gt;This is the Base User: &#123;<span class="hljs-built_in">this</span>.state.name&#125;&lt;/h1&gt;        &lt;Suspense fallback=&#123;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&#125;&gt;          &lt;ComponentToLazyLoad /&gt;        &lt;/Suspense&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><p>Suspense 用法可以参考<a href="https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html">官方文档</a></p><p>相关阅读：<a href="https://www.infoq.cn/article/KVE8xtRs-uPphptq5LUz">21个React性能优化技巧</a></p><h3 id="14、为什么-React-元素有一个-typeof-属性？"><a href="#14、为什么-React-元素有一个-typeof-属性？" class="headerlink" title="14、为什么 React 元素有一个 $$typeof 属性？"></a>14、为什么 React 元素有一个 $$typeof 属性？</h3><img src="https://i.loli.net/2021/02/02/9QgBSIZsl3u8Mat.jpg" ><p>目的是为了防止 XSS 攻击。因为 Synbol 无法被序列化，所以 React 可以通过有没有 $$typeof 属性来断出当前的 element 对象是从数据库来的还是自己生成的。</p><p>如果没有 $$typeof 这个属性，react 会拒绝处理该元素。</p><p>在 React 的古老版本中，下面的写法会出现 XSS 攻击：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 服务端允许用户存储 JSON</span><span class="hljs-keyword">let</span> expectedTextButGotJSON = &#123;  type: <span class="hljs-string">&#x27;div&#x27;</span>,  props: &#123;    dangerouslySetInnerHTML: &#123;      __html: <span class="hljs-string">&#x27;/* 把你想的搁着 */&#x27;</span>    &#125;,  &#125;,  <span class="hljs-comment">// ...</span>&#125;;<span class="hljs-keyword">let</span> message = &#123; <span class="hljs-attr">text</span>: expectedTextButGotJSON &#125;;<span class="hljs-comment">// React 0.13 中有风险</span>&lt;p&gt;  &#123;message.text&#125;&lt;/p&gt;</code></pre><p>相关阅读：<a href="https://overreacted.io/zh-hans/why-do-react-elements-have-typeof-property/">为什么React元素有一个$$typeof属性？</a></p><h3 id="15、React-如何区分-Class组件-和-Function组件？"><a href="#15、React-如何区分-Class组件-和-Function组件？" class="headerlink" title="15、React 如何区分 Class组件 和 Function组件？"></a>15、React 如何区分 Class组件 和 Function组件？</h3><p>一般的方式是借助 typeof 和 Function.prototype.toString 来判断当前是不是 class，如下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isClass</span>(<span class="hljs-params">func</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> func === <span class="hljs-string">&#x27;function&#x27;</span>    &amp;&amp; <span class="hljs-regexp">/^class\s/</span>.test(<span class="hljs-built_in">Function</span>.prototype.toString.call(func));&#125;</code></pre><p>但是这个方式有它的局限性，因为如果用了 babel 等转换工具，将 class 写法全部转为 function 写法，上面的判断就会失效。</p><p>React 区分 Class组件 和 Function组件的方式很巧妙，由于所有的类组件都要继承 React.Component，所以只要判断原型链上是否有 React.Component 就可以了：</p><p>AComponent.prototype instanceof React.Component<br>相关阅读：<a href="https://overreacted.io/zh-hans/how-does-react-tell-a-class-from-a-function/">React 如何区分 Class 和 Function？</a></p><h3 id="16、HTML-和-React-事件处理有什么区别"><a href="#16、HTML-和-React-事件处理有什么区别" class="headerlink" title="16、HTML 和 React 事件处理有什么区别?"></a>16、HTML 和 React 事件处理有什么区别?</h3><p>在 HTML 中事件名必须小写：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&#x27;activateLasers()&#x27;</span>&gt;</span>而在 React 中需要遵循驼峰写法：<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;activateLasers&#125;</span>&gt;</span>在 HTML 中可以返回 false 以阻止默认的行为：<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#x27;#&#x27;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&#x27;console.log(&quot;The link was clicked.&quot;); return false;&#x27;</span> /&gt;</span>而在 React 中必须地明确地调用 preventDefault()：</code></pre><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleClick</span>(<span class="hljs-params">event</span>) </span>&#123;  event.preventDefault()  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The link was clicked.&#x27;</span>)&#125;</code></pre><h3 id="17、什么是-suspense-组件"><a href="#17、什么是-suspense-组件" class="headerlink" title="17、什么是 suspense 组件?"></a>17、什么是 suspense 组件?</h3><p>Suspense 让组件“等待”某个异步操作，直到该异步操作结束即可渲染。在下面例子中，两个组件都会等待异步 API 的返回值：<br>/ [səˈspens]/ 悬念；悬疑；焦虑；悬而不决</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> resource = fetchProfileData();<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ProfilePage</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> (    &lt;Suspense fallback=&#123;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Loading profile...<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>&#125;&gt;      &lt;ProfileDetails /&gt;      &lt;Suspense fallback=&#123;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Loading posts...<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>&#125;&gt;        &lt;ProfileTimeline /&gt;      &lt;/Suspense&gt;    &lt;/Suspense&gt;  );&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ProfileDetails</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">// 尝试读取用户信息，尽管该数据可能尚未加载</span>  <span class="hljs-keyword">const</span> user = resource.user.read();  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ProfileTimeline</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">// 尝试读取博文信息，尽管该部分数据可能尚未加载</span>  <span class="hljs-keyword">const</span> posts = resource.posts.read();  <span class="hljs-keyword">return</span> (    &lt;ul&gt;      &#123;posts.map(<span class="hljs-function"><span class="hljs-params">post</span> =&gt;</span> (        &lt;li key=&#123;post.id&#125;&gt;&#123;post.text&#125;&lt;/li&gt;      ))&#125;    &lt;/ul&gt;  );&#125;</code></pre><p>Suspense 也可以用于懒加载，参考下面的代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> OtherComponent = React.lazy(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./OtherComponent&#x27;</span>));<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> (    &lt;div&gt;      &lt;Suspense fallback=&#123;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&#125;&gt;        &lt;OtherComponent /&gt;      &lt;/Suspense&gt;    &lt;/div&gt;  );&#125;</code></pre><h3 id="18、为什么-JSX-中的组件名要以大写字母开头？"><a href="#18、为什么-JSX-中的组件名要以大写字母开头？" class="headerlink" title="18、为什么 JSX 中的组件名要以大写字母开头？"></a>18、为什么 JSX 中的组件名要以大写字母开头？</h3><p>因为 React 要知道当前渲染的是组件还是 HTML 元素。</p><h3 id="19、redux-是什么？"><a href="#19、redux-是什么？" class="headerlink" title="19、redux 是什么？"></a>19、redux 是什么？</h3><p>Redux 是一个为 JavaScript 应用设计的，可预测的状态容器。</p><p>它解决了如下问题：</p><p>跨层级组件之间的数据传递变得很容易<br>所有对状态的改变都需要 dispatch，使得整个数据的改变可追踪，方便排查问题。<br>但是它也有缺点：</p><p>概念偏多，理解起来不容易<br>样板代码太多</p><h3 id="20、react-redux-的实现原理？"><a href="#20、react-redux-的实现原理？" class="headerlink" title="20、react-redux 的实现原理？"></a>20、react-redux 的实现原理？</h3><p>通过 redux 和 react context 配合使用，并借助高阶函数，实现了 react-redux。</p><p>参考链接：<a href="http://huziketang.mangojuice.top/books/react/lesson36">React.js 小书</a></p><h3 id="21、reudx-和-mobx-的区别？"><a href="#21、reudx-和-mobx-的区别？" class="headerlink" title="21、reudx 和 mobx 的区别？"></a>21、reudx 和 mobx 的区别？</h3><p>得益于 Mobx 的 observable，使用 mobx 可以做到精准更新；对应的 Redux 是用 dispath 进行广播，通过Provider 和 connect 来比对前后差别控制更新粒度；</p><p>相关阅读：<a href="https://segmentfault.com/a/1190000011148981">Redux or MobX: An attempt to dissolve the Confusion</a></p><h3 id="22、redux-异步中间件有什么什么作用"><a href="#22、redux-异步中间件有什么什么作用" class="headerlink" title="22、redux 异步中间件有什么什么作用?"></a>22、redux 异步中间件有什么什么作用?</h3><p>假如有这样一个需求：请求数据前要向 Store dispatch 一个 loading 状态，并带上一些信息；请求结束后再向Store dispatch 一个 loaded 状态</p><p>一些同学可能会这样做：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> onClick = <span class="hljs-function">() =&gt;</span> &#123;    dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;LOADING&#x27;</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;data is loading&#x27;</span> &#125;)    fetch(<span class="hljs-string">&#x27;dataurl&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> &#123;      dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;LOADED&#x27;</span> &#125;)    &#125;);  &#125;  <span class="hljs-keyword">return</span> (&lt;div&gt;    &lt;button onClick=&#123;onClick&#125;&gt;click&lt;/button&gt;  &lt;/div&gt;);&#125;</code></pre><p>但是如果有非常多的地方用到这块逻辑，那应该怎么办？</p><p>聪明的同学会想到可以将 onClick 里的逻辑抽象出来复用，如下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchData</span>(<span class="hljs-params">message: string</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span> &#123;    dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;LOADING&#x27;</span>, message &#125;)    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;LOADED&#x27;</span> &#125;)    &#125;, <span class="hljs-number">1000</span>)  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> onClick = <span class="hljs-function">() =&gt;</span> &#123;    fetchData(<span class="hljs-string">&#x27;data is loading&#x27;</span>)(dispatch)  &#125;  <span class="hljs-keyword">return</span> (&lt;div&gt;    &lt;button onClick=&#123;onClick&#125;&gt;click&lt;/button&gt;  &lt;/div&gt;);&#125;</code></pre><p>很好，但是 fetchData(‘data is loading’)(dispatch) 这种写法有点奇怪，会增加开发者的心智负担。</p><p>于是可以借助 rudux 相关的异步中间件，以 rudux-chunk 为例，将写法改为如下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchData</span>(<span class="hljs-params">message: string</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span> &#123;    dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;LOADING&#x27;</span>, message &#125;)    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;LOADED&#x27;</span> &#125;)    &#125;, <span class="hljs-number">1000</span>)  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> onClick = <span class="hljs-function">() =&gt;</span> &#123;-   fetchData(<span class="hljs-string">&#x27;data is loading&#x27;</span>)(dispatch)+   dispatch(fetchData(<span class="hljs-string">&#x27;data is loading&#x27;</span>))  &#125;  <span class="hljs-keyword">return</span> (&lt;div&gt;    &lt;button onClick=&#123;onClick&#125;&gt;click&lt;/button&gt;  &lt;/div&gt;);&#125;</code></pre><p>这样就更符合认知一些了，redux 异步中间件没有什么奥秘，主要做的就是这样的事情。</p><p>相关阅读：<a href="https://stackoverflow.com/questions/34570758/why-do-we-need-middleware-for-async-flow-in-redux">Why do we need middleware for async flow in Redux?</a></p><h3 id="24、事件1：React-事件流程是什么-？"><a href="#24、事件1：React-事件流程是什么-？" class="headerlink" title="24、事件1：React 事件流程是什么 ？"></a>24、事件1：React 事件流程是什么 ？</h3><ul><li><p>事件注册</p><ul><li>组件装载 / 更新</li><li>通过 <code>lastProps</code>、<code>nextProps</code> 判断是否新增、删除事件分别调用事件注册、卸载方法</li><li>调用 <code>EventPluginHub</code> 的 <code>enqueuePutListener</code> 进行事件存储</li><li>获取 <code>document</code> 对象</li><li>根据事件名称（如 <code>onClick</code>、<code>onCaptureClick</code>）判断是进行冒泡还是捕获</li><li>判断是否存在 <code>addEventListener</code> 方法，否则使用 <code>attachEvent</code>（兼容IE）</li><li>给 <code>document</code> 注册原生事件回调为 <code>dispatchEvent</code>（统一的事件分发机制）</li></ul></li><li><p>事件存储</p><ul><li><code>EventPluginHub</code>负责管理<code>React</code>合成事件的<code>callback</code>，它将<code>callback</code>存储在<code>listenerBank</code>中，另外还存储了负责合成事件的<code>Plugin</code></li><li><code>EventPluginHub</code>的<code>putListener</code>方法是向存储容器中增加一个<code>listener</code></li><li>获取绑定事件的元素的唯一标识<code>key</code></li><li>将<code>callback</code>根据事件类型，元素的唯一标识<code>key</code>存储在<code>listenerBank</code>中</li><li><code>listenerBank</code>的结构是：<code>listenerBank[registrationName][key]</code><br>例如</li></ul><pre><code class="hljs javaScript">&#123;  onClick: &#123;      nodeid1:<span class="hljs-function">()=&gt;</span>&#123;...&#125;      nodeid2:<span class="hljs-function">()=&gt;</span>&#123;...&#125;  &#125;,  onChange: &#123;      nodeid3:<span class="hljs-function">()=&gt;</span>&#123;...&#125;      nodeid4:<span class="hljs-function">()=&gt;</span>&#123;...&#125;  &#125;&#125;</code></pre></li><li><p>事件触发/执行<br>这里的事件执行利用了React的批处理机制：</p><ul><li>触发 <code>document</code>注册原生事件的回调<code>dispatchEvent</code></li><li>获取到触发这个事件最深一级的元素</li></ul><p>找到事件触发的最深一级元素后：</p><ul><li>遍历这个元素的所有父元素，依次对每一级元素进行处理</li><li>构造合成事件</li><li>将每一级的合成事件存储在<code>eventQueue</code>事件队列中</li><li>遍历<code>eventQueue</code></li><li>通过<code>isPropagationStopped</code>判断当前事件是否执行了阻止冒泡方法</li><li>如果阻止了冒泡，停止遍历，否则通过<code>executeDispatch</code>执行合成事件</li></ul><p><code>react</code>在自己的合成事件中重写了<code>stopPropagation</code>方法，将<code>isPropagationStopped</code>设置为<code>true</code>，然后在遍历每一级事件的过程中根据此遍历判断是否继续执行。这就是<code>react</code>自己实现的冒泡机制。</p></li><li><p>合成事件</p><ul><li>调用<code>EventPluginHub</code>的<code>extractEvents</code>方法</li><li>循环所有类型的<code>EventPlugin</code>（用来处理不同事件的工具方法）</li><li>在每个<code>EventPlugin</code>中根据不同的事件类型，返回不同的事件池</li><li>在事件池中取出合成事件，如果事件池是空的，那么创建一个新的</li><li>根据元素<code>nodeid</code>(唯一标识<code>key</code>)和事件类型从<code>listenerBink</code>中取出回调函数</li><li>返回带有合成事件参数的回调函数</li></ul></li></ul><h3 id="25、事件2：React-为什么要手动绑定-this-？"><a href="#25、事件2：React-为什么要手动绑定-this-？" class="headerlink" title="25、事件2：React 为什么要手动绑定 this ？"></a>25、事件2：React 为什么要手动绑定 this ？</h3><p>  回调函数是<strong>直接调用</strong>的，并<strong>没有指定调用的组件</strong>，所以不进行手动绑定的情况下直接获取到的<code>this</code>是<code>undefined</code>。</p><p>  这里可以使用实验性的属性初始化语法 ，也就是<strong>直接在组件声明箭头函数</strong>。箭头函数不会创建自己的<code>this</code>，它只会从自己的作用域链的上一层继承<code>this</code>。因此这样我们在<code>React</code>事件中获取到的就是组件本身了。</p><h3 id="26、事件3：React事件和原生事件有什么区别-？"><a href="#26、事件3：React事件和原生事件有什么区别-？" class="headerlink" title="26、事件3：React事件和原生事件有什么区别 ？"></a>26、事件3：React事件和原生事件有什么区别 ？</h3><ul><li><p><strong>Vue</strong></p><ul><li>event 是原生的</li><li>事件被挂在到当前元素(触发也指向当前元素), 和DOM事件是一样的</li></ul></li><li><p><strong>React</strong></p><ul><li>event 事件的构造函数是 SyntheticEvent, 是模拟出来 DOM 事件的所有能力</li><li>event.nativeEvent 是原生事件对象</li><li>所有的事件都挂在到 document上, 和DOM 事件不一样, 和vue也不一样.(触发对象是和vue、DOM原生事件的对象一样)<br>React自己实现了一套事件机制，自己模拟了事件冒泡和捕获的过程，采用了事件代理、批量更新等方法，并且抹平了各个浏览器的兼容性问题。</li></ul></li><li><p>React 事件使用驼峰命名，原生事件命名全部小写</p></li><li><p>React 中的 <code>JSX</code> 事件传递的是一个函数作为事件处理程序，原生事件传递的是一个字符串</p></li><li><p>React 中组织默认行为必须明确调用 <code>preventDefault</code> ，原生事件 通过返回 <code>false</code> 来阻止默认行为</p></li></ul><h3 id="27、事件4：React事件和原生事件的执行顺序-？"><a href="#27、事件4：React事件和原生事件的执行顺序-？" class="headerlink" title="27、事件4：React事件和原生事件的执行顺序 ？"></a>27、事件4：React事件和原生事件的执行顺序 ？</h3><p>  react的所有事件都挂载在 <code>document</code> 中，当真实 <code>dom</code> 触发后冒泡到 <code>document</code> 后才会对 <code>react</code> 事件进行处理。<br>  所以：</p><ul><li>首先原生的事件会执行</li><li>然后执行react合成事件</li><li>最后执行真正在 <code>document</code> 上挂载的事件</li></ul><h3 id="28、事件5：react事件和原生事件可以混用吗？"><a href="#28、事件5：react事件和原生事件可以混用吗？" class="headerlink" title="28、事件5：react事件和原生事件可以混用吗？"></a>28、事件5：react事件和原生事件可以混用吗？</h3><p>  <code>react</code> 事件和原生事件最好不要混用。<br>  原生事件中如果执行了 <code>stopPropagation</code> 方法，则会导致其他 <code>react</code> 事件失效。因为所有元素的事件将无法冒泡到 <code>document</code> 上。<br>  由上面的执行机制不难得出，所有的 <code>react</code> 事件都将无法被注册。</p><h3 id="29、事件5：react-合成事件的浏览器兼容性问题"><a href="#29、事件5：react-合成事件的浏览器兼容性问题" class="headerlink" title="29、事件5：react 合成事件的浏览器兼容性问题"></a>29、事件5：react 合成事件的浏览器兼容性问题</h3><p>  事件处理程序将传递 <code>SyntheticEvent</code> 的实例，这是一个跨浏览器原生事件包装器。 它具有与浏览器原生事件相同的接口，包括 <code>stopPropagation()</code> 和 <code>preventDefault()</code> ，在所有浏览器中他们工作方式都相同。</p><p>  每个 <code>SyntheticEvent</code> 对象都具有以下属性：</p>  <pre><code class="hljs text">boolean bubblesboolean cancelableDOMEventTarget currentTargetboolean defaultPreventednumber eventPhaseboolean isTrustedDOMEvent nativeEventvoid preventDefault()boolean isDefaultPrevented()void stopPropagation()boolean isPropagationStopped()DOMEventTarget targetnumber timeStampstring type</code></pre><p>  <code>React</code>合成的<code>SyntheticEvent</code>采用了事件池，这样做可以大大节省内存，而不会频繁的创建和销毁事件对象。</p><p>  另外，不管在什么浏览器环境下，浏览器会将该事件类型统一创建为合成事件，从而达到了浏览器兼容的目的。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/304213203">React 灵魂 23 问，你能答对几个？</a><br><a href="https://segmentfault.com/a/1190000018391074">关于React事件的疑问</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>React</tag>
      
      <tag>题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-正则</title>
    <link href="/2021/01/05/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E6%AD%A3%E5%88%99/"/>
    <url>/2021/01/05/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E6%AD%A3%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h2 id="一、-matchAll-And-replace"><a href="#一、-matchAll-And-replace" class="headerlink" title="一、 matchAll And replace"></a>一、 matchAll And replace</h2><h3 id="1、String-prototype-matchAll"><a href="#1、String-prototype-matchAll" class="headerlink" title="1、String.prototype.matchAll()"></a>1、String.prototype.matchAll()</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll">MDN-String.prototype.matchAll()</a></p><p>作用: matchAll() 方法返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。</p><p>语法: <code>str.matchAll(regexp)</code></p><p>参数:</p><ul><li>regexp: 正则表达式对象。如果所传参数不是一个正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp 。(RegExp必须是设置了全局模式g的形式，否则会抛出异常TypeError。)</li></ul><p>返回值: 一个迭代器（不可重用，结果耗尽需要再次调用方法，获取一个新的迭代器）。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 实例一:</span><span class="hljs-keyword">const</span> regexp = <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;foo[a-z]*&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>); <span class="hljs-comment">// const regexp = /foo[a-z]*/g;</span><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;table football, foosball&#x27;</span>;<span class="hljs-comment">// 1、直接获取迭代器,进行 next() 遍历</span><span class="hljs-keyword">const</span> matches = str.matchAll(regexp);<span class="hljs-keyword">const</span> resArr = [];<span class="hljs-keyword">let</span> nextVal;<span class="hljs-keyword">while</span>(nextVal = matches.next().value) &#123;resArr.push(nextVal[<span class="hljs-number">0</span>]);&#125;<span class="hljs-comment">// 2、转换为数组</span><span class="hljs-keyword">var</span> ite = str.matchAll(regexp)<span class="hljs-keyword">var</span> array = [...ite];<span class="hljs-built_in">console</span>.log(array.length); <span class="hljs-comment">// 2</span></code></pre><img src="https://i.loli.net/2021/01/07/IWgdFcxN3XpOJoe.png" ><pre><code class="hljs javascript"><span class="hljs-comment">// 实例二:</span><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/([a-z])\1&#123;2,&#125;/g</span><span class="hljs-keyword">var</span> r = [];<span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;abcdddeeeeaabbbcd&quot;</span>;s.replace(reg, <span class="hljs-function">(<span class="hljs-params">a, _, i</span>) =&gt;</span> r.push([i, i + a.length - <span class="hljs-number">1</span>]));<span class="hljs-built_in">console</span>.log(r);</code></pre><h3 id="2、String-prototype-replace"><a href="#2、String-prototype-replace" class="headerlink" title="2、String.prototype.replace()"></a>2、String.prototype.replace()</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace">MDN-String.prototype.replace()</a></p><p>作用: replace() 方法返回一个由替换值（replacement）替换部分或所有的模式（pattern）匹配项后的新字符串。模式可以是一个字符串或者一个正则表达式，替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。<strong>如果pattern是字符串，则仅替换第一个匹配项。</strong><br><strong>原字符串不会改变。</strong></p><p>语法: <code>str.replace(regexp|substr, newSubStr|function)</code></p><p>参数:</p><ul><li><code>regexp (pattern)</code> —— 一个RegExp 对象或者其字面量。该正则所匹配的内容会被第二个参数的返回值替换掉。</li><li><code>substr (pattern)</code> —— 一个将被 newSubStr 替换的 字符串。其被视为一整个字符串，而不是一个正则表达式。仅第一个匹配项会被替换。</li><li><code>newSubStr (replacement)</code> —— 用于替换掉第一个参数在原字符串中的匹配部分的字符串。该字符串中可以内插一些特殊的变量名。</li><li><code>function (replacement)</code> —— 一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。</li></ul><pre><code class="hljs text">function (replacement)当指定一个函数作为第二个参数时，函数的参数如下：- match —— 匹配的子串- p1,p2, ... —— 如果第一个参数是一个正则，可能会匹配n个对象，代表匹配的对象如果是用 /(\a+)(\b+)/ 这个来匹配，p1 就是匹配的 \a+，p2 就是匹配的 \b+，以此类推- offset —— 匹配到的子字符串在原字符串中的偏移量- string —— 被匹配的原字符串- NamedCaptureGroup</code></pre><p>返回值: 一个部分或全部匹配由替代模式所取代的新的字符串。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 实例一:</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replacer</span>(<span class="hljs-params">match, p1, p2, p3, offset, string</span>) </span>&#123;  <span class="hljs-keyword">return</span> [p1, p2, p3].join(<span class="hljs-string">&#x27; - &#x27;</span>);&#125;<span class="hljs-keyword">var</span> newString = <span class="hljs-string">&#x27;abc12345#$*%&#x27;</span>.replace(<span class="hljs-regexp">/([^\d]*)(\d*)([^\w]*)/</span>, replacer);<span class="hljs-built_in">console</span>.log(newString);  <span class="hljs-comment">// abc - 12345 - #$*%</span><span class="hljs-comment">// 实例二:</span><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;abcdddeeeeaabbbcd&quot;</span>;<span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/([a-z])\1&#123;2,&#125;/g</span><span class="hljs-keyword">let</span> g = s.matchAll(reg);<span class="hljs-keyword">var</span> r = [];<span class="hljs-keyword">var</span> t;<span class="hljs-keyword">while</span> (t = g.next().value) r.push([t.index, t.index + t[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>]);<span class="hljs-built_in">console</span>.log(r);</code></pre><h3 id="3、例题"><a href="#3、例题" class="headerlink" title="3、例题"></a>3、例题</h3><h4 id="1-较大分组的位置"><a href="#1-较大分组的位置" class="headerlink" title="1.较大分组的位置"></a>1.较大分组的位置</h4><p><a href="https://leetcode-cn.com/problems/positions-of-large-groups/">leetcode-830较大分组的位置[简单]</a></p><p>在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。</p><p>例如，在字符串 s = “abbxxxxzyy” 中，就含有 “a”, “bb”, “xxxx”, “z” 和 “yy” 这样的一些分组。</p><p>分组可以用区间 [start, end] 表示，其中 start 和 end 分别表示该分组的起始和终止位置的下标。上例中的 “xxxx” 分组用区间表示为 [3,6] 。</p><p>我们称所有包含大于或等于三个连续字符的分组为 <strong>较大分组</strong> 。</p><p>找到每一个 <strong>较大分组</strong> 的区间，<strong>按起始位置下标递增顺序排序后</strong>，返回结果。</p><p>示例 1：</p><pre><code class="hljs text">输入：s = &quot;abbxxxxzzy&quot;输出：[[3,6]]解释：&quot;xxxx&quot; 是一个起始于 3 且终止于 6 的较大分组。</code></pre><p>示例 2：</p><pre><code class="hljs text">输入：s = &quot;abc&quot;输出：[]解释：&quot;a&quot;,&quot;b&quot; 和 &quot;c&quot; 均不是符合要求的较大分组。</code></pre><p>示例 3：</p><pre><code class="hljs text">输入：s = &quot;abcdddeeeeaabbbcd&quot;输出：[[3,5],[6,9],[12,14]]解释：较大分组为 &quot;ddd&quot;, &quot;eeee&quot; 和 &quot;bbb&quot;</code></pre><p>示例 4：</p><pre><code class="hljs text">输入：s = &quot;aba&quot;输出：[]</code></pre><p>提示：</p><ol><li>1 &lt;= s.length &lt;= 1000</li><li>s 仅含小写英文字母</li></ol><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> largeGroupPositions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;    <span class="hljs-comment">// 解法一: 双指针</span>    <span class="hljs-comment">// let res = [];</span>    <span class="hljs-comment">// if (!s) return res;</span>    <span class="hljs-comment">// let p1 = 0;</span>    <span class="hljs-comment">// let p2;</span>    <span class="hljs-comment">// while(p1 &lt; s.length - 1) &#123;</span>    <span class="hljs-comment">//     p2 = p1 + 1;</span>    <span class="hljs-comment">//     while(s[p1] === s[p2]) &#123;</span>    <span class="hljs-comment">//         p2++;</span>    <span class="hljs-comment">//     &#125;</span>    <span class="hljs-comment">//     if(p2 - p1 &gt;= 3 ) &#123;</span>    <span class="hljs-comment">//         res.push([p1, p2 - 1]);</span>    <span class="hljs-comment">//         p1 = p2;</span>    <span class="hljs-comment">//     &#125; else &#123;</span>    <span class="hljs-comment">//         p1++;</span>    <span class="hljs-comment">//     &#125;</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-comment">// return res;</span>    <span class="hljs-comment">// 解法二: 正则matchAll —— ([a-z])捕获小写字母，\1反向引用刚才捕获的字母，&#123;2,&#125;该字母又出现&gt;=2次</span>    <span class="hljs-comment">// let g = s.matchAll(/([a-z])\1&#123;2,&#125;/g);</span>    <span class="hljs-comment">// let r = [];</span>    <span class="hljs-comment">// let t;</span>    <span class="hljs-comment">// while (t = g.next().value) r.push([t.index, t.index + t[0].length - 1])</span>    <span class="hljs-comment">// return r</span>    <span class="hljs-comment">// 解法三</span>    <span class="hljs-keyword">const</span> r = [];    s.replace(<span class="hljs-regexp">/([a-z])\1&#123;2,&#125;/g</span>, <span class="hljs-function">(<span class="hljs-params">a, _, i</span>)=&gt;</span> r.push([i, i + a.length - <span class="hljs-number">1</span>]));    <span class="hljs-keyword">return</span> r;&#125;;</code></pre><h4 id="2-下划线转驼峰"><a href="#2-下划线转驼峰" class="headerlink" title="2.下划线转驼峰"></a>2.下划线转驼峰</h4><p>方法一：正则表达式 （推荐）</p><pre><code class="hljs JavaScript"><span class="hljs-comment">// 驼峰式转下横线：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerLine</span>(<span class="hljs-params">str</span>) </span>&#123;<span class="hljs-keyword">var</span> temp = str.replace(<span class="hljs-regexp">/[A-Z]/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">match</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;_&quot;</span> + match.toLowerCase();  &#125;);<span class="hljs-comment">//如果首字母是大写，执行replace时会多一个_，这里需要去掉</span>  <span class="hljs-keyword">if</span>(temp.slice(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) === <span class="hljs-string">&#x27;_&#x27;</span>)&#123;  temp = temp.slice(<span class="hljs-number">1</span>);  &#125;<span class="hljs-keyword">return</span> temp;&#125;;<span class="hljs-built_in">console</span>.log(toLowerLine(<span class="hljs-string">&quot;TestToLowerLine&quot;</span>));  <span class="hljs-comment">//test_to_lower_line</span><span class="hljs-built_in">console</span>.log(toLowerLine(<span class="hljs-string">&quot;testToLowerLine&quot;</span>));  <span class="hljs-comment">//test_to_lower_line</span><span class="hljs-comment">// 下横线转驼峰式：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toCamel</span>(<span class="hljs-params">str</span>) </span>&#123;  <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/([^_])(?:_+([^_]))/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">match, $<span class="hljs-number">1</span>, $<span class="hljs-number">2</span></span>) </span>&#123;<span class="hljs-comment">// match=t_b, $1=t, $2=b</span><span class="hljs-comment">// match=e_c, $1=e, $2=c</span><span class="hljs-keyword">return</span> $<span class="hljs-number">1</span> + $<span class="hljs-number">2.</span>toUpperCase();  &#125;);&#125;<span class="hljs-built_in">console</span>.log(toCamel(<span class="hljs-string">&#x27;test_be_camel&#x27;</span>)); <span class="hljs-comment">//testToCamel</span></code></pre><p>方法二：利用数组的 reduce 方法实现</p><pre><code class="hljs JavaScript"><span class="hljs-comment">// 驼峰式转下横线：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerLine</span>(<span class="hljs-params">arr</span>)</span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> arr === <span class="hljs-string">&#x27;string&#x27;</span>)&#123;arr = arr.split(<span class="hljs-string">&#x27;&#x27;</span>);&#125;<span class="hljs-keyword">return</span> arr.reduce(doLowerLine,<span class="hljs-string">&#x27;&#x27;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doLowerLine</span>(<span class="hljs-params">previousValue, currentValue, currentIndex, array</span>)</span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-regexp">/[A-Z]/</span>.test(currentValue))&#123;currentValue = currentValue.toLowerCase();<span class="hljs-keyword">if</span>(currentIndex === <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> previousValue + currentValue;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> previousValue + <span class="hljs-string">&#x27;_&#x27;</span> + currentValue;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> previousValue + currentValue;&#125;&#125;<span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;TestToLowerLine&#x27;</span>;<span class="hljs-keyword">var</span> res1 = toLowerLine(a);<span class="hljs-comment">//test_to_lower_line</span><span class="hljs-keyword">var</span> res2 = [].reduce.call(a,doLowerLine,<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-comment">//test_to_lower_line</span><span class="hljs-comment">// 下横线转驼峰式：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toCamel</span>(<span class="hljs-params">str</span>) </span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> str === <span class="hljs-string">&#x27;string&#x27;</span>)&#123;str = str.split(<span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-comment">//转为字符数组</span>&#125;<span class="hljs-keyword">return</span> str.reduce(doCamel);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doCamel</span>(<span class="hljs-params">previousValue, currentValue, currentIndex, array</span>)</span>&#123;<span class="hljs-keyword">if</span> (previousValue.endsWith(<span class="hljs-string">&#x27;_&#x27;</span>)) &#123;<span class="hljs-keyword">return</span> previousValue.substring(<span class="hljs-number">0</span>, previousValue.length - <span class="hljs-number">1</span>) + currentValue.toUpperCase();&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> previousValue + currentValue;&#125;&#125;<span class="hljs-built_in">console</span>.log(toCamel(<span class="hljs-string">&#x27;test_to_camel&#x27;</span>));    <span class="hljs-comment">//TestToCamel</span></code></pre><p>方法三：利用数组的 map 方法实现</p><pre><code class="hljs JavaScript"><span class="hljs-comment">// 驼峰式转下横线：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doLowerLine</span>(<span class="hljs-params">val, index, arr</span>)</span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-regexp">/[A-Z]/</span>.test(val))&#123;<span class="hljs-keyword">if</span>(index === <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> val.toLowerCase();&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;_&#x27;</span> + val.toLowerCase();&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> val;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerLine</span>(<span class="hljs-params">arr</span>)</span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> arr === <span class="hljs-string">&#x27;string&#x27;</span>)&#123;<span class="hljs-keyword">return</span> [].map.call(arr,doLowerLine).join(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-comment">// Array.prototype.map.call(arr, doLowerLine).join(&#x27;&#x27;);</span>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> arr.map(doLowerLine).join(<span class="hljs-string">&#x27;&#x27;</span>);&#125;&#125;<span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;TestToLowerLine&#x27;</span>;<span class="hljs-keyword">var</span> res1 = [].map.call(a,doLowerLine).join(<span class="hljs-string">&#x27;&#x27;</span>);    <span class="hljs-comment">//test_to_lower_line</span><span class="hljs-keyword">var</span> res2 = toLowerLine(a);    <span class="hljs-comment">//test_to_lower_line</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/21/old/vue-interview/"/>
    <url>/2020/12/21/old/vue-interview/</url>
    
    <content type="html"><![CDATA[<h1 id="vue目录"><a href="#vue目录" class="headerlink" title="vue目录"></a>vue目录</h1><p><a href="#_Toc29832069">1. MVC和MVVM的区别 2</a></p><p><a href="#_Toc29832070">2. Vue数据双向绑定的原理 2</a></p><p><a href="#_Toc29832071">3. Vue组件通信 2</a></p><p><a href="#_Toc29832072">4. Vue组件data为什么必须是函数 3</a></p><p><a href="#_Toc29832073">5. vue-route是怎么实现的 4</a></p><p><a href="#_Toc29832074">6. Vue中$nextTick有什么用 4</a></p><p><a href="#_Toc29832075">7.为什么Vue的$nextTick不稳定 4</a></p><p><a href="#_Toc29832076">8. Vue中怎么自定义指令 4</a></p><p><a href="#_Toc29832077">9. Vue中key的作用 5</a></p><p><a href="#_Toc29832078">10. Vue生命周期的理解 5</a></p><p><a href="#_Toc29832079">11. Vue父组件和子组件生命周期钩子函数执行顺序 5</a></p><p><a href="#_Toc29832080">12.父组件可以监听到子组件的生命周期吗 6</a></p><p><a href="#_Toc29832081">13.clas与style如何动态绑定 6</a></p><p><a href="#_Toc29832082">14.直接给一个数组项赋值，vue能监听到吗 7</a></p><p><a href="#_Toc29832083">15.Vue是怎么实现对象和数组的监听 7</a></p><p><a href="#_Toc29832084">16.Vue怎么用vm.$set()解决对象新增属性不能相应的问题 7</a></p><p><a href="#_Toc29832085">17.vue3.0有哪些改变 8</a></p><p><a href="#_Toc29832086">18.Proxy与Object.defineProperty优劣对比 8</a></p><p><a href="#_Toc29832087">19.谈谈你对keep-alive的理解 9</a></p><p><a href="#_Toc29832088">20.虚拟DOM的优缺点 9</a></p><p><a href="#_Toc29832089">21.你有对vue项目进行哪些优化 9</a></p><p><a href="#_Toc29832090">（一）代码层面的优化</a> 9</p><p><a href="#_Toc29832091">（二）</a>webpack层面的优化 11</p><p><a href="#_Toc29832092">（三）基础的</a>web技术优化 13</p><h1 id="1-MVC和MVVM的区别"><a href="#1-MVC和MVVM的区别" class="headerlink" title="1. MVC和MVVM的区别"></a>1. MVC和MVVM的区别</h1><p><strong>MVC</strong> ：MVC是单向的，通过Collector（JS代码）处理用户与应用的交互，响应对View（Html）的操作（对事件监听），并调用Model（JS的Ajax代码）对数据进行操作，完成Model与View的同步（根据Model的改变，通过选择器对View进行操作更新）。</p><p><strong>MVVM</strong> ：MVVM是双向的，它实现了Model和View的自动同步，也就是当Model的属性改变时，我们不再手动操作DOM元素来改变View的显示。</p><p>React和Vue的区别：</p><ul><li><p><strong>数据流</strong> ：</p></li><li><p>React是单向数据流（Props从父组件到子组件单向，数据到视图单向），称之为onChange/setState模式</p></li><li><p>Vue默认支持双向绑定（数据和视图双向绑定），在vue1.0版本中props支持父子组件之间双向绑定，到vue2.x版本原生不支持了，但是提供了一个语法糖通过事件的方式修改。</p></li><li><p><strong>数据监听</strong> ：</p></li><li><p>React是在setState后比较数据引用的方式监听，如果不优化（PureComponent/shouldComponentUpdate）可能会导致大量不必要的VDOM的从新渲染</p></li><li><p>Vue通过ES5的数据劫持方法defineProperty监听数据变化，能精确知道数据变化，不需要特别的优化就能达到很好的性能transform</p></li><li><p><strong>模板渲染</strong> ：</p></li><li><p>React是使用JSX，本质上在js中使用原生的语法(如if、map等方法)动态渲染模板。</p></li></ul><p>好处是更加纯粹更加原生，比如React的render函数是支持闭包特性的，所以我们import的组件可以直接调用；但是在Vue中，由于模板使用的数据都必须挂在this上进行一次中转，所以我们import一个组件后还需要在components中再声明一下，这样显得很奇怪但是又不得不这样做。</p><ul><li><p>Vue则是使用指令来动态渲染模板，实现模板和JS代码分离。</p></li><li><p><strong>Vuex**</strong> 和 <strong>**Redux</strong> ：</p></li><li><p>React中的每个组件都需要显示的用connect把需要的props和dispatch连接起来。原理上来说，Redux在检测数据变化的时候，是通过diff的方式比较差异的，并且Redux使用的是不可变数据，每次都是用新的state来替代旧的state</p></li><li><p>Vue的$store直接被注入的组件实例中,因此使用非常灵活，使用dispatch和commit提交更新，通过mapState或者直接this.$store来读取数据。原来上来说，Vuex与vue原理一样，通过getter/setter来比较，如果看过源码会知道，它内部是通过直接创建一个vue实例来跟踪数据变化的</p></li><li><p><strong>HOC**</strong> 和 <strong>**mixin</strong> ：</p></li><li><p>React中组合不同功能的方式通过Hoc（高阶组件），高阶组件本质就是高阶函数，React组件是一个纯粹的函数，所以高阶组件对于React来说非常简单。早期React也是使用Mixin，后来由于对组件侵入性太强会导致很多问题，后来弃用Mixin转而使用Hoc</p></li><li><p>Vue对组合不同功能的方式使用Mixin，不能使用Hoc是因为vue是一个被包装的函数，vue在创建组件实例时隐式做了很多事情，如果我们直接把组件的声明包装一下，返回一个高阶组件，那么这个高阶组件就无法正常工作了。</p></li></ul><h1 id="2-Vue数据双向绑定的原理"><a href="#2-Vue数据双向绑定的原理" class="headerlink" title="2. Vue数据双向绑定的原理"></a>2. Vue数据双向绑定的原理</h1><p>实现MVVM的双向绑定，是通过Object.defineProperty()来劫持各个属性的getter和setter，并结合发布者-订阅者模式的方式实现。</p><h1 id="3-Vue组件通信"><a href="#3-Vue组件通信" class="headerlink" title="3. Vue组件通信"></a>3. Vue组件通信</h1><p>（1）父组件向子组件传值 - Props传递数据</p><p>（2）子组件通信父组件 - $emit方法回调</p><p>（3）$emit、$on 通过Vue的实例触发事件和监听事件，实现跨级组件的通信</p><p>&amp;lt;!–在Vue的原型链上添加$bus属性，赋值为Vue实例–&amp;gt;</p><p>const EventBus = new Vue()</p><p>Object.defineProperties(Vue.prototype, {</p><p>$bus: {</p><p>get () {</p><p>return EventBus</p><p>}</p><p>}</p><p>})</p><p>window.globalVue = EventBus</p><p>&amp;lt;!– 使用 –&amp;gt;</p><p>// 在组价B中监听固定的事件名，当A组件触发change事件后，监听到事件触发，触发事件时机不确定，一般在created或mounted中监听</p><p>// 组件A</p><p>&amp;lt;template&amp;gt;</p><p>&amp;lt;div @click = &quot;changeHandle&quot; &amp;gt;触发事件&amp;lt;/div&amp;gt;</p><p>&amp;lt;/template&amp;gt;</p><p>&amp;lt;script&amp;gt;</p><p>exportdefault {</p><p>methods: {</p><p>changeHandle () {</p><p>window.globalVue.$emit(&#39;change&#39;, 4456)</p><p>}</p><p>}</p><p>}</p><p>&amp;lt;/script&amp;gt;</p><p>// 组件B</p><p>&amp;lt;template&amp;gt;</p><p>&amp;lt;div&amp;gt;监听事件&amp;lt;/div&amp;gt;</p><p>&amp;lt;/template&amp;gt;</p><p>&amp;lt;script&amp;gt;</p><p>exportdefault {</p><p>mounted () {</p><p>window.globalVue.$on(&#39;change&#39;, str =&amp;gt; {</p><p>console.log(str) // 4456</p><p>})</p><p>}</p><p>}</p><p>&amp;lt;/script&amp;gt;</p><p>（3）$parent、$children 多层级传递</p><p>（4）$attrs批量向下传递属性，$listeners批量向下传递方法</p><p>（5）Provide &amp; Inject</p><p>Provide在父级中注入数据：</p><p>provide () {</p><p>return {parentMsg: &#39;wwwaa&#39;}</p><p>}</p><p>Inject在任意子组件中可以注入父级数据</p><p>inject: [&#39;parentMsg&#39;] // 会将数据挂在在当前实例上</p><p>（6）ref使用</p><p>this.$refs.grand.name // 通过$refs获取组件实例，并获取属性或方法</p><p>（7）EventBus：跨组件通知</p><p>provide () {</p><p>return {parentMsg: &#39;wwwaa&#39;}</p><p>}</p><p>Vue.prototype.$bus = new Vue()</p><p>// Son2组件和Grandson1互相通信</p><p>mounted () {</p><p>// 父组件注册</p><p>this.$bus.$on(&#39;my&#39;, data =&amp;gt; {</p><p>console.log(data)</p><p>})</p><p>}</p><p>mounted () {</p><p>// 侄子组件调用</p><p>this.$nextTick(() =&amp;gt; {</p><p>this.$bus.$emit(&#39;my&#39;, &#39;我是小红&#39;)</p><p>})</p><p>}</p><h1 id="4-Vue组件data为什么必须是函数"><a href="#4-Vue组件data为什么必须是函数" class="headerlink" title="4. Vue组件data为什么必须是函数"></a>4. Vue组件data为什么必须是函数</h1><p>因为组件可以被用来创建对个实例对象，如果 <strong>data</strong> 是一个对象，每个实例对象的 <strong>data</strong> 属性都指向该 <strong>data</strong> 的内存地址值，也就是说每个实例对象中的 <strong>data</strong> 都是同一个对象</p><p>如果 <strong>data</strong> 是一个函数的话，每创建一个组件的实例对象，就会返回一个新的 <strong>data</strong> ，类似于给每个组件实例创建一个私有的数据空间，让各自组件实例维护各自的数据。</p><h1 id="5-vue-route是怎么实现的"><a href="#5-vue-route是怎么实现的" class="headerlink" title="5. vue-route是怎么实现的"></a>5. vue-route是怎么实现的</h1><p>vue-route是通过hash与Historyinterface两种方式实现前端路由，&quot;更新视图但不请求页面&quot;是前端路由原理的核心之一。</p><p><strong>hash**</strong> 模式**：在浏览器中&quot;#&quot;以及&quot;#&quot;后面的字符称之为hash，用window.location.hash读取。特点：hash虽然在url中，但不包含在HTTP请求中，用来指导浏览器动作，对服务器安全无用，hash的值发生变化，不会重新向服务器发送请求。</p><p><strong>history**</strong> 模式 <strong>：依赖</strong> HTML5 <strong>的History API和服务器配置，History API提供了两个方法：pushState</strong> ()**、replaceState()，利用history.pushState API来完成URL的跳转而无需重新加载页面，并且可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。（由于这种配置下我们的应用是单页客户端应用，如果后台没有正确的配置，用户请求页面将会返回404。因此需要在服务端增加一个覆盖所有情况的候选资源：如果URL匹配不到任何静态资源，则返回同一个index.html页面，这个页面就是你APP依赖的页面。）</p><p><strong>abstract</strong> :支持所有JavaScript运行环境，包括NodeJS服务器端。</p><h1 id="6-Vue中-nextTick有什么用"><a href="#6-Vue中-nextTick有什么用" class="headerlink" title="6. Vue中$nextTick有什么用"></a>6. Vue中$nextTick有什么用</h1><p>Vue.$nextTick用于延迟执行一段代码，它接收2个参数（回调函数和执行回调函数的上下文环境），如果没有提供回调函数，那么将返回 <strong>promise</strong> 对象。</p><p>在nextTick中定义了三个重要变量：callBacks（用来存储所有需要执行的回调函数）、pending（用来标记是否正在执行回调函数）、timeFunc（用来触发执行回调函数）。</p><p>timeFunc的触发方式有三种：</p><ul><li>先判断是否原生支持promise，如果支持，则利用promise来触发执行回调函数</li><li>否则，如果支持MutationObserve，则实例化一个观察者对象，观察文本接点发生变化时，触发执行所有的回调函数。（MutationObserve是HTML5的新API，是个用来监听DOM变动的接口）</li><li>如果都不支持，则利用setTimeOut设置延迟为0来实现异步。</li></ul><p>总结：Vue.$nextTick是一个异步函数，当DOM更新完成后执行传入的回调函数。</p><h1 id="7-为什么Vue的-nextTick不稳定"><a href="#7-为什么Vue的-nextTick不稳定" class="headerlink" title="7.为什么Vue的$nextTick不稳定"></a>7.为什么Vue的$nextTick不稳定</h1><p>因为Vue的$nextTick采用的是优雅降级：promise.then =&amp;gt; setImmediate =&amp;gt; MutationObserve =&amp;gt;setTimeOut， DOM是异步更新，真正更新渲染好的时间，不能完全确定，因此$nextTick并不能保证拿到最新的DOM。</p><h1 id="8-Vue中怎么自定义指令"><a href="#8-Vue中怎么自定义指令" class="headerlink" title="8. Vue中怎么自定义指令"></a>8. Vue中怎么自定义指令</h1><p>(1)自定义全局指令</p><p>// main.js</p><p>Vue.directive(&#39;mycolor&#39;, {</p><p>inserted (el) {</p><p>// 这里的el就是获取的标签元素，可以直接操作DOM</p><p>el.color.style = &#39;red&#39;</p><p>}</p><p>})</p><p>// template</p><p>&amp;lt;div v-mycolor &amp;gt;&amp;lt;/div&amp;gt;</p><p>(2)组件内部自定义指令</p><p>// template</p><p>&amp;lt;div v-mycolor&amp;gt;&amp;lt;/div&amp;gt;</p><p>// script</p><p>directives: {</p><p>mycolor: {</p><p>inserted (el) {</p><p>el.color.style = &#39;red&#39;</p><p>}</p><p>}</p><p>}</p><h1 id="9-Vue中key的作用"><a href="#9-Vue中key的作用" class="headerlink" title="9. Vue中key的作用"></a>9. Vue中key的作用</h1><p>Vue和React虚拟DOM的diff算法大致相同，其核心是基于两个简单的假设：</p><p>（1）两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构；</p><p>（2）同一层级的一组节点，他们可以通过唯一的id进行区分。</p><p>key是给每一个vNode的唯一id，可以依靠key更精确、更快的拿到oldVnode中对应的vNode节点。利用key的唯一性生成map对象来获取对应节点，比遍历方式更快。</p><h1 id="10-Vue生命周期的理解"><a href="#10-Vue生命周期的理解" class="headerlink" title="10. Vue生命周期的理解"></a>10. Vue生命周期的理解</h1><p>Vue实例从创建到销毁的过程，就是一个vue组件的生命周期。</p><p>开始创建=&amp;gt;初始化数据=&amp;gt;编译模板=&amp;gt;挂载DOM=&amp;gt;渲染、更新=&amp;gt;渲染、卸载</p><ul><li><strong>beforeCreate</strong> ：组件实例被创建之初，组件的属性生效之前</li><li><strong>created</strong> ：组件实例已经完全被创建，属性已绑定，但真实的DOM还没生成，$el还不能用</li><li><strong>beforeMount</strong> ：在挂载之前被调用，相关的render函数首次被调用</li><li><strong>mounted</strong> ：el被新创建的vm.$el替换，并挂载到实例上之后调用该钩子函数</li><li><strong>beforeUpdate</strong> ：组件数据更新之前调用，发生在虚拟DOM打补丁之前</li><li><strong>update</strong> ：组件数据更新之后</li><li><strong>activated</strong> ：keep-alive专属，组件被激活时调用</li><li><strong>deactivated</strong> ：keep-alive专属，组件被销毁时调用</li><li><strong>beforeDestory</strong> ：组件销毁时调用</li><li><strong>destoryed</strong> ：组件销毁后调用</li></ul><p>推荐在created钩子函数中调用异步请求，有以下优点：</p><ul><li>能更快的获取到服务端数据，减少loading时间</li><li>ssr不支持beforeMount、mounted钩子函数，所以放在created有助于一致性</li></ul><h1 id="11-Vue父组件和子组件生命周期钩子函数执行顺序"><a href="#11-Vue父组件和子组件生命周期钩子函数执行顺序" class="headerlink" title="11. Vue父组件和子组件生命周期钩子函数执行顺序"></a>11. Vue父组件和子组件生命周期钩子函数执行顺序</h1><ul><li>加载渲染过程：</li></ul><p>父beforeCreate -&amp;gt; 父created –&amp;gt; 父beforeMount -&amp;gt; 子beforeCreate -&amp;gt; 子created -&amp;gt;子beforeMounte -&amp;gt; 子mounted -&amp;gt;父mounted</p><ul><li>子组件跟新过程：</li></ul><p>父beforeUpdate-&amp;gt;子beforeUpdate-&amp;gt;子updated-&amp;gt;父updated</p><ul><li>父组件更新过程：</li></ul><p>父beforeUpdate-&amp;gt;父updated</p><ul><li>销毁过程：</li></ul><p>父beforeDestory-&amp;gt;子beforeDestory-&amp;gt;子destoryed-&amp;gt;父destoryed</p><h1 id="12-父组件可以监听到子组件的生命周期吗"><a href="#12-父组件可以监听到子组件的生命周期吗" class="headerlink" title="12.父组件可以监听到子组件的生命周期吗"></a>12.父组件可以监听到子组件的生命周期吗</h1><p>（1）可以在子组件生命周期中通过$emit手动触发监听函数</p><p>// Parent.vue</p><p>&amp;lt;Child @mounted=&quot;doSomeThing&quot;&amp;gt;&amp;lt;/Child&amp;gt;</p><p>// Child.vue</p><p>mounted () {</p><p>this.$emit(&#39;mounted&#39;);</p><p>}</p><p>（2）通过@hook自动触发监听函数</p><p>@hook方法不仅仅可以监听mounted，其他的生命周期函数都能监听到，如createdupdated</p><p>// Parent.vue</p><p>&amp;lt;Child @hook:mounted=&quot;doSomeThing&quot;&amp;gt;&amp;lt;/Child&amp;gt;</p><p>methods: {</p><p>doSomeThing () {</p><p>console.log(&#39;父组件监听到子组件的mounted钩子函数&#39;)</p><p>}</p><p>}</p><p>// Child.vue</p><p>mounted () {</p><p>console.log(&#39;子组件触发了mounted钩子函数&#39;)</p><p>}</p><p>// 以上输出顺序为：</p><p>// 子组件触发了mounted钩子函数</p><p>// 父组件监听到子组件的mounted钩子函数</p><h1 id="13-class与style如何动态绑定"><a href="#13-class与style如何动态绑定" class="headerlink" title="13.class与style如何动态绑定"></a>13.class与style如何动态绑定</h1><p>Class可以通过对象语法和数组语法进行动态绑定：</p><p>// 对象语法</p><p>&amp;lt;div :class=&quot;{active: isActive, &#39;text-change&#39;: hasError}&quot;&amp;gt;&amp;lt;/div&amp;gt;</p><p>data: {</p><p>active: &#39;active1&#39;,</p><p>isActive: true,</p><p>hasError: false</p><p>}</p><p>// 数组语法</p><p>&amp;lt;div :class=&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&amp;gt;&amp;lt;/div&amp;gt;</p><p>data: {</p><p>activeClass: &#39;active1&#39;,</p><p>isActive: true,</p><p>errorClass: &#39;text-danger</p><p>}</p><p>Style也可以通过对象语法和数组语法进行动态绑定</p><p>// 对象语法</p><p>&amp;lt;div :style=&quot;{color: activeColor, fontSize: mySize + &#39;px&#39;}&quot;&amp;gt;&amp;lt;/div&amp;gt;</p><p>data: {</p><p>activeColor: &#39;red&#39;,</p><p>mySize: 18</p><p>}</p><p>// 数组语法</p><p>&amp;lt;div : style =&quot;[styleColor, styleSize]&quot;&amp;gt;&amp;lt;/div&amp;gt;</p><p>data: {</p><p>styleColor:{</p><p>color: &#39;red&#39;</p><p>},</p><p>styleSize:{</p><p>fontSize: &#39;24px&#39;</p><p>}</p><p>}</p><h1 id="14-直接给一个数组项赋值，vue能监听到吗"><a href="#14-直接给一个数组项赋值，vue能监听到吗" class="headerlink" title="14.直接给一个数组项赋值，vue能监听到吗"></a>14.直接给一个数组项赋值，vue能监听到吗</h1><p>受JavaScript的限制，Vue不能检测到数组的以下变动：</p><ul><li>利用索引直接给设置一个数组项，例如vm.items[indexOfItem] = newValue</li><li>修改数组的长度，例如 vm.items.length = newLength</li></ul><p>为解决第一个问题，Vue提供了以下操作方法：</p><ul><li>Vue.set(vm.items, indexOfItem, newValue)</li><li>vm.$set(vm.items, indexOfItem, newValue)</li><li>vm.items.splice(indexOfItem, 1, newValue)</li></ul><p>为解决第二个问题，可以使用 Array.property.splice：</p><p>vm.items.splice(newLength)</p><h1 id="15-Vue是怎么实现对象和数组的监听"><a href="#15-Vue是怎么实现对象和数组的监听" class="headerlink" title="15.Vue是怎么实现对象和数组的监听"></a>15.Vue是怎么实现对象和数组的监听</h1><p>由于Object,defineProperty()只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行数据劫持。但是在Vue框架中 通过对遍历数组和递归对象，从而达到利用Object.defineProperty()也能对对象和数组（部分方法的操作）进行监听。</p><h1 id="16-Vue怎么用vm-set-解决对象新增属性不能相应的问题"><a href="#16-Vue怎么用vm-set-解决对象新增属性不能相应的问题" class="headerlink" title="16.Vue怎么用vm.$set()解决对象新增属性不能相应的问题"></a>16.Vue怎么用vm.$set()解决对象新增属性不能相应的问题</h1><p>受JavaScript的限制，Vue无法检测到对象属性的添加或删除。由于Vue会在初始化实例时对属性执行getter/setter转化，所以属性必须在data对象上才能让vue将它转换为响应式。</p><p>并且vue提供了Vue.set(object, propertyName, value) / vm.$set(object, propertyName, value)来实现为对象添加响应式属性。</p><p>vm.$set的实现原理是：</p><ul><li>如果目标是数组，直接使用数组的splice方法触发响应式</li><li>如果目标是对象，会先判断属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则通过调用defineReactive方法进行响应式处理（defineReactive方法是vue在初始化对象时，给对象属性采用Object.defineproperty动态添加getter/setter的功能所调用的方法）</li></ul><h1 id="17-vue3-0有哪些改变"><a href="#17-vue3-0有哪些改变" class="headerlink" title="17.vue3.0有哪些改变"></a>17.vue3.0有哪些改变</h1><p>（1）检测机制的改变</p><p>Vue3.0是基于proxy的observe实现响应式，提供了全语言覆盖的反应性跟踪。避免了vue2.x中基于Object.defineProperty的许多限制：</p><ul><li>即能监测属性，也能监测对象</li><li>可以监测对象属性的添加和删除</li><li>监测数据索引和长度的变更</li><li>支持Map、Set、WeakMap和WeakSet</li></ul><p>新的observe还提供了以下属性：</p><ul><li><strong>用于创建</strong> observable <strong>的公开</strong> API <strong>：</strong> 这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。</li><li><strong>默认采用惰性观察：</strong> 在2.x中，不管反应式数据有多大，都会在启动时 被观察到。如果数据集很大，这可能会在应用启动时带来明显的开销：在3.0中，只观察用于渲染应用程序最初可见的部分数据。</li><li><strong>更精确的通知：</strong> 在2.x中，通过Vue.$set强制添加新属性将导致依赖于该对象的watcher收到变更通知。3.0中，只有依赖于特性属性的watcher才会收到通知。</li><li><strong>不可变的</strong> observable <strong>：</strong> 我们可以创建值的&quot;不可变&quot;版本（即使是嵌套属性），除非系统在内部暂时将其&quot;解禁&quot;。这个机制可用于冻结prop传递或Vuex状态树以外的变化。</li><li><strong>更好的调试功能：</strong> 我们可以使用新的renderTracked和renderTriggered钩子精确的跟踪组件在什么时候以及为什么重新渲染。</li></ul><p>（2）模板</p><p>模板方面没有大的变更，只改作用域插槽。2.x中如果作用域插槽变了，父组件也会从新渲染。3.0中把作用域插槽改为函数的方式，这样只会影响子组件的重新渲染，提高了渲染性能。</p><p>（3）对象式的组件声明方式</p><p>2.x中组件是通过声明的方式传入一系列option，和TypeScript的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0修改了组件的声明方式，改成了类式的写法，使得和TypeScript结合变得更容易。并且3.0的源码也改用TypeScript来写，使得对外暴露的API更容易结合TypeScript。当代码功能复杂之后，必须有一个静态类型系统来做一些辅助管理，静态类型系统对复杂代码的维护确实很有必要。</p><p>（4）其他方面的修改</p><ul><li>支持自定义渲染器，从而使得weex可以通过自定义渲染器的方式来维护，而不是直接fork源码来改的方式。</li><li>支持Fragment（多个根节点）和Protal（在DOM其他部分渲染组件内容）组件，针对一些特定的场景做了处理。</li><li>基于treeShaking优化，提供了更多的内置功能。</li></ul><h1 id="18-Proxy与Object-defineProperty优劣对比"><a href="#18-Proxy与Object-defineProperty优劣对比" class="headerlink" title="18.Proxy与Object.defineProperty优劣对比"></a>18.Proxy与Object.defineProperty优劣对比</h1><p>Proxy的优势如下：</p><ul><li>Proxy可以直接监听对象而非属性</li><li>Proxy可以直接监听数组的变化</li><li>Proxy有多达13种拦截方法，不限于apply、ownKeys、deleteProperty、has等是Object.defineProperty不具备的</li><li>Proxy返回的是一个新对象，我们可以只操作新对象达到目的，而Object.defineProperty只能遍历对象属性直接修改</li><li>Proxy作为新标准将受到浏览器厂商重点持续的性能优化</li></ul><p>Object.defineProperty的优势如下：</p><ul><li>兼容性好！支持 IE9，而Proxy存在浏览器兼容性问题，并且无法通过polyfill磨平。</li></ul><h1 id="19-谈谈你对keep-alive的理解"><a href="#19-谈谈你对keep-alive的理解" class="headerlink" title="19.谈谈你对keep-alive的理解"></a>19.谈谈你对keep-alive的理解</h1><p>keep-alive是vue的一个内置组件，可以使被包含的组件保留状态，避免重新渲染，其有以下特性：</p><p>一般结合路由和动态组件一起使用，用于缓存组件</p><p>提供include和exclude属性，两者都支持字符串和正则表达式。include表示只有名称匹配的组件会被缓存，exclude表示任何名称匹配的组件都不会被缓存，其中exclude的优先级比include高。</p><p>对应两个钩子函数：activated和deactivated，当组件被激活时，触发钩子函数函数activated，当组件被移除时，触发钩子函数deactived。</p><h1 id="20-VUE常见的修饰后缀"><a href="#20-VUE常见的修饰后缀" class="headerlink" title="20.VUE常见的修饰后缀"></a>20.VUE常见的修饰后缀</h1><p>@click.stop = &#39;click&#39; // 阻止事件向上冒泡</p><p>@click.self = &#39;click&#39; // 根据实际操作对象执行函数</p><p>@click.prevent = &#39;click&#39; // 阻止默认动作 event.preventDefault()</p><p>@click.native = &#39;click&#39; // 为自定义组件添加原生事件</p><p>@click.once = &#39;click&#39; // 事件将只能执行一次</p><p>@input.trim = &#39;input&#39; // 去掉前后空格</p><h1 id="21-虚拟DOM的优缺点"><a href="#21-虚拟DOM的优缺点" class="headerlink" title="21.虚拟DOM的优缺点"></a>21.虚拟DOM的优缺点</h1><p>优点：</p><ul><li><strong>保证性能下限</strong> ：框架的虚拟DOM需要适配任何上层API可能产生的操作，它的一些DOM操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的DOM操作性能要好很多。因此框架的虚拟DOM至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li><li><strong>无需手动操作</strong> DOM：我们不再需要手动去操作DOM，只需要写好View-Model的代码逻辑，框架会根据虚拟DOM和数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率。</li><li><strong>跨平台</strong> ：虚拟DOM本质上是JavaScript对象，而DOM与平台强相关，相比之下虚拟DOM可以进行更方便的跨平台操作，例如服务端渲染、Weex开发等等。</li></ul><p>缺点：</p><p><strong>无法进行极致优化</strong> ：虽然虚拟DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化。</p><h1 id="22-你有对vue项目进行哪些优化"><a href="#22-你有对vue项目进行哪些优化" class="headerlink" title="22.你有对vue项目进行哪些优化"></a>22.你有对vue项目进行哪些优化</h1><p>(<a href="https://juejin.im/post/5d548b83f265da03ab42471d#heading-1">https://juejin.im/post/5d548b83f265da03ab42471d#heading-1</a>)</p><h2 id="（一）代码层面的优化"><a href="#（一）代码层面的优化" class="headerlink" title="（一）代码层面的优化"></a>（一）代码层面的优化</h2><p>1.1 v-if和v-show区分使用场景</p><p>v-if用于运行时很少改变的文件，不需要频繁切换条件的场景；</p><p>v-show则适用于需要频繁切换条件的场景，只是简单地基于CSS的display属性进行切换。</p><p>1.2 v-for遍历必须为item添加key，且避免同时使用v-if</p><p>（1） v-for遍历必须为item添加key</p><p>（2） v-for避免与v-if同时使用</p><p>v-for比v-if优先级高，如果每一次都需要遍历整个数据，将会影响速度，尤其是当已知需要渲染很小一部分的时候，必要情况下应该替换成computed属性（将需要遍历的数组通过filter过滤掉不需要渲染的数据）</p><p>1.3 长列表性能优化</p><p>Vue是通过Object.defineProperty对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要Vue来劫持我们的数据。在大量数据展示的情况的下，这能够很明显的减少组件初始化的时间。我们可以通过Object.freeze来冻结一个对象，禁止Vue劫持我们的数据</p><p>export default {</p><p>data: () =&amp;gt; ({</p><p>users: {}</p><p>}),</p><p>async created() {</p><p>const users = await axios.get(&quot;/api/users&quot;);</p><p>this.users = Object.freeze(users);</p><p>}</p><p>}</p><p>1.4 事件的销毁</p><p>Vue组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指定以及事件监听器，但是仅限于组件本身的事件。如果在js内使用addEventListener等方式添加的事件是不会自动销毁的，我们需要在组件销毁时手动移除这些监听事件，以免造成 内存泄漏。</p><p>created() {</p><p>addEventListener(&#39;click&#39;, this.click, false)</p><p>},</p><p>beforeDestroy() {</p><p>removeEventListener(&#39;click&#39;, this.click, false)</p><p>}</p><p>1.5 图片资源懒加载</p><p>将页面内未出现在可视区域的图片先不做加载，等到滚动到可视区域后再去加载，这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用vue的vue-lazyload插件</p><ol><li>安装插件 – npm install vue-lazyload –-save-dev</li><li>在入口文件main.js中引入并使用 import VueLazyload from &#39;vue-lazyload&#39;</li><li>然后在vue中直接使用 Vue.use(VueLazyload)</li><li>最后在vue文件中将img标签的src属性直接改为v-lazy，从而将图片显示方式更改为懒加载显示： &amp;lt;img v-lazy=&quot;/static/img/img1.png&quot;&amp;gt;</li></ol><p>1.6 路由懒加载</p><p>Vue是单页面应用，可能会有很多路由引入，这样使用webpack打包后的文件很大。当进入首页时，加载的资源过多，页面就会出现白屏的情况，不利于用户体验。</p><p>因此我们结合vue的异步组件和webpack的代码分割功能，可以实现路由的懒加载。即把不同路由对应的组件分割成不同的代码块，然后当组件被访问的时候才加载对应组件。</p><p>路由懒加载：</p><p>const Foo = () =&amp;gt; import(&#39;./Foo.vue&#39;)</p><p>const router = new VueRouter({</p><p>routes: [</p><p>{ path: &#39;/foo&#39;, component: Foo }</p><p>]</p><p>})</p><p>把组件安组分块：</p><p>我们通过解释语法来提供chunkname，将组件安组分块.</p><p>Webpack会将任何一个异步模块与相同的模块名称组合到相同的异步块中。</p><p>const Foo = () =&amp;gt; import(/* webpackChunkName: &quot;groun-foo&quot; */ &#39;./Foo.vue&#39; )</p><p>const Bar = () =&amp;gt; import(/* webpackChunkName: &quot;groun-foo&quot; */ &#39;./Bar.vue&#39; )</p><p>const Baz = () =&amp;gt; import(/* webpackChunkName: &quot;groun-foo&quot; */ &#39;./Baz.vue&#39; )</p><p>1.7 第三方插件按需引入</p><p>借助babel-plugin-component，只引入需要的组件，以达到减少项目体积的目的。</p><ol><li>安装插件 - npm install babel-plugin-component –D</li><li>在.bablerc文件中增加修改</li></ol><p>{</p><p>&quot;presets&quot;: [[&quot;es2015&quot;, { &quot;modules&quot;: false }]],</p><p>&quot;plugins&quot;: [</p><p>[</p><p>&quot;component&quot;,</p><p>{</p><p>&quot;libraryName&quot;: &quot;element-ui&quot;,</p><p>&quot;styleLibraryName&quot;: &quot;theme-chalk&quot;</p><p>}</p><p>]</p><p>]</p><p>}</p><ol><li>在main.js中引入需要的组件</li></ol><p>import Vue from &#39;vue&#39;;</p><p>import { Button, Select } from &#39;element-ui&#39;;</p><p>Vue.use(Button)</p><p>Vue.use(Select)</p><p>1.8 优化无限列表性能</p><p>如果你的应用存在非常长或者无限滚动的列表，那么需要采用窗口化的技术来优化性能。只需要渲染少部分区域的内容，减少重新渲染组件和创建dom节点的时间。可以参考以下开源项目 vue-virtual-scroll-list和 vue-virtual-scroller来优化这种无限列表的场景。</p><p>1.9 服务端渲染SSR或预渲染</p><p>服务端渲染是指Vue在客户端将标签渲染成整个html片段的工作在服务端完成，服务端形成的html片段直接返回给客户端。</p><p>服务端渲染的优点：</p><ul><li>更好的SEO：因为SPA页面的内容是通过Ajax获取，而搜索引擎爬取工具并不会等待Ajax异步完成之后再抓取页面内容，所以在SPA中是爬取不到页面通过Ajax获取到的内容；而SSR是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面。</li><li>更快的内容到达时间（首屏加载更快）：SPA会等待所有VUE编译后的js文件都下载完成后，才开始进行页面渲染，文件下载需要一定的时间等待，所以首屏渲染需要一定的的时间；SSR由服务端渲染好页面直接返回，无需等待下载js文件及再去渲染等，所以SSR有更快的内容到达时间。</li></ul><p>服务端渲染的缺点：</p><ul><li>更多的开发条件限制：例如服务端渲染只支持beforeCreate和created两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端显然应用程序中运行；并且与可以部署在任何静态服务器上的完全静态SPA不同，服务端渲染程序需要处于Node.js server运行环境。</li><li>更多的服务器负载：在Node.js中渲染完整的应用程序，显然会比仅仅提供静态文件的server更加大量占用CPU资源，因此如果你预料在高流量环境下使用，请准备相应的服务器负载，并明智的采用缓存策略。</li></ul><p>如果你的项目的 SEO和 首屏渲染 是评价项目的关键指标，那么就需要使用服务端渲染来实现最佳性能。（VueSSR踩坑之旅：<a href="https://juejin.im/post/5cb6c36e6fb9a068af37aa35">https://juejin.im/post/5cb6c36e6fb9a068af37aa35</a>）</p><p>如果你的项目只需要改善少数营销页面的SEO，那么可能需要预渲染，在构建时（buildtime）简单的生成针对特定路由的静态HTML文件。优点是设置预渲染更简单 ，并且可以将你的前端作为一个完全静态的站点，具体你可以使用<a href="https://github.com/chrisvfritz/prerender-spa-plugin">prerender-spa-plugin</a>（<a href="https://github.com/chrisvfritz/prerender-spa-plugin">https://github.com/chrisvfritz/prerender-spa-plugin</a>）就可以轻松地添加预渲染。</p><h2 id="（二）webpack层面的优化"><a href="#（二）webpack层面的优化" class="headerlink" title="（二）webpack层面的优化"></a>（二）webpack层面的优化</h2><p>2.1 webpack对图片进行压缩</p><p>在vue项目中可以在webpack.base.conf.js中的url-loader中设置limit大小来对图片处理，小于limit的图片转化为base64格式，其余的不做处理。对于较大的图片资源，在请求资源的时候加载会很慢，可以用image-webpack-loader来压缩图片：</p><ol><li>安装image-webpack-loader : npm install image-webpack-loader –save-dev</li><li>然后在webpack.base.conf.js中进行配置：</li></ol><p>{</p><p>test: /.(png|jpe?g|gif|svg)(?.*)?$/,</p><p>use:[</p><p>{</p><p>loader: &#39;url-loader&#39;,</p><p>options: {</p><p>limit: 10000,</p><p>name: utils.assetsPath(&#39;img/[name].[hash:7].[ext]&#39;)</p><p>}</p><p>},</p><p>{</p><p>loader: &#39;image-webpack-loader&#39;,</p><p>options: {</p><p>bypassOnDebug: true,</p><p>}</p><p>}</p><p>]</p><p>}</p><p>2.2减少ES6转为ES5的冗余代码</p><p>Babel插件在将ES6代码转换为ES5时会注入一些辅助函数，例如下面的ES6代码：</p><p>class HelloWebpack extends Component{…}</p><p>这段代码在转换为ES5时会注入一下两个辅助函数：</p><p>babel-runtime/helpers/createClass // 用于实现 class 语法</p><p>babel-runtime/helpers/inherits // 用于实现 extends 语法</p><p>在默认情况下，Babel会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。我们可以使用babel-plugin-transform-runtime插件来实现将这些辅助函数替换成导入语句，从而减少babel编译出来的代码文件体积。</p><p>首先安装babel-plugin-transform-runtime ：npm install babel-plugin-transform-runtime –save-dev</p><p>然后在.bablerc文件中添加配置：</p><p>&quot;plugins&quot;: [</p><p>&quot;transform-runtime&quot;</p><p>]</p><p>2.3 提取公共代码</p><p>如果项目中没有将每个页面的第三方库和公共模块提取出来，则会存在以下问题：</p><ul><li>相同的资源被重复加载，浪费用户的流量和服务器成本</li><li>每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验</li></ul><p>所以我们要将每个页面的公共代码抽离成单独的文件，来优化以上问题。Webpack内置了专门用于提取多个Chunk中的公共部分插件CommonsChunkPlugin,项目中CommonChunkPlugin的配置如下：</p><p>// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。</p><p>new webpack.optimize.CommonsChunkPlugin({</p><p>name: &#39;vendor&#39;,</p><p>minChunks: function(module, count) {</p><p>return (</p><p>module.resource &amp;&amp;</p><p>/.js$/.test(module.resource) &amp;&amp;</p><p>module.resource.indexOf(</p><p>path.join(__dirname, &#39;../node_modules&#39;)</p><p>) === 0</p><p>);</p><p>}</p><p>}),</p><p>// 抽取出代码模块的映射关系</p><p>new webpack.optimize.CommonsChunkPlugin({</p><p>name: &#39;manifest&#39;,</p><p>chunks: [&#39;vendor&#39;]</p><p>})</p><p>2.4 模板预编译</p><p>当使用DOM内模板或JavaScript内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。</p><p>预编译模板最简单的方式就是使用单文件组件——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数，而不是原始的模板字符串。</p><p>如果喜欢分离JavaScript和模板文件，可以使用vue-template-loader，它可以在构建过程中把模板文件转换为JavaScript渲染函数。</p><p>2.5 提取组件的CSS</p><p>当使用单文件组件时，组件内的CSS会以style标签的方式通过JavaScript动态注入。会有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段&quot;无样式内容闪烁&quot;(fous)。为了避免这个问题，可以将所有组件的CSS提取到同一个文件。</p><p>npm install extract-text-webpack-plugin –save-dev</p><p>2.6 优化SourceMap</p><p>我们在项目打包后，会将多个文件打包到一个文件，并且经过压缩、去空格、babel编译后的代码才用于生产环境，那么这样处理后的代码与源代码有很大的差别，进行Bug调试时无法定位到开发环境中的代码，因此SourceMap出现了，解决了不好调试代码的问题。</p><p>开发环境推荐：cheap-module-eval-source-map</p><p>生产环境推荐：cheap-module-source-map</p><p>2.7 构建结果输出分析</p><p>通过工具：webpack-bundle-analyzer，并且在webpack.prod.conf.js中进行配置：</p><p>if (config.build.bundleAnalyzerReport) {</p><p>var BundleAnalyzerPlugin = require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin;</p><p>webpackConfig.plugins.push(new BundleAnalyzerPlugin());</p><p>}</p><p>再执行$ npm run build –-report后即可生成分析报告。</p><h2 id="（三）基础的web技术优化"><a href="#（三）基础的web技术优化" class="headerlink" title="（三）基础的web技术优化"></a>（三）基础的web技术优化</h2><p>3.1 开启gzip压缩</p><p>HTTP协议上的的gzip(GNUzip的缩写)编码是一种用来改进web应用性能的技术，web服务器和客户端（浏览器）必须同时支持gzip。目前主流的浏览器和服务器都支持gzip，gzip的压缩效率非常高，通常可以达到70%左右。</p><p>以熟悉的express为例：</p><p>安装：npm install compression –save</p><p>添加逻辑代码：</p><p>var compression = require(&#39;compression&#39;);</p><p>var app = express();</p><p>app.use(compression())</p><p>在responseheader中看到下面红色的字段就表明gzip开启成功</p><p><img src="RackMultipart20201221-4-8pnvt0_html_954a711a5c1f437c.png"></p><p>3.2 浏览器缓存</p><p>3.3 CDN的使用</p><p>浏览器从服务器上下载CSS、JS和图片等文件时都要和服务器连接，而大部分服务器的宽带有限，如果超过限制，网页就半天反应不过来。而CDN可以通过不同的域名来加载文件，从而使下载文件的并发连接数大大增加，且CDN具有更好的可用性，更低的网络延迟和丢包率。</p><p>3.4预解析DNS</p><p>&amp;lt;link rel=&quot;dns-prefetch&quot; href=&quot;//host_name_to_prefetch.com&quot;&amp;gt;放在head里面</p><p>&amp;lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&amp;gt;一些高级浏览器是默认打开a标签的预解析的。如果页面是https协议开头的，浏览器基本是默认关闭dns预解析的，通过这一段标签是用来强制打开a标签的dns预解析的。</p><p>3.5 使用Chrome的Performance查找性能瓶颈</p><p>Chrome的performance面板可以录制一段时间内的js执行细节和时间。使用Chrome开发工具分析页面性能的步骤如下：</p><ol><li>打开Chrome开发工具，切换到performance面板</li><li>点击Record开始录制</li><li>刷新页面或展开某个节点</li><li>点击stop停止录制</li></ol><h1 id="23-页面性能优化的方向"><a href="#23-页面性能优化的方向" class="headerlink" title="23.页面性能优化的方向"></a>23.页面性能优化的方向</h1><p>1、资源压缩合并，减少HTTP请求</p><p>2、非核心代码异步加载</p><p>3、利用浏览器缓存</p><p>4、使用CDN</p><p>5、预解析DNS</p><h1 id="23-vue频繁操作DOM只更新一次"><a href="#23-vue频繁操作DOM只更新一次" class="headerlink" title="23.vue频繁操作DOM只更新一次"></a>23.vue频繁操作DOM只更新一次</h1><p>当频繁操作一个数据时，按照set-&amp;gt;订阅器(dep)-&amp;gt;订阅者(watcher)-&amp;gt;update 的过程，DOM应该会频繁更新，会很消耗性能，但实际上这个过程只更新了一次DOM。</p><p>这是因为vue异步执行dom更新，只要观察到数据变化，Vue将开启一个队列用于存储本次事件循环中所有watcher更新，并且同一个watcher更新只会被推入队列一次，并在本次事件循环的微任务执行结束后此更新。</p><p>DOM更新会放在下一个宏任务或当前宏任务的末尾（微任务）中进行执行。</p><p>Vue在内部尝试对异步队列使用原生的promise.then和MessageChannel,如果执行环境不支持，会采用setTimeout(fn, 0)代替。</p><p><strong>请说一下响应式数据的原理？</strong></p><p><strong>Vue</strong>  <strong>中是如何检测数组变化？</strong></p><p><strong>为什么**</strong> Vue <strong>**采用异步渲染？</strong></p><p><strong>谈一下**</strong> nextTick <strong>**的实现原理？</strong></p><p><strong>你知道**</strong> Vue <strong><strong>中</strong></strong> computed <strong>**是怎么实现的吗？</strong></p><p>· <strong>28</strong> / <strong>28</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>js Q&amp;A</title>
    <link href="/2020/12/14/interview/js-Q&amp;A/"/>
    <url>/2020/12/14/interview/js-Q&amp;A/</url>
    
    <content type="html"><![CDATA[<h2 id="一-如何正确判断-this-的指向"><a href="#一-如何正确判断-this-的指向" class="headerlink" title="一.如何正确判断 this 的指向"></a>一.如何正确判断 this 的指向</h2><ol><li><p>全局环境中的 this</p><p>   &nbsp;&nbsp;&nbsp;&nbsp;– 浏览器环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象 <code>window</code><br> &nbsp;&nbsp;&nbsp;&nbsp;– node 环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部），this 都是空对象 <code>&#123;&#125;</code></p></li><li><p>是否是 new 的绑定</p><p> 如果是 new 绑定，并且构造函数中没有返回 function 或者是 object，那么 this 指向这个新对象。如下：</p> <pre><code class="hljs javascript"><span class="hljs-comment">// 构造函数返回值不是 function 或 object</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Super</span>(<span class="hljs-params">name</span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name;&#125;<span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> Super(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<span class="hljs-built_in">console</span>.log(instance.name); <span class="hljs-comment">// zhangsan</span></code></pre> <pre><code class="hljs javascript"><span class="hljs-comment">// 构造函数返回值是 function 或 object</span><span class="hljs-comment">// 这种情况下 this 指向的是返回的对象</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Super</span>(<span class="hljs-params">name</span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name;<span class="hljs-keyword">let</span> obj = &#123;a: <span class="hljs-string">&#x27;123&#x27;</span>&#125;<span class="hljs-keyword">return</span> obj;&#125;<span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> Super(<span class="hljs-string">&#x27;hello&#x27;</span>);<span class="hljs-built_in">console</span>.log(instance.name); <span class="hljs-comment">// undefined</span></code></pre></li><li><p>函数通过 call、apply 调用，或者通过 bind 绑定<br> this 绑定的就是指向的对象<br> <strong>特殊情况</strong>：如果 call,apply 或者 bind 传入的第一个参数值是 undefined 或者 null，严格模式下 this 的值为传入的值 null /undefined。非严格模式下，实际应用的默认绑定规则，this 指向全局对象(node环境为global，浏览器环境为window)</p></li><li><p>箭头函数<br> 箭头函数没有自己的this，继承外层上下文绑定的this。</p> <pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;age: <span class="hljs-number">20</span>,info: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.age); <span class="hljs-comment">//this继承的是外层上下文绑定的this</span>&#125;&#125;&#125;<span class="hljs-keyword">let</span> person = &#123;<span class="hljs-attr">age</span>: <span class="hljs-number">28</span>&#125;;<span class="hljs-keyword">let</span> info = obj.info();info(); <span class="hljs-comment">//20</span><span class="hljs-keyword">let</span> info2 = obj.info.call(person);info2(); <span class="hljs-comment">//28</span></code></pre></li><li><p>隐式绑定——函数的调用是在某个对象上触发,即调用位置上存在上下文对象。典型的隐式调用为: <code>obj1.fn()</code></p> <pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">info</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.age);&#125;<span class="hljs-keyword">var</span> person = &#123;age: <span class="hljs-number">20</span>,info&#125;<span class="hljs-keyword">var</span> age = <span class="hljs-number">28</span>;person.info(); <span class="hljs-comment">//20;执行的是隐式绑定</span></code></pre></li></ol><h2 id="二-剩余参数-和-arguments-对象的区别"><a href="#二-剩余参数-和-arguments-对象的区别" class="headerlink" title="二.剩余参数 和 arguments 对象的区别"></a>二.剩余参数 和 <code>arguments</code> 对象的区别</h2><p>剩余参数 —— 剩余参数语法允许我们将不定数量的参数表示为一个数组：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">...args</span>) </span>&#123;<span class="hljs-comment">// ...</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum2</span>(<span class="hljs-params">agr1, arg2, ...rest</span>) </span>&#123;<span class="hljs-comment">// ...</span>&#125;</code></pre><p>区别：</p><ol><li>剩余参数只包含那些没有对应形参的实参（可以是参数的 部分）<br>而 arguments 对象包含了传给函数的所有实参（是参数的全部）</li><li>arguments 对象<strong>不是一个真实的数组</strong><br>剩余参数<strong>是真实的 Array 实例</strong>。也就是说，能够在它上面直接使用所有的数组方法，比如 sort、map、forEach、pop</li><li>Arguments Objects 是函数上下文里的激活对象AO中的内部对象，arguments 对象还有一些附加的属性(如 callee 属性)<br>arguments.callee 是一个指针，指向拥有这个arguments对象的函数</li><li>如果想在 arguments 对象上使用数组方法，首先要将它转换为真实的数组，比如使用<ul><li>[].slice.call(arguments)</li><li>Array.from(arguments)</li><li>[… arguments]</li><li>Array.protoType.slice.call(arguments)</li></ul></li></ol><h2 id="三-39-1-39-39-2-39-39-3-39-map-parseInt"><a href="#三-39-1-39-39-2-39-39-3-39-map-parseInt" class="headerlink" title="三.[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)"></a>三.<code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)</code></h2><pre><code class="hljs javaScript"><span class="hljs-comment">// Array.prototype.map() 语法:</span><span class="hljs-keyword">var</span> new_array = arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">currentValue[, index[, array]]</span>) </span>&#123;<span class="hljs-comment">// Return element for new_array </span>&#125;[, thisArg])<span class="hljs-comment">/* 参数</span><span class="hljs-comment">-- callback 生成新数组元素的函数，使用三个参数</span><span class="hljs-comment">-- currentValue callback 数组中正在处理的当前元素</span><span class="hljs-comment">-- index (可选) 数组中正在处理的当前元素的索引</span><span class="hljs-comment">-- array (可选) 方法调用的数组</span><span class="hljs-comment">-- thisArg (可选) 执行 callback 函数时值被用作this</span><span class="hljs-comment">*/</span></code></pre><pre><code class="hljs javaScript"><span class="hljs-comment">// parseInt() 语法:</span><span class="hljs-built_in">parseInt</span>(string, radix);<span class="hljs-comment">/* 参数</span><span class="hljs-comment">-- string 要解析的值。</span><span class="hljs-comment">如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。</span><span class="hljs-comment">字符串开头的空白符将会被忽略</span><span class="hljs-comment">-- radix (可选) 一个介于2到36之间的整数，代表字符串的基数(数学数字系统中的基)</span><span class="hljs-comment">小心-这并不是默认为10</span><span class="hljs-comment">*/</span><span class="hljs-comment">// 返回值: 从给定的字符串中解析出的一个整数 或者 NaN</span><span class="hljs-comment">// 返回NaN 的情况:</span><span class="hljs-comment">// (1)radix 小于 2 或大于 36 (2)第一个非空格字符不能转换为数字</span></code></pre><p>执行过程：</p><ol><li>parseInt(‘1’, 0)<br> -&gt; radix 为 0 时，且 string 参数不以“0x”和“0”开头时，按照 10 为基数处理。这个时候返回 1</li><li>parseInt(‘2’, 1)<br> -&gt; radix 基数为 1（1 进制),而 radix 要求是小于 2 或大于 36，否则返回 NaN</li><li>parseInt(‘3’, 2)<br> -&gt; radix 基数为 2 (2 进制),而 二进制表示的数中最大值(为1)小于 3, 所以无法解析，返回 NaN</li></ol><p>因此执行结果是  [1, NaN, NaN]</p><h2 id="四-让-a-1-amp-amp-a-2-amp-amp-a-3-的值为true"><a href="#四-让-a-1-amp-amp-a-2-amp-amp-a-3-的值为true" class="headerlink" title="四.让 (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 的值为true"></a>四.让 (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 的值为true</h2><p>方法一: 利用隐式类型转换</p><p>将 a 转换为复杂数据类型(即 Object)。当 复杂数据类型(Object) 与 简单数据类型(Number)进行对比时, Object 转换为原始类型.<br>Object 转换为原始类型会调用什么方法呢？<br>(1) 如果部署了 [Symbol.toPrimitive] 接口，那么调用此接口，若返回的不是基本数据类型，抛出错误<br>(2) 如果没有部署 [Symbol.toPrimitive] 接口，那么根据要转换的类型，先调用 valueOf / toString<br>    - 非Date类型对象，hint 是 default 时，调用顺序为：valueOf &gt;&gt;&gt; toString，即valueOf 返回的不是基本数据类型，才会继续调用 valueOf，如果toString 返回的还不是基本数据类型，那么抛出错误。<br>    - 如果 hint 是 string(Date对象的hint默认是string) ，调用顺序为：toString &gt;&gt;&gt; valueOf，即toString 返回的不是基本数据类型，才会继续调用 valueOf，如果valueOf 返回的还不是基本数据类型，那么抛出错误。<br>    - 如果 hint 是 number，调用顺序为： valueOf &gt;&gt;&gt; toString</p><pre><code class="hljs javascript"><span class="hljs-comment">// 部署 [Symbol.toPrimitive] / valueOf/ toString 皆可</span><span class="hljs-comment">// 一次返回1，2，3 即可。</span><span class="hljs-keyword">let</span> a = &#123;[<span class="hljs-built_in">Symbol</span>.toPrimitive]: (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">hint</span>) </span>&#123;<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;<span class="hljs-comment">//闭包的特性之一：i 不会被回收</span><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> i++;&#125;&#125;)()&#125;</code></pre><p>方法二: 利用数据劫持(Proxy/Object.definedProperty)</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(&#123;&#125;, &#123;i: <span class="hljs-number">1</span>,get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.i++;&#125;&#125;);</code></pre><p>方法三: 数组的 toString 接口默认调用数组的 join 方法，重新 join 方法</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];a.join = a.shift;</code></pre><blockquote><p><a href="https://github.com/YvetteLau/Blog/issues/35">github-blog</a></p></blockquote><h2 id="五-异步加载JS脚本的方式"><a href="#五-异步加载JS脚本的方式" class="headerlink" title="五.异步加载JS脚本的方式"></a>五.异步加载JS脚本的方式</h2><h3 id="1-async-和-defer"><a href="#1-async-和-defer" class="headerlink" title="1.async 和 defer"></a>1.async 和 defer</h3><p><code>&lt;script&gt;</code> 标签中增加 <code>async(html5)</code> 或者 <code>defer(html4)</code> 属性,脚本就会异步加载。</p><img src="https://i.loli.net/2021/02/23/qGLYkT7COZFlhz4.png" ><p>(绿色代表HTML解析，蓝色代表JavaScript加载，红色代表JavaScript执行)</p><p>defer 和 async 的区别在于：</p><ul><li>defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），在window.onload 之前执行；</li><li>async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。</li><li>defer是顺序加载，async是无序加载</li></ul><h3 id="2-动态创建-script-标签"><a href="#2-动态创建-script-标签" class="headerlink" title="2.动态创建 script 标签"></a>2.动态创建 script 标签</h3><p>动态创建的 script ，设置 src 并不会开始下载，而是要添加到文档中，JS文件才会开始下载。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);script.src = <span class="hljs-string">&#x27;XXX.js&#x27;</span>;<span class="hljs-comment">// 添加到html文件中才会开始下载</span><span class="hljs-built_in">document</span>.body.append(script);</code></pre><h3 id="3-XHR-异步加载JS"><a href="#3-XHR-异步加载JS" class="headerlink" title="3.XHR 异步加载JS"></a>3.XHR 异步加载JS</h3><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();xhr.open(<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;js/xxx.js&quot;</span>,<span class="hljs-literal">true</span>);xhr.send();xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">if</span> (xhr.readyState == <span class="hljs-number">4</span> &amp;&amp; xhr.status == <span class="hljs-number">200</span>) &#123;<span class="hljs-built_in">eval</span>(xhr.responseText);&#125;&#125;</code></pre><h2 id="六-隐藏页面中的某个元素"><a href="#六-隐藏页面中的某个元素" class="headerlink" title="六.隐藏页面中的某个元素"></a>六.隐藏页面中的某个元素</h2><p>影藏元素的类型有：</p><ul><li>完全影藏： 元素从DOM树中消失，不占空间</li><li>视觉上的影藏：屏幕上不可见，占据空间</li><li>语义上的影藏：读屏软件不可读，但政策占据空间</li></ul><h3 id="1-完全影藏"><a href="#1-完全影藏" class="headerlink" title="1. 完全影藏"></a>1. 完全影藏</h3><ul><li>display: none</li><li><code>&lt;div hidden&gt;&lt;/div&gt;</code> : HTML5 新增的属性，相当于 display:none</li></ul><h3 id="2-视觉上的影藏"><a href="#2-视觉上的影藏" class="headerlink" title="2.视觉上的影藏"></a>2.视觉上的影藏</h3><ul><li><p>利用 <code>position</code> 和 盒模型 将元素移出可视区范围</p><ul><li><p>设置元素<code>posoition:absolute</code> 或 <code>position:fixed</code>,再通过设置 top、left 等值，将其移出可视区域</p><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">position</span>:absolute;<span class="hljs-attribute">left</span>: -<span class="hljs-number">99999px</span>;&#125;</code></pre></li><li><p>设置元素<code>posoition:relative</code>，通过设置 <code>top、left</code> 等值，将其移出可视区域</p><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">position</span>: relative;<span class="hljs-attribute">left</span>: -<span class="hljs-number">99999px</span>;<span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>&#125;</code></pre></li><li><p>设置 margin 值，将其移出可视区域范围（可视区域占位）</p><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">99999px</span>;<span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li><li><p>利用 transform</p><ul><li><p>缩放 scale</p><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0</span>);<span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p>移动 translateX, translateY</p><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">99999px</span>);<span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p>旋转 rotate</p><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">90deg</span>);&#125;</code></pre></li></ul></li><li><p>设置其大小为0</p><ul><li><p>宽高为0，字体大小为0</p><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">font-size</span>: <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p>宽高为0，超出影藏</p><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">overflow</span>: hidden;&#125;</code></pre></li></ul></li><li><p>设置透明度为0 <code>opacity: 0;</code></p></li><li><p><code>visibility: hidden</code></p></li><li><p>层级覆盖, z-index 属性</p>  <pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">position</span>: relative;<span class="hljs-attribute">z-index</span>: -<span class="hljs-number">999</span>;&#125;</code></pre></li><li><p>clip-path:polygon(0 0, 0 0, 0 0, 0 0); 裁剪</p></li></ul><h3 id="3-语义上的隐藏"><a href="#3-语义上的隐藏" class="headerlink" title="3.语义上的隐藏"></a>3.语义上的隐藏</h3><p>aria-hidden 属性<br>读屏软件不可读，占据空间，可见。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">aria-hidden</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h2 id="七-执行上下文栈和作用域链"><a href="#七-执行上下文栈和作用域链" class="headerlink" title="七.执行上下文栈和作用域链"></a>七.执行上下文栈和作用域链</h2><h3 id="1-执行上下文"><a href="#1-执行上下文" class="headerlink" title="1. 执行上下文"></a>1. 执行上下文</h3><p>执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。</p><p>执行上下文创建过程中，需要做以下几件事:</p><ul><li>创建变量对象：首先初始化函数的参数arguments，提升函数声明和变量声明。</li><li>创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。</li><li>确定this的值，即 ResolveThisBinding。</li></ul><h3 id="2-执行上下文栈-（执行栈）"><a href="#2-执行上下文栈-（执行栈）" class="headerlink" title="2.执行上下文栈 （执行栈）"></a>2.执行上下文栈 （执行栈）</h3><p>执行栈，也叫做调用栈，具有 LIFO (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。</p><h3 id="3-作用域"><a href="#3-作用域" class="headerlink" title="3.作用域"></a>3.作用域</h3><p>作用域负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限</p><h3 id="4-作用域链"><a href="#4-作用域链" class="headerlink" title="4.作用域链"></a>4.作用域链</h3><p>作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。</p><h2 id="八-可迭代对象有哪些特点"><a href="#八-可迭代对象有哪些特点" class="headerlink" title="八 可迭代对象有哪些特点"></a>八 可迭代对象有哪些特点</h2><p>（呼应 js-手写代码 的 7-给对象加上 iterator 接口,使之能被 for…of 遍历）</p><p>ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，换个角度，也可以认为，一个数据结构只要具有 Symbol.iterator 属性(Symbol.iterator 方法对应的是遍历器生成函数，返回的是一个遍历器对象)，那么就可以其认为是可迭代的。</p><p>可迭代对象的特点:</p><ul><li>具有 Symbol.iterator 属性，Symbol.iterator() 返回的是一个遍历器对象</li><li>可以使用 for … of 进行循环</li><li>通过被 Array.from 转换为数组</li></ul><p>原生具有 Iterator 接口的数据结构：Array、Map、Set、String、TypedArray、函数的arguments对象、NodeList对象.</p><blockquote><p><a href="https://github.com/YvetteLau/Blog/issues/35">这儿有20道大厂面试题等你查收</a></p></blockquote><h2 id="九-diff-时间复杂度从-O-n-3-优化到-O-n"><a href="#九-diff-时间复杂度从-O-n-3-优化到-O-n" class="headerlink" title="九 diff 时间复杂度从 O(n^3) 优化到 O(n)"></a>九 diff 时间复杂度从 O(n^3) 优化到 O(n)</h2><p>oldNode 每一个节点都去遍历 newNode 的节点，直到找到新树对应的节点。那么这个流程就是 O(n^2).<br>再紧接着找到不同之后，再计算最短修改距离然后修改节点，这里是 O(n^3).</p><p>vue的更新策略就是：深度优先、同层比较。就是只比较同层级，也就是 O(n)</p>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise全解</title>
    <link href="/2020/12/11/interview/Promise%E5%85%A8%E8%A7%A3/"/>
    <url>/2020/12/11/interview/Promise%E5%85%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Promise规范"><a href="#一、Promise规范" class="headerlink" title="一、Promise规范"></a>一、Promise规范</h2><p>Promise/A+兼容扩展了Promise/A而来，ES6里的Promise遵守了Promise/A+规范，也就是当今的标准规范。</p><ol><li><p>一个 Promise 必然处于以下几种状态之一：<br>　　· <strong>pending</strong>（待定/等待）: 初始状态，既没有被兑现，也没有被拒绝。<br>　　· <strong>fulfilled</strong>（已兑现/已完成）: 意味着操作成功完成。<br>　　· <strong>rejected</strong>（已拒绝）: 意味着操作失败。</p></li><li><p>一个Promise对象的状态只能从<code>pending -&gt; fulfilled</code>, 或者<code>pending -&gt; rejected</code>状态，不能逆向转换，也不能互相转换。</p></li><li><p>一个Promise必须实现then方法（then是Promise的核心），而then必须返回一个Promise，同一个Promise的then可以调用多次，执行顺序跟它们的定义顺序一致。</p></li><li><p>then方法接收两个参数: resolve和reject，第一个参数是成功的回调，第二个是失败的回调。同时，then可以接收另一个Promise传入，也接收一个“类then”的对象或方法，即thenable对象。</p></li></ol><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN-Promise</a></p></blockquote><h2 id="二、手写一个Promise"><a href="#二、手写一个Promise" class="headerlink" title="二、手写一个Promise"></a>二、手写一个Promise</h2><ul><li>实现<strong>Promise类</strong>类</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 1、 定义status状态</span><span class="hljs-comment"> * 2、 定义fn1 fn2 数组</span><span class="hljs-comment"> * 3、 定义 resolve reject 方法</span><span class="hljs-comment"> * 4、 executor执行</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span>(<span class="hljs-params">executor</span>) </span>&#123;  <span class="hljs-keyword">let</span> self = <span class="hljs-built_in">this</span>;  <span class="hljs-comment">// 初始化 status 为等待状态</span>  self.status = <span class="hljs-string">&#x27;pending&#x27;</span>;  self.fn1Callback = [];  self.fn2Callback = [];  <span class="hljs-comment">// resolve 做的事情：</span>  <span class="hljs-comment">// 1. 修改 this 实例的状态</span>  <span class="hljs-comment">// 2. 修改 this 实例的data</span>  <span class="hljs-comment">// 3. 遍历执行this fn1Callback 上挂载的方法</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>&#123;    <span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;  <span class="hljs-keyword">return</span> value.then(resolve, reject);&#125;<span class="hljs-comment">// 异步执行所有的回调函数</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">if</span>(self.status === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;self.status = <span class="hljs-string">&#x27;resolved&#x27;</span>;self.data = value;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; self.fn1Callback.length; i++) &#123;self.fn1Callback[i](value);&#125;  &#125;&#125;)  &#125;  <span class="hljs-comment">// reject 做的事情</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>) </span>&#123;<span class="hljs-comment">// 异步执行所有的回调函数</span>  <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;self.status = <span class="hljs-string">&#x27;rejected&#x27;</span>;self.data = reason;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; self.fn2Callback.length; i++) &#123;  self.fn2Callback[i](reason);&#125;  &#125;&#125;)  &#125;  <span class="hljs-comment">// 如果 executor 执行报错, 直接执行reject</span>  <span class="hljs-keyword">try</span> &#123;    executor(resolve, reject);  &#125; <span class="hljs-keyword">catch</span> (err) &#123;    reject(err);  &#125;&#125;</code></pre><ul><li><p>实现<strong>then</strong>方法</p><ul><li>Promise对象有一个then方法，用来注册在这个Promise状态确定后的回调;</li><li>当Promise状态发生了转变，不论成功或者失败都会调用then方法;</li><li>then方法时在Promise实例上调用，因此then方法的实现是在Promise的prototype上;</li><li>then方法会返回一个Promise，而且是返回一个新的Promise对象</li></ul></li></ul><p><img src="https://i.loli.net/2020/12/13/vBFdAnoX2OrNb14.png" alt="PromiseThen.png"></p><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn1, fn2</span>) </span>&#123;  <span class="hljs-keyword">var</span> self = <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">var</span> promose2;  <span class="hljs-comment">// 首先对fn1 fn2 做判断</span>  fn1 = <span class="hljs-keyword">typeof</span> fn1 === <span class="hljs-string">&#x27;function&#x27;</span> ? fn1 : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>&#123; <span class="hljs-keyword">return</span> v; &#125;;  fn2 = <span class="hljs-keyword">typeof</span> fn2 === <span class="hljs-string">&#x27;function&#x27;</span> ? fn2 : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">r</span>) </span>&#123; <span class="hljs-keyword">throw</span> r; &#125;;  <span class="hljs-comment">// 执行到 then, 并不确定 Promise的状态</span>  <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;    <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 先定义一个方法，把方法挂载到 onResolvedCallback 数组上</span>  <span class="hljs-comment">// 方法里面就是调用传入的 fn1</span>  self.onResolvedCallback.push(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<span class="hljs-keyword">try</span> &#123;  <span class="hljs-keyword">let</span> x = fn1(value);  resolvePromise(promise2, x, resolve, reject);&#125; <span class="hljs-keyword">catch</span>(r) &#123;  reject(r);&#125;  &#125;)  self.onRejectedCallback.push(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;    <span class="hljs-keyword">try</span> &#123;  <span class="hljs-keyword">let</span> x = fn2(reason);  resolvePromise(promise2, x, resolve, reject)&#125; <span class="hljs-keyword">catch</span>(r) &#123;  reject(r);&#125;  &#125;)&#125;)  &#125;  <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">&#x27;resolved&#x27;</span>) &#123;<span class="hljs-comment">// then 执行后， 返回一个Promise</span><span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 异步执行onResolved</span>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">try</span> &#123;  <span class="hljs-comment">// 执行 fn1(), 拿到结果</span>  <span class="hljs-comment">// fn1 是用户传入的, 所以fn1的返回值 就可能有很多种,因此封装到 resolvePromise处理</span>  <span class="hljs-keyword">let</span> x = fn1(self.data);  resolvePromise(promise2, x, resolve, reject);&#125; <span class="hljs-keyword">catch</span> (err) &#123;reject(reason);&#125;  &#125;)&#125;)  &#125;  <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">&#x27;rejected&#x27;</span>) &#123;    <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 异步执行onRejected</span>        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">let</span> x = fn2(self.data);          resolvePromise(promise2, x, resolve, reject);        &#125; <span class="hljs-keyword">catch</span> (reason) &#123;          reject(reason);        &#125;      &#125;)    &#125;)  &#125;&#125;<span class="hljs-comment">// 1. 普通值</span><span class="hljs-comment">// 2. promise 值</span><span class="hljs-comment">// 3. thenable 的值，执行 then</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) </span>&#123;  <span class="hljs-comment">// 为了防止循环引用</span>  <span class="hljs-keyword">if</span> (promise2 === x) &#123;<span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Chaining cycle detected for promise!&#x27;</span>));  &#125;  <span class="hljs-comment">// 如果 x 是 promise</span>  <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;x.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;  resolve(data)&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;  reject(e)&#125;);<span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-comment">// 如果 x 是 object 类型或者是 function</span>  <span class="hljs-keyword">if</span> ((x !== <span class="hljs-literal">null</span>) &amp;&amp; ((<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;object&#x27;</span>) || (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;function&#x27;</span>))) &#123;<span class="hljs-comment">// 拿x.then可能会报错</span><span class="hljs-keyword">try</span> &#123;   <span class="hljs-comment">// 先拿到 x.then</span>    <span class="hljs-keyword">var</span> then = x.then    <span class="hljs-keyword">var</span> called;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;    <span class="hljs-comment">// 这里的写法，是 then.call(this, fn1, fn2)</span>    then.call(x, <span class="hljs-function">(<span class="hljs-params">y</span>) =&gt;</span> &#123;<span class="hljs-comment">// called 是干什么用的呢？</span><span class="hljs-comment">// 有一些 promise 实现的不是很规范，瞎搞的，比如说，fn1, fn2 本应执行一个，</span><span class="hljs-comment">// 但是有些then实现里面，fn1, fn2都会执行</span><span class="hljs-comment">// 为了 fn1 和 fn2 只能调用一个, 设置一个 called 标志位</span><span class="hljs-keyword">if</span> (called) &#123;<span class="hljs-keyword">return</span>;&#125;called = <span class="hljs-literal">true</span>;<span class="hljs-keyword">return</span> resolvePromise(promise2, y, resolve, reject);&#125;, <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (called) &#123;<span class="hljs-keyword">return</span>;&#125;called = <span class="hljs-literal">true</span>;<span class="hljs-keyword">return</span> reject(r);&#125;);&#125; <span class="hljs-keyword">else</span> &#123;resolve(x);&#125;&#125; <span class="hljs-keyword">catch</span> (err) &#123;  <span class="hljs-keyword">if</span> (called) &#123;        <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-keyword">return</span> reject(e);&#125;  &#125; <span class="hljs-keyword">else</span> &#123;  resolve(x);  &#125;&#125;</code></pre><blockquote><p><a href="https://mp.weixin.qq.com/s/oURuka-Qgbbj8JKtlYNMaw">可能是目前最易理解的手写promise</a></p></blockquote><h2 id="三、手写Promise-all-Promise-retry"><a href="#三、手写Promise-all-Promise-retry" class="headerlink" title="三、手写Promise.all / Promise.retry"></a>三、手写Promise.all / Promise.retry</h2><p><strong><code>Promise.all</code></strong></p><pre><code class="hljs javascript"><span class="hljs-comment">// 只要有一个 promise 失败即返回失败的结果</span><span class="hljs-built_in">Promise</span>.all = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr)) &#123;  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;argument must be a array&#x27;</span>);&#125;<span class="hljs-keyword">let</span> dataArr = [];<span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;  <span class="hljs-keyword">let</span> p = arr[i];  p.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;    dataArr.push(data);    num ++;    <span class="hljs-keyword">if</span> (num === arr.length) &#123;      <span class="hljs-keyword">return</span> resolve(dataArr);    &#125;  &#125;).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> reject(e))&#125;  &#125;)&#125;</code></pre><p><strong><code>Promise.retry</code></strong></p><pre><code class="hljs javascript"><span class="hljs-comment">// retry 是报错会尝试，尝试超过一定次数才真正的 reject</span><span class="hljs-built_in">Promise</span>.retry = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">getData, times, delay</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">attemp</span>(<span class="hljs-params"></span>) </span>&#123;  getData().then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;resolve(data);  &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (times === <span class="hljs-number">0</span>) &#123;  reject(err);&#125; <span class="hljs-keyword">else</span> &#123;  times --;  <span class="hljs-built_in">setTimeout</span>(attemp, delay);&#125;  &#125;)&#125;attemp();  &#125;)&#125;</code></pre><h2 id="四、promise-题"><a href="#四、promise-题" class="headerlink" title="四、promise 题"></a>四、promise 题</h2><p>1</p><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;resolve(a)&#125;).then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`成功：<span class="hljs-subst">$&#123;result&#125;</span>`</span>)<span class="hljs-keyword">return</span> result * <span class="hljs-number">10</span>&#125;).then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`成功：<span class="hljs-subst">$&#123;result&#125;</span>`</span>)&#125;,<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`失败：<span class="hljs-subst">$&#123;reason&#125;</span>`</span>)&#125;).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`catch：<span class="hljs-subst">$&#123;e&#125;</span>`</span>)&#125;)</code></pre><p>2</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">await</span> async2();<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);&#125;async1();<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>);&#125;, <span class="hljs-number">0</span>)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5&#x27;</span>);resolve();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;6&#x27;</span>);&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;7&#x27;</span>)&#125;)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;8&#x27;</span>)<span class="hljs-comment">// script start -&gt; Promise -&gt; script end -&gt; async2 end -&gt; promise1 -&gt; async1 end -&gt; promise2 -&gt; setTimeout</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Promise</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络/浏览器百问百答</title>
    <link href="/2020/12/11/interview/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C/"/>
    <url>/2020/12/11/interview/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="1-谈谈你对dns-prefetch的理解"><a href="#1-谈谈你对dns-prefetch的理解" class="headerlink" title="1. 谈谈你对dns-prefetch的理解"></a>1. 谈谈你对dns-prefetch的理解</h3><p><a href="https://zhuanlan.zhihu.com/p/92700557">JS的Reflect学习和应用</a></p><p>DNS是什么 ———— Domain Name System, 域名系统, 作为域名和IP地址相互映射的一个分布式数据库.</p><p>DNS-Perfetching: DNS预解析, 浏览器根据自定义的规则, 提前去解析后面可能会用到的域名, 来加速网站的访问速度, 以免延迟。</p><p>方式:</p><pre><code class="hljs javascript">&lt;link rel=<span class="hljs-string">&quot;dns-prefetch&quot;</span> href=<span class="hljs-string">&quot;//wq.test.com&quot;</span>&gt;</code></pre><p>总结：</p><ol><li><p>DNS Prefetching是提前加载域名解析的,省去了解析时间。</p></li><li><p>a标签的href在Chrome、Firefox、高版本IE等浏览器会自动开启DNS Prefetching. 但是在HTTPS协议下不起作用，需要通过meta标签手动设置打开。<br><code>&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;</code></p></li><li><p>DNS预解析对什么样的网站更有用呢？当你的网站引用了很多其他域名的资源, 类似淘宝这种网站。如果你的网站的资源基本都在你的本域名下, 那么这个基本没有什么作用了。因为DNS Chrome在访问你的网站就帮你缓存了。</p></li></ol><h3 id="2-get-post请求传参长度有什么特点"><a href="#2-get-post请求传参长度有什么特点" class="headerlink" title="2. get/post请求传参长度有什么特点"></a>2. get/post请求传参长度有什么特点</h3><p>HTTP协议相关只是，待补充<br><a href="https://juejin.cn/post/6860253625030017031">GET 请求能传图片吗</a>  </p><h3 id="3-前端需要注意哪些SEO"><a href="#3-前端需要注意哪些SEO" class="headerlink" title="3. 前端需要注意哪些SEO"></a>3. 前端需要注意哪些SEO</h3><ol><li><p>合理的title、description、keyWords<br>　　搜索对这三项的权重逐渐减小：　　<br>　　· title 值强调重点即可，不同title要有所不同，重要关键词不要超过两次，而且要靠前<br>　　· description 把页面内容高度概括，长度合适，不要过分堆砌关键字，不同页面的<br>　　· keyWords 列举出重要关键词即可</p></li><li><p>语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</p></li><li><p>重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</p></li><li><p>重要内容不要用 js 输出：爬虫不会执行 js 获取内容</p></li><li><p>少用 iframe(搜索引擎不会抓取 iframe 中的内容)</p></li><li><p>非装饰性图片必须加 alt</p></li><li><p>提高网站速度(网站速度是搜索引擎排序的一个重要指标)</p></li></ol><h3 id="4-实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后-退时正确响应。给出你的技术实现方案？"><a href="#4-实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后-退时正确响应。给出你的技术实现方案？" class="headerlink" title="4. 实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后 退时正确响应。给出你的技术实现方案？"></a>4. 实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后 退时正确响应。给出你的技术实现方案？</h3><p><a href="https://www.renfei.org/blog/html5-introduction-3-history-api.html">HTML5 简介（三）：利用 History API 无刷新更改地址栏</a><br><a href="https://juejin.cn/post/6844903558576341000">简单聊聊H5的pushState与replaceState</a><br><a href="http://blog.chenxu.me/post/detail?id=ed4f0732-897f-48e4-9d4f-821e82f17fad">pushState + ajax 实现浏览器无刷新前进后退</a></p><p>方案：</p><ol><li>利用History.pushState(state, title[, url]) API记录当前浏览器会话的历史堆栈中需要保留的状态（state）,<br>浏览器历史记录可以看作一个「栈」，栈是一种后进先出的结构，用户每点开一个新网页，都会将当前网页加入到栈中，叫「入栈」。用户每次点击「后退」按钮都会取走最上面的那个记录，叫做「出栈」。而每次浏览器显示的自然是最顶端的盘子的内容。<br>执行pushState函数之后，会往浏览器的历史记录中添加一条新记录，同时改变地址栏的地址内容。</li><li>再利用popstate监听。 当用户点击浏览器的「前进」、「后退」按钮时，就会触发popstate事件。你可以监听这一事件，从而作出反应。</li></ol><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;popstate&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;    <span class="hljs-keyword">var</span> state = e.state;    <span class="hljs-comment">// do something...</span>&#125;);</code></pre><ol start="3"><li>我们通过对 window.onpopstate 事件监听来响应浏览器 的前进后退操作。</li></ol><p>使用 pushState 来实现有两个问题，一个是打开首页时没有记录，我们可以使用 replaceState 来将首页的记录替换，另一个问 题是当一个页面刷新的时候，仍然会向服务器端请求数据，因此如果请求的 url 需要后端的配 合将其重定向到一个页面。</p><h3 id="5-如何优化SPA应用的首屏加载速度慢的问题？"><a href="#5-如何优化SPA应用的首屏加载速度慢的问题？" class="headerlink" title="5. 如何优化SPA应用的首屏加载速度慢的问题？"></a>5. 如何优化SPA应用的首屏加载速度慢的问题？</h3><ul><li>将公用的JS库通过script标签外部引入，减小app.bundel的大小，让浏览器并行下载资源文件，提高下载速度；</li><li>在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的js文件；</li><li>root中插入loading 或者 骨架屏 prerender-spa-plugin，提升用户体验；</li><li>如果在webview中的页面，可以进行页面预加载</li><li>独立打包异步组件公共 Bundle，以提高复用性&amp;缓存命中率</li><li>静态文件本地缓存，有两种方式分别为HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头和Service Worker离线缓存</li><li>配合 PWA 使用</li><li>SSR</li><li>root中插入loading 或者 骨架屏 prerender-spa-plugin</li><li>使用 Tree Shaking 减少业务代码体积 更多参考：<a href="https://github.com/LuckyWinty/fe-weekly-questions/issues/69">如何优化SPA应用的首屏加载速度慢的问题？</a></li></ul><h3 id="6-Reflect-反射-对象创建目的？"><a href="#6-Reflect-反射-对象创建目的？" class="headerlink" title="6. Reflect(反射) 对象创建目的？"></a>6. Reflect(反射) 对象创建目的？</h3><p>MDN(<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">MDN-Reflect</a>)对Reflect的定义：Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers的方法相同。Reflect不是一个函数对象，因此它是不可构造的。</p><ul><li>将 Object对象的一些明显属于语言内部的方法（ 比 如 Object.defineProperty）放到 Reflect 对象上。</li><li>修改某些 Object 方法的返回结果，让其变得更合理。</li><li>让 Object 操作都变成函数行为。</li><li>Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象 的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可 以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。</li></ul><p>也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取 默认行为。</p><blockquote><p>参考：<br><a href="https://mp.weixin.qq.com/s/kWULrNVG7XQ1Zq4BW4Z52w">12 道腾讯前端面试真题及答案整理</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>interview题 归类</title>
    <link href="/2020/12/10/interview/%E6%96%87%E7%AB%A0%E5%BD%92%E7%B1%BB/"/>
    <url>/2020/12/10/interview/%E6%96%87%E7%AB%A0%E5%BD%92%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6860253625030017031">1、GET 请求能传图片吗</a><br>　　tags: Http协议、get/Post</p><p>1、错误收集  sendTry<br>2、性能监控<br>3、自动化测试<br>4、微前端<br>5、如何体现项目管理能力</p><p>正则表达式 - 算法</p><p>例题1：<br><a href="https://leetcode-cn.com/problems/positions-of-large-groups/">https://leetcode-cn.com/problems/positions-of-large-groups/</a></p><p>// matchAll<br>var largeGroupPositions = function(s) {<br>    let g = s.matchAll(/([a-z])\1{2,}/g), r = [], t<br>    while (t = g.next().value) r.push([t.index, t.index + t[0].length - 1])<br>    return r<br>};</p><p>// replace<br>var largeGroupPositions = function(s) {<br>    const r = []<br>    s.replace(/([a-z])\1{2,}/g, (a, _, i)=&gt; r.push([i, i + a.length - 1]))<br>    return r<br>};</p>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React百问百答</title>
    <link href="/2020/12/09/interview/interview-React/"/>
    <url>/2020/12/09/interview/interview-React/</url>
    
    <content type="html"><![CDATA[<h2 id="一、生命周期相关"><a href="#一、生命周期相关" class="headerlink" title="一、生命周期相关"></a>一、生命周期相关</h2><h3 id="1、React-V16生命周期发生了什么变化？"><a href="#1、React-V16生命周期发生了什么变化？" class="headerlink" title="1、React V16生命周期发生了什么变化？"></a>1、React V16生命周期发生了什么变化？</h3><p>React16废弃的三个生命周期函数</p><ul><li><del>componentWillMount</del></li><li><del>componentWillReceiveProps</del></li><li><del>componentWillUpdate</del></li></ul><p>取而代之的是两个新的生命中后期函数:</p><ul><li>static getDerivedStateFromProps</li><li>getSnapshotBeforeUpdate</li></ul><blockquote><p>注：目前在16版本中componentWillMount、componentWillReceiveProps、componentWillUpdate并未完全删除这三个生命周期函数，而且新增了UNSAFE_componentWillMount、UNSAFE_componentWillReceiveProps、UNSAFE_componentWillUpdate三个函数，官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们  </p></blockquote><h3 id="2、setState-异步设计原理"><a href="#2、setState-异步设计原理" class="headerlink" title="2、setState 异步设计原理"></a>2、setState 异步设计原理</h3><p>异步的作用是<strong>提高性能，降低冗余。简单说，因为state具有更新队列，将所有更新都累计到最后进行批量合，并再去渲染可以极大提高应用的性能，像源生JS那样修改后就进行DOM的重渲染，会造成巨大的性能消耗。</strong>同样这与react优化后的diff算法也有关系。</p><p><strong>结论：</strong><br><strong>1. setState只在合成事件和钩子函数中是”异步”的，在原生事件和setTimeout中都是同步的。</strong><br><strong>2. setState的”异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的”异步”，当然可以通过第二个参数setState(partialState, callback)中的callback拿到更新后的结果。</strong><br><strong>3. setState的批量更新优化也是建立在”异步”（合成事件、钩子函数）之上的。在原生事件和setTimeout中不会批量更新，在”异步”中如果对同一个值进行多次setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，在更新时会对其进行合并批量更新。</strong></p><ul><li><p>setState 中的批量更新<br>在setState的时候React内部会创建一个updateQueue，通过firstUpdate、lastUpdate、lastUpdate.next 去维护一个更新的队列，在最终的perforWork中，相同的key会被覆盖，只会对最后一次的setState进行更新。</p></li><li><p>为什么原生事件中 setState 可以同步拿到更新后的state的值？<br>原生事件自带的事件监听addEventListener，或者用原生js、jq直接document.querySelector().onclick这种绑定事件的实行都属于原生事件。<br>由于原生事件没有走合成事件的那一大堆逻辑，直接触发click事件，到requestWork，在requestWork里由于expirationTime===Sync的原因，直接走了performSyncWork去更新，并不想合成事件或者钩子函数中被return，所以原生事件中的setState能同步拿到更新后的state的值。</p></li><li><p>为什么 setTimeout 的 setSate 可以同步拿到更新后的 state 的值？<br>由于interactiveUpdates文件中，setTimeout( () =&gt; { this.setState() }, 0) 在try代码块中，当你try代码执行到setTimeout的时候，把它丢到了队列里，并没有去执行，而是限制性finally代码块，等finally执行完了，isBatchingUpdates又变为了false，导致最红去执行队列的setState时候，requestWork走的是和原生事件一样的 expirationTime === Sync，直接走了performSyncWork去更新，表现就会和原生事件一样了。</p></li></ul><h3 id="3、在哪些钩子函数里调用setState不会引起组件重新渲染"><a href="#3、在哪些钩子函数里调用setState不会引起组件重新渲染" class="headerlink" title="3、在哪些钩子函数里调用setState不会引起组件重新渲染"></a>3、在哪些钩子函数里调用setState不会引起组件重新渲染</h3><ol><li><p>componentWillMount<br>因为这个钩子函数是在组件挂载到DOM前调用，且只会被调用一次。</p></li><li><p>componentWillReceiveProps<br>因为<code>componentWillReceiveProps</code>中判断<code>props</code>是否发生变，若变化了，<code>this.setState</code>将引起<code>state</code>变化，从而引起<code>render</code>，此时就没必要再做第二次因重传<code>props</code>引起的<code>render</code>了，不然重复做一样的渲染了。</p></li></ol><h2 id="二、输出结果"><a href="#二、输出结果" class="headerlink" title="二、输出结果"></a>二、输出结果</h2><h3 id="1、输出结果是什么，如何改进"><a href="#1、输出结果是什么，如何改进" class="headerlink" title="1、输出结果是什么，如何改进"></a>1、输出结果是什么，如何改进</h3><pre><code class="hljs javascript">state = &#123;    num: <span class="hljs-number">0</span>&#125;<span class="hljs-function"><span class="hljs-title">ComponentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-built_in">this</span>.setState(&#123;        num: <span class="hljs-built_in">this</span>.state.num + <span class="hljs-number">1</span>    &#125;, <span class="hljs-function">()=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.num) <span class="hljs-comment">// 1</span>    &#125;)    <span class="hljs-built_in">this</span>.setState(&#123;        num:<span class="hljs-built_in">this</span>.state.num + <span class="hljs-number">1</span>    &#125;, <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.num) <span class="hljs-comment">// 1</span>    &#125;)&#125;</code></pre><p>两次都打印1的原因是：回调函数仅仅可以获取到当前修改后的state，再次执行setState方法<strong>获取到的state值依然为挂载后初始state值</strong>。</p><p>解决办法：</p><pre><code class="hljs javascript">state = &#123;    num: <span class="hljs-number">0</span>&#125;<span class="hljs-function"><span class="hljs-title">ComponentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-built_in">this</span>.setState(        preState =&gt; &#123;            num: preState.num + <span class="hljs-number">1</span>        &#125;, <span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.num) <span class="hljs-comment">// 1</span>        &#125;    )    <span class="hljs-built_in">this</span>.setState(        preState =&gt; &#123;            num: preState.num + <span class="hljs-number">1</span>        &#125;, <span class="hljs-function">()=&gt;</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.num) <span class="hljs-comment">// 2</span>        &#125;    )&#125;</code></pre><p>实现原理 是setState本身可以接受函数作为参数，而在这里我们使用的参数就是上一次的state。</p><h2 id="2、输出结果是什么"><a href="#2、输出结果是什么" class="headerlink" title="2、输出结果是什么"></a>2、输出结果是什么</h2><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;  state = &#123;    count: <span class="hljs-number">0</span>  &#125;;​  <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-comment">// 生命周期中调用</span>    <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span> &#125;);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;lifecycle: &quot;</span> + <span class="hljs-built_in">this</span>.state.count);    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-comment">// setTimeout中调用</span>      <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span> &#125;);      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;setTimeout: &quot;</span> + <span class="hljs-built_in">this</span>.state.count);    &#125;, <span class="hljs-number">0</span>);    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;div2&quot;</span>).addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-built_in">this</span>.increment2);  &#125;​  increment = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// 合成事件中调用</span>    <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span> &#125;);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;react event: &quot;</span> + <span class="hljs-built_in">this</span>.state.count);  &#125;;​  increment2 = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// 原生事件中调用</span>    <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span> &#125;);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;dom event: &quot;</span> + <span class="hljs-built_in">this</span>.state.count);  &#125;;​  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> (      &lt;div className=<span class="hljs-string">&quot;App&quot;</span>&gt;        &lt;h2&gt;couont: &#123;<span class="hljs-built_in">this</span>.state.count&#125;&lt;/h2&gt;        &lt;div id=<span class="hljs-string">&quot;div1&quot;</span> onClick=&#123;<span class="hljs-built_in">this</span>.increment&#125;&gt;          click me and count+<span class="hljs-number">1</span>        &lt;/div&gt;        &lt;div id=<span class="hljs-string">&quot;div2&quot;</span>&gt;click me and count+<span class="hljs-number">1</span>&lt;/div&gt;      &lt;/div&gt;    );  &#125;&#125;</code></pre><blockquote><p> 参考<br><a href="https://zhuanlan.zhihu.com/p/50335551">setState异步、同步与进阶</a><br><a href="https://zhuanlan.zhihu.com/p/61847529">React的setState你真的用对了吗？</a><br><a href="https://juejin.cn/post/6844903636749778958#comment">你真的理解setState吗？</a>  </p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js - Foo.getName()</title>
    <link href="/2020/12/02/%E9%A2%98%E7%9B%AE/Foo.getName/"/>
    <url>/2020/12/02/%E9%A2%98%E7%9B%AE/Foo.getName/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params"></span>) </span>&#123;getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;&#125;foo.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);&#125;foo.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);&#125;<span class="hljs-keyword">var</span> getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>);&#125;foo.getName();getName();foo().getName();getName();<span class="hljs-keyword">new</span> foo().getName();<span class="hljs-keyword">new</span> <span class="hljs-keyword">new</span> foo().getName();</code></pre><p>关于 <code>new new foo().getName()</code>:<br>1、执行优先级： <code>new foo() &gt;  foo() &gt; new foo </code><br>2、拆解步骤：<br>    （1）<code>var a = new foo();</code><br>        =&gt; <code>new a.getName()</code><br>    （2）<code>new a.getName();</code></p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promise1 = <span class="hljs-built_in">Promise</span>.resolve()    .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>))    .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>))<span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>)        resolve()    &#125;)&#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>))<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>)    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([promise2, promise1]))    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>)    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">obj</span>: <span class="hljs-number">5</span> &#125;&#125;<span class="hljs-keyword">let</span> promise3 = <span class="hljs-built_in">Promise</span>.resolve()    .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">8</span>))    .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">9</span>))<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> main())</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>手写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器与JS运行机制</title>
    <link href="/2020/12/02/%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8EJS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/12/02/%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8EJS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="一、JavaScript预解析"><a href="#一、JavaScript预解析" class="headerlink" title="一、JavaScript预解析"></a>一、JavaScript预解析</h2><p>JavaScript代码运行分为两个阶段：</p><ul><li>(1) 预解析</li></ul><p>所有函数定义提前，函数体提升(当然不包括如var box = function() {} )<br>形参声明并赋值<br>变量声明(不赋值)</p><ul><li>(2) 执行</li></ul><p>按照js运行机制从，从上到下执行</p><h2 id="二、进程与线程"><a href="#二、进程与线程" class="headerlink" title="二、进程与线程"></a>二、进程与线程</h2><ul><li><strong>进程是cpu资源分配的最小单位</strong>（是能够拥有资源和独立运行的最小单位）</li><li><strong>线程是cpu调度的最小单位</strong>（线程是建立在进程的基础上的一次程序运行单位，一个进程可以有多个线程</li></ul><p>举例：此处有多个工厂，每个工厂有1个或多个工人。此时<strong>工厂就好比进程</strong>，有单独专属自己的工厂资源；<strong>工人就好比是线程</strong>，多个工人在工厂中写作工作。工厂的空间是工人们共享的，这象征一个进程的内存空间是共享的，每个线程都可以共享内存。并且每个工厂之间相互独立存在。<br><img src="https://i.loli.net/2020/12/02/fvhtrWzeMkpCR15.png" alt="进程和线程.png"></p><ul><li>应用程序必须运行在某个进程的某个线程上</li><li>一个进程至少有一个运行的线程：主线程，进程启动后自动创建</li></ul><h2 id="三、浏览器进程"><a href="#三、浏览器进程" class="headerlink" title="三、浏览器进程"></a>三、浏览器进程</h2><p>浏览器内核是指支持浏览器运行的最核心的部分，分为渲染引擎和JS引擎。现在JS引擎比较独立，内核更加倾向于说渲染引擎</p><p><strong>(1)浏览器内核分类</strong></p><ul><li>Chrome、Safari： Webkit (Bink)</li><li>Firefox：Gecko</li><li>IE：Trident</li><li>360、搜狗等国内浏览器：Trident+Webkit</li><li>…</li></ul><p><strong>(2)浏览器进程</strong></p><ul><li>浏览器是多进程的</li><li>浏览器之所以能运行，是因为系统给它的进程分配了资源（cpu、内存）</li><li>简单来说，每打一个Tab页，就相当于创建了一个独立的浏览器进程</li></ul><p>浏览器进程的组成：</p><ul><li><strong>Browser进程</strong><br>浏览器的主进程，负责协调、主控，只有一个。<br>负责内容：浏览器页面显示；与用户交互（前进、后退等）；网络资源的管理、下载；各个页面的管理，创建和销毁其他进程等</li><li><strong>第三方插件进程</strong><br> 每种类型的插件对应一个进程，仅当插件使用时才创建</li><li><strong>GPU进程</strong><br>最多一个，用于3D绘制等</li><li><strong>浏览器渲染进程</strong>（浏览器内核，Renderer进程，内部是多线程的）<br>默认 每个Tab页面一个进程，互不影响<br>负责内容：页面渲染；脚本执行；事件处理</li></ul><p>浏览器是多线程的优势：避免单个Tab页崩溃或单个插件崩溃影响其他整个浏览器，可以充分多核优势，方便使用沙盒模型隔离插件等进程，提高浏览器的稳定性。缺点是，内存和cpu消耗会更大，有点空间换时间的意思。</p><p>Borwser进程与浏览器内核（Renderer进程）的通信过程：</p><ul><li>Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程<ul><li>渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和GPU进程来帮助渲染</li><li>当然可能会有JS线程操作DOM（可能会造成回流并重绘）</li><li>最后Renderer进程将结果传递给Browser进程</li></ul></li><li>Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染</li><li>Browser进程收到结果并将结果绘制出来</li></ul><h2 id="四、浏览器渲染进程"><a href="#四、浏览器渲染进程" class="headerlink" title="四、浏览器渲染进程"></a>四、浏览器渲染进程</h2><p>对于前端操作来说 ，最重要的是渲染进程，并且<strong>渲染进程也是多线程的</strong>。<br>渲染进程包含哪些线程？</p><ul><li><strong>GUI渲染线程</strong><ul><li>负责渲染浏览器页面，解析HTML、CSS，构建DOM树和RenderObject树，布局和绘制等</li><li>负责重绘（Repaint）和回流（Reflow）</li><li>GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI线程会保存在一个队列里等 js引擎空闲时执行。</li></ul></li><li><strong>JS引擎线程</strong><ul><li>负责处理JavaScript脚本，执行代码</li></ul></li><li><strong>事件触发线程</strong><ul><li>主要负责将准备好的事件交给JS引擎线程执行<br>比如setTimeout定时器计数结束、ajax等异步请求成功并触发回调函数、用户触发点击事件等，该线程会将整装待发的事件加入到任务队列的队尾，等待JS引擎线程的执行。</li></ul></li><li><strong>定时器触发线程</strong><ul><li>主要负责异步定时器一类的函数处理，如setTimeout、setInterval<br>主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理。当计数完毕后，事件触发线程会将计数完毕的事件加入到任务队列的尾部，等待JS引擎线程执行。</li></ul></li><li><strong>异步HTTP请求线程</strong><ul><li>负责执行异步请求一类的函数，如：ajax、axios、promise等<br>主线程依次执行代码是，遇到异步请求，会将异步请求函数交给该线程处理。当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待 JS引擎线程执行。</li></ul></li></ul><h2 id="五、事件循环"><a href="#五、事件循环" class="headerlink" title="五、事件循环"></a>五、事件循环</h2><h3 id="1-浏览器中的事件循环"><a href="#1-浏览器中的事件循环" class="headerlink" title="1 浏览器中的事件循环"></a><strong>1 浏览器中的事件循环</strong></h3><p>JavaScript语言是单线程的，意思是同一时间只能做一件事。后来为了有效利用多核CPU的计算能力，HTML5提出Web Server标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，并且子线程不能操作DOM。所以新标准并没有改变JavaScript单线程的本质。</p><p>简单描述JS的执行机制：</p><ol><li>首先判断JS是同步任务还是异步任务，同步任务就进入主线程执行，异步任务进入event table</li><li>异步任务在event table中注册函数，异步函数又分为宏任务(macro-task)和微任务(micro-task)，当满足触发条件后，宏任务被推入宏任务队列(macro-task queue)，微任务被推入微任务队列(micro-task queue)</li><li>同步任务在主线程中一直执行，直到同步任务执行完毕，主线程空闲空闲时，才去微任务队列(micro-task queue)中查看是否有可执行的异步任务，如果有就推入主线程中执行</li><li>直到全部微任务依次执行完毕后，主线程空闲，再去宏任务队列(macro-task queue) 查看是否有可执行的异步任务，如果有就推入主线程中执行<br>以上四步循环执行，就是event loop。  </li></ol><p>一个完整的Event Loop过程：</p><p>① 所有的同步任务都在主线程上执行，形成一个执行栈(exection context stack)，我们可以认为执行栈是一个函数调用的栈结构，遵循先进后出的原则。除了主线程的执行栈，还存在一个任务队列(task queue)，任务队列分为宏任务队列(macro-task queue)和微任务队列(micro-task queue)。<br>一开始执行栈为空，宏任务队列(macro-task queue)里只有一个script代码(整体代码)，微任务队列(micro-task queue)队列为空。<br>② 宏任务队列(macro-task queue)中的全局上下文(script标签)会被推入执行栈，同步代码执行。在执行的过程中会判断是同步任务还是异步任务，同步任务依次执行，异步任务会通过对一些接口的调用而产生新的macro-task和micro-task(只要异步任务有了运行结果，就会在对应的任务队列中放置一个事件，等待调用)。同步代码执行完了，script脚本会行和出队的过程。<br>③ 上一步出队的是一个macro-task，这一步要处理的是micro-task。需要注意的是，当macro-task出队时，任务是一个一个执行的，而micro-task出队时，任务是一队一队执行的。因此，我们处理micro-task这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。<br>④ 执行渲染操作，更新页面<br>⑤ 检查是否存在Web worker任务，如果有，则对其进行进行处理<br>⑥ 上述过程重复循环，直到两个队列都清空<br><img src="https://i.loli.net/2020/12/02/ZTb26DuxecrvmJt.jpg" alt="event-loop.jpg"></p><p>宏任务队列可以有多个，而微任务队列只有一个：  </p><ul><li>常见的macro-task：setTimeout、setInterval、script(整套代码)、I/O操作、UI渲染等；  </li><li>常见的micro-task：new Promise().then(回调)、process.nextTick、MutationObserver(HTML5新特性)等</li></ul><h3 id="2-Node中的事件循环"><a href="#2-Node中的事件循环" class="headerlink" title="2 Node中的事件循环"></a><strong>2 Node中的事件循环</strong></h3><p>Node中的事件循环与浏览器的是完全不同不同的东西。Node采用V8作为js的解析引擎，而I/O处理方面使用自己设计的libuv。<br>libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统的一些底层特性，对外提供API，事件循环也是在它里面实现：<br><img src="https://i.loli.net/2020/12/02/2dRg1pCtJw5894s.png" alt="node-eventLoop.png"></p><p>NodeJS运行机制如下：</p><ul><li>V8引擎解析JavaScript脚本</li><li>解析后的代码调用Node API</li><li>libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎</li><li>V8引擎再将结果返回给用户</li></ul><p>libuv引擎的事件循环分为6个阶段：</p><ol><li>timers阶段：执行timers（setTimeout和setInterval）的回调</li><li>I/O callbacks阶段：处理上一轮循环少数未执行的的I/O回调</li><li>idel、prepare阶段：仅Node内部使用</li><li>poll阶段：获取新的I/O事件，执行I/O回调</li><li>check阶段：执行setImmediate()回调</li><li>close callbacks阶段：执行socket的close事件回调<br>绝大部分的异步任务都在timers、poll、check这个3个阶段处理</li></ol><p>NodeJS执行环境下的特殊情况：<br>1）<strong>setTimeout和setImmediate</strong><br>二者非常相似，区别主要在于调用时机不同：</p><ul><li>setImmediate设计在poll阶段完成时执行，即check阶段</li><li>setTimeout设计在poll阶段为空闲时，且设定阶段到达后执行，但它在timers阶段执行</li></ul><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeout</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout&#x27;</span>);&#125;,<span class="hljs-number">0</span>);setImmediate(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">immediate</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;immediate&#x27;</span>);&#125;);</code></pre><p>对于以上代码，setTimeout可能执行在前，也可能执行在后；<br>取决于setImmediate的准备时间；因为当setTimeout指定时间小于4ms，则增加到4ms（4ms是H5de新标准，2010年以前的浏览器是10ms）</p><p>但是如果二者在I/O callback内部回调时，总是先执行setImmediate，后执行setTimeout:</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)fs.readFile(__filename, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout&#x27;</span>);    &#125;, <span class="hljs-number">0</span>)    setImmediate(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;immediate&#x27;</span>)    &#125;)&#125;)<span class="hljs-comment">// immediate</span><span class="hljs-comment">// timeout</span><span class="hljs-comment">// 因为这两个代码都写在I/O回调中，I/O回调是在poll阶段执行，当回调执行完毕后队列清空，发现SetImmediate回调，所以立即跳转到check阶段执行回调。</span>&#125;);</code></pre><p>2）<strong>process.nextTick</strong></p><p>process.nextTick是独立于Event Loop之外的，它有一个自己的队列，会优先于其他micro-task队列执行：</p><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timer1&#x27;</span>)    <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise1&#x27;</span>)&#125;)&#125;, <span class="hljs-number">0</span>)process.nextTick(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;nextTick&#x27;</span>)process.nextTick(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;nextTick&#x27;</span>)process.nextTick(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;nextTick&#x27;</span>)process.nextTick(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;nextTick&#x27;</span>)&#125;)   &#125;) &#125;)&#125;)<span class="hljs-comment">// nextTick=&gt;nextTick=&gt;nextTick=&gt;nextTick=&gt;timer1=&gt;promise1</span></code></pre><h3 id="3-浏览器与Node的Event-Loop差异"><a href="#3-浏览器与Node的Event-Loop差异" class="headerlink" title="3 浏览器与Node的Event Loop差异"></a><strong>3 浏览器与Node的Event Loop差异</strong></h3><p><strong>浏览器环境下，micro-task的任务队列是每个macro-task执行之后执行；</strong><br><strong>Node环境下，在node10及其以前版本，micro-task会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会执行micro-task队列的任务</strong><br><strong>Node在node11版本开始，Event Loop的运行原来发生了变化，一旦一个阶段里的宏任务执行完，就会立即执行微任务队列，这一点与浏览器一直。</strong></p><p><img src="https://i.loli.net/2020/12/02/KAmfl3ceQICY64i.png" alt="diff-eventLoop.png"></p><h3 id="4-Web-worker"><a href="#4-Web-worker" class="headerlink" title="4 Web worker"></a><strong>4 Web worker</strong></h3><p>由于JS是单线程，当遇到计算密集型或高延迟的任务，用户界面可能会短暂“冻结”，不能做其他操作。<br>于是HTML5提出Web Worker，它允许JavaScript创造多线程环境，允许主线程创建Worker线程，将一些任务分配给后者。主线程运行的同时，Worker线程在后台运行，两者互不干扰，等到Worker完成计算任务，在把结果返回给主线程。<br>Web Worker的优点是可以承担一些密集型或高延迟任务，使主线程流畅，不被阻塞或拖慢。<br>缺点：</p><ul><li>不能跨域加载JS</li><li>Worker内部代码不能访问DOM</li><li>不是所有浏览器都支持这个新特性</li></ul><p>Web Worker使用方法：</p><ul><li><p>主线程调用Worker线程：</p><ol><li>主线程通过new Worker()调用Worker构造函数，新建一个Worker线程</li><li>主线程调用worker.postMessage()方法，向Worker发消息</li><li>主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息</li></ol></li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// 主线程：</span><span class="hljs-keyword">var</span> input = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;number&#x27;</span>)<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;btn&#x27;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> number = input.value<span class="hljs-comment">//1、创建一个Worker对象</span><span class="hljs-keyword">var</span> worker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&#x27;worker.js&#x27;</span>)<span class="hljs-comment">// 3、绑定接收消息的监听</span>worker.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;主线程接收分线程返回的数据: &#x27;</span>+event.data)alert(event.data)&#125;<span class="hljs-comment">// 2、向分线程发送消息</span>worker.postMessage(number)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;主线程向分线程发送数据: &#x27;</span>+number)&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">// window</span></code></pre><p>Worker线程响应：</p><ol><li>Worker内部通过onmseeage()监听事件</li><li>通过postMessage(data)方法向主线程发送数据</li></ol><pre><code class="hljs javascript"><span class="hljs-comment">//worker.js文件</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fibonacci</span>(<span class="hljs-params">n</span>) </span>&#123;<span class="hljs-keyword">return</span> n&lt;=<span class="hljs-number">2</span> ? <span class="hljs-number">1</span> : fibonacci(n-<span class="hljs-number">1</span>) + fibonacci(n-<span class="hljs-number">2</span>)  <span class="hljs-comment">//递归调用</span>&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<span class="hljs-comment">//[object DedicatedWorkerGlobalScope]</span><span class="hljs-built_in">this</span>.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;<span class="hljs-keyword">var</span> number = event.data<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;分线程接收到主线程发送的数据: &#x27;</span>+number)<span class="hljs-comment">//计算</span><span class="hljs-keyword">var</span> result = fibonacci(number)postMessage(result)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;分线程向主线程返回数据: &#x27;</span>+result)<span class="hljs-comment">// alert(result)  alert是window的方法, 在分线程不能调用</span><span class="hljs-comment">// 分线程中的全局对象不再是window, 所以在分线程中不可能更新界面</span>&#125;</code></pre><blockquote><p>参考资料：<br><a href="https://github.com/ljianshu/Blog/issues/54">https://github.com/ljianshu/Blog/issues/54</a><br><a href="https://juejin.im/post/5bb05494e51d450e7428da59">https://juejin.im/post/5bb05494e51d450e7428da59</a><br><a href="https://juejin.im/post/5bee1e1ff265da61590b3fff">深入浅出JavaScript运行机制</a><br><a href="https://segmentfault.com/a/1190000012806637">10分钟理解JS引擎的执行机制</a><br><a href="https://www.jianshu.com/p/5e90253b5907">浏览器组成</a><br><a href="https://mp.weixin.qq.com/s/bWGjZlBhlIfdSwRDK8XDHQ">全面梳理JS引擎的运行机制</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx</title>
    <link href="/2020/12/01/%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/nginx/"/>
    <url>/2020/12/01/%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/nginx/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/12/01/HMLZ7bmBI23PkxD.png" alt="nginx.png"></p><h2 id="1-负载均衡"><a href="#1-负载均衡" class="headerlink" title="1 负载均衡"></a>1 负载均衡</h2><p>当用户访问web的时候，首先访问到的是负载均衡器，再通过负载均衡器将请求转发给后台服务器。<br>负载均衡的几种常用方式：</p><ul><li>轮询（默认）</li></ul><pre><code class="hljs javacript">&#x2F;&#x2F; nginx.configupstream backserver &#123;  server 192.168.0.1;  server 192.168.0.2;&#125;</code></pre><ul><li>权重（weight）—指定不同ip的权重，权重越高，访问越大，适用于不同性能的服务器</li></ul><pre><code class="hljs javacript">&#x2F;&#x2F; nginx.configupstream backserver &#123;    server 192.168.0.1 weight&#x3D;2;  server 192.168.0.2 weight&#x3D;8;&#125;</code></pre><ul><li>相应时间来分配—公平竞争，谁快谁处理， 不过需要依赖第三方插件nginx-upstream-fair</li></ul><pre><code class="hljs javacript">&#x2F;&#x2F; nginx.configupstream backserver &#123;  server 192.168.0.1;  server 192.168.0.2;  fair;&#125;server &#123;  listen 80;  server_name localhost;  location &#123;    proxy_pass  http:&#x2F;&#x2F;backserver;    &#125;&#125;</code></pre><p>nginx自带健康检查模块<code>（ngx_upstream_module）</code>，本质上是服务器心跳的检查，通过定时轮询向集群里的服务器健康检查请求，用来检查服务器是否处于异常状态。<br>健康检查涉及到两个配置属性：</p><ul><li>fail_timeout：设定服务器认为不可用的时间段以及统计失败尝试次数的时间段，默认为10S</li><li>max_fails：设定Nginx与服务器通信尝试失败的次数，默认为1次</li></ul><pre><code class="hljs javacript">upstream backserver&#123;  server 192.168.0.1 max_fails&#x3D;1 fail_timeout&#x3D;40s;  server 192.168.0.2  max_fails&#x3D;1 fail_timeout&#x3D;40s;&#125;</code></pre><h2 id="2-反向代理"><a href="#2-反向代理" class="headerlink" title="2 反向代理"></a>2 反向代理</h2><p>nginx代理服务器承担着中间人的角色，起到分配和沟通的作用。</p><ul><li>反向代理的作用：<ul><li>防火墙作用：让用户无法通过请求直接访问真正的服务器，通过nginx过滤掉没有权限或者非法请求，来保障内部服务器的安全。</li><li>负载均衡</li></ul></li><li>如何使用反向代理：通过location功能匹配指定的URI，然后把接收的符合匹配URI的请求通过proxy_pass转移给之前定义好的upstream节点池。</li></ul><pre><code class="hljs javacript">&#x2F;&#x2F; nginx.configserver&#123;    listen 80;    server_name localhost;    location&#123;        proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000;（upstream）      &#125;&#125;</code></pre><h2 id="3-Https设置"><a href="#3-Https设置" class="headerlink" title="3 Https设置"></a>3 Https设置</h2><p>Nginx常用来配置Https认证，主要有两个步骤：签署第三方可信任的SSL证书 和 配置Https</p><ul><li><p>签署第三方可信任的SSL：<br>配置Https要用到私钥example.key文件和example.crt证书文件，而申请证书文件的时候要用到example.csr文件。</p></li><li><p>Nginx配置Https：<br>要开启Https服务，在配置文件信息块（server）必须使用监听命令listen的ssl参数和定义服务器证书文件和私钥文件：</p></li></ul><pre><code class="hljs javacript">&#x2F;&#x2F; nginx.configserver&#123;  #ssl参数  listen   443 ssl;  &#x2F;&#x2F;监听443端口，因为443端口是https的默认端口。80为http的默认端口  server_name  example.com;  #证书文件  ssl_certificate    example.com.crt;  #私钥文件  ssl_certificate_key    example.com.key;&#125;</code></pre><ul><li>ssl_certificate：证书的绝对路径</li><li>ssl_certificate_key：密钥的绝对路径;</li></ul><h2 id="4-其他常用设置"><a href="#4-其他常用设置" class="headerlink" title="4 其他常用设置"></a>4 其他常用设置</h2><h3 id="（1）IP白名单"><a href="#（1）IP白名单" class="headerlink" title="（1）IP白名单"></a>（1）IP白名单</h3><p>通过配置nginx白名单，规定哪些IP可以访问你的服务器，防爬虫必备</p><h3 id="（2）适配PC与移动环境"><a href="#（2）适配PC与移动环境" class="headerlink" title="（2）适配PC与移动环境"></a>（2）适配PC与移动环境</h3><p>获取请求客户端的userAgent，从而知道当前用户终端是PC端还是移动端，并重定向到PC站和H5站</p><h3 id="（3）配置gzip"><a href="#（3）配置gzip" class="headerlink" title="（3）配置gzip"></a>（3）配置gzip</h3><p>开启nginx gzip压缩，静态资源的大小会大大减少，从而节省带宽，提高传输效率。</p><h3 id="（4）配置跨域请求"><a href="#（4）配置跨域请求" class="headerlink" title="（4）配置跨域请求"></a>（4）配置跨域请求</h3><p>当出现403跨域错误或其他跨域错误时，给nginx服务器配置相应的header参数</p><h2 id="5-如何使用nginx"><a href="#5-如何使用nginx" class="headerlink" title="5 如何使用nginx"></a>5 如何使用nginx</h2><p>本地nginx的基本使用：</p><ul><li>启动——<code>sudo nginx</code></li><li>修改<code>nginx.conf</code>配置——<code>vim /usr/local/etc/nginx/nginx.conf</code></li><li>检查语法是否正常——<code>sudo nginx –t</code></li><li>重启<code>nginx</code>——<code>sudo nginx –s reload</code></li><li>创建软连接——便于管理多个<code>nginx</code></li></ul><p>当我们需要管理多个网站的<code>nginx</code>，<code>nginx</code>文件放在一起是最好的管理方式。<br>我们把配置文件丢在<code>/nginx/conf.d/</code>文件夹下，假如我们程序文件夹下有一个<code>nginx</code>配置文件：<code>/home/app.nginx.conf</code>，只需要给这个文件创建一个软连接到<code>/nginx/conf.d/</code>下即可：<br><code>ln -s /home/app/app.example.com.nginx.conf /etc/nginx/conf.d/app.nginx.conf</code><br>这样操作之后，我们修改配置文件后，<code>/nginx/conf.d/</code>下与之对应的配置文件也会被修改，修改后重启<code>nginx</code>即可使用新的配置属性。</p><h2 id="6-停止Nginx服务的四种方法"><a href="#6-停止Nginx服务的四种方法" class="headerlink" title="6 停止Nginx服务的四种方法"></a>6 停止Nginx服务的四种方法</h2><ul><li>从容停止服务<br>这种方法较stop相比就比较温和一些了，需要进程完成当前工作后再停止。</li></ul><pre><code class="hljs cos">nginx -<span class="hljs-keyword">s</span> <span class="hljs-keyword">quit</span></code></pre><ul><li>立即停止服务<br>这种方法比较强硬，无论进程是否在工作，都直接停止进程。</li></ul><pre><code class="hljs arduino">nginx -s <span class="hljs-built_in">stop</span></code></pre><ul><li>systemctl 停止<br>systemctl属于Linux命令</li></ul><pre><code class="hljs arduino">systemctl <span class="hljs-built_in">stop</span> nginx.service</code></pre><ul><li>killall 方法杀死进程<br>直接杀死进程，在上面无效的情况下使用，态度强硬，简单粗暴！</li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">killall nginx</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo help</title>
    <link href="/2020/11/30/hello-world/"/>
    <url>/2020/11/30/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>清除缓存 &amp;&amp; 生成 &amp;&amp; 启动服务预览</p><pre><code class="hljs bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></pre><p>部署到服务器</p><pre><code class="hljs bash">hexo d</code></pre><h2 id="命令简写"><a href="#命令简写" class="headerlink" title="命令简写"></a>命令简写</h2><pre><code class="hljs bash">hexo n <span class="hljs-string">&quot;我的博客&quot;</span> == hexo new <span class="hljs-string">&quot;我的博客&quot;</span> <span class="hljs-comment">#新建文章</span>hexo g == hexo generate <span class="hljs-comment">#生成</span>hexo s == hexo server <span class="hljs-comment">#启动服务预览</span>hexo d == hexo deploy <span class="hljs-comment">#部署</span>  hexo server <span class="hljs-comment">#Hexo会监视文件变动并自动更新，无须重启服务器</span>hexo server -s <span class="hljs-comment">#静态模式</span>hexo server -p 5000 <span class="hljs-comment">#更改端口</span>hexo server -i 192.168.1.1 <span class="hljs-comment">#自定义 IP</span>hexo clean <span class="hljs-comment">#清除缓存，若是网页正常情况下可以忽略这条命令</span>刚刚的三个命令依次是新建一篇博客文章、生成网页、在本地预览的操作。</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法设计 - 回溯算法</title>
    <link href="/2020/05/16/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2020/05/16/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><ul><li>回溯算法是<strong>算法设计</strong>中的一种方法</li><li>回溯算法是一种<strong>渐进式</strong>寻找并构建问题解决方式的策略</li><li>回溯算法会先从一个可能的动作开始解决问题，如果不行，就回溯并选择另一个动作，直到将问题解决</li></ul><h2 id="二、练习题"><a href="#二、练习题" class="headerlink" title="二、练习题"></a>二、练习题</h2><h3 id="1、全排列"><a href="#1、全排列" class="headerlink" title="1、全排列"></a>1、全排列</h3><p><a href="https://leetcode-cn.com/problems/permutations/">leetcode-46 全排列</a></p><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p><p>示例 1：</p><pre><code class="hljs text">输入: [1,2,3]输出:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]</code></pre><pre><code class="hljs text">解题思路：1. 用递归模拟出所有情况2. 如果遇到包含重复元素的情况，就回溯（即不再递归下去）3. 收集所有达到递归终点的情况，并返回</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> permute = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-comment">// 时间复杂度：O(!n) ; !n = 1 x 2 x 3 x ... x (n-1) x n</span>    <span class="hljs-comment">// 空间复杂度：O(n)</span>    <span class="hljs-keyword">const</span> res = [];    <span class="hljs-keyword">const</span> backtrck = <span class="hljs-function"><span class="hljs-params">path</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (path.length === nums.length) &#123;            res.push(path);            <span class="hljs-keyword">return</span>;        &#125;        nums.forEach(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> &#123;            <span class="hljs-keyword">if</span> (path.includes(n)) <span class="hljs-keyword">return</span>;            backtrck(path.concat(n));        &#125;)    &#125;    backtrck([]);    <span class="hljs-keyword">return</span> res;&#125;;</code></pre><h3 id="2、子集"><a href="#2、子集" class="headerlink" title="2、子集"></a>2、子集</h3><p><a href="https://leetcode-cn.com/problems/subsets/">leetcode-78 子集</a></p><p>给你一个整数数组 nums ，返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。</p><p>示例 1：</p><pre><code class="hljs text">输入：nums = [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</code></pre><p>示例 2：</p><pre><code class="hljs text">输入：nums = [0]输出：[[],[0]]</code></pre><p>提示:</p><ul><li>1 &lt;= nums.length &lt;= 10</li><li>-10 &lt;= nums[i] &lt;= 10</li></ul><pre><code class="hljs text">解题思路1. 用递归模拟出所有情况2. 保证接的数字都是后面的数字3. 手机所有到达递归终点的情况，并返回</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> subsets = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-comment">// 时间复杂度：O(2^n) 因为每个元素都有两种可能（存在或不存在）</span>    <span class="hljs-comment">// 空间复杂度：O(n)</span>    <span class="hljs-keyword">const</span> res = [];    <span class="hljs-keyword">const</span> backtrack = <span class="hljs-function">(<span class="hljs-params">path, l, start</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (path.length === l) &#123;            res.push(path);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = start; i &lt; nums.length; i += <span class="hljs-number">1</span>) &#123;            backtrack(path.concat(nums[i]), l, i + <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= nums.length; i += <span class="hljs-number">1</span>) &#123;        backtrack([], i, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法设计 - 贪心算法</title>
    <link href="/2020/05/15/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <url>/2020/05/15/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><ul><li>贪心算法是<strong>算法设计</strong>中的一种常见方法</li><li>期盼通过每个阶段的<strong>局部最优</strong>选择，从而达到全局的最优</li><li>结果并<strong>一定是最优</strong></li></ul><h2 id="二、练习题"><a href="#二、练习题" class="headerlink" title="二、练习题"></a>二、练习题</h2><h3 id="1、分发饼干"><a href="#1、分发饼干" class="headerlink" title="1、分发饼干"></a>1、分发饼干</h3><p><a href="https://leetcode-cn.com/problems/assign-cookies/">leetcode-455 分发饼干</a></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>示例 1：</p><pre><code class="hljs text">输入: g = [1,2,3], s = [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。</code></pre><p>示例 2：</p><pre><code class="hljs text">输入: g = [1,2], s = [1,2,3]输出: 2解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.</code></pre><p>提示：</p><ul><li>1 &lt;= g.length &lt;= 3 * 104</li><li>0 &lt;= s.length &lt;= 3 * 104</li><li>1 &lt;= g[i], s[j] &lt;= 231 - 1</li></ul><pre><code class="hljs text">解题思路：1. 局部最优：既能满足孩子，还消耗最少2. 先将“较小的饼干” 分给 “胃口最小” 的孩子  - 对饼干数量和胃口数组升序排列  - 遍历饼干数组，找到能满足第一个孩子的饼干  - 然后继续遍历饼干，找到能满足 第二、三...、n 个孩子的饼干</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">g</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">s</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> findContentChildren = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">g, s</span>) </span>&#123;    <span class="hljs-comment">// 综合来说，时间复杂度是 O(n logn)</span>    <span class="hljs-comment">// 空间复杂度是 O(1)</span>    <span class="hljs-comment">// 排序的时间复杂度是 O(n logn)</span>    g.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);    s.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;    <span class="hljs-comment">// forEach的时间复杂度是 O(n)</span>    s.forEach(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (n &gt;= g[i]) &#123;            i += <span class="hljs-number">1</span>;        &#125;    &#125;)    <span class="hljs-keyword">return</span> i;&#125;;</code></pre><h3 id="2、买卖股票的最佳时机-II"><a href="#2、买卖股票的最佳时机-II" class="headerlink" title="2、买卖股票的最佳时机 II"></a>2、买卖股票的最佳时机 II</h3><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">leetcode-122  买卖股票的最佳时机 II</a></p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1：</p><pre><code class="hljs text">输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</code></pre><p>示例 2：</p><pre><code class="hljs text">输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</code></pre><p>示例 3：</p><pre><code class="hljs text">输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre><p>提示:</p><ul><li>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</li><li>0 &lt;= prices[i] &lt;= 10 ^ 4</li></ul><pre><code class="hljs text">解题思路1. 前提： 上帝视角，知道未来的价格2. 局部最优：见好就收，见差就不动，不作任何长远打算    - 新建一个变量，用来统计总陆润    - 编辑价格数组，如果当天价格比昨天高，就在昨天买，今天卖。否则就不做交易    - 遍历结束后，返回所有利润之和</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">prices</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;    <span class="hljs-comment">// 解法一: 统计找到最大利润</span>    <span class="hljs-comment">// var min = prices[0];</span>    <span class="hljs-comment">// var resArr = [];</span>    <span class="hljs-comment">// var tem = 0;</span>    <span class="hljs-comment">// for (let i = 1 ; i &lt; prices.length ; i++) &#123;</span>    <span class="hljs-comment">//     if (prices[i] &gt; prices[i - 1]) &#123;</span>    <span class="hljs-comment">//         tem = prices[i] - min</span>    <span class="hljs-comment">//         if (i === prices.length - 1) &#123;</span>    <span class="hljs-comment">//             resArr.push(tem)</span>    <span class="hljs-comment">//         &#125;</span>    <span class="hljs-comment">//     &#125; else &#123;</span>    <span class="hljs-comment">//         resArr.push(tem)</span>    <span class="hljs-comment">//         min = prices[i];</span>    <span class="hljs-comment">//         tem = 0</span>    <span class="hljs-comment">//     &#125;</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-comment">// return resArr.reduce((x, y) =&gt; &#123;</span>    <span class="hljs-comment">//     return x + y</span>    <span class="hljs-comment">// &#125;, 0)</span>    <span class="hljs-comment">// 解法二：贪心算法，只要有利润就赚</span>    <span class="hljs-comment">// 时间复杂度：O(n) 空间复杂度：O(1)</span>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;        <span class="hljs-keyword">if</span>(prices[i] &gt; prices[i - <span class="hljs-number">1</span>]) &#123;            res += prices[i] - prices[i - <span class="hljs-number">1</span>];        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法设计 - 动态规划</title>
    <link href="/2020/05/05/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2020/05/05/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><ul><li>动态规划是<strong>算法设计</strong>中的一种常见方法</li><li>动态规划是将一个问题分解为<strong>相互重叠</strong>的子问题，通过反复求解子问题，来解决原来的问题。</li></ul><p><strong>动态规划</strong> 与 <strong>分而治之</strong> 的区别：</p><ul><li>动态规划: 它们的子问题是<strong>相互重叠</strong>的</li><li>分而治之: 它们的子问题是<strong>完全独立</strong>的</li></ul><img src="https://i.loli.net/2021/01/09/HW6oDIpLO7vT8JA.png" ><h2 id="二、练习题"><a href="#二、练习题" class="headerlink" title="二、练习题"></a>二、练习题</h2><h3 id="1、爬楼梯"><a href="#1、爬楼梯" class="headerlink" title="1、爬楼梯"></a>1、爬楼梯</h3><p><a href="https://leetcode-cn.com/problems/climbing-stairs/">leetcode-70 爬楼梯</a></p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><pre><code class="hljs text">输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1.  1 阶 + 1 阶2.  2 阶</code></pre><p>示例 2：</p><pre><code class="hljs text">输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1.  1 阶 + 1 阶 + 1 阶2.  1 阶 + 2 阶3.  2 阶 + 1 阶</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> climbStairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;<span class="hljs-comment">// 动态规划一： 时间复杂度 O(n) 空间复杂度：O(n)</span><span class="hljs-comment">// if (n &lt; 2) &#123;</span><span class="hljs-comment">//     return 1;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// const dp = [1, 1];</span><span class="hljs-comment">// for(let i = 2; i &lt;= n; i++) &#123;</span><span class="hljs-comment">// // 斐波那契数列 f(n) = f(n-1) + f(n-2)</span><span class="hljs-comment">//     dp[i] = dp[i - 1] + dp[i - 2];</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// return dp[n];</span><span class="hljs-comment">// 动态规划二： 时间复杂度 O(n) 空间复杂度 O(1)</span><span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">let</span> dp1 = <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录 n-2 的值</span><span class="hljs-keyword">let</span> dp2 = <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录 n-1 的值</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<span class="hljs-comment">// 将 n-1 的值赋值给 n-2</span><span class="hljs-comment">// 将 n-1 和 n-2 的和, 赋值给 n-1</span><span class="hljs-comment">// 即 完成了 f(n) = f(n-1) + f(n-2)</span><span class="hljs-keyword">const</span> tem = dp1;dp1 = dp2;dp2 = tem + dp1;&#125;<span class="hljs-keyword">return</span> dp2;&#125;;</code></pre><h3 id="2、打家劫舍"><a href="#2、打家劫舍" class="headerlink" title="2、打家劫舍"></a>2、打家劫舍</h3><p><a href="https://leetcode-cn.com/problems/house-robber/">leetcode-198打家劫舍</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例 1：</p><pre><code class="hljs text">输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。     偷窃到的最高金额 = 1 + 3 = 4 。</code></pre><p>示例 2：</p><pre><code class="hljs text">输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> rob = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-comment">// 动态规划算法</span>    <span class="hljs-comment">// 解题步骤：</span>    <span class="hljs-comment">// 1. 用 fn1(k) 代表 前k个房屋中能偷窃到的最大金额</span>    <span class="hljs-comment">// 2. 用 fn2(k) 代表 第k个房屋中的金额</span>    <span class="hljs-comment">// 3. fn1(k) = Math.max(fn1(k-2) + fn2(k), fn1(k-1))</span>    <span class="hljs-comment">// 动态规划解法一：</span>    <span class="hljs-comment">// 时间复杂度: O(n)</span>    <span class="hljs-comment">// 空间复杂度: O(n)</span>    <span class="hljs-comment">// if (nums.length === 0) &#123;</span>    <span class="hljs-comment">//     return 0;</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-comment">// if (nums.length === 1) &#123;</span>    <span class="hljs-comment">//     return nums[0];</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-comment">// const dp = [0, nums[0]]; // dp[0]代表第0个房屋的金额, dp[1]代表第1个房屋的金额</span>    <span class="hljs-comment">// for(let i = 2; i &lt;= nums.length; i++) &#123;</span>    <span class="hljs-comment">//     dp[i] = Math.max(dp[i - 2] + nums[i - 1], dp[i - 1]);</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-comment">// return dp[dp.length - 1];</span>    <span class="hljs-comment">// 动态规划解法二：</span>    <span class="hljs-comment">// 时间复杂度: O(n)</span>    <span class="hljs-comment">// 空间复杂度: O(1) </span>    <span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];    &#125;    <span class="hljs-keyword">let</span> dp0 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> dp1 = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= nums.length; i++) &#123;        <span class="hljs-keyword">const</span> tem = <span class="hljs-built_in">Math</span>.max(dp0 + nums[i - <span class="hljs-number">1</span>], dp1);        dp0 = dp1;        dp1 = tem;    &#125;    <span class="hljs-keyword">return</span> dp1;&#125;;</code></pre><h3 id="3、连续子数组的最大和"><a href="#3、连续子数组的最大和" class="headerlink" title="3、连续子数组的最大和"></a>3、连续子数组的最大和</h3><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">leetcode-53最大子序和</a></p><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例 1：</p><pre><code class="hljs text">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</code></pre><p>示例 2：</p><pre><code class="hljs text">输入：nums = [1]输出：1</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> maxSubArray = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> ans = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) &#123;        <span class="hljs-comment">// if(sum &gt; 0) &#123; 可以写成这样</span>        <span class="hljs-keyword">if</span>(sum + num &gt; num )&#123;            sum = sum + num;        &#125; <span class="hljs-keyword">else</span> &#123;            sum = num;        &#125;        ans = <span class="hljs-built_in">Math</span>.max(ans, sum);    &#125;;    <span class="hljs-keyword">return</span> ans;&#125;;</code></pre><h3 id="4、最长回文子串"><a href="#4、最长回文子串" class="headerlink" title="4、最长回文子串"></a>4、最长回文子串</h3><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">leetcode-5最长回文子串</a></p><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p>示例 1：</p><pre><code class="hljs text">输入：s = &quot;babad&quot;输出：&quot;bab&quot;解释：&quot;aba&quot; 同样是符合题意的答案。</code></pre><p>示例 2：</p><pre><code class="hljs text">输入：s = &quot;cbbd&quot;输出：&quot;bb&quot;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<span class="hljs-keyword">let</span> len = s.length;<span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-comment">// 创建二维数组</span><span class="hljs-keyword">let</span> dp = <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len),<span class="hljs-function">()=&gt;</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len).fill(<span class="hljs-number">0</span>)));<span class="hljs-comment">// 从字符串首部开始</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<span class="hljs-comment">// 从字符串i前开始依次向前查找</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i; j &gt;= <span class="hljs-number">0</span>; j--) &#123;dp[j][i] = s[i] == s[j] &amp;&amp; (i - j &lt; <span class="hljs-number">2</span> || dp[j + <span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>]);<span class="hljs-keyword">if</span>(dp[j][i] &amp;&amp; i - j + <span class="hljs-number">1</span> &gt; res.length) &#123;res = s.substring(j, i + <span class="hljs-number">1</span>);&#125;&#125;&#125;<span class="hljs-comment">// console.log(dp)</span><span class="hljs-keyword">return</span> res&#125;;</code></pre><h3 id="5、编辑距离"><a href="#5、编辑距离" class="headerlink" title="5、编辑距离"></a>5、编辑距离</h3><p><a href="https://leetcode-cn.com/problems/edit-distance/">leetcode-72编辑距离</a></p><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符</p><p>示例 1：</p><pre><code class="hljs text">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)rorse -&gt; rose (删除 &#x27;r&#x27;)rose -&gt; ros (删除 &#x27;e&#x27;)</code></pre><p>示例 2：</p><pre><code class="hljs text">输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 &#x27;t&#x27;)inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)exection -&gt; execution (插入 &#x27;u&#x27;)</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">word1</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">word2</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> minDistance = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">word1, word2</span>) </span>&#123;    <span class="hljs-keyword">let</span> m = word1.length + <span class="hljs-number">1</span>;    <span class="hljs-keyword">let</span> n = word2.length + <span class="hljs-number">1</span>;    <span class="hljs-keyword">let</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; m; k++) &#123;        dp[k] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++ ) &#123;        dp[i][<span class="hljs-number">0</span>] =  i;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++ ) &#123;        dp[<span class="hljs-number">0</span>][j] =  j;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; m; i++ ) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; n; j++ ) &#123;            <span class="hljs-keyword">if</span>(word1[i-<span class="hljs-number">1</span>] == word2[j-<span class="hljs-number">1</span>]) &#123;                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]            &#125;            <span class="hljs-keyword">else</span> &#123;                dp[i][j] = <span class="hljs-number">1</span> + <span class="hljs-built_in">Math</span>.min(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>])            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>]&#125;;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法设计 - 分而治之</title>
    <link href="/2020/05/02/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B/"/>
    <url>/2020/05/02/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><ul><li>分而治之是<strong>算法设计</strong>中的一种常见方法</li><li>分而治之是将一个问题<strong>分</strong>成多个和原问题相似的小问题，通过<strong>递归</strong>解决这些小问题，再将小问题的结果<strong>合并</strong>以解决原来的问题。</li></ul><h3 id="场景一：-归并排序"><a href="#场景一：-归并排序" class="headerlink" title="场景一： 归并排序"></a>场景一： 归并排序</h3><ul><li>分：先把数组从中间一分为二</li><li>解：递归的对两个子数组进行归并排序</li><li>合：合并有序子数组</li></ul><h3 id="场景二：-快速排序"><a href="#场景二：-快速排序" class="headerlink" title="场景二： 快速排序"></a>场景二： 快速排序</h3><ul><li>分：选基准，按基准把数组分成两个子数组</li><li>解：递归的对两个子数组进行快速排序</li><li>合：对两个子数组进行合并</li></ul><h2 id="二、练习题"><a href="#二、练习题" class="headerlink" title="二、练习题"></a>二、练习题</h2><h3 id="1、猜数字大小"><a href="#1、猜数字大小" class="headerlink" title="1、猜数字大小"></a>1、猜数字大小</h3><p><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/">leetcode-374 猜数字大小</a></p><p>猜数字游戏的规则如下：</p><p>每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。<br>如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。<br>你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：</p><p>-1：我选出的数字比你猜的数字小 pick &lt; num<br>1：我选出的数字比你猜的数字大 pick &gt; num<br>0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num</p><p>示例 1：</p><pre><code class="hljs text">输入：n = 10, pick = 6输出：6</code></pre><p>示例 2：</p><pre><code class="hljs text">输入：n = 1, pick = 1输出：1</code></pre><p>示例 3：</p><pre><code class="hljs text">输入：n = 2, pick = 1输出：1</code></pre><p>示例 4：</p><pre><code class="hljs text">输入：n = 2, pick = 2输出：2</code></pre><p>提示：</p><ul><li>1 &lt;= n &lt;= 231 - 1</li><li>1 &lt;= pick &lt;= n</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">/** </span><span class="hljs-comment"> * Forward declaration of guess API.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>num   your guess</span><span class="hljs-comment"> * <span class="hljs-doctag">@return             </span>-1 if num is lower than the guess number</span><span class="hljs-comment"> *             1 if num is higher than the guess number</span><span class="hljs-comment"> *                       otherwise return 0</span><span class="hljs-comment"> * var guess = function(num) &#123;&#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> guessNumber = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;<span class="hljs-comment">// // 解法一：二分搜索 时间复杂度 O(logN) 空间复杂度 O(1)</span><span class="hljs-comment">// let low = 1;</span><span class="hljs-comment">// let high = n;</span><span class="hljs-comment">// while(high &gt;= low) &#123;</span><span class="hljs-comment">// // const mid = Math.floor((low + high) / 2);</span><span class="hljs-comment">// const mid = (low + high) &gt;&gt;&gt; 1; // 除以二并取整</span><span class="hljs-comment">// const res = guess(mid);</span><span class="hljs-comment">// if (res === -1) &#123;</span><span class="hljs-comment">// // 结果比mid 小，下次需要搜索 0 - mid 范围</span><span class="hljs-comment">// high = mid - 1;</span><span class="hljs-comment">// &#125; else if (res === 1) &#123;</span><span class="hljs-comment">// // 结果比mid 大，下次需要搜索 mid - n 范围</span><span class="hljs-comment">// low = mid + 1;</span><span class="hljs-comment">// &#125; else if (res === 0) &#123;</span><span class="hljs-comment">// return mid;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// // 解法二: 分而治之 时间复杂度 O(logN) 空间复杂度 O(logN)</span><span class="hljs-keyword">const</span> rec = <span class="hljs-function">(<span class="hljs-params">low, high</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (low &gt; high) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">const</span> mid = (low + high) &gt;&gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 除二取整</span><span class="hljs-keyword">const</span> res = guess(mid);<span class="hljs-keyword">if</span> (res === <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 猜对了</span><span class="hljs-keyword">return</span> mid;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res === <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 结果比mid大</span><span class="hljs-keyword">return</span> rec(mid + <span class="hljs-number">1</span>, high);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res === -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 结果比mid小</span><span class="hljs-keyword">return</span> rec(low, mid - <span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-keyword">return</span> rec(<span class="hljs-number">1</span>, n);&#125;;</code></pre><h3 id="2、翻转二叉树"><a href="#2、翻转二叉树" class="headerlink" title="2、翻转二叉树"></a>2、翻转二叉树</h3><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/">leetcode-226翻转二叉树</a></p><p>翻转一棵二叉树。</p><p>示例：</p><pre><code class="hljs text">输入：     4   /   \  2     7 / \   / \1   3 6   9输出：     4   /   \  7     2 / \   / \9   6 3   1</code></pre><p>备注:<br>这个问题是受到 Max Howell 的 原问题 启发的 ：<br>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * function TreeNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.left = this.right = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> invertTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-comment">// 时间复杂度: O(N)</span>    <span class="hljs-comment">// 空间复杂度: O(h)  h是树的高度 </span>    <span class="hljs-keyword">if</span>(!root) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">return</span> &#123;        val: root.val,        left: invertTree(root.right),        right: invertTree(root.left),    &#125;&#125;;</code></pre><h3 id="3、相同的树"><a href="#3、相同的树" class="headerlink" title="3、相同的树"></a>3、相同的树</h3><p><a href="https://leetcode-cn.com/problems/same-tree/">leetcode-100相同的树</a></p><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>示例 1:</p><pre><code class="hljs text">输入:       1         1          / \       / \         2   3     2   3        [1,2,3],   [1,2,3]输出: true</code></pre><p>示例 2:</p><pre><code class="hljs text">输入:      1          1          /           \         2             2        [1,2],     [1,null,2]输出: false</code></pre><p>示例 3:</p><pre><code class="hljs text">输入:       1         1          / \       / \         2   1     1   2        [1,2,1],   [1,1,2]输出: false</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">p</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">q</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-comment">// 时间复杂度: O(n)</span><span class="hljs-comment">// 空间复杂度: O(n) // 当二叉树是均匀分配时,是 O(logN)</span><span class="hljs-keyword">var</span> isSameTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">p, q</span>) </span>&#123;    <span class="hljs-keyword">if</span>(!p &amp;&amp; !q) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">if</span>(p &amp;&amp; q &amp;&amp; p.val === q.val &amp;&amp;        isSameTree(p.left, q.left) &amp;&amp;        isSameTree(p.right, q.right    )) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;</code></pre><h3 id="4、对称二叉树"><a href="#4、对称二叉树" class="headerlink" title="4、对称二叉树"></a>4、对称二叉树</h3><p><a href="https://leetcode-cn.com/problems/symmetric-tree/">leetcode-101对称二叉树</a></p><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><pre><code class="hljs text">    1   / \  2   2 / \ / \3  4 4  3</code></pre><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><pre><code class="hljs text">  1 / \2   2 \   \ 3    3</code></pre><p>进阶：</p><p>你可以运用递归和迭代两种方法解决这个问题吗？</p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * function TreeNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.left = this.right = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> isSymmetric = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-comment">// 解法一: 递归 时间复杂度 O(n) 空间复杂度 O(n) 【当二叉树均匀分配时,空间复杂度最小是 O(logN)】</span><span class="hljs-keyword">if</span> (!root) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">const</span> isMirror = <span class="hljs-function">(<span class="hljs-params">l ,r</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!l &amp;&amp; !r) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">if</span> (l &amp;&amp; r &amp;&amp; l.val === r.val &amp;&amp;isMirror(l.left, r.right) &amp;&amp;isMirror(l.right, r.left)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">return</span> isMirror(root.left, root.right);&#125;;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-链表</title>
    <link href="/2020/03/12/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/03/12/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一、什么是链表"><a href="#一、什么是链表" class="headerlink" title="一、什么是链表"></a>一、什么是链表</h2><p>[维基百科] 链表（<code>Linked list</code>）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(<code>Pointer</code>)。</p><h2 id="二、链表分类"><a href="#二、链表分类" class="headerlink" title="二、链表分类"></a>二、链表分类</h2><p><img src="http://ql0a05ojc.hn-bkt.clouddn.com/LinkedList.jpg" alt="LinkedList"></p><p>链表常用的有 3 类： 单链表、双向链表、循环链表。</p><p><img src="https://i.loli.net/2020/12/01/sDPwyYFuN5UxnqQ.png" alt="单向链表"></p><p><img src="https://i.loli.net/2020/12/01/ndJAIes6K4ClMb8.png" alt="双向链表"><br>一般来说，说到链表，就要提下数组，一般链表都是和数组进行对比。</p><p><img src="https://i.loli.net/2020/12/01/gAR4wEzpj5evO3P.png" alt="循环链表"></p><h2 id="三、链表设计"><a href="#三、链表设计" class="headerlink" title="三、链表设计"></a>三、链表设计</h2><p>说到链表，就要提下数组，一般链表都是和数组进行对比。</p><p>在很多编程语言中，数组的长度时固定的，所以数组中的增加和删除比较麻烦，需要频繁的移动数组中的其他元素。<br>然而，<code>JavaScript</code>中的数组并不存在上述问题，JS中的数组相对其他语言使用上更方便，因为JS中的数组本质是一个类似数组的对象，这就使得JS的数组虽然使用更方便，但比其他语言<code>(C++、Java、C#)</code>的数组效率要低。</p><p>所以，在实际应用中如果发现数组很慢，就可以考虑使用链表来替代它。除了对数据的随机访问，链表几乎可以用在任何可以使用一维数组的情况中。如果需要随机访问，数组仍然是更好的选择。</p><ul><li>定义</li></ul><pre><code class="hljs JavaScript"><span class="hljs-comment">// 定义</span><span class="hljs-keyword">var</span> a = &#123; <span class="hljs-attr">val</span>: <span class="hljs-string">&#x27;a&#x27;</span> &#125;;<span class="hljs-keyword">var</span> b = &#123; <span class="hljs-attr">val</span>: <span class="hljs-string">&#x27;b&#x27;</span> &#125;;<span class="hljs-keyword">var</span> c = &#123; <span class="hljs-attr">val</span>: <span class="hljs-string">&#x27;c&#x27;</span> &#125;;<span class="hljs-keyword">var</span> d = &#123; <span class="hljs-attr">val</span>: <span class="hljs-string">&#x27;d&#x27;</span> &#125;;a.next = b;b.next = c;c.next = d;<span class="hljs-comment">// 遍历</span><span class="hljs-keyword">var</span> point = a;<span class="hljs-keyword">while</span> (point) &#123;    <span class="hljs-built_in">console</span>.log(point.val);    point = point.next;&#125;</code></pre><p><img src="https://i.loli.net/2020/12/01/EcLYkBzx19uyDVw.png" alt=" "></p><ul><li>插入</li></ul><pre><code class="hljs JavaScript"><span class="hljs-comment">// 插入</span><span class="hljs-keyword">var</span> e = &#123; <span class="hljs-attr">val</span>: e &#125;;c.next = e;e.next = d;</code></pre><p><img src="https://i.loli.net/2020/12/01/aBZK4SrMgF97XNH.png" alt=" "></p><pre><code class="hljs J">&#x2F;&#x2F; 删除c.next &#x3D; d;</code></pre><p><img src="https://i.loli.net/2020/12/01/9jLAQfl45pCBJOR.png" alt=" "></p><ul><li><strong>数据结构</strong></li></ul><pre><code class="hljs JavaScript"><span class="hljs-comment">// Definition for singly-linked list. 定义单链表</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ListNode</span>(<span class="hljs-params">val</span>) </span>&#123;    <span class="hljs-built_in">this</span>.val = val;    <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;&#125;</code></pre><h2 id="四、链表练习"><a href="#四、链表练习" class="headerlink" title="四、链表练习"></a>四、链表练习</h2><h3 id="1、删除链表中的指定节点"><a href="#1、删除链表中的指定节点" class="headerlink" title="1、删除链表中的指定节点"></a>1、删除链表中的指定节点</h3><blockquote><p>(<a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">力扣 237</a>)</p></blockquote><p>题目描述：请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 <strong>要被删除的节点</strong> 。</p><p>示例 1：</p><pre><code class="hljs text">输入： 4-&gt;5-&gt;1-&gt;9, val = 5输出： 4-&gt;1-&gt;9</code></pre><p>示例 2：</p><pre><code class="hljs text">输入： 4-&gt;5-&gt;1-&gt;9, val = 1输出： 4-&gt;5-&gt;9</code></pre><p>提示：</p><ul><li>链表至少包含两个节点</li><li>链表中所有节点的值都是唯一的</li><li>给定的节点为非末尾节点，并且一定是链表中的一个有效节点</li><li>不要从你的函数中返回任何结果</li></ul><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * function ListNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.next = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">node</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span> </span>Do not return anything, modify node in-place instead.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> deleteNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>&#123;&#125;;</code></pre><p><img src="https://i.loli.net/2020/12/04/WKFPZbhrQdOTXJN.png" alt="题1.jpg"></p><ul><li>题解:</li></ul><pre><code class="hljs text">解题思路：1、无法直接获取被删除节点的上个节点；2、将被删除节点转移到下个节点。</code></pre><p>code view:</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> deleteNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>&#123;    node.val = node.next.val;    node.next = node.next.next;&#125;;</code></pre><h3 id="2、删除链表中的重复元素"><a href="#2、删除链表中的重复元素" class="headerlink" title="2、删除链表中的重复元素"></a>2、删除链表中的重复元素</h3><blockquote><p>(<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">力扣 83</a>)</p></blockquote><p>题目描述：给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>示例 1：</p><pre><code class="hljs text">输入： 1-&gt;1-&gt;2输出： 1-&gt;2</code></pre><p>示例 2：</p><pre><code class="hljs text">输入： 1-&gt;1-&gt;2-&gt;3-&gt;3输出： 1-&gt;2-&gt;3</code></pre><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * function ListNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.next = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> reverseList = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;&#125;;</code></pre><ul><li>题解:</li></ul><pre><code class="hljs text">解题思路：1、因为链表是有序的，所以重复元素一定相邻；2、遍历链表，如果发现当前元素和下个元素的值相等，就删除下个元素。</code></pre><p>code view:</p><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> deleteDuplicates = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;    <span class="hljs-keyword">let</span> p = head;    <span class="hljs-keyword">while</span> (p &amp;&amp; p.next) &#123;        <span class="hljs-keyword">if</span> (p.val === p.next.val) &#123;            p.next = p.next.next        &#125; <span class="hljs-keyword">else</span> &#123;            p = p.next; <span class="hljs-comment">// 只有不相等时指针才指向下一个元素，防止出现多个</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> head;&#125;;</code></pre><h3 id="3、反转链表"><a href="#3、反转链表" class="headerlink" title="3、反转链表"></a>3、反转链表</h3><blockquote><p>(<a href="https://leetcode-cn.com/problems/reverse-linked-list/">力扣 206</a>)</p></blockquote><p>题目描述：反转一个单链表。</p><p>示例 1：</p><pre><code class="hljs text">输入： 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出： 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * function ListNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.next = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> reverseList = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;&#125;;</code></pre><p><img src="https://i.loli.net/2020/12/04/vJtIb2U6PxTkFZR.png" alt="题3.jpg"></p><ul><li>题解:</li></ul><pre><code class="hljs text">解题思路：1、反转两个节点：将n+1的next指向n；   输入: n -&gt; n+1   输出: n+1 -&gt; n2、反转多个节点：双指针遍历链表，重复上述操作。   输入： 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL   输出： 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><p>code view:</p><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> reverseList = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;    <span class="hljs-keyword">let</span> p1 = head;    <span class="hljs-keyword">let</span> p2 = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">while</span>(p1) &#123;        <span class="hljs-keyword">const</span> tmp = p1.next;        p1.next = p2;        p2 = p1;        p1 = tmp;    &#125;    <span class="hljs-keyword">return</span> p2;&#125;;reverseList(node);<span class="hljs-built_in">console</span>.log(reverseList);</code></pre><p><img src="https://i.loli.net/2020/12/04/JorOq5nG4VEQKmy.png" alt="题3.jpg"></p><h3 id="4、判断环形链表"><a href="#4、判断环形链表" class="headerlink" title="4、判断环形链表"></a>4、判断环形链表</h3><blockquote><p>(<a href="https://leetcode-cn.com/problems/linked-list-cycle/">力扣 141</a>)</p></blockquote><p>题目描述：给定一个链表，判断链表中是否有环。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。<strong>注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况</strong>。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p>示例 1：</p><pre><code class="hljs text">输入： head = [3, 2, 0, -4], pos = 1输出： true解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p><img src="https://i.loli.net/2020/12/01/rZmGveAKEuXY7qx.png" alt=" "></p><p>示例 2：</p><pre><code class="hljs text">输入： head = [1, 2], pos = 0输出： true解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p><img src="https://i.loli.net/2020/12/01/2aTXMxQotje7yhB.png" alt=" "></p><p>示例 3：</p><pre><code class="hljs text">输入： head = [1], pos = -1输出： false解释：链表中没有环。</code></pre><p><img src="https://i.loli.net/2020/12/01/rLfT2v41CVpaUud.png" alt=" "></p><ul><li><strong>提示：</strong><ul><li>链表中节点的数目范围是 [0, 10^4]</li><li>-10^5 &lt;= Node.val &lt;= 10^5</li><li>pos 为 -1 或者链表中的一个 有效索引</li></ul></li></ul><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * function ListNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.next = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> hasCycle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;  &#125;;</code></pre><ul><li>题解:</li></ul><pre><code class="hljs text">解题思路：1、两个人在圆形操场上的同一个起点起跑，速度快的人和速度慢的人一定会再次相遇（最少超过一圈）；2、用一快一慢两个指针遍历链表，如果指针能够相逢，那么链表就有圈。    即: 用一快一慢两个指针遍历链表，如果指针能够相逢，就返回true；        遍历结束后，还没有相逢就返回false。</code></pre><p>code view:</p><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> hasCycle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;    <span class="hljs-keyword">var</span> p1 = head;    <span class="hljs-keyword">var</span> p2 = head;    <span class="hljs-keyword">while</span>(p1 &amp;&amp; p2 &amp;&amp; p2.next) &#123;        p1 = p1.next;        p2 = p2.next.next;        <span class="hljs-keyword">if</span> (p1 === p2) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;</code></pre><h3 id="5、链表的中间结点"><a href="#5、链表的中间结点" class="headerlink" title="5、链表的中间结点"></a>5、链表的中间结点</h3><blockquote><p>(<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">力扣 876</a>)</p></blockquote><p>题目描述：给定一个头结点为 head 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p>示例 1：</p><pre><code class="hljs text">输入：[1,2,3,4,5]输出：此列表中的结点 3 (序列化形式：[3,4,5])返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。注意，我们返回了一个 ListNode 类型的对象 ans，这样：ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</code></pre><p>示例 2：</p><pre><code class="hljs text">输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6])由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</code></pre><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * function ListNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.next = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> middleNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;&#125;;</code></pre><ul><li>题解:</li></ul><pre><code class="hljs text">解题思路：1、快指针p每次移2节点，慢指针head移1节点2、快指针先到尾，此时慢指针的位置刚好在中间</code></pre><p>code view:</p><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">l1</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">l2</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> middleNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;    <span class="hljs-keyword">var</span> p = head;    <span class="hljs-keyword">while</span>(p &amp;&amp; p.next) &#123;        head = head.next;        p = p.next.next;    &#125;    <span class="hljs-keyword">return</span> head;&#125;;</code></pre><h3 id="6、链表相加"><a href="#6、链表相加" class="headerlink" title="6、链表相加"></a>6、链表相加</h3><blockquote><p>(<a href="https://leetcode-cn.com/problems/add-two-numbers/">力扣 2</a>)</p></blockquote><p>题目描述：给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例 1：</p><pre><code class="hljs text">输入：(1 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：6 -&gt; 0 -&gt; 8原因：341 + 465 = 806</code></pre><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list 2.</span><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">l1</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">l2</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;&#125;;</code></pre><ul><li>题解:</li></ul><pre><code class="hljs text">解题思路：1、新建一个空链表2、遍历被相加的两个链表，模拟相加的操作，将相加后结果的个位数追加到新链表上，将十位数留到下一位去相加</code></pre><p>code view:</p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">l1</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">l2</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;    <span class="hljs-keyword">const</span> l3 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);    <span class="hljs-keyword">let</span> p1 = l1;    <span class="hljs-keyword">let</span> p2 = l2;    <span class="hljs-keyword">let</span> p3 = l3;    <span class="hljs-keyword">let</span> carry = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(p1 || p2) &#123;        <span class="hljs-keyword">const</span> v1 = p1 ? p1.val : <span class="hljs-number">0</span>;        <span class="hljs-keyword">const</span> v2 = p2 ? p2.val : <span class="hljs-number">0</span>;        <span class="hljs-keyword">const</span> val = v1 + v2 + carry;        carry = <span class="hljs-built_in">Math</span>.floor(val / <span class="hljs-number">10</span>);        p3.next = <span class="hljs-keyword">new</span> ListNode(val % <span class="hljs-number">10</span>);        <span class="hljs-keyword">if</span> (p1) p1 = p1.next;        <span class="hljs-keyword">if</span> (p2) p2 = p2.next;        p3 = p3.next;    &#125;    <span class="hljs-keyword">if</span> (carry) &#123;        p3.next = <span class="hljs-keyword">new</span> ListNode(carry);    &#125;    <span class="hljs-keyword">return</span> l3.next;&#125;;</code></pre><h2 id="五、JS中的原型链"><a href="#五、JS中的原型链" class="headerlink" title="五、JS中的原型链"></a>五、JS中的原型链</h2><ul><li>原型链的本质是链表</li><li>原型链上的节点是各种原型对象，比如<code>Function.prototype 、Object.prototype、Array.prototype</code> …</li><li>原型链通过 <code>__proto__</code> 属性连接各种原型对象</li></ul><p><img src="https://i.loli.net/2020/12/01/h1prO86qAekmYsf.png" alt=" "></p><h2 id="六、React-Hooks-的链表结构"><a href="#六、React-Hooks-的链表结构" class="headerlink" title="六、React Hooks 的链表结构"></a>六、React Hooks 的链表结构</h2><blockquote><p>在这里只探讨一下React中userState的数据结构，以及简单的render流程<br>对于useContext、useMemo、useRef、useEffect、useLayoutEffect…的原理 都<strong>不探讨</strong>，因为我也不太懂</p></blockquote><p><a href="https://github.com/facebook/react/blob/c05b4b81f91c0b43a02e101d6a37b3de768f017b/packages/react-dom/src/server/ReactPartialRendererHooks.js">react/packages/react-dom/src/server/ReactPartialRendererHooks.js源码</a></p><p>1、如果我们在一个组件内使用多个<code>useState Hooks</code>, <code>React</code> 如何知道哪个 <code>Hooks</code> 对应哪个 <code>state</code>？<br>2、为什么不要在 <code>if</code> 内使用 <code>Hooks</code>？</p><ul><li><code>React Hooks</code>的结构是一个链表型的数据结构, 每一个 Hooks 对象结构为：</li></ul><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createHook</span>(<span class="hljs-params"></span>): <span class="hljs-title">Hook</span> </span>&#123;  <span class="hljs-keyword">if</span> (numberOfReRenders &gt; <span class="hljs-number">0</span>) &#123;    invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">&#x27;Rendered more hooks than during the previous render&#x27;</span>);  &#125;  <span class="hljs-keyword">return</span> &#123;    memoizedState: <span class="hljs-literal">null</span>,    queue: <span class="hljs-literal">null</span>,    next: <span class="hljs-literal">null</span>,  &#125;;&#125;</code></pre><ul><li>有一个链表的头部链表的头部, 在 <code>React</code> 内部称为 <code>firstWorkInProgressHook</code>，保存着组件内所有的 <code>Hooks</code></li><li>还有一个链表，<code>workInProgressHook</code>，对应的是上述链表的一个节点，在组件内部就是调用<code>useState()</code> 的时候的当前的 <code>Hooks</code>。每一次我们调用<code>useState()</code>，<code>React</code> 内部会调用一个方法来生成一个 <code>workInProgressHook</code></li></ul><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createWorkInProgressHook</span>(<span class="hljs-params"></span>): <span class="hljs-title">Hook</span> </span>&#123;  <span class="hljs-keyword">if</span> (workInProgressHook === <span class="hljs-literal">null</span>) &#123;    <span class="hljs-comment">// This is the first hook in the list</span>    <span class="hljs-keyword">if</span> (firstWorkInProgressHook === <span class="hljs-literal">null</span>) &#123;      isReRender = <span class="hljs-literal">false</span>;      firstWorkInProgressHook = workInProgressHook = createHook();    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// There&#x27;s already a work-in-progress. Reuse it.</span>      isReRender = <span class="hljs-literal">true</span>;      workInProgressHook = firstWorkInProgressHook;    &#125;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">if</span> (workInProgressHook.next === <span class="hljs-literal">null</span>) &#123;      isReRender = <span class="hljs-literal">false</span>;      <span class="hljs-comment">// Append to the end of the list</span>      workInProgressHook = workInProgressHook.next = createHook();    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// There&#x27;s already a work-in-progress. Reuse it.</span>      isReRender = <span class="hljs-literal">true</span>;      workInProgressHook = workInProgressHook.next;    &#125;  &#125;  <span class="hljs-keyword">return</span> workInProgressHook;&#125;</code></pre><p>我们以组件的两次 render 来介绍该链表是如何初始化以及如何应对更新的：</p><ul><li>初始条件下（组件还未渲染），<code>firstWorkInProgressHook</code> 和 <code>workInProgressHook</code> 都是 <code>null</code> 0️⃣</li><li>初次渲染：<ul><li>第一个 <code>Hooks</code>: <code>firstWorkInProgressHook = workInProgressHook = createHook()</code> 1️⃣</li><li>第二个 <code>Hooks</code>: <code>workInProgressHook = workInProgressHook.next = createHook()</code> 2️⃣</li><li>…</li><li>第 n 个 <code>Hooks</code>: <code>workInProgressHook = workInProgressHook.next = createHook()</code> 3️⃣</li><li>渲染结束，<code>React</code> 调用 <code>finishHooks</code>，重置 <code>workInProgressHook</code>为 <code>null</code> 4️⃣</li></ul></li></ul><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-number">0</span>️：<span class="hljs-regexp">//</span> firstWorkInProgressHook = workInProgressHook = nullfirstWorkInProgressHook                        ↘                          null                        ↗     workInProgressHook<span class="hljs-regexp">//</span> <span class="hljs-number">1</span>:<span class="hljs-regexp">//</span> workInProgressHook = workInProgressHook.<span class="hljs-keyword">next</span> = createHook()          firstWorkInProgressHook                                 ↘                          null    Hook1                                 ↗              workInProgressHook<span class="hljs-regexp">//</span> <span class="hljs-number">2</span>:<span class="hljs-regexp">//</span> workInProgressHook = workInProgressHook.<span class="hljs-keyword">next</span> = createHook()          firstWorkInProgressHook                                 ↘                           null   Hook1 ⟶️ Hook2                                           ↗                         workInProgressHook<span class="hljs-regexp">//</span> <span class="hljs-number">3</span>:<span class="hljs-regexp">//</span> workInProgressHook = workInProgressHook.<span class="hljs-keyword">next</span> = createHook()          firstWorkInProgressHook                                 ↘                           null   Hook1 ⟶️ Hook2 ...⟶️... HookN                                                          ↗                                        workInProgressHook<span class="hljs-regexp">//</span> <span class="hljs-number">4</span>:<span class="hljs-regexp">//</span> workInProgressHook = null          firstWorkInProgressHook                                 ↘                           null   Hook1 ⟶️ Hook2 ...⟶️... HookN                          ↗        workInProgressHook</code></pre><p>所以：</p><ul><li>初次渲染的时候，Hooks 链表为空，每次 useState() 的时候都会新建一个 Hooks 作为当前的 Hooks（workInProgressHook）</li><li>再次渲染的时候，按照调用顺序，依次取上次生成的 Hooks 链表各个节点（每个节点就是一个 Hooks）</li></ul><p>这也是为什么我们需要保证在每次渲染的时候各个 Hooks 以相同的顺序被调用，也是为什么不要在 if 内使用 Hooks 的原因：这会导致 Hooks 调用顺序不同。</p><blockquote><p>参考资料：<br><a href="https://bk.tw.lvfukeji.com/wiki/%E9%93%BE%E8%A1%A8">维基百科—链表</a><br><a href="https://www.lagou.com/lgeduarticle/5561.html">JS数据结构第二篇—链表</a><br><a href="https://www.jianshu.com/p/73d56c3d228c">数据结构：链表</a><br><a href="https://imliyan.com/blogs/article/React%20Hooks%20%E7%9A%84%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84/">React Hooks</a>  </p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 - 堆</title>
    <link href="/2020/02/04/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E5%A0%86/"/>
    <url>/2020/02/04/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h2 id="一、堆是什么"><a href="#一、堆是什么" class="headerlink" title="一、堆是什么"></a>一、堆是什么</h2><ul><li>堆是一种特殊的完全二叉树</li><li>所有的节点都大于等于（最大堆）或者 小于等于（最小堆）它的子节点</li></ul><p>最大堆：<br><img src="https://i.loli.net/2021/01/03/U9g6mZKP7zpkSH5.png" width="35%" height="35%"></p><p>最小堆：<br><img src="https://i.loli.net/2021/01/03/q1PZ98B3iYEXUjw.png" width="35%" height="35%"></p><p>JS 中如何表示堆：</p><ul><li>JS 中通常用数组表示堆</li><li>左侧子节点的位置: <code>2 * index + 1</code></li><li>右侧子节点的位置: <code>2 * index + 2</code></li><li>父节点的位置: <code>(index - 1) / 2</code></li></ul><img src="https://i.loli.net/2021/01/03/HUXBaTKo15dpO8M.png" width="45%" height="45%"><p>堆的应用：</p><ul><li>堆能高效、快速的找出最大值和最小值——之间复杂度是 O(1)</li><li>找出第 K 个最大（小）值<ul><li>构建一个最小堆，并将元素一次插入堆中</li><li>当堆的容量超过 K，就删除堆顶</li><li>插入结束后，堆顶就是第 K 个最大元素</li></ul></li></ul><h2 id="二、通过-JavaScript-实现堆"><a href="#二、通过-JavaScript-实现堆" class="headerlink" title="二、通过 JavaScript 实现堆"></a>二、通过 JavaScript 实现堆</h2><p>步骤：</p><ol><li>在类里，声明一个数组，用来装元素</li><li>主要方法： 插入、删除堆顶、获取堆顶、获取堆顶大小</li></ol><ul><li>插入：<ul><li>将值插入堆的底部，即数组的尾部</li><li>然后上移：将这个值和它的父节点进行交换，直到父节点小于等于这个插入的值</li><li>大小为 K 的堆中插入元素的时间复杂度为O(logK)</li></ul></li><li>删除堆顶<ul><li>用数组尾部元素替换堆顶（直接删除堆顶会破坏堆结构）</li><li>然后下移：将新堆顶和它的子节点进行交换，直到子节点大于等于这个新堆顶</li><li>大小为 K 的堆中删除堆顶的时间复杂度为O(logK)</li></ul></li><li>获取堆顶：返回数组的头部</li><li>获取堆的大小：返回数组的长度</li></ul><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinHead</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.heap = [];&#125;<span class="hljs-comment">// 插入方法</span><span class="hljs-function"><span class="hljs-title">insert</span>(<span class="hljs-params">value</span>)</span> &#123;<span class="hljs-comment">// 插入到底部</span><span class="hljs-built_in">this</span>.heap.push(value);<span class="hljs-comment">// 上移操作</span><span class="hljs-built_in">this</span>.shiftUp(<span class="hljs-built_in">this</span>.heap.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">// 删除堆顶</span><span class="hljs-function"><span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-comment">// 把原来heap中最末尾的推出来, 并赋值给堆顶</span><span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>] = <span class="hljs-built_in">this</span>.heap.pop();<span class="hljs-built_in">this</span>.shiftDown(<span class="hljs-number">0</span>); <span class="hljs-comment">// 下移操作</span>&#125;<span class="hljs-comment">// 获取堆顶</span><span class="hljs-function"><span class="hljs-title">peek</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>];&#125;<span class="hljs-comment">// 获取堆的大小</span><span class="hljs-function"><span class="hljs-title">size</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap.length;&#125;<span class="hljs-comment">// 获取父节点</span><span class="hljs-function"><span class="hljs-title">getParentIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-comment">// 二进制操作，把二进制的数字右移一位</span><span class="hljs-comment">// return Math.floor((i - 1) / 2);</span><span class="hljs-keyword">return</span> (i - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>; &#125;<span class="hljs-comment">// 获取左侧子节点</span><span class="hljs-function"><span class="hljs-title">getLeftIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 获取右侧子节点</span><span class="hljs-function"><span class="hljs-title">getRightIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;&#125;<span class="hljs-comment">// 将两个节点的位置进行交换</span><span class="hljs-function"><span class="hljs-title">swap</span>(<span class="hljs-params">i1, i2</span>)</span> &#123;<span class="hljs-keyword">const</span> temp = <span class="hljs-built_in">this</span>.heap[i1];<span class="hljs-built_in">this</span>.heap[i1] = <span class="hljs-built_in">this</span>.heap[i2];<span class="hljs-built_in">this</span>.heap[i2] = temp;&#125;<span class="hljs-comment">// 上移</span><span class="hljs-function"><span class="hljs-title">shiftUp</span>(<span class="hljs-params">index</span>)</span> &#123;<span class="hljs-comment">// 递归的终点: 到达堆顶</span><span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">const</span> parentIndex = <span class="hljs-built_in">this</span>.getParentIndex(index);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.heap[parentIndex] &gt; <span class="hljs-built_in">this</span>.heap[index]) &#123;<span class="hljs-comment">// 实现交换的方法</span><span class="hljs-built_in">this</span>.swap(parentIndex, index);<span class="hljs-comment">// 如果还是需要上移，则递归</span><span class="hljs-built_in">this</span>.shiftUp(parentIndex);&#125;&#125;<span class="hljs-comment">// 下移</span><span class="hljs-function"><span class="hljs-title">shiftDown</span>(<span class="hljs-params">index</span>)</span> &#123;<span class="hljs-keyword">const</span> leftIndex = <span class="hljs-built_in">this</span>.getLeftIndex(index);<span class="hljs-keyword">const</span> rightIndex = <span class="hljs-built_in">this</span>.getRightIndex(index);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[leftIndex] &lt; <span class="hljs-built_in">this</span>.heap[index]) &#123;<span class="hljs-built_in">this</span>.swap(leftIndex, index);<span class="hljs-built_in">this</span>.shiftDown(leftIndex);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[rightIndex] &lt; <span class="hljs-built_in">this</span>.heap[index]) &#123;<span class="hljs-built_in">this</span>.swap(rightIndex, index);<span class="hljs-built_in">this</span>.shiftDown(rightIndex);&#125;&#125;&#125;</code></pre><h2 id="三、练习题"><a href="#三、练习题" class="headerlink" title="三、练习题"></a>三、练习题</h2><h3 id="1、数组中的第K个最大元素"><a href="#1、数组中的第K个最大元素" class="headerlink" title="1、数组中的第K个最大元素"></a>1、数组中的第K个最大元素</h3><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">leetcode-215数组中的第K个最大元素【中等】</a></p><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:</p><pre><code class="hljs text">输入: [3,2,1,5,6,4] 和 k = 2输出: 5</code></pre><p>示例 2:</p><pre><code class="hljs text">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4</code></pre><p>说明:<br>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> findKthLargest = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;&#125;;</code></pre><p>解题思路：<br>1、构建一个最小堆，并依次把数组的值插入堆中<br>2、当堆的容量超过K， 就删除堆顶<br>3、插入结束后，堆顶就是第K个最大元素</p><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinHead</span> </span>&#123;<span class="hljs-comment">// 实现一个最小堆...</span><span class="hljs-comment">// 代码前面已经写过，这里不再重复</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> * 时间复杂度： O(n * log(k))</span><span class="hljs-comment"> * 空间复杂度： O(k)</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> findKthLargest = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;    <span class="hljs-keyword">const</span> h1 = <span class="hljs-keyword">new</span> MinHead();    nums.forEach(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> &#123;        h1.insert(n);        <span class="hljs-keyword">if</span>(h1.size() &gt; k) &#123;            h1.pop();        &#125;    &#125;)    <span class="hljs-keyword">return</span> h1.peek();&#125;;</code></pre><h3 id="2、前-K-个高频元素"><a href="#2、前-K-个高频元素" class="headerlink" title="2、前 K 个高频元素"></a>2、前 K 个高频元素</h3><p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">leetcode-347前 K 个高频元素【中等】</a></p><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><p>示例 1:</p><pre><code class="hljs text">输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2]</code></pre><p>示例 2:</p><pre><code class="hljs text">输入: nums = [1], k = 1输出: [1]</code></pre><p>提示：</p><ul><li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</li><li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li><li>你可以按任意顺序返回答案。</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> topKFrequent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;&#125;;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> topKFrequent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">    解法一：</span><span class="hljs-comment">        1、将输入的数组进行统计，得到每个元素出现次数的二维数组（二维数组的第一项是元素，第二项是元素出现的次数）</span><span class="hljs-comment">        2、再将元素按照统计次数进行降序排列，数组的前K个就是所需要的结果</span><span class="hljs-comment">        3、但是这个解法 不符合 题目时间复杂度的要求</span><span class="hljs-comment"></span><span class="hljs-comment">    时间复杂度： </span><span class="hljs-comment">        1、nums.forEach =&gt; O(n)</span><span class="hljs-comment">        2、Array.sort =&gt; O(n log n)</span><span class="hljs-comment">        所以结合起来， 时间复杂度 就是 O(n log n) ，不符合题目要求的 时间复杂度必须由于 O(n log n)</span><span class="hljs-comment">    */</span>   <span class="hljs-comment">//  const map = new Map();</span>   <span class="hljs-comment">//  nums.forEach(n =&gt; &#123;</span>   <span class="hljs-comment">//      map.set(n, map.has(n) ? map.get(n) + 1 : 1);</span>   <span class="hljs-comment">//  &#125;);</span>   <span class="hljs-comment">//  const arr = Array.from(map).sort((a, b) =&gt; b[1] - a[1]);</span>   <span class="hljs-comment">//  return arr.slice(0, k).map(n =&gt; n[0]);</span><span class="hljs-comment">/**</span><span class="hljs-comment">    解法二：</span><span class="hljs-comment">        1、建立最小堆</span><span class="hljs-comment">  2、当堆的容量超过K， 就删除堆顶</span><span class="hljs-comment">  3、插入结束后，堆顶就是第K个最大元素</span><span class="hljs-comment"></span><span class="hljs-comment">    时间复杂度： </span><span class="hljs-comment">        1、nums.forEach =&gt; O(n)</span><span class="hljs-comment">        2、map.forEach =&gt; O(n) 而 嵌套的 insert 和 pop 都是 logK, 结合起来就是 O(n log k)</span><span class="hljs-comment">        所以结合起来， 时间复杂度 就是 O(n log K) ，由于 k &lt; n 所有符合题目要求的</span><span class="hljs-comment">   */</span><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();nums.forEach(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> &#123;map.set(n, map.has(n) ? map.get(n) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);&#125;);<span class="hljs-keyword">const</span> h = <span class="hljs-keyword">new</span> MinHead();map.forEach(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;h.insert(&#123;value, key&#125;);<span class="hljs-keyword">if</span> (h.size() &gt; k) &#123;h.pop();&#125;&#125;)<span class="hljs-keyword">return</span> h.heap.map(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a.key)    &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinHead</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.heap = [];&#125;<span class="hljs-comment">// 插入方法</span><span class="hljs-function"><span class="hljs-title">insert</span>(<span class="hljs-params">value</span>)</span> &#123;<span class="hljs-built_in">this</span>.heap.push(value); <span class="hljs-comment">// 插入到底部</span><span class="hljs-built_in">this</span>.shiftUp(<span class="hljs-built_in">this</span>.heap.length - <span class="hljs-number">1</span>); <span class="hljs-comment">// 上移操作</span>&#125;<span class="hljs-comment">// 删除堆顶</span><span class="hljs-function"><span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>] = <span class="hljs-built_in">this</span>.heap.pop(); <span class="hljs-comment">// 把原来heap中最末尾的推出来, 并赋值给堆顶</span><span class="hljs-built_in">this</span>.shiftDown(<span class="hljs-number">0</span>); <span class="hljs-comment">// 下移操作</span>&#125;<span class="hljs-comment">// 获取堆顶</span><span class="hljs-function"><span class="hljs-title">peek</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>];&#125;<span class="hljs-comment">// 获取堆的大小</span><span class="hljs-function"><span class="hljs-title">size</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap.length;&#125;<span class="hljs-comment">// 获取父节点</span><span class="hljs-function"><span class="hljs-title">getParentIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-comment">// return Math.floor((i - 1) / 2);</span><span class="hljs-keyword">return</span> (i - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 二进制操作，把二进制的数字右移一位</span>&#125;<span class="hljs-comment">// 获取左侧子节点</span><span class="hljs-function"><span class="hljs-title">getLeftIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 获取右侧子节点</span><span class="hljs-function"><span class="hljs-title">getRightIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;&#125;<span class="hljs-comment">// 将两个节点的位置进行交换</span><span class="hljs-function"><span class="hljs-title">swap</span>(<span class="hljs-params">i1, i2</span>)</span> &#123;<span class="hljs-keyword">const</span> temp = <span class="hljs-built_in">this</span>.heap[i1];<span class="hljs-built_in">this</span>.heap[i1] = <span class="hljs-built_in">this</span>.heap[i2];<span class="hljs-built_in">this</span>.heap[i2] = temp;&#125;<span class="hljs-comment">// 上移</span><span class="hljs-function"><span class="hljs-title">shiftUp</span>(<span class="hljs-params">index</span>)</span> &#123;<span class="hljs-comment">// 递归的终点: 到达堆顶</span><span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">const</span> parentIndex = <span class="hljs-built_in">this</span>.getParentIndex(index);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.heap[parentIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[parentIndex].value &gt; <span class="hljs-built_in">this</span>.heap[index].value) &#123;<span class="hljs-built_in">this</span>.swap(parentIndex, index); <span class="hljs-comment">// 实现交换的方法</span><span class="hljs-built_in">this</span>.shiftUp(parentIndex); <span class="hljs-comment">// 如果还是需要上移，则递归</span>&#125;&#125;<span class="hljs-comment">// 下移</span><span class="hljs-function"><span class="hljs-title">shiftDown</span>(<span class="hljs-params">index</span>)</span> &#123;<span class="hljs-keyword">const</span> leftIndex = <span class="hljs-built_in">this</span>.getLeftIndex(index);<span class="hljs-keyword">const</span> rightIndex = <span class="hljs-built_in">this</span>.getRightIndex(index);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[leftIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[leftIndex].value &lt; <span class="hljs-built_in">this</span>.heap[index].value) &#123;<span class="hljs-built_in">this</span>.swap(leftIndex, index);<span class="hljs-built_in">this</span>.shiftDown(leftIndex);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[rightIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[rightIndex].value &lt; <span class="hljs-built_in">this</span>.heap[index].value) &#123;<span class="hljs-built_in">this</span>.swap(rightIndex, index);<span class="hljs-built_in">this</span>.shiftDown(rightIndex);&#125;&#125;&#125;</code></pre><h3 id="3、合并K个升序链表"><a href="#3、合并K个升序链表" class="headerlink" title="3、合并K个升序链表"></a>3、合并K个升序链表</h3><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">leetcode-23合并K个升序链表【困难】</a></p><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p>示例 1：</p><pre><code class="hljs text">输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre><p>示例 2：</p><pre><code class="hljs text">输入：lists = []输出：[]</code></pre><p>示例 3：</p><pre><code class="hljs text">输入：lists = [[]]输出：[]</code></pre><p>提示：</p><ul><li>k == lists.length</li><li>0 &lt;= k &lt;= 10^4</li><li>0 &lt;= lists[i].length &lt;= 500</li><li>-10^4 &lt;= lists[i][j] &lt;= 10^4</li><li>lists[i] 按 升序 排列</li><li>lists[i].length 的总和不超过 10^4</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode[]&#125;</span> <span class="hljs-variable">lists</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> mergeKLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lists</span>) </span>&#123;    &#125;;</code></pre><p>解题思路：<br>1、构建一个最小堆，并依次把链表头插入到堆中<br>2、弹出堆顶到输出链表，并将堆顶所在的链表的新链表头插入堆中<br>3、等堆元素全部弹出，合并工作就完成了</p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 时间复杂度： O(n) * logK // n是所有链表树的和，k是链表的数</span><span class="hljs-comment"> * 空间复杂度： O(k) // 中间遍历是 堆，堆的大小是K，k是链表的数</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode[]&#125;</span> <span class="hljs-variable">lists</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><span class="hljs-comment"> */</span> <span class="hljs-keyword">var</span> mergeKLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lists</span>) </span>&#123;<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<span class="hljs-keyword">let</span> p = res;<span class="hljs-keyword">const</span> h = <span class="hljs-keyword">new</span> MinHead();lists.forEach(<span class="hljs-function"><span class="hljs-params">l</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span>(l) h.insert(l);&#125;)<span class="hljs-keyword">while</span>(h.size()) &#123;<span class="hljs-keyword">const</span> n = h.pop(); <span class="hljs-comment">// 弹出堆顶（即lists中最小的那个链表节点）</span>p.next = n;p = p.next;<span class="hljs-keyword">if</span>(n.next) h.insert(n.next); <span class="hljs-comment">// 再把最小节点的下一个节点加到堆中</span>&#125;<span class="hljs-keyword">return</span> res.next;    &#125;;<span class="hljs-comment">// 构建一个最小堆（堆中的元素时 链表的节点）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinHead</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.heap = [];&#125;<span class="hljs-comment">// 插入方法</span><span class="hljs-function"><span class="hljs-title">insert</span>(<span class="hljs-params">value</span>)</span> &#123;<span class="hljs-built_in">this</span>.heap.push(value); <span class="hljs-comment">// 插入到底部</span><span class="hljs-built_in">this</span>.shiftUp(<span class="hljs-built_in">this</span>.heap.length - <span class="hljs-number">1</span>); <span class="hljs-comment">// 上移操作</span>&#125;<span class="hljs-comment">// 删除堆顶</span><span class="hljs-function"><span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-comment">// 与原生的最小堆相比，需要做修改。 需要记住 top 的元素，并返回</span><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.size() === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap.shift();<span class="hljs-keyword">const</span> top = <span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>]; <span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>] = <span class="hljs-built_in">this</span>.heap.pop(); <span class="hljs-comment">// 把原来heap中最末尾的推出来, 并赋值给堆顶</span><span class="hljs-built_in">this</span>.shiftDown(<span class="hljs-number">0</span>); <span class="hljs-comment">// 下移操作</span><span class="hljs-keyword">return</span> top;&#125;<span class="hljs-comment">// 获取堆顶</span><span class="hljs-function"><span class="hljs-title">peek</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>];&#125;<span class="hljs-comment">// 获取堆的大小</span><span class="hljs-function"><span class="hljs-title">size</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap.length;&#125;<span class="hljs-comment">// 获取父节点</span><span class="hljs-function"><span class="hljs-title">getParentIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-comment">// return Math.floor((i - 1) / 2);</span><span class="hljs-keyword">return</span> (i - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 二进制操作，把二进制的数字右移一位</span>&#125;<span class="hljs-comment">// 获取左侧子节点</span><span class="hljs-function"><span class="hljs-title">getLeftIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 获取右侧子节点</span><span class="hljs-function"><span class="hljs-title">getRightIndex</span>(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;&#125;<span class="hljs-comment">// 将两个节点的位置进行交换</span><span class="hljs-function"><span class="hljs-title">swap</span>(<span class="hljs-params">i1, i2</span>)</span> &#123;<span class="hljs-keyword">const</span> temp = <span class="hljs-built_in">this</span>.heap[i1];<span class="hljs-built_in">this</span>.heap[i1] = <span class="hljs-built_in">this</span>.heap[i2];<span class="hljs-built_in">this</span>.heap[i2] = temp;&#125;<span class="hljs-comment">// 上移</span><span class="hljs-function"><span class="hljs-title">shiftUp</span>(<span class="hljs-params">index</span>)</span> &#123;<span class="hljs-comment">// 递归的终点: 到达堆顶</span><span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">const</span> parentIndex = <span class="hljs-built_in">this</span>.getParentIndex(index);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.heap[parentIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[parentIndex].val &gt; <span class="hljs-built_in">this</span>.heap[index].val) &#123;<span class="hljs-built_in">this</span>.swap(parentIndex, index); <span class="hljs-comment">// 实现交换的方法</span><span class="hljs-built_in">this</span>.shiftUp(parentIndex); <span class="hljs-comment">// 如果还是需要上移，则递归</span>&#125;&#125;<span class="hljs-comment">// 下移</span><span class="hljs-function"><span class="hljs-title">shiftDown</span>(<span class="hljs-params">index</span>)</span> &#123;<span class="hljs-keyword">const</span> leftIndex = <span class="hljs-built_in">this</span>.getLeftIndex(index);<span class="hljs-keyword">const</span> rightIndex = <span class="hljs-built_in">this</span>.getRightIndex(index);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[leftIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[leftIndex].val &lt; <span class="hljs-built_in">this</span>.heap[index].val) &#123;<span class="hljs-built_in">this</span>.swap(leftIndex, index);<span class="hljs-built_in">this</span>.shiftDown(leftIndex);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[rightIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[rightIndex].val &lt; <span class="hljs-built_in">this</span>.heap[index].val) &#123;<span class="hljs-built_in">this</span>.swap(rightIndex, index);<span class="hljs-built_in">this</span>.shiftDown(rightIndex);&#125;&#125;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js-手写红绿灯</title>
    <link href="/2019/12/19/interview/%E6%89%8B%E5%86%99%E7%BA%A2%E8%B7%AF%E7%81%AF/"/>
    <url>/2019/12/19/interview/%E6%89%8B%E5%86%99%E7%BA%A2%E8%B7%AF%E7%81%AF/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"><span class="hljs-selector-class">.light-content</span> &#123;</span>width: 400px;height: 150px;<span class="css"><span class="hljs-selector-tag">border</span>: 1<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#666</span>;</span>border-radius: 20px;<span class="css"><span class="hljs-selector-tag">background</span>: <span class="hljs-selector-id">#f7f7f7</span>;</span>display: flex;justify-content: space-around;align-items: center;&#125;<span class="css"><span class="hljs-selector-id">#red-light</span>, <span class="hljs-selector-id">#yellow-light</span>, <span class="hljs-selector-id">#green-light</span> &#123;</span>width: 100px;height: 100px;border-radius: 50px;display: flex;align-items: center;justify-content: center;font-size: 35px;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript"><span class="hljs-keyword">let</span> red = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;red-light&#x27;</span>);</span><span class="javascript"><span class="hljs-keyword">let</span> yellow= <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;yellow-light&#x27;</span>);</span><span class="javascript"><span class="hljs-keyword">let</span> green = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;green-light&#x27;</span>);</span><span class="javascript"><span class="hljs-keyword">let</span> colorsChange = <span class="hljs-function">(<span class="hljs-params">color, duration</span>) =&gt;</span> &#123;</span><span class="javascript"><span class="hljs-keyword">if</span>(color === <span class="hljs-string">&#x27;red&#x27;</span>) &#123;</span><span class="javascript"><span class="hljs-comment">// 设置灯的颜色变化</span></span>red.style.background = color;<span class="javascript">green.style.background = <span class="hljs-string">&#x27;#E2DCDC&#x27;</span>;</span><span class="javascript">yellow.style.background = <span class="hljs-string">&#x27;#E2DCDC&#x27;</span>;</span><span class="javascript"><span class="hljs-comment">// 设置倒计时</span></span>green.innerText = 0;yellow.innerText = 0;<span class="javascript"><span class="hljs-keyword">let</span> timeOut = duration;</span>red.innerText = timeOut / 1000;<span class="javascript"><span class="hljs-keyword">let</span> times = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;</span>red.innerText = (timeOut - 1000) / 1000;timeOut -= 1000;<span class="javascript"><span class="hljs-keyword">if</span> (timeOut === <span class="hljs-number">0</span>) &#123;</span><span class="javascript"><span class="hljs-built_in">clearInterval</span>(times);</span>&#125;&#125;, 1000);&#125;<span class="javascript"><span class="hljs-keyword">if</span>(color === <span class="hljs-string">&#x27;yellow&#x27;</span>) &#123;</span><span class="javascript"><span class="hljs-comment">// 设置灯的颜色变化</span></span>yellow.style.background = color;<span class="javascript">green.style.background = <span class="hljs-string">&#x27;#E2DCDC&#x27;</span>;</span><span class="javascript">red.style.background = <span class="hljs-string">&#x27;#E2DCDC&#x27;</span>;</span><span class="javascript"><span class="hljs-comment">// 设置倒计时</span></span>red.innerText = 0;green.innerText = 0;<span class="javascript"><span class="hljs-keyword">let</span> timeOut = duration;</span>yellow.innerText = timeOut / 1000;<span class="javascript"><span class="hljs-keyword">let</span> times = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;</span>yellow.innerText = (timeOut - 1000) / 1000;timeOut -= 1000;<span class="javascript"><span class="hljs-keyword">if</span> (timeOut === <span class="hljs-number">0</span>) &#123;</span><span class="javascript"><span class="hljs-built_in">clearInterval</span>(times);</span>&#125;&#125;, 1000);&#125;<span class="javascript"><span class="hljs-keyword">if</span>(color === <span class="hljs-string">&#x27;green&#x27;</span>) &#123;</span><span class="javascript"><span class="hljs-comment">// 设置灯的颜色变化</span></span>green.style.background = color;<span class="javascript">red.style.background = <span class="hljs-string">&#x27;#E2DCDC&#x27;</span>;</span><span class="javascript">yellow.style.background = <span class="hljs-string">&#x27;#E2DCDC&#x27;</span>;</span><span class="javascript"><span class="hljs-comment">// 设置倒计时</span></span>yellow.innerText = 0;red.innerText = 0;<span class="javascript"><span class="hljs-keyword">let</span> timeOut = duration;</span>green.innerText = timeOut / 1000;<span class="javascript"><span class="hljs-keyword">let</span> times = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;</span>green.innerText = (timeOut - 1000) / 1000;timeOut -= 1000;<span class="javascript"><span class="hljs-keyword">if</span> (timeOut === <span class="hljs-number">0</span>) &#123;</span><span class="javascript"><span class="hljs-built_in">clearInterval</span>(times);</span>&#125;&#125;, 1000);&#125;&#125;;<span class="javascript"><span class="hljs-keyword">let</span> setColor = <span class="hljs-function">(<span class="hljs-params">color, duration</span>) =&gt;</span> &#123;</span><span class="javascript"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res,rej</span>) =&gt;</span> &#123;</span>colorsChange(color, duration);<span class="javascript"><span class="hljs-built_in">setTimeout</span>(res, duration);</span>&#125;)&#125;<span class="javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setLight</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript"><span class="hljs-keyword">await</span> setColor(<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-number">7000</span>);</span><span class="javascript"><span class="hljs-keyword">await</span> setColor(<span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-number">3000</span>);</span><span class="javascript"><span class="hljs-keyword">await</span> setColor(<span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-number">5000</span>);</span><span class="javascript"><span class="hljs-keyword">await</span> setLight();</span>&#125;setLight();&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;light-content&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;red-light&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;yellow-light&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;green-light&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>js</tag>
      
      <tag>手写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Set Map</title>
    <link href="/2019/11/30/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-Set&amp;Map/"/>
    <url>/2019/11/30/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-Set&amp;Map/</url>
    
    <content type="html"><![CDATA[<h2 id="一、集合-Set-是什么"><a href="#一、集合-Set-是什么" class="headerlink" title="一、集合(Set)是什么"></a>一、集合(Set)是什么</h2><ul><li>一种<strong>无序且唯一</strong>的数据结构</li><li>ES6中有集合，名为Set</li><li>集合的常用操作：去重、判断某元素是否在集合中、求交集…</li></ul><p>(<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set">MDN-Set</a>)</p><p><code>Set</code>对象是值的集合，你可以按照插入的顺序迭代它的元素。 Set中的元素只会<strong>出现一次</strong>，即 <code>Set</code> 中的元素是唯一的。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个set集合</span><span class="hljs-keyword">let</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;, <span class="hljs-number">3</span>]); <span class="hljs-comment">// return undefined =&gt; [1, &#123;a: 1&#125;, 3]</span><span class="hljs-keyword">let</span> mySet2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(); <span class="hljs-comment">// return undefined =&gt; []</span><span class="hljs-comment">// 增加元素</span>mySet.add(<span class="hljs-number">1</span>); <span class="hljs-comment">// return [1, &#123;a: 1&#125;, 3]</span>mySet.add(<span class="hljs-number">4</span>); <span class="hljs-comment">// return [1, &#123;a: 1&#125;, 3, 4]</span><span class="hljs-comment">// 删除某个元素</span>mySet.delete(<span class="hljs-number">3</span>); <span class="hljs-comment">// true  =&gt; [1, &#123;a: 1&#125;, 4]</span><span class="hljs-comment">// 清空</span>mySet2.clear(); <span class="hljs-comment">// return undefined =&gt; []</span><span class="hljs-comment">// 判断存在与否</span>mySet.has(<span class="hljs-number">4</span>); <span class="hljs-comment">// reruen true</span><span class="hljs-comment">// 获取长度 (长度为实例属性，不是方法)</span>mySet.size; <span class="hljs-comment">// 3</span><span class="hljs-comment">// 迭代</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> mySet) <span class="hljs-built_in">console</span>.log(item); <span class="hljs-comment">// 1 &#123;a: 1&#125; 3</span>mySet.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123; <span class="hljs-built_in">console</span>.log(item) &#125;); <span class="hljs-comment">// 1 &#123;a: 1&#125; 3</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> mySet.keys()) <span class="hljs-built_in">console</span>.log(item); <span class="hljs-comment">// 1 &#123;a: 1&#125; 3</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> mySet.values()) <span class="hljs-built_in">console</span>.log(item); <span class="hljs-comment">// 1 &#123;a: 1&#125; 3</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> mySet.entries()) <span class="hljs-built_in">console</span>.log(key, value); <span class="hljs-comment">// 1 1  &#123;a: 1&#125; &#123;a: 1&#125; 3 3</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> mySet.entries()) <span class="hljs-built_in">console</span>.log(key === value); <span class="hljs-comment">// true true true</span><span class="hljs-comment">// 与数组相关</span><span class="hljs-keyword">let</span> arr1 = <span class="hljs-built_in">Array</span>.from(mySet);<span class="hljs-keyword">let</span> arr2 = [...mySet]<span class="hljs-keyword">let</span> mySet3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr1);</code></pre><h2 id="二、字典-Map-是什么"><a href="#二、字典-Map-是什么" class="headerlink" title="二、字典(Map)是什么"></a>二、字典(Map)是什么</h2><ul><li>与集合类似，字典也是一种存储唯一值的数据结构，但是它以<strong>键值对</strong>的形式来存储</li><li>ES6中有字典，名为Map</li><li>字典的常用操作：键值对的增删改查</li></ul><p>(<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/map">MDN-Map</a>)</p><p><code>Map</code> 对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个map</span><span class="hljs-keyword">let</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<span class="hljs-keyword">let</span> keyString = <span class="hljs-string">&#x27;a string&#x27;</span>;<span class="hljs-keyword">let</span> keyObj = &#123;&#125;;<span class="hljs-keyword">let</span> keyFunc = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<span class="hljs-comment">// 添加</span>myMap.set(keyString, <span class="hljs-string">&#x27;和键&quot;a string&quot;关联的值&#x27;</span>);myMap.set(keyObj, <span class="hljs-string">&quot;和键keyObj关联的值&quot;</span>);myMap.set(keyFunc, <span class="hljs-string">&quot;和键keyFunc关联的值&quot;</span>);myMap.set(<span class="hljs-literal">NaN</span>, <span class="hljs-string">&quot;not a number&quot;</span>);<span class="hljs-comment">// 获取长度 (长度为实例属性，不是方法)</span>myMap.size;<span class="hljs-comment">// 读取值</span>myMap.get(keyString);    <span class="hljs-comment">// &quot;和键&#x27;a string&#x27;关联的值&quot;</span>myMap.get(keyObj);       <span class="hljs-comment">// &quot;和键keyObj关联的值&quot;</span>myMap.get(keyFunc);      <span class="hljs-comment">// &quot;和键keyFunc关联的值&quot;</span>myMap.get(<span class="hljs-literal">NaN</span>); <span class="hljs-comment">// &quot;not a number&quot;</span>myMap.get(<span class="hljs-string">&#x27;a string&#x27;</span>);   <span class="hljs-comment">// &quot;和键&#x27;a string&#x27;关联的值&quot;</span>                         <span class="hljs-comment">// 因为keyString === &#x27;a string&#x27;</span>myMap.get(&#123;&#125;);           <span class="hljs-comment">// undefined, 因为keyObj !== &#123;&#125;</span>myMap.get(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;); <span class="hljs-comment">// undefined, 因为keyFunc !== function () &#123;&#125;</span><span class="hljs-comment">// 遍历</span>myMap.forEach(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">&quot; = &quot;</span> + value);&#125;)<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> myMap) &#123;  <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">&quot; = &quot;</span> + value);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> a <span class="hljs-keyword">of</span> myMap.keys()) <span class="hljs-built_in">console</span>.log(a);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> a <span class="hljs-keyword">of</span> myMap.values()) <span class="hljs-built_in">console</span>.log(a)<span class="hljs-comment">// map与数组的关系</span><span class="hljs-keyword">let</span> arr1 = [[<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>], [<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>]];<span class="hljs-keyword">let</span> myMap2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(arr1); <span class="hljs-comment">// 数组 转 map</span><span class="hljs-keyword">let</span> arr2 = arr1.from(myMap2); <span class="hljs-comment">// map 转 数组</span><span class="hljs-keyword">let</span> arr3 = [...myMap2]; <span class="hljs-comment">// map 转 数组</span><span class="hljs-comment">// 发现一个问题</span><span class="hljs-keyword">let</span> otherNaN1 = <span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;foo1&quot;</span>);<span class="hljs-keyword">let</span> otherNaN2 = <span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;foo2&quot;</span>);myMap.get(otherNaN1); <span class="hljs-comment">// &quot;not a number&quot;</span>myMap.get(otherNaN2); <span class="hljs-comment">// &quot;not a number&quot;</span>otherNaN1 == otherNaN2; <span class="hljs-comment">// false</span>otherNaN1 === otherNaN2; <span class="hljs-comment">// false</span>myMap.get(otherNaN1) === myMap.get(otherNaN2); <span class="hljs-comment">// true</span><span class="hljs-comment">// why ??</span></code></pre><h2 id="三、练习题"><a href="#三、练习题" class="headerlink" title="三、练习题"></a>三、练习题</h2><h3 id="1、两个数组的交集-1"><a href="#1、两个数组的交集-1" class="headerlink" title="1、两个数组的交集-1"></a>1、两个数组的交集-1</h3><blockquote><p>(<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">leecode-349</a>)</p></blockquote><p>题目描述：给定两个数组，编写一个函数来计算它们的交集。</p><p>示例1：</p><pre><code class="hljs text">输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2]</code></pre><p>示例2：</p><pre><code class="hljs text">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4]</code></pre><pre><code class="hljs text">说明：- 输出结果中的每个元素一定是唯一的。- 我们可以不考虑输出结果的顺序。</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums1</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums2</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> intersection = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums1, nums2</span>) </span>&#123;    <span class="hljs-comment">// 解法一: Set</span>    <span class="hljs-keyword">return</span> [...new <span class="hljs-built_in">Set</span>(nums1)].filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> nums2.includes(item));    <span class="hljs-comment">// 解法二: Map</span>    <span class="hljs-comment">// const map = new Map();</span>    <span class="hljs-comment">// nums1.forEach(item =&gt; &#123;</span>    <span class="hljs-comment">//     map.set(item, true);</span>    <span class="hljs-comment">// &#125;)</span>    <span class="hljs-comment">// const res = [];</span>    <span class="hljs-comment">// nums2.forEach(item =&gt; &#123;</span>    <span class="hljs-comment">//     if (map.get(item)) &#123;</span>    <span class="hljs-comment">//         res.push(item);</span>    <span class="hljs-comment">//         map.delete(item)</span>    <span class="hljs-comment">//     &#125;</span>    <span class="hljs-comment">// &#125;)</span>    <span class="hljs-comment">// return res;</span>&#125;;<span class="hljs-comment">/* Set</span><span class="hljs-comment">时间复杂度： O(n²)  （首先num1的filter遍历，所以复杂度为O(n)；num2的includes也遍历，所以时间复杂度为O(n)，嵌套循环后就是 n*n，即 O(n²)</span><span class="hljs-comment">     更严谨的说，时间复杂度为  O(m*n), 其中m为num1去重后的长度，n为num2的长度</span><span class="hljs-comment">空间复杂度： 除了num1和num2数组内部的元素，没有新增变量，所以空间复杂度为 O(m), 其中m是去重后num1 的长度</span><span class="hljs-comment">*/</span><span class="hljs-comment">/*Map</span><span class="hljs-comment">时间复杂度： O(m+n); 其中m是nums1的长度，n是num2的长度</span><span class="hljs-comment">空间复杂度： O(m); 其中m是nums1的长度</span><span class="hljs-comment">*/</span></code></pre><h3 id="2、两个数组的交集-2"><a href="#2、两个数组的交集-2" class="headerlink" title="2、两个数组的交集-2"></a>2、两个数组的交集-2</h3><blockquote><p>(<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">leecode-350</a>)</p></blockquote><p>题目描述：给定两个数组，编写一个函数来计算它们的交集。</p><p>示例1：</p><pre><code class="hljs text">输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2,2]</code></pre><p>示例2：</p><pre><code class="hljs text">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[4,9]</code></pre><pre><code class="hljs text">说明：- 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。- 我们可以不考虑输出结果的顺序。</code></pre><pre><code class="hljs text">进阶：- 如果给定的数组已经排好序呢？你将如何优化你的算法？- 如果 nums1 的大小比 nums2 小很多，哪种方法更优？- 如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums1</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums2</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> intersection = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums1, nums2</span>) </span>&#123;    <span class="hljs-comment">// 解法一: Set</span>    <span class="hljs-keyword">return</span> [...new <span class="hljs-built_in">Set</span>(nums1)].filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> nums2.includes(item));    <span class="hljs-comment">// 解法二: Map</span>    <span class="hljs-comment">// const map = new Map();</span>    <span class="hljs-comment">// nums1.forEach(item =&gt; &#123;</span>    <span class="hljs-comment">//     map.set(item, true);</span>    <span class="hljs-comment">// &#125;)</span>    <span class="hljs-comment">// const res = [];</span>    <span class="hljs-comment">// nums2.forEach(item =&gt; &#123;</span>    <span class="hljs-comment">//     if (map.get(item)) &#123;</span>    <span class="hljs-comment">//         res.push(item);</span>    <span class="hljs-comment">//         map.delete(item)</span>    <span class="hljs-comment">//     &#125;</span>    <span class="hljs-comment">// &#125;)</span>    <span class="hljs-comment">// return res;</span>&#125;;<span class="hljs-comment">/* Set</span><span class="hljs-comment">时间复杂度： O(n²)  （首先num1的filter遍历，所以复杂度为O(n)；num2的includes也遍历，所以时间复杂度为O(n)，嵌套循环后就是 n*n，即 O(n²)</span><span class="hljs-comment">     更严谨的说，时间复杂度为  O(m*n), 其中m为num1去重后的长度，n为num2的长度</span><span class="hljs-comment">空间复杂度： 除了num1和num2数组内部的元素，没有新增变量，所以空间复杂度为 O(m), 其中m是去重后num1 的长度</span><span class="hljs-comment">*/</span><span class="hljs-comment">/*Map</span><span class="hljs-comment">时间复杂度： O(m+n); 其中m是nums1的长度，n是num2的长度</span><span class="hljs-comment">空间复杂度： O(m); 其中m是nums1的长度</span><span class="hljs-comment">*/</span></code></pre><h3 id="2、有效的括号"><a href="#2、有效的括号" class="headerlink" title="2、有效的括号"></a>2、有效的括号</h3><blockquote><p>(<a href="https://leetcode-cn.com/problems/valid-parentheses/">leecode-20</a>)</p></blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。  </p><p>示例 1:</p><pre><code class="hljs text">输入: &quot;()&quot;输出: true</code></pre><p>示例 2:</p><pre><code class="hljs text">输入: &quot;()[]&#123;&#125;&quot;输出: true</code></pre><p>示例 3:</p><pre><code class="hljs text">输入: &quot;(]&quot;输出: false</code></pre><p>示例 4:</p><pre><code class="hljs text">输入: &quot;([)]&quot;输出: false</code></pre><p>示例 5:</p><pre><code class="hljs text">输入: &quot;&#123;[]&#125;&quot;输出: true</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 时间复杂度:  O(n)</span><span class="hljs-comment"> * 空间复杂度:  O(1)</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> isValid = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!s) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">if</span> (s.length &amp; <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();    map.set(<span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;)&#x27;</span>);    map.set(<span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;]&#x27;</span>);    map.set(<span class="hljs-string">&#x27;&#123;&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>);    <span class="hljs-keyword">const</span> stack = [];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;        <span class="hljs-keyword">if</span> (map.has(s[i])) &#123;            stack.push(s[i]);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map.get(stack.pop()) !== s[i]) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> stack.length === <span class="hljs-number">0</span>;&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 时间复杂度: O(n) n为s的长度</span><span class="hljs-comment"> * 空间复杂度: O(n) 因为map一个常量级的O(1)的空间复杂度</span><span class="hljs-comment"> * /</span></code></pre><h3 id="3、两数之和"><a href="#3、两数之和" class="headerlink" title="3、两数之和"></a>3、两数之和</h3><blockquote><p>(<a href="https://leetcode-cn.com/problems/two-sum/">leecode-1</a>)</p></blockquote><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>示例:</p><pre><code class="hljs text">给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">target</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> twoSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;    <span class="hljs-comment">// 解法一： map 时间复杂度: O(n) 空间复杂度: O(n);</span>    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;        <span class="hljs-keyword">const</span> n1 = nums[i];        <span class="hljs-keyword">const</span> n2 = target - n1;        <span class="hljs-keyword">if</span> (map.has(n2)) &#123;            <span class="hljs-keyword">return</span>[map.get(n2), i];        &#125; <span class="hljs-keyword">else</span> &#123;            map.set(n1, i);        &#125;    &#125;    <span class="hljs-comment">// 解法二：  时间复杂度: O(n) 空间复杂度: O(1);</span>    <span class="hljs-comment">// for(let i = 0; i &lt; nums.length; i++) &#123;</span>    <span class="hljs-comment">//   if (nums.indexOf(target - nums[i]) &gt; -1 &amp;&amp; nums.indexOf(target - nums[i]) !== i) &#123;</span>    <span class="hljs-comment">//     return [i, nums.indexOf(target - nums[i])]</span>    <span class="hljs-comment">//   &#125;</span>    <span class="hljs-comment">// &#125;</span>&#125;;</code></pre><h3 id="4、无重复字符的最长子串"><a href="#4、无重复字符的最长子串" class="headerlink" title="4、无重复字符的最长子串"></a>4、无重复字符的最长子串</h3><blockquote><p>(<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">leecode-3</a>)</p></blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p>示例1:</p><pre><code class="hljs text">输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p>示例2:</p><pre><code class="hljs text">输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p>示例3:</p><pre><code class="hljs text">输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><p>示例4:</p><pre><code class="hljs text">输入: s = &quot;&quot;输出: 0</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> * 解题思路：</span><span class="hljs-comment"> * 1、用双指针维护一个滑动窗口，从来剪切子串</span><span class="hljs-comment"> * 2、不断移动右指针，遇到重复字符串，就把左指针移动到重复字符串的下一位</span><span class="hljs-comment"> * 3、移动右指针的过程中，记录所有窗口的长度，并返回最大值</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> lengthOfLongestSubstring = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;    <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> r = <span class="hljs-number">0</span>; r &lt; s.length; r++) &#123;        <span class="hljs-keyword">if</span> (map.has(s[r]) &amp;&amp; map.get(s[r]) &gt;= l) &#123;            l = map.get(s[r]) + <span class="hljs-number">1</span>;        &#125;        map.set(s[r], r);        res = <span class="hljs-built_in">Math</span>.max(res, r - l + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 时间复杂度： O(n)</span><span class="hljs-comment"> * 空间复杂度： O(m)  m是字符串s不重复字符的个数</span><span class="hljs-comment"> */</span></code></pre><h3 id="5、最小覆盖子串"><a href="#5、最小覆盖子串" class="headerlink" title="5、最小覆盖子串"></a>5、最小覆盖子串</h3><blockquote><p>(<a href="https://leetcode-cn.com/problems/minimum-window-substring/">leecode-76</a>)</p></blockquote><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p><strong>注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。</strong></p><p>示例1:</p><pre><code class="hljs text">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;输出：&quot;BANC&quot;</code></pre><p>示例2:</p><pre><code class="hljs text">输入：s = &quot;a&quot;, t = &quot;a&quot;输出：&quot;a&quot;</code></pre><p>提示：</p><ul><li>1 &lt;= s.length, t.length &lt;= 105</li><li>s 和 t 由英文字母组成</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">t</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 用双指针维护一个滑动窗口</span><span class="hljs-comment"> * 移动右指针，直到找到包含t的所有子串，此时再移动左指针，尽量减少包含t的子串的长度。</span><span class="hljs-comment"> * 时间复杂度:  O(m + n) ,m是t的长度,n是s的长度</span><span class="hljs-comment"> * 空间复杂度:  O(m) ,m是t中不同字符的个数</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> minWindow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;    <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> r = <span class="hljs-number">0</span>;    <span class="hljs-keyword">const</span> need = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> c <span class="hljs-keyword">of</span> t) &#123;        need.set(c, need.get(c) ? need.get(c) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">let</span> needType = need.size;    <span class="hljs-keyword">let</span> resStr = <span class="hljs-string">&#x27;&#x27;</span>;    <span class="hljs-keyword">while</span>(r &lt; s.length) &#123;        <span class="hljs-keyword">const</span> c1 = s[r];        <span class="hljs-keyword">if</span> (need.has(c1)) &#123;            need.set(c1, need.get(c1) - <span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span> (need.get(c1) === <span class="hljs-number">0</span>) needType -= <span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// 当needType=0时，表示右指针已经移动到可以包含t的位置，此时需要移动左指针</span>        <span class="hljs-keyword">while</span>(needType === <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (!resStr || resStr.length &gt; s.substring(l, r + <span class="hljs-number">1</span>).length) &#123;                resStr = s.substring(l, r + <span class="hljs-number">1</span>);            &#125;            <span class="hljs-keyword">const</span> c2 = s[l];            <span class="hljs-keyword">if</span> (need.has(c2)) &#123;                need.set(c2, need.get(c2) + <span class="hljs-number">1</span>);                <span class="hljs-keyword">if</span> (need.get(c2) === <span class="hljs-number">1</span>) needType += <span class="hljs-number">1</span>;            &#125;            l += <span class="hljs-number">1</span>;        &#125;        r += <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> resStr;&#125;;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 - 图</title>
    <link href="/2019/11/01/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E5%9B%BE/"/>
    <url>/2019/11/01/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="一、-图是什么"><a href="#一、-图是什么" class="headerlink" title="一、 图是什么"></a>一、 图是什么</h2><ul><li>图是<strong>网络结构</strong>的抽象模型，是一组由<strong>边</strong>连接的<strong>节点</strong></li><li>图可以表示任何二元关系，比如道路、航班…</li></ul><p>图的表示法：邻接矩阵、邻接表、关联矩阵…</p><p>邻接矩阵表示法：<br><img src="https://i.loli.net/2021/01/02/8VuqBSxOD5NnfL9.png" ></p><p>邻接表表示法 ：<br><img src="https://i.loli.net/2021/01/02/FOmAQuPw78dtnp5.png" ></p><h2 id="二、图的常用操作"><a href="#二、图的常用操作" class="headerlink" title="二、图的常用操作"></a>二、图的常用操作</h2><ul><li>深度优先遍历</li><li>广度优先遍历</li></ul><p><strong>深度优先遍历：</strong></p><ol><li>先访问根节点</li><li>对根节点的<strong>没有访问过的相邻节点</strong>依次进行深度优先遍历</li></ol><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> graph = &#123;A: [<span class="hljs-string">&#x27;B&#x27;</span>],B: [<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>],C: [<span class="hljs-string">&#x27;E&#x27;</span>],D: [<span class="hljs-string">&#x27;A&#x27;</span>],E: [<span class="hljs-string">&#x27;D&#x27;</span>]&#125;<span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<span class="hljs-keyword">const</span> dfs = <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(n); <span class="hljs-comment">// 访问节点</span>visited.add(n);graph[n].forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!visited.has(item)) &#123;dfs(item);&#125;&#125;)&#125;dfs(<span class="hljs-string">&#x27;B&#x27;</span>);</code></pre><p><strong>广度优先遍历：</strong></p><ol><li>新建一个队列，把根节点入队</li><li>把队头出队并访问</li><li>把队头的<strong>没有访问过的相邻接点</strong>入队</li><li>重复第二、第三步操作，直到队列为空</li></ol><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> graph = &#123;A: [<span class="hljs-string">&#x27;B&#x27;</span>],B: [<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>],C: [<span class="hljs-string">&#x27;E&#x27;</span>],D: [<span class="hljs-string">&#x27;A&#x27;</span>],E: [<span class="hljs-string">&#x27;D&#x27;</span>]&#125;<span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<span class="hljs-keyword">const</span> stack = [<span class="hljs-string">&#x27;B&#x27;</span>];<span class="hljs-keyword">while</span>(stack.length) &#123;<span class="hljs-keyword">const</span> m = stack.shift();visited.add(m);<span class="hljs-built_in">console</span>.log(m); <span class="hljs-comment">// 访问节点</span>graph[m].forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!visited.has(item)) &#123;stack.push(item);&#125;&#125;)&#125;</code></pre><h2 id="三、练习题"><a href="#三、练习题" class="headerlink" title="三、练习题"></a>三、练习题</h2><h3 id="1、有效数字"><a href="#1、有效数字" class="headerlink" title="1、有效数字"></a>1、有效数字</h3><p><a href="https://leetcode-cn.com/problems/valid-number/">LeetCode-65有效数字</a></p><p>题目描述：<br>验证给定的字符串是否可以解释为十进制数字。</p><pre><code class="hljs text">例如:&quot;0&quot; =&gt; true&quot; 0.1 &quot; =&gt; true&quot;abc&quot; =&gt; false&quot;1 a&quot; =&gt; false&quot;2e10&quot; =&gt; true&quot; -90e3   &quot; =&gt; true&quot; 1e&quot; =&gt; false&quot;e3&quot; =&gt; false&quot; 6e-1&quot; =&gt; true&quot; 99e2.5 &quot; =&gt; false&quot;53.5e93&quot; =&gt; true&quot; --6 &quot; =&gt; false&quot;-+3&quot; =&gt; false&quot;95a54e53&quot; =&gt; false</code></pre><p>说明: 我们有意将问题陈述地比较模糊。在实现代码之前，你应当事先思考所有可能的情况。这里给出一份可能存在于有效十进制数字中的字符列表：</p><ul><li>数字 0-9</li><li>指数 - “e”</li><li>正/负号 - “+”/“-“</li><li>小数点 - “.”</li></ul><p>当然，在输入中，这些字符的上下文也很重要。</p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> isNumber = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;&#125;;</code></pre><p>题解：</p><p>解题思路<br>   这道题的描述可以用这个图数据结构来表示：<br>    <img src="https://i.loli.net/2021/01/02/FJMwKiICBEyep6h.png" ></p><p>上图中的 0-7 的8个节点 代表字符串的8种状态，只有3、5、6是合法的数字。</p><p>遍历字符串，并沿着图走，如果走到某个节点无路可走，就返回false<br>遍历结束，如果最后走到3、5、6，则返回true，否则就返回false</p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> isNumber = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;    <span class="hljs-comment">// 数字 0-9 用字符串 &#x27;shuzi&#x27; 表示</span>    <span class="hljs-comment">// 指数 e 用字符串 &#x27;e&#x27;表示</span>    <span class="hljs-comment">// 正/负号 用字符串 &#x27;zhengfu&#x27; 表示</span>    <span class="hljs-comment">// 小数点 . 用字符串 &#x27;.&#x27; 表示</span>    <span class="hljs-comment">// 空格用字符串 &#x27;blank&#x27;</span>    <span class="hljs-keyword">const</span> graph = &#123;        <span class="hljs-number">0</span>: &#123; <span class="hljs-string">&#x27;blank&#x27;</span>: <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;zhengfu&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>: <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;shuzi&#x27;</span>: <span class="hljs-string">&#x27;6&#x27;</span> &#125;,        <span class="hljs-number">1</span>: &#123; <span class="hljs-string">&#x27;.&#x27;</span>: <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;shuzi&#x27;</span>: <span class="hljs-string">&#x27;6&#x27;</span> &#125;,        <span class="hljs-number">2</span>: &#123; <span class="hljs-string">&#x27;shuzi&#x27;</span>: <span class="hljs-string">&#x27;3&#x27;</span> &#125;,        <span class="hljs-number">3</span>: &#123; <span class="hljs-string">&#x27;shuzi&#x27;</span>: <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>: <span class="hljs-string">&#x27;4&#x27;</span> &#125;,        <span class="hljs-number">4</span>: &#123; <span class="hljs-string">&#x27;shuzi&#x27;</span>: <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;zhengfu&#x27;</span>: <span class="hljs-string">&#x27;7&#x27;</span> &#125;,        <span class="hljs-number">5</span>: &#123; <span class="hljs-string">&#x27;shuzi&#x27;</span>: <span class="hljs-string">&#x27;5&#x27;</span> &#125;,        <span class="hljs-number">6</span>: &#123; <span class="hljs-string">&#x27;.&#x27;</span>: <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;shuzi&#x27;</span>: <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>: <span class="hljs-string">&#x27;4&#x27;</span> &#125;,        <span class="hljs-number">7</span>: &#123; <span class="hljs-string">&#x27;shuzi&#x27;</span>: <span class="hljs-string">&#x27;5&#x27;</span> &#125;    &#125;    <span class="hljs-keyword">let</span> state = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> s.trim()) &#123;        <span class="hljs-keyword">if</span> (item &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; item &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;            item = <span class="hljs-string">&#x27;shuzi&#x27;</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item === <span class="hljs-string">&#x27; &#x27;</span>) &#123;            item = <span class="hljs-string">&#x27;blank&#x27;</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item === <span class="hljs-string">&#x27;+&#x27;</span> || item === <span class="hljs-string">&#x27;-&#x27;</span>) &#123;            item = <span class="hljs-string">&#x27;zhengfu&#x27;</span>;        &#125;        state = graph[state][item];        <span class="hljs-keyword">if</span> (state === <span class="hljs-literal">undefined</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> state == <span class="hljs-number">3</span> || state == <span class="hljs-number">5</span> || state == <span class="hljs-number">6</span>;&#125;;</code></pre><h3 id="2、太平洋大西洋水流问题"><a href="#2、太平洋大西洋水流问题" class="headerlink" title="2、太平洋大西洋水流问题"></a>2、太平洋大西洋水流问题</h3><p><a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">LeetCode-417太平洋大西洋水流问题</a></p><p>题目描述：<br>给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。</p><p>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。</p><p>请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。</p><p>提示：</p><ol><li>输出坐标的顺序不重要</li><li>m 和 n 都小于150</li></ol><p>示例：</p><pre><code class="hljs text">给定下面的 5x5 矩阵:  太平洋 ~   ~   ~   ~   ~        ~  1   2   2   3  (5) *       ~  3   2   3  (4) (4) *       ~  2   4  (5)  3   1  *       ~ (6) (7)  1   4   5  *       ~ (5)  1   1   2   4  *          *   *   *   *   * 大西洋返回:[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).</code></pre><p>解题思路：</p><ol><li>新建两个矩阵，分别记录能流到两个大洋的坐标</li><li>从海岸线，多管齐下，同时深度优先遍历图，过程中填充上述矩阵</li><li>遍历两个矩阵，找到能同时流到两个大洋的坐标</li></ol><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">matrix</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> pacificAtlantic = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!matrix || !matrix[<span class="hljs-number">0</span>]) &#123;        <span class="hljs-keyword">return</span> [];    &#125;    <span class="hljs-keyword">const</span> m = matrix.length; <span class="hljs-comment">// 矩阵的 行数</span>    <span class="hljs-keyword">const</span> n = matrix[<span class="hljs-number">0</span>].length; <span class="hljs-comment">// 矩阵的 列数</span>    <span class="hljs-comment">// 新建两个矩阵，分别代表太平洋和大西洋</span>    <span class="hljs-keyword">const</span> flow1 = <span class="hljs-built_in">Array</span>.from( &#123; <span class="hljs-attr">length</span>: m &#125;, <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-literal">false</span>));    <span class="hljs-keyword">const</span> flow2 = <span class="hljs-built_in">Array</span>.from( &#123; <span class="hljs-attr">length</span>: m &#125;, <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-literal">false</span>));    <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">r, c, flow</span>) =&gt;</span> &#123;        flow[r][c] = <span class="hljs-literal">true</span>;        [[r - <span class="hljs-number">1</span>, c], [r + <span class="hljs-number">1</span>, c], [r, c - <span class="hljs-number">1</span>], [r, c + <span class="hljs-number">1</span>]].forEach(<span class="hljs-function">(<span class="hljs-params">[nr, nc]</span>) =&gt;</span> &#123;            <span class="hljs-keyword">if</span> (                <span class="hljs-comment">// 保证下一个节点在矩阵中</span>                nr &gt;= <span class="hljs-number">0</span> &amp;&amp; nr &lt; m &amp;&amp;                 nc &gt;= <span class="hljs-number">0</span> &amp;&amp; nc &lt; n &amp;&amp;                <span class="hljs-comment">// 防止死循环</span>                !flow[nr][nc] &amp;&amp;                 <span class="hljs-comment">// 保证逆流而上</span>                matrix[nr][nc] &gt;= matrix[r][c]            ) &#123;                dfs(nr, nc, flow);            &#125;        &#125;);    &#125;;        <span class="hljs-comment">// 沿着海岸线逆流而上</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> r = <span class="hljs-number">0</span>; r &lt; m; r += <span class="hljs-number">1</span>) &#123;        dfs(r, <span class="hljs-number">0</span>, flow1);        dfs(r, n - <span class="hljs-number">1</span>, flow2);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c = <span class="hljs-number">0</span>; c &lt; n; c += <span class="hljs-number">1</span>) &#123;        dfs(<span class="hljs-number">0</span>, c, flow1);        dfs(m - <span class="hljs-number">1</span>, c, flow2);    &#125;    <span class="hljs-comment">// 收集能流到两个大洋里的坐标</span>    <span class="hljs-keyword">const</span> res = [];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> r = <span class="hljs-number">0</span>; r &lt; m; r += <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c = <span class="hljs-number">0</span>; c &lt; n; c += <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">if</span> (flow1[r][c] &amp;&amp; flow2[r][c]) &#123;                res.push([r, c]);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre><h3 id="3、-克隆图"><a href="#3、-克隆图" class="headerlink" title="3、 克隆图"></a>3、 克隆图</h3><p><a href="https://leetcode-cn.com/problems/clone-graph/">LeetCode-133克隆图</a></p><p>题目描述：<br>给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。</p><p>图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> val;    <span class="hljs-keyword">public</span> List&lt;Node&gt; neighbors;&#125;</code></pre><p>测试用例格式：</p><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。</p><p>邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。</p><p>示例 1：</p><pre><code class="hljs text">输入：adjList = [[2,4],[1,3],[2,4],[1,3]]输出：[[2,4],[1,3],[2,4],[1,3]]解释：图中有 4 个节点。节点 1 的值是 1，它有两个邻居：节点 2 和 4 。节点 2 的值是 2，它有两个邻居：节点 1 和 3 。节点 3 的值是 3，它有两个邻居：节点 2 和 4 。节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</code></pre><p>示例 2：</p><pre><code class="hljs text">输入：adjList = [[]]输出：[[]]解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。</code></pre><p>示例 3：</p><pre><code class="hljs text">输入：adjList = []输出：[]解释：这个图是空的，它不含任何节点。</code></pre><p>示例 4：</p><pre><code class="hljs text">输入：adjList = [[2],[1]]输出：[[2],[1]]</code></pre><p>提示：</p><ol><li>节点数不超过 100 。</li><li>每个节点值 Node.val 都是唯一的，1 &lt;= Node.val &lt;= 100。</li><li>无向图是一个简单图，这意味着图中没有重复的边，也没有自环。</li><li>由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。</li><li>图是连通图，你可以从给定节点访问到所有节点。</li></ol><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * // Definition for a Node.</span><span class="hljs-comment"> * function Node(val, neighbors) &#123;</span><span class="hljs-comment"> *    this.val = val === undefined ? 0 : val;</span><span class="hljs-comment"> *    this.neighbors = neighbors === undefined ? [] : neighbors;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Node&#125;</span> <span class="hljs-variable">node</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Node&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> cloneGraph = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>&#123;    <span class="hljs-comment">// 解法一： 深度优先遍历</span>    <span class="hljs-comment">// if (!node) return;</span>    <span class="hljs-comment">// const visited = new Map();</span>    <span class="hljs-comment">// const dfs = n =&gt; &#123;</span>    <span class="hljs-comment">//     const nCopy = new Node(n.val);</span>    <span class="hljs-comment">//     visited.set(n, nCopy);</span>    <span class="hljs-comment">//     (n.neighbors || []).forEach(ne =&gt; &#123;</span>    <span class="hljs-comment">//         if (!visited.has(ne)) &#123;</span>    <span class="hljs-comment">//             dfs(ne);</span>    <span class="hljs-comment">//         &#125;</span>    <span class="hljs-comment">//         nCopy.neighbors.push(visited.get(ne));</span>    <span class="hljs-comment">//     &#125;)</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-comment">// dfs(node);</span>    <span class="hljs-comment">// return visited.get(node);</span>    <span class="hljs-comment">// 解法二： 广度优先遍历</span>    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();    visited.set(node, <span class="hljs-keyword">new</span> Node(node.val));    <span class="hljs-keyword">const</span> q = [node];    <span class="hljs-keyword">while</span>(q.length) &#123;        <span class="hljs-keyword">const</span> n = q.shift();        (n.neighbors || []).forEach(<span class="hljs-function"><span class="hljs-params">ne</span> =&gt;</span> &#123;            <span class="hljs-keyword">if</span> (!visited.has(ne)) &#123;                q.push(ne);                visited.set(ne, <span class="hljs-keyword">new</span> Node(ne.val));            &#125;            visited.get(n).neighbors.push(visited.get(ne));        &#125;)    &#125;    <span class="hljs-keyword">return</span> visited.get(node);&#125;;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>window.location.href与window.open的区别</title>
    <link href="/2019/08/09/interview/window.location.href%E4%B8%8Ewindow.open%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2019/08/09/interview/window.location.href%E4%B8%8Ewindow.open%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="一、比较常用的JS跳转页面和打开新窗口的方法"><a href="#一、比较常用的JS跳转页面和打开新窗口的方法" class="headerlink" title="一、比较常用的JS跳转页面和打开新窗口的方法"></a>一、比较常用的JS跳转页面和打开新窗口的方法</h2><h3 id="1、替换当前页-（重新定位当前页）"><a href="#1、替换当前页-（重新定位当前页）" class="headerlink" title="1、替换当前页 （重新定位当前页）"></a>1、替换当前页 （重新定位当前页）</h3><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">&quot;https://www.xxx.com&quot;</span>; <span class="hljs-comment">// 跳转到新的域名</span><span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">`/dashboard#/setting?type=1&amp;userId=123`</span>; <span class="hljs-comment">// 在当前域名下跳转到新的子页面</span><span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">&quot;https://www.xxx.com&quot;</span>; <span class="hljs-comment">// 跳转到新的域名</span><span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">`/dashboard#/setting?type=1&amp;userId=123`</span>; <span class="hljs-comment">// 在当前域名下跳转到新的子页面</span></code></pre><h3 id="2、打开新窗口"><a href="#2、打开新窗口" class="headerlink" title="2、打开新窗口"></a>2、打开新窗口</h3><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.open(<span class="hljs-string">&quot;https://www.xxx.com&quot;</span>); <span class="hljs-comment">// 跳转到新的域名</span><span class="hljs-built_in">window</span>.history.back(-<span class="hljs-number">1</span>); <span class="hljs-comment">// 返回到上一页（在当前窗口 ）</span></code></pre><h2 id="二、window-location-href-与-window-open-的区别"><a href="#二、window-location-href-与-window-open-的区别" class="headerlink" title="二、window.location.href 与 window.open() 的区别"></a>二、<code>window.location.href</code> 与 <code>window.open()</code> 的区别</h2><ul><li><p>区别一<br>　　<code>window.location</code>是<code>window</code>对象的<strong>属性</strong><br>　　<code>window.open()</code>是<code>window</code>对象的<strong>方法</strong></p></li><li><p>区别二<br>　　<code>window.location.href</code>是用新的域名<strong>替换当前页</strong>， 也就是重新定位当前页<br>　　<code>window.open()</code>是用来<strong>打开一个新窗口</strong>的函数！</p></li><li><p>区别三<br>　　<code>window.open()</code>可能会被浏览器拦截<br>　　<code>window.location.href</code>不会被窗口拦截</p></li><li><p><code>window.location.href</code> 和 <code>document.location.href</code>的区别：<br>　　<code>window.location.href</code> 和 <code>document.location.href</code>都可以对当前窗口进行重定向。（尽管 <code>Document.location</code> 是一个只读的 <code>Location</code> 对象，但是也能够赋给它一个 <code>DOMString</code>）<br>　　当服务器未发生重定向时, 两者是相同的。<br>　　但是当服务器发生了重定向,就不一样了:<br>　　- document.location包含的是已经装载的URL<br>　　- ocation.href包含的则是原始请求的文档的URL</p></li></ul><h2 id="三、window-location-href怎么跳转新窗口"><a href="#三、window-location-href怎么跳转新窗口" class="headerlink" title="三、window.location.href怎么跳转新窗口"></a>三、<code>window.location.href</code>怎么跳转新窗口</h2><p><code>window.location.href</code>是在当前窗口进行覆盖，那怎么跳转到新窗口呢？</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> tempwindow = <span class="hljs-built_in">window</span>.open(<span class="hljs-string">&#x27;_blank&#x27;</span>);tempwindow.location = <span class="hljs-string">&#x27;https://www.xxx.com&#x27;</span>; <span class="hljs-comment">// 可以打开新的地址</span><span class="hljs-comment">// tempwindow.location = &#x27;/dashboard#/setting?type=1&amp;userId=123&#x27;; // 也可以打开原有地址的子页面</span></code></pre><blockquote><p>参考资料：<br><a href="https://www.cnblogs.com/Qian123/p/5345298.html">window.location.href和window.open的几种用法和区别</a><br><a href="https://www.imooc.com/wenda/detail/323004">window.location.href怎么跳转新窗口</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-树</title>
    <link href="/2019/07/30/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E6%A0%91/"/>
    <url>/2019/07/30/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="一、树形结构"><a href="#一、树形结构" class="headerlink" title="一、树形结构"></a>一、树形结构</h2><p>属树形结构的遍历分为<strong>深度优先遍历</strong>和<strong>广度优先遍历</strong>。</p><ul><li>深度优先遍历<br>DFS（Depth First Search），对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。<br>深度优先遍历的算法：<ul><li>访问跟节点</li><li>对根节点的children挨个进行深度优先遍历</li></ul></li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dfs = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(root.val); <span class="hljs-comment">// 访问当前节点</span>    root.children.forEach(dfs); <span class="hljs-comment">// 递归 访问子节点</span>&#125;dfs(tree);</code></pre><ul><li>广度优先遍历<br>BFS（Breadth FirstSearch），对每一层节点依次访问，访问完一层进入下一层，而且每个节点只能访问一次。<br>广度优先遍历的算法：<ul><li>新建一个队列，把根节点入队</li><li>把队头出列并访问</li><li>把队头的children挨个入队</li><li>重复第二、三步，直到队列为空</li></ul></li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// 按照遍历层级的顺序，取出数组的头部数据数据并访问，再把数据的chiledren加入到数组的尾部</span>    <span class="hljs-keyword">const</span> bfs = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;        <span class="hljs-keyword">const</span> q = [root]; <span class="hljs-comment">// 先把各节点入队</span>        <span class="hljs-keyword">while</span>(q.length &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">const</span> n = q.shift(); <span class="hljs-comment">// 出队</span><span class="hljs-built_in">console</span>.log(n.val); <span class="hljs-comment">// 访问出队的数据</span><span class="hljs-keyword">if</span> (n.children) &#123;n.children.forEach(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;q.push(child);&#125;)&#125;        &#125;    &#125;    bfs(tree);</code></pre><h2 id="二、二叉树"><a href="#二、二叉树" class="headerlink" title="二、二叉树"></a>二、二叉树</h2><h3 id="1、什么是二叉树"><a href="#1、什么是二叉树" class="headerlink" title="1、什么是二叉树"></a>1、什么是二叉树</h3><ul><li>树中每个节点最多只能有两个子节点</li></ul><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binaryTree</span>(<span class="hljs-params">val, left, right</span>) </span>&#123;    <span class="hljs-built_in">this</span>.val = (val===<span class="hljs-literal">undefined</span> ? <span class="hljs-number">0</span> : val)    <span class="hljs-built_in">this</span>.left = (left===<span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : left)    <span class="hljs-built_in">this</span>.right = (right===<span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : right)&#125;<span class="hljs-keyword">const</span> br1 = &#123;    val: <span class="hljs-number">1</span>,    left: &#123;        val: <span class="hljs-number">2</span>,        left: &#123;            val: <span class="hljs-number">3</span>,            left: <span class="hljs-literal">null</span>,            right: <span class="hljs-literal">null</span>        &#125;,        right: &#123;            val: <span class="hljs-number">4</span>,            left: &#123;                val: <span class="hljs-number">5</span>,                left: <span class="hljs-literal">null</span>,                right: <span class="hljs-literal">null</span>            &#125;,            right: <span class="hljs-literal">null</span>        &#125;    &#125;,    right: &#123;        val: <span class="hljs-number">6</span>,        left: <span class="hljs-literal">null</span>,        right: &#123;            val: <span class="hljs-number">7</span>,            left: <span class="hljs-literal">null</span>,            right: <span class="hljs-literal">null</span>        &#125;    &#125;&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 深度优先遍历二叉树</span><span class="hljs-keyword">const</span> dfs = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;    <span class="hljs-built_in">console</span>.log(root.val);    dfs(root.left);    dfs(root.right)&#125;</code></pre><img src="https://i.loli.net/2020/12/16/gaiK7fz8kS9tMum.png" width="30%" height="30%"><h3 id="2、先序遍历算法"><a href="#2、先序遍历算法" class="headerlink" title="2、先序遍历算法"></a>2、先序遍历算法</h3><p>根 -&gt; 左 -&gt; 右</p><ul><li>访问<strong>根</strong>节点</li><li>对根节点的<strong>左</strong>子树进行先序遍历</li><li>对根节点的<strong>右</strong>子树进行先序遍历</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// 先序遍历 -&gt; 递归版</span><span class="hljs-keyword">const</span> preorder = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-built_in">console</span>.log(root.val);    preorder(root.left);    preorder(root.right);&#125;<span class="hljs-comment">// 先序遍历 -&gt; 非递归版</span><span class="hljs-keyword">const</span> preorder2 = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">const</span> stack = [root];    <span class="hljs-keyword">while</span> (stack.length) &#123;        <span class="hljs-keyword">const</span> n = stack.pop();        <span class="hljs-built_in">console</span>.log(n.val);        <span class="hljs-keyword">if</span> (n.right) stack.push(n.right);        <span class="hljs-keyword">if</span> (n.left) stack.push(n.left);    &#125;&#125;</code></pre><h3 id="3、中序遍历算法"><a href="#3、中序遍历算法" class="headerlink" title="3、中序遍历算法"></a>3、中序遍历算法</h3><p>左 -&gt; 根 -&gt; 右</p><ul><li>对根节点的<strong>左</strong>子树进行先序遍历</li><li>访问<strong>根</strong>节点</li><li>对根节点的<strong>右</strong>子树进行先序遍历</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// 中序遍历 -&gt; 递归版</span><span class="hljs-keyword">const</span> inorder = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span>;    &#125;    inorder(root.left);    <span class="hljs-built_in">console</span>.log(root.val);    inorder(root.right);&#125;<span class="hljs-comment">// 中序遍历 -&gt; 非递归版</span><span class="hljs-keyword">const</span> inorder2 = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">const</span> stack = [];    <span class="hljs-keyword">let</span> p = root;    <span class="hljs-keyword">while</span> (stack.length || p) &#123;        <span class="hljs-keyword">while</span>(p) &#123;            stack.push(p);            p = p.left;        &#125;        <span class="hljs-keyword">const</span> n = stack.pop();        <span class="hljs-built_in">console</span>.log(n.val);        p = n.right;    &#125;&#125;</code></pre><h3 id="4、后序遍历算法"><a href="#4、后序遍历算法" class="headerlink" title="4、后序遍历算法"></a>4、后序遍历算法</h3><p>左 -&gt; 右 &gt; 根</p><ul><li>对根节点的<strong>左</strong>子树进行先序遍历</li><li>对根节点的<strong>右</strong>子树进行先序遍历</li><li>访问<strong>根</strong>节点</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// 后序遍历 -&gt; 递归版</span><span class="hljs-keyword">const</span> postorder = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span>;    &#125;    postorder(root.left);    postorder(root.right);    <span class="hljs-built_in">console</span>.log(root.val);&#125;<span class="hljs-comment">// 后序遍历 -&gt; 非递归版</span><span class="hljs-keyword">const</span> postorder2 = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">const</span> outputStack = [];    <span class="hljs-keyword">const</span> stack = [root];    <span class="hljs-keyword">const</span> res = [];    <span class="hljs-keyword">while</span> (stack.length) &#123;        <span class="hljs-keyword">const</span> n = stack.pop();        outputStack.push(n);        <span class="hljs-keyword">if</span> (n.left) stack.push(n.left);        <span class="hljs-keyword">if</span> (n.right) stack.push(n.right);    &#125;     <span class="hljs-keyword">while</span>(outputStack.length) &#123;        <span class="hljs-keyword">const</span> n = outputStack.pop();        <span class="hljs-built_in">console</span>.log(n.val);    &#125;&#125;</code></pre><h2 id="三、二叉树练习题"><a href="#三、二叉树练习题" class="headerlink" title="三、二叉树练习题"></a>三、二叉树练习题</h2><h3 id="1、二叉树最大深度"><a href="#1、二叉树最大深度" class="headerlink" title="1、二叉树最大深度"></a>1、二叉树最大深度</h3><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">leetcode-104</a></p><p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。<br>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><pre><code class="hljs text">  3 / \9  20  /  \ 15   7</code></pre><p>返回它的最大深度 3 。</p><pre><code class="hljs text">题解：1. 深度优先遍历二叉树的每一个节点2. 在遍历时记录每个节点的深度, 返回最大深度</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> maxDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">root, l</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;            res = <span class="hljs-built_in">Math</span>.max(res, l);        &#125;        dfs(root.left, l + <span class="hljs-number">1</span>);        dfs(root.right, l + <span class="hljs-number">1</span>)    &#125;    dfs(root, <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> res;&#125;;</code></pre><h3 id="2、二叉树最小深度"><a href="#2、二叉树最小深度" class="headerlink" title="2、二叉树最小深度"></a>2、二叉树最小深度</h3><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">leetcode-111</a></p><p>给定一个二叉树，找出其最小深度。<br>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>说明：叶子节点是指没有子节点的节点。</p><p>提示：</p><ul><li>树中节点数的范围在 [0, 105] 内</li><li>-1000 &lt;= Node.val &lt;= 1000</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> minDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;&#125;;</code></pre><pre><code class="hljs text">解法：方法一：可以沿用之前【二叉树最大深度】题目的&#x27;深度优先遍历&#x27;方法，获取最小深度；方法二：使用&#x27;广度优先遍历&#x27;，当最先遍历到叶子节点时，即为最小深度</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> minDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-comment">// 深度优先遍历: 需要遍历到所有的节点, 比较耗时</span>    <span class="hljs-comment">// let minLen = Infinity;</span>    <span class="hljs-comment">// const dpt = (root, l) =&gt; &#123;</span>    <span class="hljs-comment">//     if (!root.left &amp;&amp; !root.right) &#123;</span>    <span class="hljs-comment">//         minLen = Math.min(minLen, l);</span>    <span class="hljs-comment">//     &#125;</span>    <span class="hljs-comment">//     if (root.left) dpt(root.left, l + 1);</span>    <span class="hljs-comment">//     if (root.right) dpt(root.right, l + 1);</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-comment">// dpt(root, 1);</span>    <span class="hljs-comment">// return minLen;</span>    <span class="hljs-comment">// 广度优先遍历: 只需要到遍历到第一个叶子节点即可</span>    <span class="hljs-keyword">let</span> minLen;    <span class="hljs-keyword">const</span> stack = [[root, <span class="hljs-number">1</span>]];    <span class="hljs-keyword">while</span> (stack.length) &#123;        <span class="hljs-keyword">const</span> [n, l] = stack.shift();        <span class="hljs-keyword">if</span> (!n.left &amp;&amp; !n.right) &#123;            <span class="hljs-keyword">return</span> l;        &#125;        <span class="hljs-keyword">if</span> (n.left) stack.push([n.left, l + <span class="hljs-number">1</span>]);        <span class="hljs-keyword">if</span> (n.right) stack.push([n.right, l + <span class="hljs-number">1</span>]);    &#125;&#125;;</code></pre><h3 id="3、二叉树的层序遍历"><a href="#3、二叉树的层序遍历" class="headerlink" title="3、二叉树的层序遍历"></a>3、二叉树的层序遍历</h3><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">leetcode-102</a></p><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><pre><code class="hljs text">示例：二叉树：[3,9,20,null,null,15,7],    3   / \  9  20    /  \   15   7返回其层序遍历结果：[  [3],  [9,20],  [15,7]]</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * function TreeNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.left = this.right = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-comment">//  广度优先遍历 + map  【推荐 一颗星】</span>    <span class="hljs-comment">//   if (!root) return [];</span>    <span class="hljs-comment">// var bfs = (root, l) =&gt; &#123;</span>    <span class="hljs-comment">// var stack = [[root, l]];</span>    <span class="hljs-comment">// var res = new Map();</span>    <span class="hljs-comment">// while (stack.length) &#123;</span>    <span class="hljs-comment">//  var [n, l] = stack.shift();</span>    <span class="hljs-comment">//  console.log(n.val, l);</span>    <span class="hljs-comment">//  if (!res.has(l)) &#123;</span>    <span class="hljs-comment">// res.set(l, [n.val])</span>    <span class="hljs-comment">//  &#125; else &#123;</span>    <span class="hljs-comment">// let val = res.get(l);</span>    <span class="hljs-comment">// val.push(n.val);</span>    <span class="hljs-comment">// res.set(l, val)</span>    <span class="hljs-comment">//  &#125;</span>    <span class="hljs-comment">//  if (n.left) stack.push([n.left, l + 1]);</span>    <span class="hljs-comment">//  if (n.right) stack.push([n.right, l + 1]); </span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-comment">// return res;</span>    <span class="hljs-comment">//   &#125;</span>    <span class="hljs-comment">//   const map = bfs(root, 1);</span>    <span class="hljs-comment">//   const res = [];</span>    <span class="hljs-comment">//   for(let [key, val] of map) &#123;</span>    <span class="hljs-comment">// res.push(val)</span>    <span class="hljs-comment">//   &#125;</span>    <span class="hljs-comment">//   return res;</span>    <span class="hljs-comment">// 广度优先遍历   【推荐 二颗星】</span>    <span class="hljs-comment">// if (!root) return [];</span>    <span class="hljs-comment">// var stack = [[root, 0]];</span>    <span class="hljs-comment">// var res = [];</span>    <span class="hljs-comment">// while (stack.length) &#123;</span>    <span class="hljs-comment">//     var [n, level] = stack.shift();</span>    <span class="hljs-comment">//     if (!res[level]) &#123;</span>    <span class="hljs-comment">//         res.push([n.val]);</span>    <span class="hljs-comment">//     &#125; else &#123;</span>    <span class="hljs-comment">//         res[level].push(n.val);</span>    <span class="hljs-comment">//     &#125;</span>    <span class="hljs-comment">//     if (n.left) stack.push([n.left, level + 1]);</span>    <span class="hljs-comment">//     if (n.right) stack.push([n.right, level + 1]); </span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-comment">// return res;</span>    <span class="hljs-comment">// 广度优先遍历 - 每次清空当前层级数据    【推荐 三颗星】</span>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];    <span class="hljs-keyword">const</span> stack = [root];    <span class="hljs-keyword">const</span> res = [];    <span class="hljs-keyword">while</span>(stack.length) &#123;        res.push([]);        <span class="hljs-keyword">let</span> len = stack.length;        <span class="hljs-keyword">while</span>(len--) &#123;            <span class="hljs-keyword">const</span> n = stack.shift();            res[res.length - <span class="hljs-number">1</span>].push(n.val);            <span class="hljs-keyword">if</span> (n.left) stack.push(n.left);            <span class="hljs-keyword">if</span> (n.right) stack.push(n.right);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre><h3 id="4、二叉树的锯齿形层序遍历"><a href="#4、二叉树的锯齿形层序遍历" class="headerlink" title="4、二叉树的锯齿形层序遍历"></a>4、二叉树的锯齿形层序遍历</h3><p><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">leetcode-103</a></p><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><pre><code class="hljs text">例如：给定二叉树 [3,9,20,null,null,15,7],    3   / \  9  20    /  \   15   7返回锯齿形层序遍历如下：[  [3],  [20,9],  [15,7]]</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * function TreeNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.left = this.right = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 按照顺序获得结果，然后在锯齿位置反转数组</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> zigzagLevelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">let</span> stack = [root];<span class="hljs-keyword">while</span>(stack.length) &#123;        <span class="hljs-keyword">let</span> len = stack.length;        res.push([]);        <span class="hljs-keyword">while</span>(len--) &#123;    <span class="hljs-keyword">const</span> n = stack.shift();            res[res.length - <span class="hljs-number">1</span>].push(n.val);            <span class="hljs-keyword">if</span> (n.left) stack.push(n.left);            <span class="hljs-keyword">if</span> (n.right) stack.push(n.right);        &#125;&#125;    res.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> index % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? item : item.reverse());<span class="hljs-keyword">return</span> res;&#125;;</code></pre><h3 id="5、二叉树的所有路径"><a href="#5、二叉树的所有路径" class="headerlink" title="5、二叉树的所有路径"></a>5、二叉树的所有路径</h3><p><a href="https://leetcode-cn.com/problems/binary-tree-paths/">leetcode-257</a></p><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p><pre><code class="hljs text">例如：输入:   1 /   \2     3 \  5输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> binaryTreePaths = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];    <span class="hljs-keyword">const</span> res = [];    <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">root, str = <span class="hljs-string">&#x27;&#x27;</span></span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (root.left) dfs(root.left, str + root.val + <span class="hljs-string">&#x27;-&gt;&#x27;</span>);        <span class="hljs-keyword">if</span> (root.right) dfs(root.right, str + root.val + <span class="hljs-string">&#x27;-&gt;&#x27;</span>);        <span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right) res.push(str + root.val);        <span class="hljs-keyword">return</span>;     &#125;    dfs(root);    <span class="hljs-keyword">return</span> res;&#125;;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React step 3 —— React面试题</title>
    <link href="/2019/05/16/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React-step3/"/>
    <url>/2019/05/16/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React-step3/</url>
    
    <content type="html"><![CDATA[<h3 id="1、组件之间如何通讯"><a href="#1、组件之间如何通讯" class="headerlink" title="1、组件之间如何通讯"></a>1、组件之间如何通讯</h3><ul><li>父子组件 props</li><li>自定义事件</li><li>Redux 和 Context</li></ul><h3 id="2、JSX本质是什么"><a href="#2、JSX本质是什么" class="headerlink" title="2、JSX本质是什么"></a>2、JSX本质是什么</h3><ul><li>JSX解析出来后是一个 createElement 函数</li><li>函数执行后会返回 vnode</li><li>vnode 通过 patch 渲染到页面</li></ul><h3 id="3、Context-是什么，如何使用"><a href="#3、Context-是什么，如何使用" class="headerlink" title="3、Context 是什么，如何使用"></a>3、Context 是什么，如何使用</h3><ul><li>父组件 向其下所有子孙组件传递信息</li><li>比如一些简单的公共信息：如 主题色、语言等</li><li>复杂的公共信息 请用 Redux</li></ul><h3 id="4、shouldComponentUpdate-用途"><a href="#4、shouldComponentUpdate-用途" class="headerlink" title="4、shouldComponentUpdate 用途"></a>4、shouldComponentUpdate 用途</h3><ul><li>性能优化</li><li>配合state的”不可变值“ 一起使用，否则会出错</li></ul><h3 id="5、Redux-单项数据流"><a href="#5、Redux-单项数据流" class="headerlink" title="5、Redux 单项数据流"></a>5、Redux 单项数据流</h3><img src="https://i.loli.net/2020/12/30/1XfzRaJ8dYcnT6x.png" ><img src="https://i.loli.net/2020/12/30/luqEbTaCHQL3Iwf.png" ><h3 id="5、setState-场景题"><a href="#5、setState-场景题" class="headerlink" title="5、setState 场景题"></a>5、setState 场景题</h3><img src="https://i.loli.net/2021/01/01/pHPVRyw5iodLrJD.png" ><h3 id="6、什么是纯函数"><a href="#6、什么是纯函数" class="headerlink" title="6、什么是纯函数"></a>6、什么是纯函数</h3><p>纯函数： 执行函数后 返回一个新值, 没有副作用（不会修改函数以外的值）</p><h3 id="7、React组件生命周期"><a href="#7、React组件生命周期" class="headerlink" title="7、React组件生命周期"></a>7、React组件生命周期</h3><ul><li>单个组件生命周期</li><li>父子组件生命周期、调用顺序（创建、更新、销毁）</li><li>shouldComponentUpdate 函数的作用</li></ul><h3 id="8、React发起ajax应该在哪个生命周期"><a href="#8、React发起ajax应该在哪个生命周期" class="headerlink" title="8、React发起ajax应该在哪个生命周期"></a>8、React发起ajax应该在哪个生命周期</h3><ul><li>同Vue（mounted）</li><li>componentDidMount</li></ul><h3 id="9、渲染列表，为什么使用key"><a href="#9、渲染列表，为什么使用key" class="headerlink" title="9、渲染列表，为什么使用key"></a>9、渲染列表，为什么使用key</h3><ul><li>同Vue。必须使用key， 且不能是 index 和 random</li><li>diff算法中通过 tag 和 key 来判断 是否是 sameNode</li><li>目的是 减少渲染次数，提升渲染性能</li></ul><h3 id="10、函数组件和-class-组件的区别"><a href="#10、函数组件和-class-组件的区别" class="headerlink" title="10、函数组件和 class 组件的区别"></a>10、函数组件和 class 组件的区别</h3><ul><li>纯函数， 输入 props， 输出JSX</li><li>没有实例，没有生命周期，没有state</li><li>不能扩展其他方法</li></ul><h3 id="11、-什么是受控组件-和-非受控组件"><a href="#11、-什么是受控组件-和-非受控组件" class="headerlink" title="11、 什么是受控组件 和 非受控组件"></a>11、 什么是受控组件 和 非受控组件</h3><p>受控组件：</p><ul><li>表单的值 受 state 控制</li><li>需要自行监听 onChange， 更新 state</li></ul><p>非受控组件：表单的值 不受 state 控制</p><p>非受控组件使用场景：</p><ul><li>必须手动操作DOM元素，setState实现不了</li><li>比如： 文件上传 <code>&lt;input type=file&gt;</code></li><li>某些富文本编辑器，需要传入DOM元素</li></ul><h3 id="12、-何时使用异步组件"><a href="#12、-何时使用异步组件" class="headerlink" title="12、 何时使用异步组件"></a>12、 何时使用异步组件</h3><ul><li>同vue</li><li>加载大组件</li><li>路由懒加载</li></ul><p>API：</p><ul><li>import()</li><li>React.lazy</li><li>React.Suspense</li></ul><h3 id="13、-多个组件有公共逻辑，如何抽离"><a href="#13、-多个组件有公共逻辑，如何抽离" class="headerlink" title="13、 多个组件有公共逻辑，如何抽离"></a>13、 多个组件有公共逻辑，如何抽离</h3><ul><li>高阶组件 HOC</li><li>Render Props</li></ul><h3 id="14、-Redux-如何进行异步请求"><a href="#14、-Redux-如何进行异步请求" class="headerlink" title="14、 Redux 如何进行异步请求"></a>14、 Redux 如何进行异步请求</h3><ul><li>使用异步 action</li><li>如 redux-thunk</li></ul><h3 id="15、-react-router-如何配置路由懒加载"><a href="#15、-react-router-如何配置路由懒加载" class="headerlink" title="15、 react-router 如何配置路由懒加载"></a>15、 react-router 如何配置路由懒加载</h3><img src="https://i.loli.net/2021/01/01/dq1AOPsMivhaHRe.png" ><h3 id="16、-component-和-PureComponent-有何区别"><a href="#16、-component-和-PureComponent-有何区别" class="headerlink" title="16、 component 和 PureComponent 有何区别"></a>16、 component 和 PureComponent 有何区别</h3><ul><li>PureComponent 实现了浅比较的 shouldComponentUpdate （diff了state第一层的值）</li><li>优化性能</li><li>但是要配合 state 的不可变值使用</li></ul><h3 id="17、-React-事件-和-DOM-事件的区别"><a href="#17、-React-事件-和-DOM-事件的区别" class="headerlink" title="17、 React 事件 和 DOM 事件的区别"></a>17、 React 事件 和 DOM 事件的区别</h3><ul><li>所有事件挂在到 document 上</li><li>event 不是原生的，是 SyntheticEvent 合成事件对象</li><li>引用了 dispatchEvent 机制 (派发事件)</li></ul><h3 id="18、-React-性能优化"><a href="#18、-React-性能优化" class="headerlink" title="18、 React 性能优化"></a>18、 React 性能优化</h3><ol><li>渲染事件是增加合适的key</li><li>自定义事件、DOM 事件 及时销毁</li><li>合理使用异步组件 ——异步加载大组件</li><li>减少函数 bind this 的次数</li><li>合理使用 shouldComponentUpdate PureComponent 和 memo</li><li>合理使用 Immutable.js ——是否彻底拥抱不可变值</li><li>webpack 层面的优化</li><li>前端通用的性能优化，如图片懒加载</li><li>使用 SSR</li></ol><h3 id="19、-React-和-Vue-的区别"><a href="#19、-React-和-Vue-的区别" class="headerlink" title="19、 React 和 Vue 的区别"></a>19、 React 和 Vue 的区别</h3><p>相同点：</p><ol><li>都支持组件化</li><li>都支持数据驱动视图</li><li>都是用 vdom 操作 DOM</li></ol><p>区别：</p><ol><li>React 使用 JSX 拥抱 JS， Vue 使用模板拥抱 HTML</li><li>React 函数式编程（setState传入一个state，返回一个JSX或者视图）， Vue 声明时编程（声明state的值）</li><li>React 需要更多的自力更生（比如shouldComponentUpdate，没有watch，没有computed，自己通过js实现）， Vue 把想要的都给你</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack 详解</title>
    <link href="/2019/05/16/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Webpack/"/>
    <url>/2019/05/16/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Webpack/</url>
    
    <content type="html"><![CDATA[<h2 id="一-webpack-配置"><a href="#一-webpack-配置" class="headerlink" title="一 webpack 配置"></a>一 webpack 配置</h2><p>配置项细节知识点：</p><h3 id="1-loader-的执行顺序"><a href="#1-loader-的执行顺序" class="headerlink" title="1. loader 的执行顺序"></a>1. loader 的执行顺序</h3><p> 从后往前 (因此引入的一些全局插件,需要放到最后的配置中. 比如 postcss-loader(用于兼容所有浏览器的), 要放到所有 css loader 配置的后面)</p><h3 id="2-多入口配置方法"><a href="#2-多入口配置方法" class="headerlink" title="2. 多入口配置方法"></a>2. 多入口配置方法</h3><ul><li><ol><li><p>入口 entry 配置多个</p><pre><code class="hljs JavaScript">entry: &#123;index: path.join(srcPath, <span class="hljs-string">&#x27;index.js&#x27;</span>),other: path.join(srcPath, <span class="hljs-string">&#x27;other.js&#x27;</span>),&#125;</code></pre></li></ol></li><li><ol start="2"><li><p>输出 output 配置多个</p><pre><code class="hljs JavaScript">output: &#123;<span class="hljs-comment">// name 即多入口时 entry 中入口文件的名称</span>filename: <span class="hljs-string">&#x27;[name].[contentHans:8].js&#x27;</span>,path: distPath,&#125;</code></pre></li></ol></li><li><ol start="3"><li><p>plugin 要针对每个入口都要建一个生成 HTML 的 HtmlWebpackPlugin 配置</p><pre><code class="hljs JavaScript">plugins: [<span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;template: path.join(srcPath, <span class="hljs-string">&#x27;index.html&#x27;</span>),filename: <span class="hljs-string">&#x27;index.html&#x27;</span>,<span class="hljs-comment">// chunks 表示要引用哪些 chunk (设置 index.html 只引用 index.js 文件)</span>chunks: [<span class="hljs-string">&#x27;index&#x27;</span>, <span class="hljs-string">&#x27;vendor&#x27;</span>, <span class="hljs-string">&#x27;common&#x27;</span>]  <span class="hljs-comment">// index.js 对应 entry 中定义的入口文件名</span><span class="hljs-comment">// vendor 代表打包的第三方文件, common 代表公共模块代码</span>&#125;),<span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;template: path.join(srcPath, <span class="hljs-string">&#x27;other.html&#x27;</span>),filename: <span class="hljs-string">&#x27;other.html&#x27;</span>,<span class="hljs-comment">// chunks 表示要引用哪些 chunk (设置 other.html 只引用 other.js 文件)</span>chunks: [<span class="hljs-string">&#x27;other&#x27;</span>, <span class="hljs-string">&#x27;vendor&#x27;</span>, <span class="hljs-string">&#x27;common&#x27;</span>]  <span class="hljs-comment">// other.js 对应 entry 中定义的入口文件名</span><span class="hljs-comment">// vendor 代表打包的第三方文件, common 代表公共模块代码</span>&#125;)]</code></pre></li></ol></li></ul><h3 id="3-文件的异步加载"><a href="#3-文件的异步加载" class="headerlink" title="3. 文件的异步加载"></a>3. 文件的异步加载</h3><p> webpack 原生支持的，不需要要做配置，只需要引入的文件 用 import() 方法即可。 异步加载的文件也是生成的一个单独 chunk</p><pre><code class="hljs JavaScript"><span class="hljs-comment">// 异步加载的文件 import()方法返回一个 promise</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./dynamic-demo.js&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<span class="hljs-comment">// 注意这里的 default, 获取对应的资源</span><span class="hljs-built_in">console</span>.log(res.default.xxx()); &#125;)<span class="hljs-comment">// 非异步加载的文件</span><span class="hljs-keyword">import</span> css <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./cssFile/index.css&#x27;</span>;</code></pre><h2 id="二-webpack-性能优化"><a href="#二-webpack-性能优化" class="headerlink" title="二  webpack 性能优化"></a>二  webpack 性能优化</h2><h3 id="1-优化打包构建速度-——-开发体验和效率"><a href="#1-优化打包构建速度-——-开发体验和效率" class="headerlink" title="1. 优化打包构建速度 —— 开发体验和效率"></a>1. 优化打包构建速度 —— 开发体验和效率</h3><h4 id="1-优化-babel-loader-开发"><a href="#1-优化-babel-loader-开发" class="headerlink" title="(1) 优化 babel-loader - 开发"></a>(1) 优化 babel-loader - 开发</h4><p>使用 <code>webpack</code> 缓存的方法有几种：<code>cache-loader</code>，<code>HardSourceWebpackPlugin</code> 或 <code>babel-loader</code> 的 <code>cacheDirectory</code> 标志</p><pre><code class="hljs JavaScript">&#123;test: <span class="hljs-regexp">/\.js$/</span>,use: [<span class="hljs-string">&#x27;babel-loader?cacheDirectory&#x27;</span>], <span class="hljs-comment">// 开启缓存</span><span class="hljs-comment">// 对于 babel-loader 解析的文件进行缓存</span>includes: srcPath<span class="hljs-comment">// 或者使用 cache-loader 插件</span>&#125;</code></pre><h4 id="2-noParse-开发-生产"><a href="#2-noParse-开发-生产" class="headerlink" title="(2) noParse - 开发/生产"></a>(2) noParse - 开发/生产</h4><p>过滤不需要解析的文件，比如打包的时候依赖了三方库（jquyer、lodash），提高打包的速度</p><h4 id="3-happyPack-开发-生产"><a href="#3-happyPack-开发-生产" class="headerlink" title="(3) happyPack - 开发/生产"></a>(3) happyPack - 开发/生产</h4><p>多进程打包或构建本地环境。(JS是单线程的).<br>除了 happyPack ，多进程打包还有一个插件  thread-loader<br>如果小项目，文件不多，无需开启多进程打包，反而会变慢，因为开启进程是需要花费时间的。</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> HappyPack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;happypack&#x27;</span>);<span class="hljs-built_in">module</span>: &#123;rules: [<span class="hljs-comment">// js</span>&#123;test: <span class="hljs-regexp">/\.js$/</span>,<span class="hljs-comment">// 把 .js 文件转交给 id 为 happyScss 的 HappyPack 实例对象处理</span>use: [<span class="hljs-string">&#x27;happyPack/loader?id=happyScss&#x27;</span>],include: srcPath&#125;]&#125;,plugins: [<span class="hljs-comment">// happyPack 开启多进程打包</span><span class="hljs-keyword">new</span> HappyPack(&#123;<span class="hljs-comment">// 用唯一 id 达标当前 happyPack 是用来处理哪些文件</span>id: <span class="hljs-string">&#x27;happyScss&#x27;</span>,<span class="hljs-comment">// 如何处理, 用法与 loader 配置中的一样</span>loaders: [<span class="hljs-string">&#x27;babel-loader?cacheDiewctory&#x27;</span>]&#125;)]</code></pre><h4 id="4-自动刷新-开发"><a href="#4-自动刷新-开发" class="headerlink" title="(4) 自动刷新- 开发"></a>(4) 自动刷新- 开发</h4><p>modele.export = { watch: true }</p><h4 id="5-热更新-开发"><a href="#5-热更新-开发" class="headerlink" title="(5) 热更新 - 开发"></a>(5) 热更新 - 开发</h4><p>自动刷新: 整个网页全部刷新，速度慢，状态会丢失<br>热更新: 新代码生效，网页不刷新，状态不丢失</p><pre><code class="hljs JavaScript"><span class="hljs-comment">// webpack.config.js 配置文件</span><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);plugins: [<span class="hljs-keyword">new</span> webpack.HotModuleReplacementPlugin(),],devServer: &#123;hot: <span class="hljs-literal">true</span>,&#125;<span class="hljs-comment">// main.js</span><span class="hljs-comment">// 除此之外，还需要在 main.js 中配置热更新范围</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">module</span>.hot) &#123;<span class="hljs-built_in">module</span>.hot.accept(<span class="hljs-string">&#x27;./App&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;ReactDOM.unmountComponentAtNode(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>));render(App);&#125;);&#125;</code></pre><h4 id="6-DllPlugin-开发"><a href="#6-DllPlugin-开发" class="headerlink" title="(6) DllPlugin - 开发"></a>(6) DllPlugin - 开发</h4><p>动态链接库插件</p><ul><li>webpack 已经内置了 DLLPlugin 支持</li><li>DLLPlugin —— 打包出 dll 文件</li><li>DllReferencePlugin —— 使用 dll 文件</li></ul><p>步骤：</p><ol><li><p>打包生成 dll 文件：通过 package.json 中添加 dll 的打包命令，执行 webpack.dll.js 文件中定义的打包命令进行打包。（产出一个打包文件react.dll.js 和 一个索引文件 react.manifest.js</p></li><li><p>引用 dll 文件：首先在 html 的模板文件中引用打包生成的 dll 文件（react.dll.js），然后通过 DllReferencePlugin 插件告诉 webpack 使用了哪些动态链接库 和 dll 文件索引位置（react.manifest.js）</p></li></ol><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./react.dll.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="2-优化产出代码-产品性能"><a href="#2-优化产出代码-产品性能" class="headerlink" title="2. 优化产出代码 - 产品性能"></a>2. 优化产出代码 - 产品性能</h3><h4 id="1-小图片-base64-编码"><a href="#1-小图片-base64-编码" class="headerlink" title="(1) 小图片 base64 编码"></a>(1) 小图片 base64 编码</h4><pre><code class="hljs JavaScript"><span class="hljs-built_in">module</span>: &#123;       rules: [&#123;test: <span class="hljs-regexp">/\.(png|jpg|gif)/</span>,include: [path.join(__dirname, <span class="hljs-string">&#x27;..&#x27;</span>, <span class="hljs-string">&#x27;src&#x27;</span>), path.join(__dirname, <span class="hljs-string">&#x27;..&#x27;</span>, <span class="hljs-string">&#x27;server&#x27;</span>)],use: [&#123;loader: <span class="hljs-string">&#x27;url-loader&#x27;</span>,options: &#123; <span class="hljs-attr">limit</span>: <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> &#125;,&#125;],&#125;]&#125;</code></pre><h4 id="2-bundle-加-hash"><a href="#2-bundle-加-hash" class="headerlink" title="(2) bundle 加 hash"></a>(2) bundle 加 hash</h4><pre><code class="hljs JavaScript">output: &#123;path: path.join(__dirname, <span class="hljs-string">&#x27;..&#x27;</span>, <span class="hljs-string">&#x27;dist_client&#x27;</span>),filename: <span class="hljs-string">&#x27;[name].[contentHash:8].js&#x27;</span>,&#125;</code></pre><h4 id="3-懒加载"><a href="#3-懒加载" class="headerlink" title="(3) 懒加载"></a>(3) 懒加载</h4><p>通过 import() 实现懒加载</p><h4 id="4-splitChunks-抽离公共代码-和-第三方代码"><a href="#4-splitChunks-抽离公共代码-和-第三方代码" class="headerlink" title="(4) splitChunks 抽离公共代码 和 第三方代码"></a>(4) splitChunks 抽离公共代码 和 第三方代码</h4><p>抽离的步骤：</p><ul><li><ol><li><p>在 optimization 配置要抽离的属性</p><pre><code class="hljs JavaScript">plugins: [ ],optimization: &#123;<span class="hljs-comment">// 压缩CSS</span>minimizer: [],<span class="hljs-comment">// 分割代码块</span>splitChunks: &#123;<span class="hljs-comment">// chunks有三个可设置项: all initial async</span><span class="hljs-comment">// initial(对异步导入的文件不处理) async(只处理异步文件)</span>chunks: <span class="hljs-string">&#x27;all&#x27;</span>,<span class="hljs-comment">// 缓存分组</span>cacheGrops: &#123;<span class="hljs-comment">// 第三方模块</span>vendor: &#123;name: <span class="hljs-string">&#x27;vendor&#x27;</span>, <span class="hljs-comment">// 打包后生成的 chunk 文件名称</span>priority: <span class="hljs-number">1</span>, <span class="hljs-comment">// 权重等级，设置为最高，优先抽离！！</span>test: <span class="hljs-regexp">/node_modules/</span>,minSize: <span class="hljs-number">3</span>, <span class="hljs-comment">// 大小限制，小于 3kb 的文件不抽离</span>minChunks: <span class="hljs-number">1</span> <span class="hljs-comment">// 最少引用次数，低于1次的不做抽离</span>&#125;,<span class="hljs-comment">// 公共的模块</span>common: &#123;name: <span class="hljs-string">&#x27;common&#x27;</span>, <span class="hljs-comment">// chunk 名称</span>priority: <span class="hljs-number">0</span>, <span class="hljs-comment">// 优先级</span>miniSize: <span class="hljs-number">0</span>, <span class="hljs-comment">// 公共模块的大小限制</span>minChunks: <span class="hljs-number">2</span> <span class="hljs-comment">// 引用次数低于2次的不做抽离</span>&#125;&#125;&#125;&#125;</code></pre></li></ol></li><li><ol start="2"><li><p>在 outPut 输出的文件中引用抽离的模块</p><pre><code class="hljs JavaScript">plugins: [<span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;template: path.join(srcPath, <span class="hljs-string">&#x27;index.html&#x27;</span>),filename: <span class="hljs-string">&#x27;index.html&#x27;</span>,<span class="hljs-comment">// chunks 表示要引用哪些 chunk </span>chunks: [<span class="hljs-string">&#x27;index&#x27;</span>, <span class="hljs-string">&#x27;vendor&#x27;</span>, <span class="hljs-string">&#x27;common&#x27;</span>]  <span class="hljs-comment">// index.js 对应 entry 中定义的入口文件名</span><span class="hljs-comment">// vendor 代表打包的第三方文件, common 代表公共模块代码</span>&#125;)]</code></pre></li></ol></li></ul><h4 id="5-IgnorePlugin"><a href="#5-IgnorePlugin" class="headerlink" title="(5) IgnorePlugin"></a>(5) IgnorePlugin</h4><p>忽略 moment 的本地化内容<br><code>new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/)</code></p><h4 id="6-使用-CDN-加速"><a href="#6-使用-CDN-加速" class="headerlink" title="(6) 使用 CDN 加速"></a>(6) 使用 CDN 加速</h4><pre><code class="hljs JavaScript"><span class="hljs-comment">// webpack.dev.js</span>   output: &#123;       filename: <span class="hljs-string">&#x27;[name].js&#x27;</span>,       chunkFilename: <span class="hljs-string">&#x27;[name].js&#x27;</span>,       publicPath: <span class="hljs-string">&#x27;http://127.0.0.1:9000/beauty/assets/&#x27;</span>, &#125; <span class="hljs-comment">// webpack.prod.js (在打包的图片地址上也需要增加 cdn 地址)</span>   output: &#123;       filename: <span class="hljs-string">&#x27;[name]_[chunkhash].js&#x27;</span>,  chunkFilename: <span class="hljs-string">&#x27;[name]_[chunkhash].js&#x27;</span>,  <span class="hljs-comment">// 修改所有静态文件的 url 的前缀</span>       publicPath: <span class="hljs-string">&#x27;//b.yzcdn.cn/beauty/assets/&#x27;</span>,   &#125;</code></pre><h4 id="7-使用-production-环境"><a href="#7-使用-production-环境" class="headerlink" title="(7) 使用 production 环境"></a>(7) 使用 production 环境</h4><ul><li><p>作用1：自动压缩<br>  在 <code>webpack 4.0</code> 中只需要添加 <code>mode: &#39;production&#39;</code>， 则自动开启代码压缩(开发环境 <code>mode: &#39;development&#39;</code>)。<br>  如果<code>webpack</code> 自己的压缩比较慢，可以通过 <code>ParalleUgifyPlugin</code>(<code>webpack-parallel-uglify-plugin</code>) 手动开启多进程压缩。<br>  <code>webpack 4.0</code> 默认内置了 <code>terser-webpack-plugin</code></p></li><li><p>作用2：<code>Vue/React</code> 会自动删掉调试代码（如开发环境的 <code>warning</code>），体积更小</p></li><li><p>作用3：启动 <code>Teee-Shaking</code><br>  过滤掉未引用 或者 未使用的函数、文件。<br>  前提：<code>ES6 Module</code> 才能让 <code>Tree-Shaking</code> 生效；<code>commonJs</code> 就不行。<br>  <code>ES6 Module</code> 和 <code>commonJS</code> 的区别：<br>  — <code>ES6 Module</code> 是静态引入，编译时引入(<code>import a from &#39;./a.js&#39;</code>)<br>  — <code>commonJS</code> 是动态态引入，执行时引入(<code>a = require(&#39;./a.js&#39;)</code>)</p></li></ul><h4 id="8-Scope-Hosting"><a href="#8-Scope-Hosting" class="headerlink" title="(8) Scope Hosting"></a>(8) Scope Hosting</h4><p>好处：</p><ul><li>代码体积更小</li><li>创建函数作用域更少</li><li>代码可读性更好</li></ul><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> ModuleConcatenationPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack/lib/optimize/ModuleConcatenationPlugin&#x27;</span>);<span class="hljs-built_in">module</span>.export = &#123;resolve: &#123;<span class="hljs-comment">// 针对 npm 中的第三方模块优先采用 jsnext:main 中</span><span class="hljs-comment">// 指向的ES6 模块化语法的文件</span>plugins: [<span class="hljs-comment">// 开启Scope Hosting</span><span class="hljs-keyword">new</span> ModuleConcatenationPlugin(),]&#125;&#125;</code></pre><h4 id="9-CSS-文件抽离压缩"><a href="#9-CSS-文件抽离压缩" class="headerlink" title="(9) CSS 文件抽离压缩"></a>(9) CSS 文件抽离压缩</h4><p>打包时针对 CSS 文件进行抽离并压缩。抽离并压缩的目的：开发环境用的 style-loader 是将css 代码打包到 js 文件的，需要执行 js 文件才能将 css 解析出来并塞到 html 中，对性能不友好。抽离的步骤：</p><ul><li><ol><li><p>打包解析中 mini-css-extract-plugin 插件代替 style-loader</p><pre><code class="hljs JavaScript">&#123;test: <span class="hljs-regexp">/\.css$/</span>,loader: [MiniCssExtractPlugin.loader, <span class="hljs-comment">// 注意，这里 替代了 style-loader</span><span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-comment">// 解析预发</span><span class="hljs-string">&#x27;postcss-loader&#x27;</span> <span class="hljs-comment">// 通过添加前缀增加兼容性</span>]&#125;</code></pre></li></ol></li><li><ol start="2"><li><p>在 plugins 中增加抽离 css 文件的配置</p><pre><code class="hljs JavaScript">plugins: [<span class="hljs-keyword">new</span> MiniCssExtractPlugin(&#123;filename: <span class="hljs-string">&#x27;css/main.[contentHash:8].css&#x27;</span>&#125;)]</code></pre></li></ol></li><li><ol start="3"><li><p>压缩 CSS 文件</p><pre><code class="hljs JavaScript">plugins: [ ],optimization: &#123;<span class="hljs-comment">// 压缩CSS</span>minimizer: [<span class="hljs-keyword">new</span> TerserWebpackPlugin(&#123;&#125;), <span class="hljs-keyword">new</span> OptimizeCssAssetsWebpackPlugin(&#123;&#125;)]&#125;</code></pre></li></ol></li></ul><h4 id="10-多进程压缩-ParalleUgifyPlugin"><a href="#10-多进程压缩-ParalleUgifyPlugin" class="headerlink" title="(10) 多进程压缩 ParalleUgifyPlugin"></a>(10) 多进程压缩 ParalleUgifyPlugin</h4><p>前提：开启<code>mode: &#39;production&#39;</code>会自动进行压缩，当webpack默认的压缩功能速度慢时，可以通过此插件进行开启 多进程压缩。</p><p>打包时对输出的 js 代码进行多进程压缩。<br>UglifyJS 是单进程压缩，ParalleUgifyPlugin 是webpack 4 的多进程压缩</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> ParallelUglifyPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-parallel-uglify-plugin&#x27;</span>);plugins: [<span class="hljs-comment">// happyPack 开启多进程打包</span><span class="hljs-keyword">new</span> HappyPack(&#123;<span class="hljs-comment">// 用唯一 id 达标当前 happyPack 是用来处理哪些文件</span>id: <span class="hljs-string">&#x27;happyScss&#x27;</span>,<span class="hljs-comment">// 如何处理, 用法与 loader 配置中的一样</span>loaders: [<span class="hljs-string">&#x27;babel-loader?cacheDiewctory&#x27;</span>]&#125;)<span class="hljs-keyword">new</span> ParallelUglifyPlugin(&#123;uglifyJS: &#123;output: &#123;beautify: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 最紧凑的输出</span>comments: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 删除注释</span>&#125;,compress: &#123;drop_console: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 删除 console 语句</span>drop_debugger: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 删除 debugger</span><span class="hljs-comment">// 内嵌虽然已经定义了，但是只用到一次的变量</span>collapse_vars: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 提取出现了多次但是没有定义成变量去引用的静态值</span>reduce_vars: <span class="hljs-literal">true</span>,&#125;&#125;&#125;)]</code></pre><h2 id="三-babel"><a href="#三-babel" class="headerlink" title="三  babel"></a>三  babel</h2><pre><code class="hljs JavaScript"><span class="hljs-comment">// .babelrc 文件 或者 babel.config.json 文件</span>&#123;<span class="hljs-comment">// babel 插件的集合</span><span class="hljs-string">&quot;presets&quot;</span>: [<span class="hljs-string">&quot;@babel/preset-env&quot;</span>,<span class="hljs-string">&quot;@babel/preset-react&quot;</span>,<span class="hljs-string">&quot;@babel/preset-typescript&quot;</span>,],<span class="hljs-string">&quot;plugins&quot;</span>: []&#125;</code></pre><ul><li><code>@babel/polyfill</code>: 补丁，根据浏览器的兼容性打补丁</li><li><code>polyfill</code> = <code>core-js</code> + <code>regenerator</code><ul><li><code>Babel7.4</code> 之后弃用 <code>babel-polyfill</code></li><li>推荐直接使用 <code>core-js</code> 和 <code>regenerator</code></li></ul></li></ul><h3 id="1-corejs"><a href="#1-corejs" class="headerlink" title="1. corejs"></a>1. corejs</h3><p>问题： <code>polyfill</code> 文件体积很大，项目中只是用了 <code>polyfill</code> 的部分模块，如何按需引入？</p><pre><code class="hljs JavaScript"><span class="hljs-comment">// .babelrc 文件 或者 babel.config.json 文件</span>&#123;<span class="hljs-comment">// babel 插件的集合</span><span class="hljs-string">&quot;presets&quot;</span>: [<span class="hljs-string">&quot;@babel/preset-env&quot;</span>,&#123;<span class="hljs-comment">// 这样就不需要再引入 @babel/polyfill</span><span class="hljs-string">&quot;useBuiltIns&quot;</span>: <span class="hljs-string">&quot;usage&quot;</span>,<span class="hljs-string">&quot;corejs&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-comment">// 声明corejs版本</span>&#125;],<span class="hljs-string">&quot;plugins&quot;</span>: []&#125;</code></pre><h3 id="2-babel-runtime"><a href="#2-babel-runtime" class="headerlink" title="2. babel-runtime"></a>2. babel-runtime</h3><p>问题：由于 polyfill 是定义在全局 window 上，会污染全局环境，如何处理？</p><p>通过 babel-runtime 实现</p><p><code>package.json</code> 中 <code>devDependencies</code> 安装 <code>@babel/plugin-transform-runtime</code>， <code>dependenvies</code> 中安装 <code>@babel/runtime</code></p><pre><code class="hljs JavaScript"><span class="hljs-comment">// .babelrc 文件 或者 babel.config.json 文件</span>&#123;<span class="hljs-comment">// babel 插件的集合</span><span class="hljs-string">&quot;presets&quot;</span>: [<span class="hljs-string">&quot;@babel/preset-env&quot;</span>,&#123;<span class="hljs-string">&quot;useBuiltIns&quot;</span>: <span class="hljs-string">&quot;usage&quot;</span>,<span class="hljs-string">&quot;corejs&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-comment">// 声明corejs版本</span>&#125;],<span class="hljs-string">&quot;plugins&quot;</span>: [[<span class="hljs-comment">// 引用插件 &quot;@babel/plugin-transform-runtime</span><span class="hljs-string">&quot;@babel/plugin-transform-runtime&quot;</span>,&#123;<span class="hljs-comment">// 添加配置</span><span class="hljs-string">&quot;corejs&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-comment">// 声明corejs版本</span><span class="hljs-string">&quot;absoluteRuntime&quot;</span>: <span class="hljs-literal">false</span>,<span class="hljs-string">&quot;helper&quot;</span>: <span class="hljs-literal">true</span>,<span class="hljs-string">&quot;regenerator&quot;</span>: <span class="hljs-literal">true</span>,<span class="hljs-string">&quot;useESModule&quot;</span>: <span class="hljs-literal">false</span>,&#125;]]&#125;</code></pre><h2 id="四-题"><a href="#四-题" class="headerlink" title="四 题"></a>四 题</h2><h3 id="1-前端代码为何要进行打包和构建？"><a href="#1-前端代码为何要进行打包和构建？" class="headerlink" title="1 前端代码为何要进行打包和构建？"></a>1 前端代码为何要进行打包和构建？</h3><p>代码相关：</p><ul><li>体积更小（ Tree-Shaking、压缩、合并），加载更快</li><li>编译高级语言和语法（TS、ES6+、模块化、SCSS 等）</li><li>兼容性和错误检查（Polyfill、postCSS、eslint）</li></ul><p>工程化相关：</p><ul><li>统一、高效的开发环境</li><li>统一的构建流程和产出标准</li><li>集成公司构建规范（提测、上线等）</li></ul><h3 id="2-module、chunk、bundle-分别是什么意思？有何区别？"><a href="#2-module、chunk、bundle-分别是什么意思？有何区别？" class="headerlink" title="2 module、chunk、bundle 分别是什么意思？有何区别？"></a>2 module、chunk、bundle 分别是什么意思？有何区别？</h3><ul><li>module: 各个源码文件，webpack 中一切皆模块</li><li>chunk: 多个模块合成的， 如 entry splitChunk import()</li><li>bundle: 最终的输出文件。一个 chunk 对应一个 bundle，可能有多个</li></ul><h3 id="3-loader-和-plugin-的区别？"><a href="#3-loader-和-plugin-的区别？" class="headerlink" title="3 loader 和 plugin 的区别？"></a>3 loader 和 plugin 的区别？</h3><ul><li>loader 是模块转换器， 如 less -&gt; css<ul><li>style-loader、css-loader、postcss-loader、url-loader、file-loader</li></ul></li><li>plugin 是扩展插件，如 HtmlWebpackPlugin<ul><li>HotModuleReplacementPlugin、DllPlugin、UglifyJSPlugin、HappyPack、SourceMapDevToolPlugin、SourceMapUploadPlugin</li></ul></li></ul><h3 id="4-babel-和-webpack-的区别？"><a href="#4-babel-和-webpack-的区别？" class="headerlink" title="4 babel 和 webpack 的区别？"></a>4 babel 和 webpack 的区别？</h3><ul><li>babel：JS 新语法编译工具，不关心模块化</li><li>webpack：打包构建工具，是多个 loader 和 plugin 的集合</li></ul><p>babel 原理</p><p>babel 的转译过程分为三个阶段：parsing、transforming、generating</p><p>以 ES6 代码转译为 ES5 代码为例，babel 转译的具体过程如下：</p><ul><li>ES6 代码输入</li><li>babylon 进行解析得到 AST</li><li>plugin 用 babel-traverse 对 AST 树进行遍历转译,得到新的 AST 树</li><li>用 babel-generator 通过 AST 树生成 ES5 代码</li></ul><h3 id="5-如何产出一个-lib"><a href="#5-如何产出一个-lib" class="headerlink" title="5 如何产出一个 lib"></a>5 如何产出一个 lib</h3><p>参考 webpack.dll.js， output.library</p><pre><code class="hljs JavaScript">output: &#123;<span class="hljs-comment">// lib 的中文名</span>filename: <span class="hljs-string">&#x27;lodash.js&#x27;</span>,<span class="hljs-comment">// 输出 lib 到 dist 目录下</span>path: distPath,<span class="hljs-comment">// lib 的全局变量名</span>library: <span class="hljs-string">&#x27;lodash&#x27;</span>,&#125;</code></pre><h3 id="6-babel-runtime-和-babel-polyfill-的区别？"><a href="#6-babel-runtime-和-babel-polyfill-的区别？" class="headerlink" title="6 babel-runtime 和 babel-polyfill 的区别？"></a>6 babel-runtime 和 babel-polyfill 的区别？</h3><ul><li>babel-polyfill 会污染全局</li><li>babel-runtime 不会污染全局</li><li>产出第三方 lib 需要用 babel-runtime</li></ul><h3 id="7-webpack-如何实现懒加载？"><a href="#7-webpack-如何实现懒加载？" class="headerlink" title="7 webpack 如何实现懒加载？"></a>7 webpack 如何实现懒加载？</h3><ul><li>import() 语法</li><li>结合 Vue React 异步组件</li><li>结合 vue-loader 和 react-router 异步加载路由</li></ul><h3 id="8-terser-是什么"><a href="#8-terser-是什么" class="headerlink" title="8 terser 是什么"></a>8 terser 是什么</h3><p><code>webpack4</code> 默认内置使用 <code>terser-webpack-plugin</code> 插件压缩优化代码，而该插件使用 <code>terser</code> 来缩小 <code>JavaScript</code><br>(废弃了 <code>webpack3</code> 的 <code>UglifyJsPlugin</code>(单线程压缩) 和 <code>ParallelUglifyPlugin</code>(多线程压缩))</p><p>所谓 <code>terser</code>，官方给出的定义是：<strong>用于 ES6+ 的 JavaScript 解析器、mangler/compressor（压缩器）工具包</strong></p><p>为什么 <code>webpack</code> 选择 <code>terser</code>？</p><ul><li>不再维护 <code>uglify-es</code> ，并且 <code>uglify-js</code> 不支持 <code>ES6 +</code>。</li><li><code>terser</code> 是 <code>uglify-es</code> 的一个分支，主要保留了与 <code>uglify-es</code> 和 <code>uglify-js@3</code> 的 API 和 CLI 兼容性。</li><li><code>terser</code> 使用多进程并行运行来提高构建速度。并发运行的默认数量为 os.cpus().length - 1</li></ul><h3 id="9-如何开启多线程"><a href="#9-如何开启多线程" class="headerlink" title="9 如何开启多线程"></a>9 如何开启多线程</h3><ul><li>多进程打包 —— happyPack（或者thread-loader）</li><li>多进程压缩 —— (web3)webpack-parallel-uglify-plugin（对应单进程压缩web3 UglifyJsPlugin）</li><li>多进程构建和压缩 —— (web4)terser-webpack-plugin</li></ul><h3 id="10-webpack构建流程"><a href="#10-webpack构建流程" class="headerlink" title="10 webpack构建流程"></a>10 webpack构建流程</h3><ul><li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</li><li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；</li><li>确定入口：根据配置中的 entry 找出所有的入口文件；</li><li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</li><li>完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</li><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li><li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li><li>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</li></ul><h3 id="10-热更新"><a href="#10-热更新" class="headerlink" title="10 热更新"></a>10 热更新</h3><p>Hot Module Replacement</p><p>流程：</p><ol><li>Webpack Compile: watch 打包本地文件 写入内存</li><li>Boundle Server: 启一个本地服务，提供文件在浏览器端进行访问</li><li>HMR Server: 将热更新的文件输出给 HMR(Hot Module Replacement) Runtime</li><li>HMR Runtime: 生成的文件，注入至浏览器内存</li><li>Bundle: 构建输出文件</li></ol><p>开启热更新的方法有两种：</p><ol><li>直接通过运行 webpack-dev-server 命令时 加入 –hot参数 直接开启 HMR</li><li>写入配置文件</li></ol><pre><code class="hljs javaScript"><span class="hljs-comment">// ./webpack.config.js</span><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>)<span class="hljs-built_in">module</span>.exports = &#123;<span class="hljs-comment">// ...</span>devServer: &#123;<span class="hljs-comment">// 开启 HMR 特性 如果不支持 MMR 则会 fallback 到 live reload</span>hot: <span class="hljs-literal">true</span>,&#125;,plugins: [<span class="hljs-comment">// ...</span><span class="hljs-comment">// HMR 依赖的插件</span><span class="hljs-keyword">new</span> webpack.HotModuleReplacementPlugin()]&#125;</code></pre><p>在 webpack-dev-server 源码中，通过 sockJs(github.com/sockjs/sockjs-client) 提供的服务端与浏览器端之间的桥梁.<br>在 devServer 启动的同时，建立了一个 webSocket 长链接，用于通知浏览器在 webpack 编译和打包下的各个状态，<br>同时监听 compile 下的 done 事件，当 compile 完成以后，通过 sendStats 方法, 将重新编译打包好的新模块 hash 值发送给浏览器。</p><p>浏览器 刷新策略选择：<br> webpack-dev-server/client 中首先会根据 hot 配置决定是采用哪种更新策略【刷新浏览器或者代码进行热更新（HMR）】，<br> 如果配置了 HMR，就调用 webpack/hot/emitter 将最新 hash 值发送给 webpack，<br> 如果没有配置模块热更新，就直接调用 applyReload下的location.reload 方法刷新页面。</p><p>webpack 根据 hash 请求最新模块代码：<br> 这个过程是三个模块相互配合：webpack/hot/dev-serve、webpack-dev-server/client、webpack/lib/HotModuleReplacement.runtime<br> 1.首先是 webpack/hot/dev-server（简称 dev-server） 监听 webpack-dev-server/client 发送的 webpackHotUpdate 消息<br> 2.调用 webpack/lib/HotModuleReplacement.runtime（简称 HMR runtime）中的 check 方法，检测是否有新的更新<br> 3.check 过程中利用 webpack/lib/JsonpMainTemplate.runtime（简称 jsonp runtime）中的两个方法检查和更新文件：<br>     (1) hotDownloadManifest ——通过调用 AJAX 向服务端请求是否有更新的文件，如果有则会将新的文件返回给浏览器;<br>    (2) hotDownloadUpdateChunk ——通过 jsonp 请求最新的模块代码，然后将代码返回给 HMR runtime，HMR runtime 会根据返回的新模块代码做进一步处理，可能是刷新页面，也可能是对模块进行热更新。</p><p>HMR Runtime 对模块进行热更新：<br> webpack/lib/HotModuleReplacement.runtime 主要是对模块进行热更新，核心方法是 hotApply<br> 大概流程分为三步：<br> 1.找出 outdatedModules（过期模块） 和 outdatedDependencies（过期模块对应的依赖）<br> 2.删除过期的模块以及对应依赖<br> 3.把新模块添加至 modules 中<br> 整个流程结束后，已经可以获取最新的模块代码了，下一步是业务代码如何 知晓模块已经发生了变化</p><p>HotModuleReplaceMentPlugin —— module.hot.accept：</p><pre><code class="hljs javaScript"><span class="hljs-comment">// module.hot.accept 其实等价于 module.hot._acceptedDependencies(&#x27;./child) = render</span><span class="hljs-comment">// 业务逻辑实现</span><span class="hljs-built_in">module</span>.hot.accept(<span class="hljs-string">&#x27;./child&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child 模块更新啦～&#x27;</span>)&#125;)</code></pre><p> accept方法的第一个参数是 需要监听模块的 path(相对路径)，第二个参数就是当模块更新以后如何处理<br> 当模块改变时，对模块需要做的变更，搜集到 _acceptedDependencies 中，<br> 同时当被监听的模块内容发生了改变以后，父模块可以通过_acceptedDependencies 知道哪些内容发生了变化。</p><h2 id="五-webpack-优化"><a href="#五-webpack-优化" class="headerlink" title="五 webpack 优化"></a>五 webpack 优化</h2><p>优化本地构建速度：</p><ul><li>webpack 缓存：cache-loader,HardSourceWebpackPlugin, babel-loader 的 cacheDirectory</li><li>noParse: 过滤不需要解析的文件，比如依赖的第三方库 lodash/jQ</li><li>happyPack: 开启多进程</li><li>热更新 devServer: { hot: true }）</li><li>DllPlugin （动态链接库插件）</li></ul><p>速度分析用：speed-measure-webpack-plugin 插件<br>优化打包速度：</p><ul><li>noParse: 过滤不需要解析的文件，比如依赖的第三方库 lodash/jQ</li><li>happyPack: 开启多进程</li><li>多进程压缩: web4:terser-webpack-plugin，web3:ParallelUglifyPlugin</li></ul><p>体积分析用 webpack-bundle-analyzer 插件<br>优化产出代码：</p><ul><li>小图片 base64 编码</li><li>bundle 加 hash</li><li>懒加载 （ import() ）</li><li>代码压缩 （web4:terser-webpack-plugin，web3:UglifyJsPlugin/ParallelUglifyPlugin ）</li><li>提取公共代码 （splitChunks）</li><li>使用 CDN 加速 （publicPath：’//b.yzcdn.cn/beauty/assets/‘）</li><li>IgnorePlugin (忽略 moment 的本地化内容 new webpack.IgnorePlugin(/^./locale$/, /moment$/))</li><li>使用 production (web4:自动压缩、vue/React删掉调试代码、Teee-Shaking)</li><li>Scope Hosting （代码体积小、作用域更少、可读性好 Module-Concatenation-Plugin）</li><li>CSS 文件抽离/压缩 （抽离mini-css-extract-plugin 代替 style-loader，压缩TerserWebpackPlugin/OptimizeCssAssetsWebpackPlugin ）</li></ul><h2 id="六-webpack-5"><a href="#六-webpack-5" class="headerlink" title="六 webpack 5"></a>六 webpack 5</h2><blockquote><p><a href="https://mp.weixin.qq.com/s/vBBfUdy4pHIPChs7TUkFLQ">构建效率大幅提升，webpack5 在企鹅辅导的升级实践</a></p></blockquote><p>webpack5 的发布带来了很多新的特性，例如<strong>优化持久缓存、优化长期缓存、Node Polyfill 脚本的移除、更优的 tree-shaking 以及 Module Federation</strong>等。</p><h3 id="1-优化持久缓存"><a href="#1-优化持久缓存" class="headerlink" title="1 优化持久缓存"></a>1 优化持久缓存</h3><p>webpack4 及之前的版本本身是没有持久化缓存的能力的，只能借助其他的插件或 loader 来实现：<br>使用 <code>webpack4</code> 缓存的方法有几种：<code>cache-loader</code>，<code>HardSourceWebpackPlugin</code> 或 <code>babel-loader</code> 的 <code>cacheDirectory</code> 标志</p><p>webpack5 缓存方案<br>webpack5 统一了持久化缓存的方案，有效降低了配置的复杂性。另外由于 webpack 提供了构建的 runtime，所有被 webpack 处理的模块都能得到有效的缓存，大大提高了缓存的覆盖率，因此 webpack5 的持久化缓存方案将会比其他第三方插件缓存性能要好很多。<br>webpack5 默认将构建的缓存结果放在 node_modules/.cache 目录下,可以通过配置更改目录.</p><p>cache 的属性 type 会在开发模式下被默认设置成 memory，而且在生产模式中被禁用，所以如果想要在生产打包时使用缓存需要显式的设置。<br>为了防止缓存过于固定，导致更改构建配置无感知，依然使用旧的缓存，默认情况下，每次修改构建配置文件都会导致重新开始缓存。当然也可以自己主动设置 version 来控制缓存的更新。</p><pre><code class="hljs javaScript"><span class="hljs-built_in">module</span>.exports = &#123;    cache: &#123;      <span class="hljs-comment">// 将缓存类型设置为文件系统</span>      type: <span class="hljs-string">&quot;filesystem&quot;</span>,       buildDependencies: &#123;        <span class="hljs-comment">/* 将你的 config 添加为 buildDependency，</span><span class="hljs-comment">           以便在改变 config 时获得缓存无效*/</span>        config: [__filename],        <span class="hljs-comment">/* 如果有其他的东西被构建依赖，</span><span class="hljs-comment">           你可以在这里添加它们*/</span>        <span class="hljs-comment">/* 注意，webpack.config，</span><span class="hljs-comment">           加载器和所有从你的配置中引用的模块都会被自动添加*/</span>      &#125;,      <span class="hljs-comment">// 指定缓存的版本</span>      version: <span class="hljs-string">&#x27;1.0&#x27;</span>     &#125;&#125;</code></pre><h3 id="2-长效缓存"><a href="#2-长效缓存" class="headerlink" title="2 长效缓存"></a>2 长效缓存</h3><p>仅仅改了其中一个文件，结果构建出来的所有 js 文件的 hash 值都变了，不利于浏览器进行长效缓存。<br>长效缓存指的是能充分利用浏览器缓存，尽量减少由于模块变更导致的构建文件 hash 值的改变，从而导致文件缓存失效。</p><p>webpack 4 之前的解决办法是使用 HashedModuleIdsPlugin 固定 moduleId，它会使用模块路径生成的 hash 作为 moduleId；使用 NamedChunksPlugin 来固定 chunkId。</p><p>其中 webpack4 中可以根据如下配置来解决此问题：</p><pre><code class="hljs javaScript">optimization.moduleIds = <span class="hljs-string">&#x27;hashed&#x27;</span>optimization.chunkIds = <span class="hljs-string">&#x27;named&#x27;</span></code></pre><p>webpack5 长效缓存方案</p><p>webpack5 增加了确定的 moduleId，chunkId 的支持，如下配置：</p><pre><code class="hljs javaScript">optimization.moduleIds = <span class="hljs-string">&#x27;deterministic&#x27;</span>optimization.chunkIds = <span class="hljs-string">&#x27;deterministic&#x27;</span></code></pre><p>此配置在生产模式下是默认开启的，它的作用是以确定的方式为 module 和 chunk 分配 3-5 位数字 id，相比于 v4 版本的选项 hashed，它会导致更小的文件 bundles。<br>由于 moduleId 和 chunkId 确定了，构建的文件的 hash 值也会确定，有利于浏览器长效缓存。同时此配置有利于减少文件打包大小。<br>在开发模式下，建议使用:</p><pre><code class="hljs javaScript">optimization.moduleIds = <span class="hljs-string">&#x27;named&#x27;</span>optimization.chunkIds = <span class="hljs-string">&#x27;named&#x27;</span></code></pre><p>此选项生产对调试更友好的可读的 id</p><h3 id="3-Node-Polyfill-脚本被移除"><a href="#3-Node-Polyfill-脚本被移除" class="headerlink" title="3 Node Polyfill 脚本被移除"></a>3 Node Polyfill 脚本被移除</h3><p>webpack4 版本中附带了大多数 Node.js 核心模块的 polyfill，一旦前端使用了任何核心模块，这些模块就会自动应用，但是其实有些是不必要的。<br>webpack5 将不会自动为 Node.js 模块添加 polyfill，而是更专注的投入到前端模块的兼容中。因此需要开发者手动添加合适的 polyfill。</p><h3 id="4-更优的-tree-shaking"><a href="#4-更优的-tree-shaking" class="headerlink" title="4 更优的 tree-shaking"></a>4 更优的 tree-shaking</h3><p><code>webpack5</code> 对 <code>tree-shaking</code> 进行了优化，分析模块的 <code>export</code> 和 <code>import</code> 的依赖关系，去掉未被使用的模块</p><pre><code class="hljs javaScript"><span class="hljs-comment">// const.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> a = <span class="hljs-string">&#x27;hello&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> b = <span class="hljs-string">&#x27;world&#x27;</span>;<span class="hljs-comment">// module.js</span><span class="hljs-keyword">export</span> * <span class="hljs-keyword">as</span> <span class="hljs-built_in">module</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./const&#x27;</span>;<span class="hljs-comment">// index.js</span><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> main <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module&#x27;</span>;<span class="hljs-built_in">console</span>.log(main.module.a)<span class="hljs-comment">// 以上3个文件，在 webpack4 中会被打包为：</span>!<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-string">&quot;use strict&quot;</span>; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hello&quot;</span>)&#125;();<span class="hljs-comment">// 分析了依赖关系，去掉未被使用的模块</span></code></pre><h3 id="5-Module-Federation"><a href="#5-Module-Federation" class="headerlink" title="5 Module Federation"></a>5 Module Federation</h3><p>Module Federation 使得使 JavaScript 应用得以从另一个 JavaScript 应用中动态地加载代码 —— 同时共享依赖。相当于 webpack 提供了线上 runtime 的环境，多个应用利用 CDN 共享组件或应用，不需要本地安装 npm 包再构建了，这就有点云组件的概念了。</p><p>依赖共享主要是由插件 ModuleFederationPlugin 来提供 <code>const &#123; ModuleFederationPlugin &#125; = require(&quot;webpack&quot;).container;</code></p><p>例如可以将我们项目中常用的依赖包 react 全家桶等打成一个包，做成一个 runtime,开发环境和生产环境依赖一个 runtime，这样可以大大减少项目的大小，提高编译速度。</p>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js-时钟</title>
    <link href="/2019/04/15/interview/%E6%89%8B%E5%86%99%E6%97%B6%E9%92%9F/"/>
    <url>/2019/04/15/interview/%E6%89%8B%E5%86%99%E6%97%B6%E9%92%9F/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>*&#123;padding: 0;margin: 0;&#125;html, body &#123;height: 100%;&#125;<span class="css"><span class="hljs-selector-class">.warp</span>&#123;</span>width: 230px;height: 230px;margin: 50px auto;&#125;<span class="css"><span class="hljs-selector-class">.clock</span>&#123;</span>width: 200px;height: 200px;border-radius: 115px;<span class="css"><span class="hljs-selector-tag">border</span>: 15<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#ccc</span>;</span><span class="css"><span class="hljs-selector-tag">background</span>: <span class="hljs-selector-id">#fff</span>;</span>position: relative;&#125;<span class="css"><span class="hljs-selector-class">.number</span> <span class="hljs-selector-tag">div</span>&#123;</span>position: absolute;width: 20px;height: 200px;left: 90px;&#125;<span class="css"><span class="hljs-selector-class">.number</span> <span class="hljs-selector-tag">span</span>&#123;</span>display: block;width: 20px;height: 20px;text-align: center;&#125;<span class="css"><span class="hljs-selector-class">.pointer</span>&#123;</span>position: absolute;bottom: 90px;transform-origin: 50% 90%;-webkit-transform-origin: 50% 90%;&#125;<span class="css"><span class="hljs-selector-class">.houre</span>&#123;</span>width: 4px;height: 60px;left: 100px;<span class="css"><span class="hljs-selector-tag">background</span>: <span class="hljs-selector-id">#000</span>;</span>&#125;<span class="css"><span class="hljs-selector-class">.minute</span>&#123;</span>width: 2px;height: 80px;left: 100px;<span class="css"><span class="hljs-selector-tag">background</span>: <span class="hljs-selector-id">#777</span>;</span>&#125;<span class="css"><span class="hljs-selector-class">.second</span>&#123;</span>width: 1px;height: 90px;left: 100px;<span class="css"><span class="hljs-selector-tag">background</span>: <span class="hljs-selector-id">#ff0000</span>;</span>&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript"><span class="hljs-keyword">var</span> domNumber = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;number&quot;</span>);</span><span class="javascript"><span class="hljs-keyword">var</span> domDiv = domNumber.getElementsByTagName(<span class="hljs-string">&quot;div&quot;</span>);</span><span class="javascript"><span class="hljs-keyword">var</span> domSpan = domNumber.getElementsByTagName(<span class="hljs-string">&quot;span&quot;</span>);</span><span class="javascript"><span class="hljs-comment">// 布局 =&gt; 让数字旋转到相应的位置并调整方向</span></span><span class="javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; domDiv.length; i++)&#123;</span><span class="javascript">domDiv[i].style.WebkitTransform=<span class="hljs-string">&quot;rotate(&quot;</span> + (i + <span class="hljs-number">1</span>) * <span class="hljs-number">30</span> + <span class="hljs-string">&quot;deg)&quot;</span>;</span>&#125;<span class="javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; domSpan.length; j++)&#123;</span><span class="javascript">domSpan[j].style.WebkitTransform=<span class="hljs-string">&quot;rotate(&quot;</span>+ (j + <span class="hljs-number">1</span>) * -<span class="hljs-number">30</span> + <span class="hljs-string">&quot;deg)&quot;</span>;</span>&#125;<span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clockRun</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript"><span class="hljs-keyword">var</span> domHour = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;houre&quot;</span>);</span><span class="javascript"><span class="hljs-keyword">var</span> domMinute = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;minute&quot;</span>);</span><span class="javascript"><span class="hljs-keyword">var</span> domSecond = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;second&quot;</span>);</span><span class="javascript"><span class="hljs-keyword">var</span> nowTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();</span><span class="javascript"><span class="hljs-keyword">var</span> nowHour = nowTime.getHours();</span><span class="javascript"><span class="hljs-keyword">var</span> nowMinute = nowTime.getMinutes();</span><span class="javascript"><span class="hljs-keyword">var</span> nowSecond = nowTime.getSeconds();</span><span class="javascript"><span class="hljs-comment">// 计算指针的角度，其中最重要的是在不满一小时或不满一分钟时，时针或分针应该转多少度</span></span><span class="javascript"><span class="hljs-keyword">var</span> houreDeg = (nowMinute/<span class="hljs-number">60</span>) * <span class="hljs-number">30</span>; <span class="hljs-comment">// 每小时是30度(1h = 60min, 1h =&gt;  360°/12h = 30 °/h)</span></span><span class="javascript"><span class="hljs-keyword">var</span> minuteDeg = (nowSecond/<span class="hljs-number">60</span>) * <span class="hljs-number">6</span>; <span class="hljs-comment">// 每分钟是6度(1min = 60sec, 1min =&gt; 360°/60min = 6 °/h)</span></span><span class="javascript">domHour.style.WebkitTransform = <span class="hljs-string">&quot;rotate(&quot;</span> + (nowHour * <span class="hljs-number">30</span> + houreDeg) + <span class="hljs-string">&quot;deg)&quot;</span>;</span><span class="javascript">domMinute.style.WebkitTransform = <span class="hljs-string">&quot;rotate(&quot;</span> + (nowMinute * <span class="hljs-number">6</span> + minuteDeg) + <span class="hljs-string">&quot;deg)&quot;</span>;</span><span class="javascript">domSecond.style.WebkitTransform = <span class="hljs-string">&quot;rotate(&quot;</span> + (nowSecond * <span class="hljs-number">6</span>) + <span class="hljs-string">&quot;deg)&quot;</span>;</span>&#125;clockRun();<span class="javascript"><span class="hljs-built_in">setInterval</span>(clockRun, <span class="hljs-number">1000</span>);</span>&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;warp&quot;</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;clock&quot;</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;number&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>9<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>12<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;houre&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pointer houre&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;minute&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pointer minute&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;second&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pointer second&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>js</tag>
      
      <tag>手写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project 项目</title>
    <link href="/2019/04/15/interview/project/"/>
    <url>/2019/04/15/interview/project/</url>
    
    <content type="html"><![CDATA[<h2 id="一-性能监控和错误监控"><a href="#一-性能监控和错误监控" class="headerlink" title="一 性能监控和错误监控"></a>一 性能监控和错误监控</h2><h3 id="1、性能监控"><a href="#1、性能监控" class="headerlink" title="1、性能监控"></a>1、性能监控</h3><p>前端性能监控流程：<br>数据采集 –&gt; 数据上报 –&gt; 服务端处理 –&gt; 数据库存储 –&gt; 数据监控可视化平台</p><h4 id="1-接口请求时间监控"><a href="#1-接口请求时间监控" class="headerlink" title="(1) 接口请求时间监控"></a>(1) 接口请求时间监控</h4><p>在 Node 层的中间件中判断请求的是 接口(reqInfo.type == ‘api’) 还是 页面</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;   <span class="hljs-keyword">const</span> &#123; reqInfo &#125; = ctx;<span class="hljs-keyword">if</span> (reqInfo.type == <span class="hljs-string">&#x27;api&#x27;</span>) &#123;<span class="hljs-comment">// 表示请求的是 接口</span><span class="hljs-comment">// 请求接口时，定义一个时间戳</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 否则请求的是 页面</span>&#125;<span class="hljs-comment">// 在 await next() 时表示收到响应了，中间的时间差 就是接口请求时间</span>&#125;</code></pre><h4 id="2-页面监控"><a href="#2-页面监控" class="headerlink" title="(2) 页面监控"></a>(2) 页面监控</h4><p><a href="https://github.com/woai3c/Front-end-articles/blob/master/monitor.md">前端性能和错误监控</a></p><p>页面性能数据采集的api: <strong>Web API-&gt; window.performance</strong></p><p><code>Performance</code> 接口可以获取到当前页面中与性能相关的信息，它是 <code>High Resolution Time API</code> 的一部分，同时也融合了 <code>Performance Timeline API</code>、<code>Navigation Timing API</code>、 <code>User Timing API</code> 和 <code>Resource Timing API</code>。</p><p>通过 <code>window.performance.timing</code> 属性，可以获取页面加载的各个有效数据。</p><img src="https://i.loli.net/2021/02/24/sxKmXLWdOAjJM2F.png" ><img src="https://i.loli.net/2021/02/24/cFLPZYtdofmp1MD.jpg" ><p>通过以上数据，我们可以得到几个有用的时间:</p><pre><code class="hljs javaScript"><span class="hljs-comment">// 重定向耗时 (最后一个HTTP重定向完成时的时间戳 - 第一个HTTP重定向开始时的时间戳)</span>redirect: timing.redirectEnd - timing.redirectStart,<span class="hljs-comment">// DOM 渲染耗时</span><span class="hljs-comment">// domComplete:当前文档解析完成，即Document.readyState 变为 &#x27;complete&#x27; </span><span class="hljs-comment">//      且相对应的readystatechange 被触发时的时间戳</span><span class="hljs-comment">// domLoading: 当前网页DOM结构开始解析时</span><span class="hljs-comment">//      （即Document.readyState 属性变为 “loading” 、</span><span class="hljs-comment">//       相应的 readystatechange 事件触发时）的时间戳。</span>dom: timing.domComplete - timing.domLoading,<span class="hljs-comment">// 页面加载耗时</span><span class="hljs-comment">// loadEventEnd: 当load事件结束，即加载事件完成时的时间戳</span><span class="hljs-comment">// navigationStart: 同一个浏览器上一个页面卸载(unload)结束时的时间戳。</span><span class="hljs-comment">//      如果没有上一个页面，这个值会和fetchStart相同</span><span class="hljs-comment">// fetch: 浏览器准备好使用HTTP请求来获取(fetch)文档的时间戳。这个时间点会在检查任何应用缓存之前</span>load: timing.loadEventEnd - timing.navigationStart,<span class="hljs-comment">// 页面卸载耗时</span>unload: timing.unloadEventEnd - timing.unloadEventStart,<span class="hljs-comment">// 请求耗时</span><span class="hljs-comment">// responseEnd: 返回浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时</span><span class="hljs-comment">//      （如果在此之前HTTP连接已经关闭，则返回关闭时）的Unix毫秒时间戳</span><span class="hljs-comment">// requestStart: 返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的时间戳。</span><span class="hljs-comment">//      如果传输层在开始请求之后失败并且连接被重开,</span><span class="hljs-comment">//      则该属性将会被数制成新的请求的相对应的发起时间。</span>request: timing.responseEnd - timing.requestStart,<span class="hljs-comment">// 获取性能信息时当前时间</span>time: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime(),</code></pre><p>除此之外，还有一个比较重要的时间就是<strong>白屏时间</strong>，它指从输入网址，到页面开始显示内容的时间。</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 将以下脚本放在 &lt;/head&gt; 前面就能获取白屏时间。 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    whiteScreen = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() - performance.timing.navigationStart</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>获取资源加载时间API: <code>window.performance.getEntriesByType(&#39;resource&#39;)</code></p><img src="https://i.loli.net/2021/02/24/sfEplXLtPn19NSe.png" ><p>它一般包括以下几个类型: script、link、img、css、fetch、other、xmlhttprequest<br>数据中比较有用的信息是:</p><pre><code class="hljs javaScript"><span class="hljs-comment">// 资源的名称</span>name: item.name,<span class="hljs-comment">// 资源加载耗时</span>duration: item.duration.toFixed(<span class="hljs-number">2</span>),<span class="hljs-comment">// 资源大小</span>size: item.transferSize,<span class="hljs-comment">// 资源所用协议</span>protocol: item.nextHopProtocol,</code></pre><p><strong>用户信息收集</strong>：</p><ol><li>使用 <code>window.navigator</code> 可以收集到用户的设备信息，操作系统，浏览器信息<br>用户设备信息：<code>window.navigator.userAgent</code> 中可以获取用户设备信息<br> 设备网络信息：<code>window.navigator.connection</code></li><li><code>UV(Unique visitor)</code> —— 是指通过互联网访问、浏览这个网页的自然人。00:00-24:00内相同的客户端只被计算一次，多次访问只计算一次UV。<br>在用户访问网站时，可以生成一个随机字符串+时间日期，保存在本地。在网页发生请求时（如果超过当天24:00，则重新生成），把这些参数传到后端，后端利用这些信息生成 UV 统计报告。<br>统计方法：统计 PV 时采集 userId 去重即可<br>SPA页面，可以监听hashChange</li><li><code>PV（Page View）</code>—— 即页面浏览量或点击量，用户每1次对网站中的每个网页访问均被记录1个PV。用户对同一页面的多次访问，访问量累计，用以衡量网站用户访问的网页数量。<br>统计方法：（以 Vue 应用为例）<ul><li>SPA 应用：仅单入口，在入口文件全局定义 Router.beforeEach 方便可行（或者可以监听hashChange）</li><li>MPA 应用：多入口，在每个入口文件定义 Router.beforeEach？可封装公用逻辑（伪装单入口），免去重复构造 entry 的成本</li><li>SSR 应用：调用 TemplateView 则为渲染页面（不同于前后端分离项目，服务端无法获知接口调用与页面渲染的对应关系），统计其调用次数及 TemplateName 可知页面 PV。</li></ul></li><li>页面停留时间 ——<br><strong>传统网站</strong> 用户在进入 A 页面时，通过后台请求把用户进入页面的时间捎上。过了 10 分钟，用户进入 B 页面，这时后台可以通过接口捎带的参数可以判断出用户在 A 页面停留了 10 分钟。<br><strong>SPA</strong> 可以利用 router 来获取用户停留时间，拿 Vue 举例，通过 <code>router.beforeEach destroyed</code> 这两个钩子函数来获取用户停留该路由组件的时间。</li><li>浏览深度 —— 通过 <code>document.documentElement.scrollTop</code> 属性以及屏幕高度，可以判断用户是否浏览完网站内容。</li><li>页面跳转来源 —— 通过 <code>document.referrer</code> 属性，可以知道用户是从哪个网站跳转而来。</li></ol><p><strong>用户信息收集</strong>：</p><ol><li><p><code>FP（First Paint）</code>首次绘制：首次绘制,是时间线上的第一个时间点，它代表网页的第一个像素渲染到屏幕上所用时间，也就是页面在屏幕上首次发生视觉变化的时间</p> <pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFPTime</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> timings = performance.getEntriesByType(<span class="hljs-string">&#x27;paint&#x27;</span>)[<span class="hljs-number">0</span>];    <span class="hljs-keyword">return</span> timings ? <span class="hljs-built_in">Math</span>.round(timings.startTime) : <span class="hljs-literal">null</span>&#125;</code></pre><p> FP与FCP这两个指标之间的主要区别是：</p><ul><li>FP是当浏览器开始绘制内容到屏幕上的时候，只要在视觉上开始发生变化，无论是什么内容触发的视觉变化，在这一刻，这个时间点，叫做FP。</li><li>FCP指的是浏览器首次绘制来自DOM的内容。例如：文本，图片，SVG，canvas元素等，这个时间点叫FCP。<br>FP和FCP可能是相同的时间，也可能是先FP后FCP。</li></ul></li><li><p><code>FCP（ First Contentful Paint）</code>首次内容绘制</p><p> 首次内容绘制，顾名思义，它代表浏览器第一次向屏幕绘内容。<br> 通过performance.getEntriesByType(‘paint’)，取第二个pain的时间，或者通过Mutation Observer观察到首次节点变动的时间。</p> <pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFPTime</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> timings = performance.getEntriesByType(<span class="hljs-string">&#x27;paint&#x27;</span>);    <span class="hljs-keyword">if</span>(timings.length &gt; <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> timings[<span class="hljs-number">1</span>]    <span class="hljs-keyword">return</span> timings ? <span class="hljs-built_in">Math</span>.round(timings.startTime) : <span class="hljs-literal">null</span>    <span class="hljs-comment">//伪代码,算 DOM 变化时的最小那个时间，即节点首次变动的时间</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.round(domEntries.length ? <span class="hljs-built_in">Math</span>.min(...domEntries.map(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> entry.time)) : <span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">const</span> domEntries = []<span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> MutationObserver(<span class="hljs-function">(<span class="hljs-params">mutationsList</span>)=&gt;</span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> mutation <span class="hljs-keyword">of</span> mutationsList) &#123;        <span class="hljs-keyword">if</span> (mutation.type == <span class="hljs-string">&#x27;childList&#x27;</span>) &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;A child node has been added or removed.&#x27;</span>);        &#125;        <span class="hljs-keyword">if</span> (mutation.type == <span class="hljs-string">&#x27;addedNodes&#x27;</span>) &#123;            <span class="hljs-comment">//TODO新增了节点，做处理，计算此时的可见性/位置/出现时间等信息，然后 push 进数组</span>            ...            domEntries.push(mutation)        &#125;    &#125;&#125;)</code></pre></li><li><p><code>FMP（First Meaningful Paint)</code>首次有意义的绘制<br>首次有意义的绘制，是页面主要内容出现在屏幕上的时间, 这是用户感知加载体验的主要指标。目前尚无标准化的定义, 因为很难以通用的方式去确定各种类型页面的关键内容。<br>目前没有统一逻辑，阿里有个标准为最高可见增量元素，采用深度优先遍历方法<br>其次，可以自定义，比如通 Mutation Observer 观察页面加载的一段时间(如前20s)内页面节点的变化, 即元素新增/移除/隐藏等变化记录下来，这样可以得到页面元素的可见时间点及元素与可视区域的交叉信息等。<br>然后，自定义一个计算公式，比如根据元素的类型进行权重取值(div 权重1，img 权重2等), 然后取元素与可视区域的交叉区域面积、可见度、 权重值之间的乘积为元素评分。<br>根据上面得到的信息, 以时间点为X轴, 该时间点可见元素的评分总和为Y轴, 取最高点对应的最小时间为页面主要内容出现在屏幕上的时间。</p></li><li><p><code>FID（ First Input Delay）</code>首次输入延迟<br>首次输入延迟，是测量用户首次与站点交互时的时间（即当他们单击链接/点击按钮/使用自定义的JavaScript驱动控件时）到浏览器实际能够回应这种互动的时间。</p><p> 方式一，通过performanceObserver(目前支持性为88.78%)观察类型为first-input的entry，获得其startTime/duration等数即可</p><p> 方式二，初始化时为特定事件类型(click/touch/keydown)绑定通用统计逻辑事件,开始调用时从event.timeStamp取开始处理的时间(这个时间就是首次输入延迟时间)，在事件处理中注册requestIdleCallback事件回调onIdleCallback，当onIdleCallback被执行时，当前时间减开始的event.timeStamp即为duration时间</p> <pre><code class="hljs javaScript"><span class="hljs-comment">// 方式一</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFIDTime</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> timings = performance.getEntriesByType(<span class="hljs-string">&#x27;first-input&#x27;</span>)[<span class="hljs-number">0</span>];    <span class="hljs-keyword">return</span> timings ? timings : <span class="hljs-literal">null</span>&#125;<span class="hljs-comment">// 方式二，以下代码仅代表思路</span>[<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-string">&#x27;touch&#x27;</span>,<span class="hljs-string">&#x27;keydown&#x27;</span>].forEach(<span class="hljs-function"><span class="hljs-params">eventType</span> =&gt;</span> &#123;    <span class="hljs-built_in">window</span>.addEventListener(eventType, eventHandle);&#125;);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eventHandle</span>(<span class="hljs-params">e</span>) </span>&#123;    <span class="hljs-keyword">const</span> eventTime = e.timeStamp;    <span class="hljs-built_in">window</span>.requestIdleCallback(onIdleCallback.bind(<span class="hljs-built_in">this</span>, eventTime, e));&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onIdleCallback</span>(<span class="hljs-params">eventTime, e</span>) </span>&#123;    <span class="hljs-keyword">const</span> now = <span class="hljs-built_in">window</span>.performance.now();    <span class="hljs-keyword">const</span> duration = now - eventTime;    <span class="hljs-keyword">return</span> &#123;        duration: <span class="hljs-built_in">Math</span>.round(duration),        timestamp: <span class="hljs-built_in">Math</span>.round(eventTime)    &#125;    [<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-string">&#x27;touch&#x27;</span>,<span class="hljs-string">&#x27;keydown&#x27;</span>].forEach(<span class="hljs-function"><span class="hljs-params">eventType</span> =&gt;</span> &#123;        <span class="hljs-built_in">window</span>.removeEventListener(eventType, eventHandle);    &#125;);&#125;</code></pre></li><li><p><code>TTI（ Time To Interactive）</code>可交互时间</p><p> 可交互时间，指的是应用在视觉上都已渲染出了，完全可以响应用户的输入了。是衡量应用加载所需时间并能够快速响应用户交互的指标。</p><p> 与 FMP 相同，很难规范化适用于所有网页的 TTI 指标定义。</p><p> 统计方式一：谷歌实验室写的npm包，tti-polyfill</p> <pre><code class="hljs javaScript"><span class="hljs-keyword">import</span> ttiPolyfill <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;tti-polyfill&#x27;</span>;ttiPolyfill.getFirstConsistentlyInteractive().then(<span class="hljs-function">(<span class="hljs-params">tti</span>) =&gt;</span> &#123;ga(<span class="hljs-string">&#x27;send&#x27;</span>, <span class="hljs-string">&#x27;event&#x27;</span>, &#123;    eventCategory:<span class="hljs-string">&#x27;Performance Metrics&#x27;</span>,    eventAction:<span class="hljs-string">&#x27;TTI&#x27;</span>,    eventValue: tti,    nonInteraction: <span class="hljs-literal">true</span>,&#125;);&#125;);</code></pre></li><li><p><code>FCI（First CPU Idle）</code>首次CPU空闲时间<br>首次CPU空闲时间代表着一个网页已经满足了最小程度的与用户发生交互行为的时刻。当我们打开一个网页，我们并不需要等到一个网页完全加载好了，每一个元素都已经完成了渲染，然后再去与网页进行交互行为。网页满足了我们基本的交互的时间点是衡量网页性能的一个重要指标。</p><p> FCI为在FMP之后，首次在一定窗口时间内没有长任务发生的那一时刻，并且如果这个时间点早于DOMContentLoaded时间，那么FCI的时间为DOMContentLoaded时间，窗口时间的计算函数可以根据Lighthouse提供的计算公式 <code>N = f(t) = 4 * e^(-0.045 * t) + 1</code> 进行自定义设计</p></li><li><p><code>FPS（ Frames Per Second）</code>为每秒帧率<br> 表示的是每秒钟画面更新次数，当今大多数设备的屏幕刷新率都是60次/秒。</p><p> 参考标准：单位(帧率)</p><pre><code> 50 ～ 60 FPS:动画将会相当流畅，让人倍感舒适； 30 ～ 50 FPS 之间的动画，因各人敏感程度不同，舒适度因人而异； 30 FPS 以下的动画，让人感觉到明显的卡顿和不适感； 帧率波动很大的动画，亦会使人感觉到卡顿。</code></pre><p> 统计逻辑<br> 利用requestAnimationFrame,循环调用，当now大于lastTime+1S时，计算FPS。若小于某个阀值则可以认为当前帧率较差，若连续小于多个阀值，则停止统计，当前页面处于卡顿状态，进入卡顿处理逻辑</p></li></ol><p><strong>总结</strong>:收集这些数据的代码：</p><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">monitorInit</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">const</span> monitor = &#123;        <span class="hljs-comment">// 数据上传地址</span>        url: <span class="hljs-string">&#x27;&#x27;</span>,        <span class="hljs-comment">// 性能信息</span>        performance: &#123;&#125;,        <span class="hljs-comment">// 资源信息</span>        resources: &#123;&#125;,        <span class="hljs-comment">// 错误信息</span>        errors: [],        <span class="hljs-comment">// 用户信息</span>        user: &#123;            <span class="hljs-comment">// 屏幕宽度</span>            screen: screen.width,            <span class="hljs-comment">// 屏幕高度</span>            height: screen.height,            <span class="hljs-comment">// 浏览器平台</span>            platform: navigator.platform,            <span class="hljs-comment">// 浏览器的用户代理信息</span>            userAgent: navigator.userAgent,            <span class="hljs-comment">// 浏览器用户界面的语言</span>            language: navigator.language,        &#125;,        <span class="hljs-comment">// 重置 monitor 对象</span>        <span class="hljs-function"><span class="hljs-title">reset</span>(<span class="hljs-params"></span>)</span> &#123;            <span class="hljs-built_in">window</span>.performance &amp;&amp; <span class="hljs-built_in">window</span>.performance.clearResourceTimings()            monitor.performance = getPerformance()            monitor.resources = getResources()            monitor.errors = []        &#125;,        <span class="hljs-comment">// 清空 error 信息</span>        <span class="hljs-function"><span class="hljs-title">clearError</span>(<span class="hljs-params"></span>)</span> &#123;            monitor.errors = []        &#125;,        <span class="hljs-comment">// 上传监控数据</span>        <span class="hljs-function"><span class="hljs-title">upload</span>(<span class="hljs-params"></span>)</span> &#123;            <span class="hljs-comment">// 自定义上传</span>            <span class="hljs-comment">// axios.post(&#123;</span>            <span class="hljs-comment">//     url: monitor.url,</span>            <span class="hljs-comment">//     data: &#123;</span>            <span class="hljs-comment">//         performance,</span>            <span class="hljs-comment">//         resources,</span>            <span class="hljs-comment">//         errors,</span>            <span class="hljs-comment">//         user,</span>            <span class="hljs-comment">//     &#125;</span>            <span class="hljs-comment">// &#125;)</span>        &#125;,        <span class="hljs-comment">// 设置数据上传地址</span>        <span class="hljs-function"><span class="hljs-title">setURL</span>(<span class="hljs-params">url</span>)</span> &#123;            monitor.url = url        &#125;,    &#125;    <span class="hljs-comment">// 获取性能信息</span>    <span class="hljs-keyword">const</span> getPerformance = <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">window</span>.performance) <span class="hljs-keyword">return</span>        <span class="hljs-keyword">const</span> timing = <span class="hljs-built_in">window</span>.performance.timing        <span class="hljs-keyword">const</span> performance = &#123;            <span class="hljs-comment">// 重定向耗时</span>            redirect: timing.redirectEnd - timing.redirectStart,            <span class="hljs-comment">// 白屏时间</span>            whiteScreen: whiteScreen,            <span class="hljs-comment">// DOM 渲染耗时</span>            dom: timing.domComplete - timing.domLoading,            <span class="hljs-comment">// 页面加载耗时</span>            load: timing.loadEventEnd - timing.navigationStart,            <span class="hljs-comment">// 页面卸载耗时</span>            unload: timing.unloadEventEnd - timing.unloadEventStart,            <span class="hljs-comment">// 请求耗时</span>            request: timing.responseEnd - timing.requestStart,            <span class="hljs-comment">// 获取性能信息时当前时间</span>            time: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime(),        &#125;        <span class="hljs-keyword">return</span> performance    &#125;    <span class="hljs-comment">// 获取资源信息</span>    <span class="hljs-keyword">const</span> getResources = <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">window</span>.performance) <span class="hljs-keyword">return</span>        <span class="hljs-keyword">const</span> data = <span class="hljs-built_in">window</span>.performance.getEntriesByType(<span class="hljs-string">&#x27;resource&#x27;</span>)        <span class="hljs-keyword">const</span> resource = &#123;            xmlhttprequest: [],            css: [],            other: [],            script: [],            img: [],            link: [],            fetch: [],            <span class="hljs-comment">// 获取资源信息时当前时间</span>            time: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime(),        &#125;        data.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;            <span class="hljs-keyword">const</span> arry = resource[item.initiatorType]            arry &amp;&amp; arry.push(&#123;                <span class="hljs-comment">// 资源的名称</span>                name: item.name,                <span class="hljs-comment">// 资源加载耗时</span>                duration: item.duration.toFixed(<span class="hljs-number">2</span>),                <span class="hljs-comment">// 资源大小</span>                size: item.transferSize,                <span class="hljs-comment">// 资源所用协议</span>                protocol: item.nextHopProtocol,            &#125;)        &#125;)        <span class="hljs-keyword">return</span> resource    &#125;    <span class="hljs-built_in">window</span>.onload = <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-comment">// 在浏览器空闲时间获取性能及资源信息</span>        <span class="hljs-comment">// https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.requestIdleCallback) &#123;            <span class="hljs-built_in">window</span>.requestIdleCallback(<span class="hljs-function">() =&gt;</span> &#123;                monitor.performance = getPerformance()                monitor.resources = getResources()                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;页面性能信息&#x27;</span>)                <span class="hljs-built_in">console</span>.log(monitor.performance)                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;页面资源信息&#x27;</span>)                <span class="hljs-built_in">console</span>.log(monitor.resources)            &#125;)        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;                monitor.performance = getPerformance()                monitor.resources = getResources()                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;页面性能信息&#x27;</span>)                <span class="hljs-built_in">console</span>.log(monitor.performance)                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;页面资源信息&#x27;</span>)                <span class="hljs-built_in">console</span>.log(monitor.resources)            &#125;, <span class="hljs-number">0</span>)        &#125;    &#125;    <span class="hljs-comment">// 捕获资源加载失败错误 js css img...</span>    addEventListener(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;        <span class="hljs-keyword">const</span> target = e.target        <span class="hljs-keyword">if</span> (target != <span class="hljs-built_in">window</span>) &#123;            monitor.errors.push(&#123;                type: target.localName,                url: target.src || target.href,                msg: (target.src || target.href) + <span class="hljs-string">&#x27; is load error&#x27;</span>,                <span class="hljs-comment">// 错误发生的时间</span>                time: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime(),            &#125;)            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;所有的错误信息&#x27;</span>)            <span class="hljs-built_in">console</span>.log(monitor.errors)        &#125;    &#125;, <span class="hljs-literal">true</span>)    <span class="hljs-comment">// 监听 js 错误</span>    <span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg, url, row, col, error</span>) </span>&#123;        monitor.errors.push(&#123;            type: <span class="hljs-string">&#x27;javascript&#x27;</span>, <span class="hljs-comment">// 错误类型</span>            row: row, <span class="hljs-comment">// 发生错误时的代码行数</span>            col: col, <span class="hljs-comment">// 发生错误时的代码列数</span>            msg: error &amp;&amp; error.stack? error.stack : msg, <span class="hljs-comment">// 错误信息</span>            url: url, <span class="hljs-comment">// 错误文件</span>            time: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime(), <span class="hljs-comment">// 错误发生的时间</span>        &#125;)        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;所有的错误信息&#x27;</span>)        <span class="hljs-built_in">console</span>.log(monitor.errors)    &#125;    <span class="hljs-comment">// 监听 promise 错误 缺点是获取不到行数数据</span>    addEventListener(<span class="hljs-string">&#x27;unhandledrejection&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;        monitor.errors.push(&#123;            type: <span class="hljs-string">&#x27;promise&#x27;</span>,            msg: (e.reason &amp;&amp; e.reason.msg) || e.reason || <span class="hljs-string">&#x27;&#x27;</span>,            <span class="hljs-comment">// 错误发生的时间</span>            time: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime(),        &#125;)        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;所有的错误信息&#x27;</span>)        <span class="hljs-built_in">console</span>.log(monitor.errors)    &#125;)    <span class="hljs-keyword">return</span> monitor&#125;<span class="hljs-keyword">const</span> monitor = monitorInit()</code></pre><p>性能数据可以在页面加载完之后上报，尽量不要对页面性能造成影响<br><code>window.requestIdleCallback()</code>方法将在浏览器的空闲时段内调用的函数排队.</p><pre><code class="hljs javaScript"><span class="hljs-comment">// 信息收集</span><span class="hljs-built_in">window</span>.onload = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// 在浏览器空闲时间获取性能及资源信息</span>    <span class="hljs-comment">// https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.requestIdleCallback) &#123;        <span class="hljs-built_in">window</span>.requestIdleCallback(<span class="hljs-function">() =&gt;</span> &#123;            monitor.performance = getPerformance()            monitor.resources = getResources()        &#125;)    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;            monitor.performance = getPerformance()            monitor.resources = getResources()        &#125;, <span class="hljs-number">0</span>)    &#125;&#125;</code></pre><p><code>window.performance API</code> 是有缺点: 在 SPA 切换路由时，<code>window.performance.timing</code> 的数据不会更新.<br>解决办法之一: 拿Vue举例，在路由的全局前置守卫 <code>beforeEach</code> 里获取开始时间，<br>在组件的 <code>mounted</code> 钩子里执行 <code>vm.$nextTick</code> 函数来获取组件的渲染完毕时间。</p><pre><code class="hljs JavaScript">router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;store.commit(<span class="hljs-string">&#x27;setPageLoadedStartTime&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>())&#125;)<span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.$nextTick(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;setPageLoadedTime&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() - <span class="hljs-built_in">this</span>.$store.state.pageLoadedStartTime)&#125;)&#125;</code></pre><h3 id="2、错误监控"><a href="#2、错误监控" class="headerlink" title="2、错误监控"></a>2、错误监控</h3><p>前端错误监控流程：<br>错误日志采集 –&gt; 上报  –&gt; 服务端处理 –&gt; 数据库存储  –&gt; 日志收敛 –&gt; 数据监控可视化平台</p><ul><li>可疑区域增加 <code>try...catch</code></li><li>全程监控JS异常<code>window.onerror</code></li><li>静态资源异常<code>window.addEventListener</code></li><li><code>Promise.catch</code> 异常 <code>window.addEventListener(&quot;unhandledrejection&quot;, function()&#123;&#125;)</code></li><li><code>Vue errorHandler</code> 和 <code>React componentDidCatch</code></li><li>跨域异常通过<code>crossOrigin</code>解决</li><li>监控网页崩溃：<code>window</code>对象的<code>load</code>和<code>beforeunload</code> 或<code>navigator.serviceWorker.controller.postMessage API</code></li></ul><h4 id="1-sentry引入"><a href="#1-sentry引入" class="headerlink" title="(1) sentry引入"></a>(1) sentry引入</h4><p>1、 在 src/main.js 入口文件引入 sentry 并初始化<br>    在初始化时，需要传入配置信息</p><pre><code class="hljs JavaScript"><span class="hljs-comment">// main.js</span><span class="hljs-keyword">import</span> InitSentry <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;common/sentry&#x27;</span>;<span class="hljs-comment">// 初始化sentry</span>InitSentry();<span class="hljs-comment">// common/sentry.js</span><span class="hljs-keyword">import</span> moment <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;moment&#x27;</span>;<span class="hljs-keyword">import</span> &#123; EnvEnum &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;common/const/common/env&#x27;</span>; <span class="hljs-comment">// 配置环境信息: 开发环境、预发环境、线上环境 等等</span><span class="hljs-keyword">import</span> &#123; init, captureException, withScope, Severity &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@sentry/browser&#x27;</span>;<span class="hljs-keyword">import</span> &#123; beforeSendHandler &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./handler&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> initSentry = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">const</span> _global = <span class="hljs-built_in">window</span>._global;        <span class="hljs-keyword">const</span> &#123; NODE_ENV_DOCKER &#125; = _global.env;<span class="hljs-comment">// 预发和线上环境才监控</span>  <span class="hljs-keyword">if</span> (NODE_ENV_DOCKER !== EnvEnum.ONLINE   &amp;&amp; NODE_ENV_DOCKER !== EnvEnum.PROD   &amp;&amp; NODE_ENV_DOCKER !== EnvEnum.PRE) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">const</span> &#123; BUILD_TIME = <span class="hljs-built_in">Date</span>.now() &#125; = process.env;        <span class="hljs-keyword">const</span> dsn = <span class="hljs-string">&#x27;https://4a7e72a34bdd438ebc1a9c649de1dc72@crash.youzan.com/31&#x27;</span>;        <span class="hljs-comment">/** 统一线上环境变量值 */</span>        <span class="hljs-keyword">const</span> environment = NODE_ENV_DOCKER === EnvEnum.ONLINE ? EnvEnum.PROD : NODE_ENV_DOCKER;        <span class="hljs-comment">/** 使用打包时的时间作为 release 版本控制 */</span>        <span class="hljs-keyword">const</span> release = moment(BUILD_TIME).format(<span class="hljs-string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>);        <span class="hljs-comment">/** 初始化 传入配置 */</span>        init(&#123;            dsn, <span class="hljs-comment">// 识别</span>            release, <span class="hljs-comment">// 发布版本</span>            environment, <span class="hljs-comment">// 环境</span>            beforeSend: beforeSendHandler, <span class="hljs-comment">// 上报的钩子 附加信息</span>        &#125;);    &#125; <span class="hljs-keyword">catch</span> (error) &#123;        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;sentry 初始化失败&#x27;</span>);    &#125;&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> catchReqException = <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;    withScope(<span class="hljs-function"><span class="hljs-params">scope</span> =&gt;</span> &#123;        scope.setLevel(Severity.Warning);        captureException(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-built_in">JSON</span>.stringify(err)));    &#125;);&#125;;<span class="hljs-comment">/** 自定义上传sentry */</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> catchDebugException = <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;    withScope(<span class="hljs-function"><span class="hljs-params">scope</span> =&gt;</span> &#123;        scope.setLevel(Severity.Debug);        captureException(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-built_in">JSON</span>.stringify(err)));    &#125;);&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> initSentry;<span class="hljs-comment">// handler.js</span><span class="hljs-keyword">import</span> &#123; Event &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@sentry/types&#x27;</span>;<span class="hljs-keyword">import</span> &#123; merge &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;<span class="hljs-keyword">import</span> &#123; ATTENTION_URLS &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../config&#x27;</span>;<span class="hljs-comment">// 以下url中发生的错误都会标记 alert 的标识 </span><span class="hljs-comment">// const ATTENTION_URLS: string[] = [&#x27;#/bill&#x27;, &#x27;#/cashier&#x27;, &#x27;#/dashboard&#x27;, &#x27;#/reserve&#x27;, &#x27;#/verification&#x27;];</span><span class="hljs-keyword">const</span> &#123; _global &#125; = <span class="hljs-built_in">window</span>;<span class="hljs-keyword">const</span> DeptInfo = &#123;    kdtId: _global.env.team_info.kdt_id,    shopName: _global.env.team_info.team_name,    userId: _global.env.user_info.user_id,    userAccount: _global.env.user_info.account,    roleName: _global.env.user_info.roleName,&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> composeTag = (    event: Event,    targetTag: &#123;        [key: string]: any;    &#125;) =&gt; &#123;    <span class="hljs-keyword">if</span> (!event.tags) &#123;        event.tags = &#123;&#125;;    &#125;    <span class="hljs-keyword">return</span> merge(event.tags, targetTag);&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> composeUser = (    event: Event,    targetUrl: &#123;        [key: string]: any;    &#125;) =&gt; &#123;    <span class="hljs-keyword">if</span> (!event.user) &#123;        event.user = &#123;&#125;;    &#125;    <span class="hljs-keyword">return</span> merge(event.user, targetUrl);&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> setUserContext = (event: Event): <span class="hljs-function"><span class="hljs-params">Event</span> =&gt;</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 设置基础用户上下文</span><span class="hljs-comment">     * 提交 event 时会带上</span><span class="hljs-comment">     */</span>    composeUser(event, DeptInfo);    <span class="hljs-keyword">return</span> event;&#125;;<span class="hljs-comment">/** 重置 tags.url 为完整路径 */</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> setTagUrl = (event: Event): <span class="hljs-function"><span class="hljs-params">Event</span> =&gt;</span> &#123;    composeTag(event, &#123;        url: <span class="hljs-built_in">window</span>.location.href,    &#125;);    <span class="hljs-keyword">return</span> event;&#125;;<span class="hljs-comment">/** 设置店铺信息tag方便sentry搜索 */</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> setTagDept = (event: Event): <span class="hljs-function"><span class="hljs-params">Event</span> =&gt;</span> &#123;    composeTag(event, DeptInfo);    <span class="hljs-keyword">return</span> event;&#125;;<span class="hljs-comment">/** 根据 url 判断是否需要增加tags.alert: send */</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> setTagsAlert = (event: Event): <span class="hljs-function"><span class="hljs-params">Event</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> requestUrl = event.request.url;    <span class="hljs-keyword">const</span> isAttentioned = !!ATTENTION_URLS.find(<span class="hljs-function">(<span class="hljs-params">url: string</span>) =&gt;</span> !!requestUrl.match(url));    <span class="hljs-keyword">if</span> (isAttentioned) &#123;        composeTag(event, &#123;            alert: <span class="hljs-string">&#x27;send&#x27;</span>,        &#125;);    &#125;    <span class="hljs-keyword">return</span> event;&#125;;<span class="hljs-comment">/** 设置event 的 tags.route 可以根据 route 进行分类 */</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> setTagsRoute = <span class="hljs-function">(<span class="hljs-params">event: Event</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> requestUrl = event.request.url;    <span class="hljs-keyword">const</span> hash = requestUrl.split(<span class="hljs-string">&#x27;#&#x27;</span>).slice(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>];    <span class="hljs-keyword">if</span> (!hash) &#123;        <span class="hljs-keyword">return</span> event;    &#125;    <span class="hljs-keyword">const</span> route = hash.split(<span class="hljs-string">&#x27;?&#x27;</span>).slice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>];    <span class="hljs-keyword">if</span> (!route) &#123;        <span class="hljs-keyword">return</span> event;    &#125;    composeTag(event, &#123;        route,    &#125;);    <span class="hljs-keyword">return</span> event;&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> beforeSendHandler = (event: Event): <span class="hljs-function"><span class="hljs-params">Event</span> =&gt;</span> &#123;    <span class="hljs-keyword">try</span> &#123;        setTagUrl(event);        setTagDept(event);        setTagsAlert(event);        setTagsRoute(event);        setUserContext(event);    &#125; <span class="hljs-keyword">catch</span> (error) &#123;        <span class="hljs-built_in">console</span>.error(error);    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">return</span> event; <span class="hljs-comment">// eslint-disable-line</span>    &#125;&#125;;</code></pre><p>2、 接口：接口请求和响应 发生错误时的收集</p><pre><code class="hljs JavaScript"><span class="hljs-comment">// 在 ajax.js 中引入 sentry 的 catchReqException方法</span><span class="hljs-keyword">import</span> &#123; catchReqException &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;common/sentry&#x27;</span>;<span class="hljs-comment">// 2、在接口请求和响应 发生错误时 调用 catchReqException(err) 方法，收集 错误信息</span>catchReqException(err);</code></pre><p>3、增加 config/sentry.properties 配置文件</p><pre><code class="hljs text">auth.token=35a38b7ba2fb4fb5b4946f94d572f89c997f00a136074df2a68c70eefac0e05fdefaults.url=https://sentry.xxx.com/defaults.org=sentrydefaults.project=project-webhttp.verify_ssl=false</code></pre><h4 id="2-错误日志收敛"><a href="#2-错误日志收敛" class="headerlink" title="(2) 错误日志收敛"></a>(2) 错误日志收敛</h4><h4 id="3-错误收集-接口错误和页面错误"><a href="#3-错误收集-接口错误和页面错误" class="headerlink" title="(3) 错误收集(接口错误和页面错误)"></a>(3) 错误收集(接口错误和页面错误)</h4><p>(Koa框架) 在 Node 层的中间件中，采用 try…catch -&gt; await next() 方式抓取错误</p><pre><code class="hljs javaScript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 统一错误处理</span><span class="hljs-comment"> */</span><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;    <span class="hljs-keyword">const</span> &#123; reqInfo &#125; = ctx;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">await</span> next();        <span class="hljs-comment">// 如果能正常收到响应，但是响应体是 404时，需要做对应的错误处理</span>        <span class="hljs-keyword">if</span> (ctx.status == <span class="hljs-number">404</span>) &#123;            <span class="hljs-keyword">if</span> (reqInfo.type == <span class="hljs-string">&#x27;api&#x27;</span>) &#123;                <span class="hljs-comment">// 如果是接口报错，则在响应体重增加 响应错误的信息</span>                ctx.body = &#123; <span class="hljs-attr">response</span>: &#123; <span class="hljs-attr">code</span>: <span class="hljs-number">99999</span>, <span class="hljs-attr">desc</span>: <span class="hljs-string">&#x27;接口不存在&#x27;</span> &#125; &#125;;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 如果是页面请求报错，则重定向到 错误页面的路由（错误页面已经准备好）</span>                ctx.redirect(<span class="hljs-string">&#x27;/dashboard#/notFound&#x27;</span>);            &#125;        &#125;    &#125; <span class="hljs-keyword">catch</span> (e) &#123;        <span class="hljs-comment">// 如果无法收到服务端的响应，被 catch 了</span>        <span class="hljs-keyword">if</span> (reqInfo.type == <span class="hljs-string">&#x27;api&#x27;</span>) &#123;            <span class="hljs-comment">// 接口报错</span>            ctx.body = &#123;                response: &#123;                    code: e.code || <span class="hljs-number">99999</span>,                    desc: e.desc || <span class="hljs-string">&#x27;接口调用出错&#x27;</span>,                    message: e.message || <span class="hljs-string">&#x27;&#x27;</span>,                &#125;,            &#125;;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 页面请求报错，则通过 ctx.render 将错误信息渲染到模板上</span>            <span class="hljs-keyword">await</span> ctx.render(<span class="hljs-string">&#x27;error&#x27;</span>, &#123; <span class="hljs-attr">status</span>: <span class="hljs-number">500</span>, <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;系统错误&#x27;</span> &#125;);        &#125;        <span class="hljs-comment">// 并且将错误信息上报到自定义的 错误收集平台</span>        nodejsLogger.warn(<span class="hljs-string">&#x27;系统错误&#x27;</span>, e, &#123;            url: ctx.url,            userId: _.get(ctx.state, <span class="hljs-string">&#x27;userInfo.id&#x27;</span>),            kdtId: _.get(ctx.state, <span class="hljs-string">&#x27;shopInfo.kdtId&#x27;</span>),        &#125;);    &#125;&#125;;</code></pre><h2 id="二、上报与展示"><a href="#二、上报与展示" class="headerlink" title="二、上报与展示"></a>二、上报与展示</h2><h2 id="三-Node-js环境性能监控"><a href="#三-Node-js环境性能监控" class="headerlink" title="三 Node.js环境性能监控"></a>三 Node.js环境性能监控</h2><p><a href="https://juejin.cn/post/6844903781889474567#heading-1">Node.js环境性能监控</a></p><h3 id="1、指标"><a href="#1、指标" class="headerlink" title="1、指标"></a>1、指标</h3><ul><li>CPU</li><li>内存</li><li>磁盘</li><li>I/O</li><li>网络</li></ul><p>在大多数场景下，CPU、内存以及网络就可以说是 Node 的主要性能瓶颈。</p><h3 id="2、CPU指标"><a href="#2、CPU指标" class="headerlink" title="2、CPU指标"></a>2、CPU指标</h3><ul><li>CPU负载和CPU使用率<ul><li>CPU负载： 进程角度</li><li>CPU使用率： CPU时间分配</li></ul></li><li>量化CPU指标</li></ul><h3 id="3、内存指标"><a href="#3、内存指标" class="headerlink" title="3、内存指标"></a>3、内存指标</h3><p>内存是一个非常容易量化的指标。 内存占用率是评判一个系统的内存瓶颈的常见指标。 对于Node来说，内部内存堆栈的使用状态也是一个可以量化的指标。</p><pre><code class="hljs JavaScript"><span class="hljs-comment">// /app/lib/memory.js</span><span class="hljs-keyword">const</span> os = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;os&#x27;</span>);<span class="hljs-comment">// 获取当前Node内存堆栈情况</span><span class="hljs-keyword">const</span> &#123; rss, heapUsed, heapTotal &#125; = process.memoryUsage();<span class="hljs-comment">// 获取系统空闲内存</span><span class="hljs-keyword">const</span> sysFree = os.freemem();<span class="hljs-comment">// 获取系统总内存</span><span class="hljs-keyword">const</span> sysTotal = os.totalmem();<span class="hljs-built_in">module</span>.exports = &#123;memory: <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">return</span> &#123;sys: <span class="hljs-number">1</span> - sysFree / sysTotal,  <span class="hljs-comment">// 系统内存占用率</span>heap: heapUsed / headTotal,   <span class="hljs-comment">// Node堆内存占用率</span>node: rss / sysTotal,         <span class="hljs-comment">// Node占用系统内存的比例</span>&#125;&#125;&#125;</code></pre><p>对于process.memoryUsage()拿到的值有一些需要关注的地方：</p><ul><li>rss：表示node进程占用的内存总量</li><li>heapTotal：表示堆内存的总量</li><li>heapUsed：实际堆内存的使用量</li><li>external：外部程序的内存使用量，包含Node核心的C++程序的内存使用量</li></ul><h3 id="4、QPS"><a href="#4、QPS" class="headerlink" title="4、QPS"></a>4、QPS</h3><h3 id="5、环境压测"><a href="#5、环境压测" class="headerlink" title="5、环境压测"></a>5、环境压测</h3><h2 id="四-项目"><a href="#四-项目" class="headerlink" title="四 项目"></a>四 项目</h2><h3 id="1-发现性能瓶颈并优化的经验"><a href="#1-发现性能瓶颈并优化的经验" class="headerlink" title="1 发现性能瓶颈并优化的经验"></a>1 发现性能瓶颈并优化的经验</h3><p>分享一下我近期的经验，之前项目也碰到过用起来很卡的情况，就是用element ui的tab切换组件时，点击tab切换非常卡，非常耗时，在排除了网络请求和js代码执行时间过长等原因后，跑了一次perfermance，结果发现大部分时间都花费在了 DOM GC上了，分析了下原因可能时dom结构太多导致每次tab切换渲染太耗时了。由于我每个tab里面的html结构都一样，都是一个table，只是每次tab切换时请求的数据不一样，我就把table抽离出来了，放到tab组件外面，然后tab里面就空了，就没有那么多dom了，tab切换就不卡了，很流畅。（ps：tab有20-30个切换选项，本人语文水平不行，描述的不清楚，望轻喷。）</p><h3 id="2-项目"><a href="#2-项目" class="headerlink" title="2 项目"></a>2 项目</h3><p>登录 - 本域登录、第三方接入登录（小红书、微博、爱逛等等）<br>店铺装修 - 素材、模板、员工（列表、排班、考勤、业绩提成）<br>商品 - 服务、卡项、产品，耗材、入库、出库<br>订单 - 开单、采购单、退款、欠款、核销、<br>预约<br>客户<br>数据<br>资产<br>会员<br>营销活动</p>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>js</tag>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React 生命周期</title>
    <link href="/2018/12/08/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2018/12/08/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="一、React-v16前的生命周期"><a href="#一、React-v16前的生命周期" class="headerlink" title="一、React v16前的生命周期"></a>一、React v16前的生命周期</h2><p><img src="https://i.loli.net/2020/12/14/NSUGMIZ1jLE6WOy.png" alt="React生命周期.png"></p><h3 id="1、第一阶段-initialization-组件初始化阶段"><a href="#1、第一阶段-initialization-组件初始化阶段" class="headerlink" title="1、第一阶段(initialization): 组件初始化阶段"></a>1、第一阶段(<code>initialization</code>): 组件初始化阶段</h3><p>该状态主要用于将父组件的<code>props</code>注入给子组件，并初始化<code>state</code>，对应<code>React V16</code>后的<code>constructor()</code>阶段。</p><pre><code class="hljs javascript"><span class="hljs-comment">// React v16前</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  state = &#123;    stateA: <span class="hljs-string">&#x27;aaa&#x27;</span>,    stateB: <span class="hljs-string">&#x27;bbb&#x27;</span>,  &#125;;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-comment">// return ...</span>  &#125;;&#125;<span class="hljs-comment">// React v16后</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;    <span class="hljs-built_in">super</span>(props);    <span class="hljs-built_in">this</span>.state = &#123;      stateA: <span class="hljs-string">&#x27;aaa&#x27;</span>,      stateB: <span class="hljs-string">&#x27;bbb&#x27;</span>,    &#125;  &#125;;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-comment">// return ...</span>  &#125;;&#125;</code></pre><h3 id="2、第二阶段-Mounting-组件挂载阶段"><a href="#2、第二阶段-Mounting-组件挂载阶段" class="headerlink" title="2、第二阶段(Mounting): 组件挂载阶段"></a>2、第二阶段(<code>Mounting</code>): 组件挂载阶段</h3><p>这个阶段分为三个子阶段： <strong><code>componentWillMount =&gt; render =&gt; componentDidMount</code></strong> ：</p><ul><li><p><code>componentWillMount</code>:<br>在组件挂载到DOM前调用，且只会被调用一次，在这里调用<code>this.setState</code>不会引起组件重新渲染，也可以把写在这边的内容提前到<code>constructor()</code>中，所以项目中很少用。<br>此时可以进行开启定时器、向服务器发送请求等操作。</p></li><li><p><code>render</code><br>根据组件的<code>props</code>和<code>state</code>（两者的重传递和重赋值，无论值是否有变化，都可以引起组件重新<code>render</code>），<code>return</code> 一个<code>React</code>元素（描述组件，即UI），不负责组件实际渲染工作。<br>之后由<code>React</code>自身根据此元素去渲染出页面DOM。<code>render</code>是纯函数，不能在里面执行<code>this.setState</code>，否则会有改变组件状态的副作用。</p></li><li><p><code>componentDidMount</code><br>组件挂载到DOM后调用，全程只执行一次，此时我们可以获取到DOM节点并操作，比如对canvas、svg的操作、服务器请求、订阅都可以写在这个里面，但是记得在componentWillUnmount中取消订阅。<br>需要注意的是本组件的render执行完，并不会调用componentDidMount()，而是全部子组件的render调用完后才会调用。</p></li></ul><h3 id="3、第三阶段-update-组件更新阶段"><a href="#3、第三阶段-update-组件更新阶段" class="headerlink" title="3、第三阶段(update): 组件更新阶段"></a>3、第三阶段(<code>update</code>): 组件更新阶段</h3><p><code>setState</code>引起的<code>state</code>更新或父组件重新<code>render</code>引起的<code>props</code>更新（更新后的<code>state</code>和<code>props</code>相对之前无论是否有变化），都将引起子组件的重新<code>render</code>。</p><p>造成组件更新有两类（三种）情况：</p><ol><li>父组件重新<code>render</code><br>父组件重新<code>render</code>引起子组件重新<code>render</code>的情况有两种：<br>　　（a）每当父组件重新<code>render</code>导致的重传<code>props</code>，子组件将直接跟着重新渲染(无论<code>props</code>是否有变化)。可通过<code>shouldComponentUpdate</code>方法优化。  </li></ol><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ParentComponent</span> </span>&#123;   <span class="hljs-function"><span class="hljs-title">shouldComponentUpdate</span>(<span class="hljs-params">nextProps</span>)</span>&#123;      <span class="hljs-comment">// 应该使用这个方法，否则无论state是否有变化都将会导致组件重新渲染</span>      <span class="hljs-keyword">if</span>(nextProps.someThings === <span class="hljs-built_in">this</span>.props.someThings)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>      &#125;    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;this.props.someThings&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    &#125;&#125;</code></pre><p>　　（b）在<code>componentWillReceiveProps</code>方法中，将<code>props</code>转换成自己的<code>state</code>。</p><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ParentComponent</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;    <span class="hljs-built_in">super</span>(props);    <span class="hljs-built_in">this</span>.state = &#123;        someThings: props.someThings    &#125;;  &#125;  <span class="hljs-function"><span class="hljs-title">componentWillReceiveProps</span>(<span class="hljs-params">nextProps</span>)</span> &#123; <span class="hljs-comment">// 父组件重传props时就会调用这个方法</span>    <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">someThings</span>: nextProps.someThings&#125;);  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;this.state.someThings&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  &#125;&#125;</code></pre><blockquote><p>在函数<code>componentWillReceiveProps</code>中调用 <code>this.setState()</code> 将不会引起第二次渲染。<br>(是因为<code>componentWillReceiveProps</code>中判断<code>props</code>是否发生变，若变化了，<code>this.setState</code>将引起<code>state</code>变化，从而引起<code>render</code>，此时就没必要再做第二次因重传<code>props</code>引起的<code>render</code>了，不然重复做一样的渲染了。)</p></blockquote><ol><li>组件本身调用<code>setState</code>(无论<code>state</code>有没有变化)。可通过<code>shouldComponentUpdate</code>方法优化。</li></ol><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;    <span class="hljs-built_in">super</span>(props);    <span class="hljs-built_in">this</span>.state = &#123;      someThings:<span class="hljs-number">1</span>    &#125;  &#125;  <span class="hljs-function"><span class="hljs-title">shouldComponentUpdate</span>(<span class="hljs-params">nextStates</span>)</span>&#123;     <span class="hljs-comment">// 应该使用这个方法，否则无论state是否有变化都将会导致组件重新渲染</span>    <span class="hljs-keyword">if</span>(nextStates.someThings === <span class="hljs-built_in">this</span>.state.someThings)&#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;  &#125;  handleClick = <span class="hljs-function">() =&gt;</span> &#123;     <span class="hljs-keyword">const</span> preSomeThings = <span class="hljs-built_in">this</span>.state.someThings    <span class="hljs-comment">// 虽然调用了setState ，但state并无变化</span>    <span class="hljs-built_in">this</span>.setState(&#123;      someThings: preSomeThings    &#125;)  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span> = <span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span>&#123;this.state.someThings&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  &#125;&#125;</code></pre><p>在调用<code>this.setState</code>方法到渲染完成阶段分为: </p><ul><li><p><strong>-&gt; <code>componentWillReceiveProps</code></strong></p></li><li><p><strong>-&gt;<code>shouldComponentUpdate</code></strong></p></li><li><p><strong>-&gt; <code>componentWillUpdate</code></strong></p></li><li><p><strong>-&gt; <code>render</code></strong></p></li><li><p><strong>-&gt; <code>componentDidUpdate</code></strong>:</p><ul><li><p><code>componentWillReceiveProps(nextProps)</code><br>此方法只调用于<code>props</code>引起的组件更新过程中，响应 <code>Props</code> 变化之后进行更新的唯一方式，参数<code>nextProps</code>是父组件传给当前组件的新<code>props</code>。但父组件<code>render</code>方法的调用不能保证重传给当前组件的<code>props</code>是有变化的，所以在此方法中根据<code>nextProps</code>和<code>this.props</code>来查明重传的<code>props</code>是否改变，以及如果改变了要执行啥，比如根据新的<code>props</code>调用<code>this.setState</code>出发当前组件的重新<code>render</code>.</p></li><li><p><code>shouldComponentUpdate(nextProps, nextState)</code><br>此方法通过比较<code>nextProps</code>、<code>nextState</code>及当前组件的<code>this.props</code>、<code>this.state</code>，返回true时当前组件将继续执行更新过程，返回<code>false</code>则当前组件更新停止，以此可用来减少组件的不必要渲染，优化组件性能。<br>ps：这边也可以看出，就算<code>componentWillReceiveProps()</code>中执行了<code>this.setState</code>，更新了<code>state</code>，但在<code>render</code>前（如<code>shouldComponentUpdate</code>，<code>componentWillUpdate</code>），<code>this.state</code>依然指向更新前的<code>state</code>，不然<code>nextState</code>及当前组件的<code>this.state</code>的对比就一直是<code>true</code>了。<br>如果<code>shouldComponentUpdate</code> 返回<code>false</code>，那就一定不用<code>rerender</code>(重新渲染)这个组件了，组件的<code>React elements</code>(React 元素) 也不用去比对。 但是如果<code>shouldComponentUpdate</code>返回<code>true</code>，会进行组件的<code>React elements</code>比对，如果相同，则不用<code>rerender</code>这个组件，如果不同，会调用<code>render</code>函数进行<code>rerender</code>。</p></li><li><p><code>componentWillUpdate(nextProps, nextState)</code><br>此方法在调用<code>render</code>方法前执行，在这边可执行一些组件更新发生前的工作，一般较少用。</p></li><li><p><code>render</code></p></li><li><p><code>componentDidUpdate</code><br>此方法在组件更新后被调用，可以操作组件更新的DOM，<code>prevProps</code>和<code>prevState</code>这两个参数指的是组件更新前的<code>props</code>和<code>state</code></p></li></ul></li></ul><h3 id="4、第四阶段-componentWillUnmount-组件卸载阶段"><a href="#4、第四阶段-componentWillUnmount-组件卸载阶段" class="headerlink" title="4、第四阶段(componentWillUnmount): 组件卸载阶段"></a>4、第四阶段(<code>componentWillUnmount</code>): 组件卸载阶段</h3><p>此阶段只有一个生命周期方法：<code>componentWillUnmount</code>：<br>此方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清楚组件中使用的定时器，清除<code>componentDidMount</code>中手动创建的DOM元素等，以避免引起内存泄漏。</p><h2 id="二、React-v16-的生命周期"><a href="#二、React-v16-的生命周期" class="headerlink" title="二、React v16+ 的生命周期"></a>二、React v16+ 的生命周期</h2><p><code>React V16</code>版本后生命周期的分界点在<code>React V16.3</code></p><p><strong><code>React V16.3</code>的生命周期为</strong><br><img src="https://i.loli.net/2020/12/09/5R7AXftT6szW1nq.png" alt="React V16.3生命周期"></p><p><strong><code>React V16.4+</code>的生命周期为</strong><br><img src="https://i.loli.net/2020/12/09/gEyt6U785HqOIVd.png" alt="React V16.4+生命周期"></p><p><code>React 16</code>废弃了之前的三个生命周期函数:</p><ul><li><del>componentWillMount</del></li><li><del>componentWillReceiveProps</del></li><li><del>componentWillUpdate</del></li></ul><p>取而代之的是两个新的生命中后期函数:</p><ul><li>static getDerivedStateFromProps</li><li>getSnapshotBeforeUpdate</li></ul><blockquote><p>注：目前在16版本中componentWillMount，componentWillReceiveProps，componentWillUpdate并未完全删除这三个生命周期函数，而且新增了UNSAFE_componentWillMount，UNSAFE_componentWillReceiveProps，UNSAFE_componentWillUpdate三个函数，官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们</p></blockquote><h3 id="1、第一阶段-Mounting-组件挂载阶段"><a href="#1、第一阶段-Mounting-组件挂载阶段" class="headerlink" title="1、第一阶段(Mounting): 组件挂载阶段"></a>1、第一阶段(<code>Mounting</code>): 组件挂载阶段</h3><p>这个阶段分为四个子阶段：</p><ul><li>constructor</li><li>getDerivedStateFromProps</li><li><del>componentWillMount/UNSAVE_componentWillMount</del></li><li>render</li><li>componentDidMount</li></ul><p><strong>constructor</strong></p><p>这个阶段一般会做两件事:  </p><ul><li>初始化state对象</li><li>给自定义方法绑定this</li></ul><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;    <span class="hljs-built_in">super</span>(props)        <span class="hljs-built_in">this</span>.state = &#123;      stateA: <span class="hljs-string">&#x27;aaa&#x27;</span>,      stateB: <span class="hljs-string">&#x27;bbb&#x27;</span>    &#125;    <span class="hljs-built_in">this</span>.handleChange1 = <span class="hljs-built_in">this</span>.handleChange1.bind(<span class="hljs-built_in">this</span>)&#125;</code></pre><p><strong>getDerivedStateFromProps</strong></p><blockquote><p>static getDerivedStateFromProps(nextProps, prevState)</p></blockquote><p>一个静态方法，所以不能在这个函数里面使用<code>this</code>，这个函数有两个参数<code>props</code>和<code>state</code>，分别指接收到的新参数和当前的<code>state</code>对象，这个函数会返回一个对象用来更新当前的<code>state</code>对象，如果不需要更新可以返回<code>null</code><br>该函数会在挂载时、接收到新的props、调用了setState和forceUpdate时被调用。（在React v16.3时只有在挂载时和接收到新的props被调用，据说这是官方的失误，后来修复了）</p><p><img src="https://i.loli.net/2020/12/09/AdGQNkLVj1FZn5z.png" alt="V16.3"></p><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  state = &#123;    isScrollingDown: <span class="hljs-literal">false</span>,    lastRow: <span class="hljs-literal">null</span>  &#125;  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getDerivedStateFromProps</span>(<span class="hljs-params">nextProps, prevState</span>)</span> &#123;    <span class="hljs-keyword">if</span> (nextProps.currentRow !== prevState.lastRow) &#123;        <span class="hljs-keyword">return</span> &#123;            isScrollingDown: nextProps.currentRow &gt; prevState.lastRow,            lastRow: nextProps.currentRow        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>  &#125;&#125;</code></pre><p><strong>Render</strong></p><p>React最核心的方法，一个组件中必须要有这个方法<br>返回的类型有以下几种： </p><ul><li>原生的DOM，如div</li><li>React组件</li><li>Fragment（片段） -（React16新增）</li><li>Portals（插槽） -（React16新增）</li><li>字符串和数字，被渲染成text节点</li><li>Boolean和null，不会渲染任何东西</li></ul><p><strong>componentDidMount</strong></p><p>组件挂载到DOM后调用，全程只执行一次，此时我们可以获取到DOM节点并操作，比如对canvas、svg的操作、服务器请求、订阅都可以写在这个里面，但是记得在componentWillUnmount中取消订阅。<br>需要注意的是本组件的render执行完，并不会调用componentDidMount()，而是全部子组件的render调用完后才会调用。</p><h3 id="2、第二阶段-Updating-更新阶段"><a href="#2、第二阶段-Updating-更新阶段" class="headerlink" title="2、第二阶段(Updating): 更新阶段"></a>2、第二阶段(<code>Updating</code>): 更新阶段</h3><p>更新阶段，当组件的<code>props</code>发生改变、组件内部调用了<code>setState</code> 或者<code>forceUpdate</code>发生，会发生多次.  </p><ul><li><del><code>componentWillReceiveProps/UNSAFE_componentWillReceiveProps</code></del></li><li><code>getDerivedStateFromProps</code></li><li><code>shouldComponentUpdate</code></li><li><del><code>componentWillUpdate/UNSAFE_componentWillUpdate</code></del></li><li><code>render</code></li><li><code>getSnapshotBeforeUpdate</code></li><li><code>componentDidUpdate</code></li></ul><p><strong>getDerivedStateFromProps</strong></p><p>与挂载阶段的 <code>getDerivedStateFromProps(nextProps, prevState)</code>一样</p><blockquote><p>static getDerivedStateFromProps(nextProps, prevState)</p></blockquote><p><strong>shouldComponentUpdate</strong></p><pre><code class="hljs javascript">shouldComponentUpdate(nextProps, nextState)</code></pre><p>参数nextProps和nextState分别表示新的属性和变化之后的state，返回一个布尔值。<br>true表示会触发重新渲染，false表示不会触发重新渲染，默认返回true。</p><blockquote><p>注意当我们调用forceUpdate并不会触发此方法**<br>因为默认是返回true，也就是只要接收到新的属性和调用了setState都会触发重新的渲染，这会带来一定的性能问题，所以我们需要将this.props与nextProps以及this.state与nextState进行比较来决定是否返回false，来减少重新渲染.(在未来的版本，shouldComponentUpdate返回false，仍然可能导致组件重新的渲染，这是官方自己说的)</p></blockquote><p><strong>render</strong> </p><p>与挂载阶段的 <code>render</code>一样</p><p><strong>getSnapshotBeforeUpdate</strong></p><p><code>javascript</code><br>getSnapshotBeforeUpdate(prevProps, prevState)</p><pre><code class="hljs autohotkey">这个方法在`render`之后、`componentDidUpdate`之前调用，有两个参数`prevProps`和`prevState`，表示之前的props和之前的`state`。这个函数有一个返回值，会作为第三个参数传给`componentDidUpdate`，如果你不想要返回值，请返回`null`，不写的话控制台会有警告.还有这个方法一定要和`componentDidUpdate`一起使用，否则控制台也会有警告。前面说过这个方法时用来代替 `componentWillUpdate/UNSAFE_componentWillUpdate`.**componentDidUpdate**```javascriptcomponentDidUpdate(prevProps, prevState, snapshot)</code></pre><p>该方法在<code>getSnapshotBeforeUpdate</code>方法之后被调用，有三个参数<code>prevProps</code>、<code>prevState</code>、<code>snapshot</code>，表示之前的<code>props</code>、之前的<code>state</code>，和<code>snapshot</code>。第三个参数是<code>getSnapshotBeforeUpdate</code>返回的。</p><p>在这个函数里我们可以操作DOM，和发起服务器请求，还可以<code>setState</code>，但是注意一定要用<code>if</code>语句控制，否则会导致无限循环。</p><h3 id="3、第三阶段-UnMounting-卸载阶段"><a href="#3、第三阶段-UnMounting-卸载阶段" class="headerlink" title="3、第三阶段(UnMounting): 卸载阶段"></a>3、第三阶段(<code>UnMounting</code>): 卸载阶段</h3><p>这个阶段的生命周期函数只有一个：</p><ul><li>componentWillUnmount</li></ul><p>当我们的组件被卸载或者销毁了就会调用，我们可以在这个函数里去清除一些定时器，取消网络请求，清理无效的DOM元素等垃圾清理工作。</p><p>注意不要在这个函数里去调用setState，因为组件不会重新渲染了。</p><blockquote><p>参考资料：<br><a href="https://juejin.cn/post/6844903655372488712#heading-12">我对 React v16.4 生命周期的理解</a><br><a href="https://www.jianshu.com/p/514fe21b9914">详解React生命周期(包括react16最新版)</a><br><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">生命周期图谱</a><br><a href="https://zh-hans.reactjs.org/docs/state-and-lifecycle.html">State &amp; 生命周期</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Diff</title>
    <link href="/2018/05/29/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React-diff/"/>
    <url>/2018/05/29/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React-diff/</url>
    
    <content type="html"><![CDATA[<h1 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h1><h3 id="初始化-fiber-tree-流程"><a href="#初始化-fiber-tree-流程" class="headerlink" title="初始化 fiber tree 流程"></a>初始化 fiber tree 流程</h3><h3 id="根节点-fiberRootNode-创建"><a href="#根节点-fiberRootNode-创建" class="headerlink" title="根节点 fiberRootNode 创建"></a>根节点 fiberRootNode 创建</h3><h3 id="组件-fiberNode-创建"><a href="#组件-fiberNode-创建" class="headerlink" title="组件 fiberNode 创建"></a>组件 fiberNode 创建</h3><h3 id="reconciler-阶段"><a href="#reconciler-阶段" class="headerlink" title="reconciler 阶段"></a>reconciler 阶段</h3><h3 id="renderer-阶段"><a href="#renderer-阶段" class="headerlink" title="renderer 阶段"></a>renderer 阶段</h3><h3 id="commit-阶段"><a href="#commit-阶段" class="headerlink" title="commit 阶段"></a>commit 阶段</h3><h3 id="beginWork-流程"><a href="#beginWork-流程" class="headerlink" title="beginWork 流程"></a>beginWork 流程</h3><h3 id="completeWork-流程"><a href="#completeWork-流程" class="headerlink" title="completeWork 流程"></a>completeWork 流程</h3><h3 id="commitWork-流程"><a href="#commitWork-流程" class="headerlink" title="commitWork 流程"></a>commitWork 流程</h3><h3 id="alternate-fiber-tree-流程-（diff-过程）"><a href="#alternate-fiber-tree-流程-（diff-过程）" class="headerlink" title="alternate fiber tree 流程 （diff 过程）"></a>alternate fiber tree 流程 （diff 过程）</h3><h2 id="workLoop-环节"><a href="#workLoop-环节" class="headerlink" title="workLoop 环节"></a>workLoop 环节</h2><h3 id="performConcurrentWorkOnRoot-流程"><a href="#performConcurrentWorkOnRoot-流程" class="headerlink" title="performConcurrentWorkOnRoot 流程"></a>performConcurrentWorkOnRoot 流程</h3><p>并发模式 concurrent 级别的调度任务</p><h3 id="performSyncWorkOnRoot-流程"><a href="#performSyncWorkOnRoot-流程" class="headerlink" title="performSyncWorkOnRoot 流程"></a>performSyncWorkOnRoot 流程</h3><blockquote><p>syncLane 级别的调度任务</p></blockquote><p>常量集合</p><p><strong>react执行上下文状态</strong></p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> NoContext = <span class="hljs-comment">/*             */</span> <span class="hljs-number">0b0000000</span>;<span class="hljs-keyword">const</span> BatchedContext = <span class="hljs-comment">/*               */</span> <span class="hljs-number">0b0000001</span>;<span class="hljs-keyword">const</span> EventContext = <span class="hljs-comment">/*                 */</span> <span class="hljs-number">0b0000010</span>;<span class="hljs-keyword">const</span> DiscreteEventContext = <span class="hljs-comment">/*         */</span> <span class="hljs-number">0b0000100</span>;<span class="hljs-keyword">const</span> LegacyUnbatchedContext = <span class="hljs-comment">/*       */</span> <span class="hljs-number">0b0001000</span>;<span class="hljs-keyword">const</span> RenderContext = <span class="hljs-comment">/*                */</span> <span class="hljs-number">0b0010000</span>;<span class="hljs-keyword">const</span> CommitContext = <span class="hljs-comment">/*                */</span> <span class="hljs-number">0b0100000</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> RetryAfterError = <span class="hljs-comment">/*       */</span> <span class="hljs-number">0b1000000</span>;</code></pre><p><strong>Root 节点状态</strong></p><pre><code class="hljs js">type RootExitStatus = <span class="hljs-number">0</span> | <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span> | <span class="hljs-number">4</span> | <span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> RootIncomplete = <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> RootFatalErrored = <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> RootErrored = <span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> RootSuspended = <span class="hljs-number">3</span>;<span class="hljs-keyword">const</span> RootSuspendedWithDelay = <span class="hljs-number">4</span>;<span class="hljs-keyword">const</span> RootCompleted = <span class="hljs-number">5</span>;</code></pre><p><strong>需要注意的很多标记属性</strong></p><pre><code class="hljs js"><span class="hljs-comment">// Describes where we are in the React execution stack</span><span class="hljs-keyword">let</span> executionContext: ExecutionContext = NoContext;<span class="hljs-comment">// The root we&#x27;re working on</span><span class="hljs-keyword">let</span> workInProgressRoot: FiberRoot | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<span class="hljs-comment">// The fiber we&#x27;re working on</span><span class="hljs-keyword">let</span> workInProgress: Fiber | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<span class="hljs-comment">// The lanes we&#x27;re rendering</span><span class="hljs-keyword">let</span> workInProgressRootRenderLanes: Lanes = NoLanes;<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> subtreeRenderLanes: Lanes = NoLanes;</code></pre><h4 id="flushPassiveEffects"><a href="#flushPassiveEffects" class="headerlink" title="flushPassiveEffects"></a>flushPassiveEffects</h4><p>遍历执行 useEffect 的回调</p><h4 id="renderRootSync"><a href="#renderRootSync" class="headerlink" title="renderRootSync"></a>renderRootSync</h4><p>这里应该就是 reconciler 流程的入口了</p><p>####</p>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Hooks</title>
    <link href="/2018/05/29/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React-Hooks/"/>
    <url>/2018/05/29/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React-Hooks/</url>
    
    <content type="html"><![CDATA[<h3 id="1-useState-在-组件初始化（Mount）阶段"><a href="#1-useState-在-组件初始化（Mount）阶段" class="headerlink" title="1. useState 在 组件初始化（Mount）阶段"></a>1. useState 在 组件初始化（Mount）阶段</h3><ul><li>1.获取当前 Hook 节点，同时将当前 Hook 添加到 Hook 链表中</li><li>2.初始化 Hook 的状态，即读取初始 state 值</li><li>3.创建一个新的链表作为更新队列，用来存放更新操作（setXxx()）</li><li>4.创建一个 dispatch 方法（即 useState 返回的数组的第二个参数：setXxx()），该方法的用途是用来修改 state，并将此更新操作添加到更新队列中，另外还会将该更新和当前正在渲染的 fiber 绑定起来</li><li>5.返回当前 state 和 修改 state 的方法（dispatch）</li></ul><h3 id="2-Hook-数据结构"><a href="#2-Hook-数据结构" class="headerlink" title="2. Hook 数据结构"></a>2. Hook 数据结构</h3><p>一个函数组件中的所有 Hook 是以 链表 的形式存储的。链表中的每个节点就是一个 HooK</p><pre><code class="hljs JavaScript">type Hook = &#123;memoizedState: any, <span class="hljs-comment">// Hook 自身维护的状态</span>baseState: any,baseUpdate: Update&lt;any, any&gt; | <span class="hljs-literal">null</span>,queue: UpdateQueue&lt;any, any&gt; | <span class="hljs-literal">null</span>, <span class="hljs-comment">// Hook 自身维护的更新队列</span>next: Hook | <span class="hljs-literal">null</span>, <span class="hljs-comment">// next 指向下一个 Hook</span>&#125;;</code></pre><p>链表保存在哪里：假如原来还没有 Hook 链表，那么就会将新建的 Hook 节点作为 Hook 链表的头结点，然后把 Hook 链表的头结点保存在 currentlyRenderingFiber.memoizedState 中，也就是当前 FiberNode 的 memoizedState 属性</p><h3 id="3-useState-如何处理-state-更新"><a href="#3-useState-如何处理-state-更新" class="headerlink" title="3. useState 如何处理 state 更新"></a>3. useState 如何处理 state 更新</h3><p>当我们调用跟新 state 的方法（setXxx）的时候，即时调用了 dispatchAction()，这个函数的工作是：新建一个新的 update 对象，添加到更新队列中（queue 链表）上，而且这实际是一个 循环链表。</p><p>何时触发组件更新（重新渲染）使组件到达Update 阶段？</p><p>在将 update 对象添加到 Hook 的更新队列链表后，dispatchAction() 还会去判断当前调用 setXxx(action) 传入的值（action）和上一次渲染的 state（此时正显示在屏幕上的 state）作对比，看看有没有变化，如果有变化，则调用 scheduleWork() 安排 fiberNode 的更新工作（组件重新渲染），如果没变化，则直接跳过，不安排更新（组件重新渲染）</p><p>Hook 当 Update 阶段：</p><ul><li>1.获取正在执行的处于更新阶段 Hook 节点；</li><li>2.获取该 Hook 节点的更新队列链表；</li><li>3.从该更新队列的最早的 update 对象节点开始遍历，一直遍历到最近添加的（最新的）update 对象节点，遍历到每个节点的时候执行该节点的更新操作，将该次更新的 state 值存到 newState 中；</li><li>4.当遍历完最近的一个 update 对象节点后，此时 newState 里存放的就是最新的 state 值，最后返回 newState，于是用户就拿到了最新的 state；</li></ul><h3 id="4-useState-运行流程"><a href="#4-useState-运行流程" class="headerlink" title="4. useState 运行流程"></a>4. useState 运行流程</h3><p>当第一次执行 useState，也就是 mount 阶段，所以执行的是 mountState。</p><ul><li>1 在 Hook 链表上添加该 useState 的 Hook 节点</li><li>2 初始化 state 的值</li><li>3 返回此次渲染的 state 和 修改 state 的方法</li></ul><p>当调用 setXxx/dispatchAction 时</p><ul><li>1 创建 update 对象，并将 update 对象添加到该 Hook 节点的更新队列链表；</li><li>2 判断传入的值（action）和当前正在屏幕上渲染的 state 值是否相同，若相同则略过；若不相同，则调用 scheduleWork 安排组件的重新渲染；</li><li>3 当前所有 setXxx 都逐一执行完后，假如其中能满足（2）的条件，即有调用 scheduleWork 的话，则触发更新（组件重新渲染），进入 Update 阶段；</li></ul><p>组件重新渲染（更新）时 ，进入 Update 阶段，即第 2 、第 3 、… n 次执行 useState：</p><ul><li>1 获取该 useState Hook 的更新队列链表；</li><li>2 遍历这个更新队列链表，从最早的那一个 update 对象进行遍历，直至遍历到最近的添加那一个 update 对象，最后得到最新的 state 并返回，作为组件此次渲染的 state；</li><li>3 返回此次渲染的 state 和 修改 state 的方法</li></ul><h3 id="5-useEffect-运行流程"><a href="#5-useEffect-运行流程" class="headerlink" title="5. useEffect 运行流程"></a>5. useEffect 运行流程</h3><p>一个使用 useEffect Hook 的函数组件，在运行的时候的运行流程如下：<br>组件初次渲染（挂载）：</p><ul><li>1 执行 useEffect 时，将 useEffect Hook 添加到 Hook 链表中，然后创建 fiberNode 的 updateQueue，并把本次 effect 添加到 updateQueue 中；</li><li>2 渲染组件的 UI；</li><li>3 完成 UI 渲染后，执行本次 effect；</li></ul><p>组件重新渲染（更新）：</p><ul><li><p>1 执行 useEffect 时，将 useEffect Hook 添加到 Hook 链表中，判断依赖：</p><ul><li>（1）假如没有传入依赖（useEffect 没有传入第二个参数），那么直接给这个 effect 打上 “需要执行” 的 tag（HookHasEffect）；</li><li>（2）假如有传入依赖 deps 并且当前依赖和上次渲染时的依赖对比有发生改变，那么就给这个 effect 打上 “需要执行” 的 tag（HookHasEffect）；</li><li>（3）假如有传入依赖 deps，但是依赖没有发生改变，则 不会 给这个 effect “需要执行” 的 tag；</li><li>（4）假如有传入依赖 deps，但是传入的是一个空数组 []，那么也 不会 给这个 effect “需要执行” 的 tag；</li></ul></li><li><p>2 渲染组件的 UI；</p></li><li><p>3 假如有清除函数（effect 中的 return 内容），则执行上一次渲染的清除函数；如果依赖是 []，则先不用执行清除函数，而是等到组件销毁时才执行；</p></li><li><p>4 判断本次 effect 是否有“需要执行” 的 tag（HookHasEffect），如果有，就执行本次 effect；如果没有，就直接跳过，不执行 本次 effect；</p></li></ul><p>组件销毁时：</p><p>在组件销毁之前，先执行完组件上次渲染时的清除函数</p><h3 id="7-useEffect-和-useMemo-、-useCallBack-的区别"><a href="#7-useEffect-和-useMemo-、-useCallBack-的区别" class="headerlink" title="7. useEffect 和 useMemo 、 useCallBack 的区别"></a>7. useEffect 和 useMemo 、 useCallBack 的区别</h3><p>React.memo 为高阶组件，默认对 props 做一次浅比较，如果 props 没有变化，则子组件不会重新执行。<br>它与 React.PureComponent 非常相似，但它适用于函数组件，但不适用于 class 组件。</p><h3 id="6-Hooks-闭包"><a href="#6-Hooks-闭包" class="headerlink" title="6. Hooks 闭包"></a>6. Hooks 闭包</h3><p>一个 Fiber节点就对应的是一个组件，Fiber 对象上有一个 memoizedState 用于存放组件的 state。<br>hooks 所针对的 FunctionComponnet ，一个对象都只能有一个 state 属性或者 memoizedState 属性。<br>那么怎么满足 一个 FunctionComponnet 可以存放多个 state 的需求呢？<br>所以，react用了链表这种数据结构来存储 FunctionComponent 里面的 hooks。<br>memoizedState属性就是用来存储组件上一次更新后的 state,next毫无疑问是指向下一个hook对象，<br>在组件更新的过程中，hooks函数执行的顺序是不变的，就可以根据这个链表拿到当前hooks对应的Hook对象，函数式组件就是这样拥有了state的能力。</p><p><code>useEffect</code> 会捕获 <code>props</code> 和 <code>state</code>，形成闭包。所以即便在回调函数里，你拿到的还是初始的 <code>props</code> 和 <code>state</code>。<br>如果想得到“最新”的值，可以使用 <code>ref</code>（<code>useRef</code>）。</p><p>在组件每一次渲染的过程中。 比如 ref = useRef() 所返回的都是同一个对象，每次组件更新所生成的ref指向的都是<strong>同一片内存空间</strong>， 那么当然能够每次都拿到最新鲜的值了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 - 排序和搜索</title>
    <link href="/2018/02/27/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/"/>
    <url>/2018/02/27/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p>排序算法：</p><ul><li>冒泡排序</li><li>选择排序</li><li>插入排序</li><li>归并排序</li><li>快速排序</li><li>…</li></ul><p>搜索算法：</p><ul><li>顺序搜索</li><li>二分搜索</li><li>…</li></ul><h2 id="一、排序"><a href="#一、排序" class="headerlink" title="一、排序"></a>一、排序</h2><h3 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h3><p>步骤：</p><ol><li>比较所有相邻元素，如果第一个比第二个大，则交换它们</li><li>一轮下来，可以保证最后一个数是最大的</li><li>执行 n-1 轮，就可以完成排序</li></ol><p>排序可视化网站：<br><a href="https://visualgo.net/zh/sorting">visualgo.net/zh/sorting</a></p><pre><code class="hljs javascript"><span class="hljs-comment">// 冒泡排序 稳定 平均 O(n^2)</span><span class="hljs-comment">// 时间: O(n) &lt; O(n^2) 空间: O(1)</span><span class="hljs-built_in">Array</span>.prototype.bubbleSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">this</span>.length; j++) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-built_in">this</span>.length - <span class="hljs-number">1</span> - j; i++) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>[i] &gt; <span class="hljs-built_in">this</span>[i + <span class="hljs-number">1</span>]) &#123;<span class="hljs-keyword">const</span> tem = <span class="hljs-built_in">this</span>[i];<span class="hljs-built_in">this</span>[i] = <span class="hljs-built_in">this</span>[i + <span class="hljs-number">1</span>];<span class="hljs-built_in">this</span>[i + <span class="hljs-number">1</span>] = tem;&#125;&#125;&#125;&#125;</code></pre><p>时间复杂度： 两个嵌套循环，因此<strong>冒泡排序的时间复杂度是 O(n^2)</strong></p><h3 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h3><p>步骤：</p><ol><li>找到数组中的最小值，选中它并将其放置到第一位，</li><li>接着找到第二小的值，选中它并将其放置到第二位</li><li>以此类推，执行 n-1 轮</li></ol><pre><code class="hljs javascript"><span class="hljs-comment">// 选择排序  稳定 时间: O(n^2) 空间: O(1)</span><span class="hljs-built_in">Array</span>.prototype.selectSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length - <span class="hljs-number">1</span>; i++ ) &#123;<span class="hljs-keyword">let</span> indexMin = i;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i; j &lt; <span class="hljs-built_in">this</span>.length; j++) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>[j] &lt; <span class="hljs-built_in">this</span>[indexMin]) &#123;indexMin = j;&#125;&#125;<span class="hljs-keyword">if</span> (indexMin !== i) &#123;<span class="hljs-keyword">const</span> tem = <span class="hljs-built_in">this</span>[i];<span class="hljs-built_in">this</span>[i] = <span class="hljs-built_in">this</span>[indexMin];<span class="hljs-built_in">this</span>[indexMin] = tem;&#125;&#125;&#125;</code></pre><p>时间复杂度： 两个嵌套循环，因此<strong>选择排序的时间复杂度是 O(n^2)</strong></p><h3 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h3><p>步骤：</p><ol><li>从第二个数开始往前比</li><li>如果前面的数字比它大 就往后排</li><li>以此类推 进行到最后一个数字</li></ol><pre><code class="hljs javascript"><span class="hljs-comment">// 插入排序 稳定 平均 O(n^2)</span><span class="hljs-comment">// 时间: O(n) &lt; O(n^2) 空间: O(1)</span><span class="hljs-built_in">Array</span>.prototype.insertSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;<span class="hljs-keyword">const</span> tem = <span class="hljs-built_in">this</span>[i];<span class="hljs-keyword">let</span> j = i;<span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>[j - <span class="hljs-number">1</span>] &gt; tem) &#123;<span class="hljs-built_in">this</span>[j] = <span class="hljs-built_in">this</span>[j - <span class="hljs-number">1</span>];&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">break</span>;&#125;j--;&#125;<span class="hljs-built_in">this</span>[j] = tem;&#125;&#125;</code></pre><p>时间复杂度： 两个嵌套循环，因此<strong>插入排序的时间复杂度是 O(n^2)</strong></p><h3 id="4、归并排序"><a href="#4、归并排序" class="headerlink" title="4、归并排序"></a>4、归并排序</h3><p>步骤：</p><ol><li>分： 把数组劈成两半，再递归地对子数组进行“分”操作，直到分成一个个单独的数组</li><li>合： 把两个数合并为有序数组，再对有序数组进行合并，直到全部子数组合并为一个完整的数组<ol><li>新建一个空数组res，用于存放最终排序后的数组</li><li>比较两个有序数组的头部，较小者出队并推入res中</li><li>如果两个数组还有值，就重复第二步</li></ol></li></ol><pre><code class="hljs javascript"><span class="hljs-comment">// 归并排序 稳定 时间:O(n logn) 空间:O(n)</span><span class="hljs-built_in">Array</span>.prototype.mergeSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">const</span> rec = <span class="hljs-function"><span class="hljs-params">arr</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>); <span class="hljs-comment">// arr.length &gt;&gt;&gt; 1</span><span class="hljs-keyword">const</span> left = arr.slice(<span class="hljs-number">0</span>, mid);<span class="hljs-keyword">const</span> right = arr.slice(mid, arr.length);<span class="hljs-keyword">const</span> orderLeft = rec(left);<span class="hljs-keyword">const</span> orderRight = rec(right);<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">while</span>(orderLeft.length || orderRight.length) &#123;<span class="hljs-keyword">if</span> (orderLeft.length &amp;&amp; orderRight.length) &#123;res.push(orderLeft[<span class="hljs-number">0</span>] &lt; orderRight[<span class="hljs-number">0</span>] ? orderLeft.shift() : orderRight.shift());&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (orderLeft.length) &#123;res.push(orderLeft.shift());&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (orderRight.length) &#123;res.push(orderRight.shift());&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">const</span> res = rec(<span class="hljs-built_in">this</span>);res.forEach(<span class="hljs-function">(<span class="hljs-params">n, i</span>) =&gt;</span> <span class="hljs-built_in">this</span>[i] = n);&#125;</code></pre><p>时间复杂度：</p><ul><li>分 的时间复杂度是 O(logN)</li><li>合 的时间复杂度 O(n)</li></ul><p>因此*<em>插入排序的时间复杂度是 O(n * logN)*</em></p><h3 id="5、快速排序"><a href="#5、快速排序" class="headerlink" title="5、快速排序"></a>5、快速排序</h3><p>步骤：</p><ol><li>分区： 从数组中任意选择一个“基准”，所有比基准小的元素都放在基准左边，比基准大的元素都放在基准的右边。</li><li>递归： 递归地对基准前后的子数组进行分区</li></ol><pre><code class="hljs javascript"><span class="hljs-comment">// 快速排序 不稳定 平均: O(n logn)</span><span class="hljs-comment">// 时间:O(n logn) &lt; O(n²) 空间:O(n logn)</span><span class="hljs-built_in">Array</span>.prototype.quickSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">const</span> rec = <span class="hljs-function"><span class="hljs-params">arr</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span>(arr.length &lt; <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-keyword">const</span> left = [];<span class="hljs-keyword">const</span> right = [];<span class="hljs-keyword">const</span> mid = arr[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<span class="hljs-keyword">if</span> (arr[i] &lt; mid) &#123;left.push(arr[i]);&#125; <span class="hljs-keyword">else</span> &#123;right.push(arr[i])&#125;&#125;<span class="hljs-keyword">return</span> [...rec(left), mid, ...rec(right)];&#125;;<span class="hljs-keyword">const</span> res = rec(<span class="hljs-built_in">this</span>);res.forEach(<span class="hljs-function">(<span class="hljs-params">n, i</span>) =&gt;</span> <span class="hljs-built_in">this</span>[i] = n);&#125;</code></pre><p>时间复杂度：</p><ul><li>递归的时间复杂度 O(logN)</li><li>分区的时间复杂度 O(n)</li></ul><p>因此*<em>快速排序的时间复杂度是 O(n * logN)*</em></p><h2 id="二、搜索"><a href="#二、搜索" class="headerlink" title="二、搜索"></a>二、搜索</h2><h3 id="1、顺序搜索"><a href="#1、顺序搜索" class="headerlink" title="1、顺序搜索"></a>1、顺序搜索</h3><h3 id="2、二分搜索"><a href="#2、二分搜索" class="headerlink" title="2、二分搜索"></a>2、二分搜索</h3><p>步骤：</p><ol><li>从数组的中间元素开始，如果中间元素正好是目标值，则搜索结束</li><li>如果目标值大于或者小于中间元素，则在大于或者小于中间元素的那一半数组进行搜索</li></ol><pre><code class="hljs javascript"><span class="hljs-comment">// 二分搜索 O(logN)</span><span class="hljs-built_in">Array</span>.prototype.binarySearch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<span class="hljs-keyword">let</span> low = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> high = <span class="hljs-built_in">this</span>.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(low &lt;= high) &#123;<span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor((high + low) / <span class="hljs-number">2</span>); <span class="hljs-comment">// (high + low) &gt;&gt;&gt; 1</span><span class="hljs-keyword">const</span> element = <span class="hljs-built_in">this</span>[mid];<span class="hljs-keyword">if</span> (element &lt; item) &#123;low = mid + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element &gt; item) &#123;high = mid - <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> mid;&#125;&#125;<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre><p>时间复杂度： 由于每次比较都使搜索范围缩小一半，因此<strong>二分搜索的时间复杂度是 O(logN)</strong></p><h2 id="三、练习题"><a href="#三、练习题" class="headerlink" title="三、练习题"></a>三、练习题</h2><h3 id="1、x-的平方根"><a href="#1、x-的平方根" class="headerlink" title="1、x 的平方根"></a>1、x 的平方根</h3><p><a href="https://leetcode-cn.com/problems/sqrtx/">leetcode-69 x 的平方根</a></p><p>实现 <code>int sqrt(int x)</code> 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1:</p><pre><code class="hljs text">输入: 4输出: 2</code></pre><p>示例 2:</p><pre><code class="hljs text">输入: 8输出: 2说明: 8 的平方根是 2.82842...,      由于返回类型是整数，小数部分将被舍去。</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">x</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-comment">// x 的平方根 tag: 二分搜索</span><span class="hljs-keyword">var</span> mySqrt = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>&#123;<span class="hljs-comment">// 时间复杂度: O(log N)</span>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-keyword">let</span> low = <span class="hljs-number">1</span>;    <span class="hljs-keyword">let</span> higt = x &gt;&gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 除二取整,因为一个数的平发根一定小于等于 除二取整</span>    <span class="hljs-keyword">while</span>(low + <span class="hljs-number">1</span> &lt; higt) &#123;        <span class="hljs-comment">// const mid = Math.floor((low + higt) / 2);</span>        <span class="hljs-keyword">const</span> mid = (low + higt) &gt;&gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">const</span> s = x / mid;        <span class="hljs-keyword">if</span> (s === mid) &#123;            <span class="hljs-keyword">return</span> mid;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &gt; mid) &#123;            low = mid;        &#125; <span class="hljs-keyword">else</span> &#123;            higt = mid;        &#125;    &#125;    <span class="hljs-keyword">return</span> x / higt &gt;= higt ? higt : low;&#125;;</code></pre><h3 id="2、猜数字大小"><a href="#2、猜数字大小" class="headerlink" title="2、猜数字大小"></a>2、猜数字大小</h3><p><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/">leetcode-374 猜数字大小</a></p><p>猜数字游戏的规则如下：</p><p>每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。<br>如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。<br>你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：</p><p>-1：我选出的数字比你猜的数字小 pick &lt; num<br>1：我选出的数字比你猜的数字大 pick &gt; num<br>0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num</p><p>示例 1：</p><pre><code class="hljs text">输入：n = 10, pick = 6输出：6</code></pre><p>示例 2：</p><pre><code class="hljs text">输入：n = 1, pick = 1输出：1</code></pre><p>示例 3：</p><pre><code class="hljs text">输入：n = 2, pick = 1输出：1</code></pre><p>示例 4：</p><pre><code class="hljs text">输入：n = 2, pick = 2输出：2</code></pre><p>提示：</p><ul><li>1 &lt;= n &lt;= 231 - 1</li><li>1 &lt;= pick &lt;= n</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">/** </span><span class="hljs-comment"> * Forward declaration of guess API.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>num   your guess</span><span class="hljs-comment"> * <span class="hljs-doctag">@return             </span>-1 if num is lower than the guess number</span><span class="hljs-comment"> *             1 if num is higher than the guess number</span><span class="hljs-comment"> *                       otherwise return 0</span><span class="hljs-comment"> * var guess = function(num) &#123;&#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> guessNumber = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;<span class="hljs-comment">// 猜数字大小 二分搜索 时间 O(logN) 空间 O(1)</span>    <span class="hljs-keyword">let</span> low = <span class="hljs-number">1</span>;    <span class="hljs-keyword">let</span> high = n;    <span class="hljs-keyword">while</span>(high &gt;= low) &#123;        <span class="hljs-comment">// const mid = Math.floor((low + high) / 2);</span>        <span class="hljs-keyword">const</span> mid = (low + high) &gt;&gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 除以二并取整</span>        <span class="hljs-keyword">const</span> res = guess(mid);        <span class="hljs-keyword">if</span> (res === -<span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 结果比mid 小，下次需要搜索 0 - mid 范围</span>            high = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res === <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 结果比mid 大，下次需要搜索 mid - n 范围</span>            low = mid + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res === <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> mid;        &#125;    &#125;&#125;;</code></pre><h2 id="四、Array-prototype-sort用的是什么排序算法"><a href="#四、Array-prototype-sort用的是什么排序算法" class="headerlink" title="四、Array.prototype.sort用的是什么排序算法"></a>四、Array.prototype.sort用的是什么排序算法</h2><p>ECMA官方规范(ECMA-2015/ECMA-2016/ECMA-2017)中并没有写明具体使用的排序算法(各个浏览器的实现方式会有不同)，只是说了JavaScript的sort方法（Array.prototype.sort）并不一定稳定！</p><ul><li>Chrome浏览器的JavaScript引擎是V8</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// V8引擎的官方源码中的一段注释：</span><span class="hljs-comment">// In-place QuickSort algorithm.</span><span class="hljs-comment">// For short (length &lt;= 10) arrays, insertion sort is used for efficiency.</span></code></pre><p>从代码的注释中可以得知,对于长度 <code>&lt;= 10</code> 的数组使用的是<strong>插入排序</strong>(稳定排序算法) ，<code>&gt;10</code> 的数组使用的是<strong>快速排序</strong>。快速排序是不稳定的排序算法。</p><ul><li>Firefox浏览器用的 <strong>归并排序</strong></li></ul><p>各种算法的对比:</p><table><thead><tr><th>排序类型</th><th>平均情况</th><th>最好情况</th><th>最坏情况</th><th>辅助空间</th><th>稳定性</th></tr></thead><tbody><tr><td>快速排序</td><td>O(n logn)</td><td>O(n logn)</td><td>O(n²)</td><td>O(n logn)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(n logn)</td><td>O(n logn)</td><td>O(n logn)</td><td>O(n)</td><td>稳定</td></tr><tr><td>插入排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>冒泡排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>选择排序</td><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr></tbody></table><blockquote><p><a href="https://segmentfault.com/a/1190000010648740">JS-Array.prototype.sort</a><br><a href="https://zhuanlan.zhihu.com/p/66727555">JS-Array.prototype.sort</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue step 3 —— Vue面试题</title>
    <link href="/2017/11/21/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue-step3/"/>
    <url>/2017/11/21/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue-step3/</url>
    
    <content type="html"><![CDATA[<p>v-if 和 v-show 的区别<br>key 的作用，为什么不能用index 和 random<br>父子组件的生命周期</p><h2 id="1-组件的通讯过程"><a href="#1-组件的通讯过程" class="headerlink" title="1. 组件的通讯过程"></a>1. 组件的通讯过程</h2><h2 id="2-双向数据绑定-v-model-的实现原理"><a href="#2-双向数据绑定-v-model-的实现原理" class="headerlink" title="2. 双向数据绑定 v-model 的实现原理"></a>2. 双向数据绑定 v-model 的实现原理</h2><ul><li>input 元素的 value = this.name</li><li>绑定 input 事件的 this.name = $event.target.value</li><li>data 更新触发 re-render</li></ul><h2 id="3-computed-有何特点"><a href="#3-computed-有何特点" class="headerlink" title="3. computed 有何特点"></a>3. computed 有何特点</h2><ul><li>缓存， data 不变不会重新计算</li><li>提高性能</li></ul><h2 id="4-为何组件-data-必须是一个函数"><a href="#4-为何组件-data-必须是一个函数" class="headerlink" title="4. 为何组件 data 必须是一个函数"></a>4. 为何组件 data 必须是一个函数</h2><p>因为每个组件实际是一个 class, 每次使用组件都是对 class 的一个实例化, 因此每个组件都有自己实例单独持有的 data 数据</p><h2 id="5-ajax-请求应该放在哪个生命周期"><a href="#5-ajax-请求应该放在哪个生命周期" class="headerlink" title="5. ajax 请求应该放在哪个生命周期"></a>5. ajax 请求应该放在哪个生命周期</h2><p>mounted， JS 是单线程的， ajax 异步获取数据，放在 mounted 之前没有太多的用处，只会让逻辑更加混乱</p><h2 id="6-如何将组件所有-props-传递给子组件？"><a href="#6-如何将组件所有-props-传递给子组件？" class="headerlink" title="6. 如何将组件所有 props 传递给子组件？"></a>6. 如何将组件所有 props 传递给子组件？</h2><ul><li>通过<code>$props</code></li><li><code>&lt;User v-bind=&quot;$props&quot; /&gt;</code></li></ul><h2 id="7-如何自己实现-v-model"><a href="#7-如何自己实现-v-model" class="headerlink" title="7. 如何自己实现 v-model"></a>7. 如何自己实现 v-model</h2><img src="https://i.loli.net/2021/01/23/lPKnNQ5JAoaHbw3.png" ><h2 id="8-多个组件有相同的逻辑，如何抽离"><a href="#8-多个组件有相同的逻辑，如何抽离" class="headerlink" title="8. 多个组件有相同的逻辑，如何抽离"></a>8. 多个组件有相同的逻辑，如何抽离</h2><ul><li><code>mixin</code></li><li><code>mixin</code> 有一些缺点：</li></ul><h2 id="9-何时要使用异步组件"><a href="#9-何时要使用异步组件" class="headerlink" title="9. 何时要使用异步组件"></a>9. 何时要使用异步组件</h2><ul><li>加载大组件</li><li>路由异步加载</li></ul><h2 id="10-何时使用-keep-alive"><a href="#10-何时使用-keep-alive" class="headerlink" title="10. 何时使用 keep-alive"></a>10. 何时使用 <code>keep-alive</code></h2><ul><li>缓存组件，不需要重复渲染</li><li>如多个静态 tab 页的雀环</li><li>优化性能</li></ul><h2 id="11-何时需要使用-beforeDestroy"><a href="#11-何时需要使用-beforeDestroy" class="headerlink" title="11. 何时需要使用 beforeDestroy"></a>11. 何时需要使用 beforeDestroy</h2><ul><li>解绑自定义事件 event.$off</li><li>清除定时器</li><li>解绑自定义的 DOM 事件，如 window scroll 等</li></ul><h2 id="12-Vuex-中-action-和-mutation-有何区别"><a href="#12-Vuex-中-action-和-mutation-有何区别" class="headerlink" title="12. Vuex 中 action 和 mutation 有何区别"></a>12. Vuex 中 action 和 mutation 有何区别</h2><ul><li>action 中处理异步(经常用来请求接口，并在请求结果后调用mutation去修改state的值), mutation不可以(经常用来更新state的值)</li><li>mutation 做原子操作</li><li>action 可以整合多个 mutation</li></ul><h2 id="13-请用-vnode-描述一个DOM结构"><a href="#13-请用-vnode-描述一个DOM结构" class="headerlink" title="13. 请用 vnode 描述一个DOM结构"></a>13. 请用 vnode 描述一个DOM结构</h2><img src="https://i.loli.net/2021/01/23/9FYLJP6jOlERS7I.png" ><h2 id="14-Vue-如何监听数据变化"><a href="#14-Vue-如何监听数据变化" class="headerlink" title="14. Vue 如何监听数据变化"></a>14. Vue 如何监听数据变化</h2><ul><li>Object.defineProperty 不能监听数据变化</li><li>重新定义原型，重写 push pop 等方法，实现监听</li><li>Proxy 可以原生支持监听数据变化</li></ul><h2 id="14-diff-算法的时间复杂度"><a href="#14-diff-算法的时间复杂度" class="headerlink" title="14. diff 算法的时间复杂度"></a>14. diff 算法的时间复杂度</h2><ul><li><code>O(n)</code></li><li>在 <code>O(n^3)</code> 基础上做的一些调整</li></ul><h2 id="15-简述-diff-算法过程"><a href="#15-简述-diff-算法过程" class="headerlink" title="15. 简述 diff 算法过程"></a>15. 简述 diff 算法过程</h2><ul><li>patch(elem, vnode) 和 patch(vnode, newVnode)</li><li>patchVnode 和 addVnodes 和 removeVnodes</li><li>updateChildren(key的重要性)</li></ul><h2 id="16-Vue-为何是异步渲染，-nextTick-的作用"><a href="#16-Vue-为何是异步渲染，-nextTick-的作用" class="headerlink" title="16. Vue 为何是异步渲染，$nextTick 的作用"></a>16. Vue 为何是异步渲染，$nextTick 的作用</h2><ul><li>异步渲染（以及合并 data 修改），以提高渲染性能</li><li>$nextTick 在DOM 更新完之后，可以拿到更新后的DOM</li></ul><h2 id="17-Vue-常见性能优化"><a href="#17-Vue-常见性能优化" class="headerlink" title="17. Vue 常见性能优化"></a>17. Vue 常见性能优化</h2><ul><li>合理使用 v-show 和 v-if</li><li>合理使用 computed</li><li>v-for 时使用正确的key，以及避免和 v-if 同时使用(v-for 比 v-if 具有更高的优先级)</li><li>自定义事件、DOM 事件及时销毁</li><li>合理使用异步组件</li><li>合理使用 keep-alive</li><li>data 层级不要太深，尽量扁平一些</li><li>使用 vue-loader 在开发环境做模板编译（预编译）</li><li>使用 SSR</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>框架</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue step 2 —— Vue高级特性</title>
    <link href="/2017/11/15/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue-step2/"/>
    <url>/2017/11/15/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue-step2/</url>
    
    <content type="html"><![CDATA[<ul><li><strong>组件化和 MVVM</strong></li><li><strong>响应式原理</strong></li><li><strong>vdom 和 diff 算法</strong></li><li><strong>模板编译</strong></li><li><strong>组件渲染过程</strong></li><li><strong>前端路由</strong></li></ul><h3 id="1、组件化和-MVVM"><a href="#1、组件化和-MVVM" class="headerlink" title="1、组件化和 MVVM"></a>1、组件化和 MVVM</h3><ul><li>很早就有组件化, 在Vue中通过数据驱动图的模式，对组件化进行了发展</li><li>数据驱动视图 - Vue MVVM</li><li>数据驱动视图 - React setState</li></ul><img src="https://i.loli.net/2021/01/03/zk7arT2w8KdfGi6.png" ><p>MVVM是Model-View-ViewModel的简写,它本质上就是 MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开.</p><h3 id="2、响应式原理"><a href="#2、响应式原理" class="headerlink" title="2、响应式原理"></a>2、响应式原理</h3><ul><li>核心API: Object.defineProperty</li><li>Object.defineProperty 的缺点<ul><li><strong>深度监听需要递归到底，一次性计算量大</strong></li><li><strong>无法监听 新增属性/删除属性 （Vue.set  Vue.delete）</strong></li></ul></li><li>Vue3.0启用Proxy，Proxy 兼容性不好, 且无法 polyfill</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// Object.defineProperty 的基本用法</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observer</span>(<span class="hljs-params">target</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#x27;object&#x27;</span> || target === <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">return</span> target;&#125;<span class="hljs-comment">// 重新定义各个属性 for...in 可以监听数组 也可以监听对象</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> target) &#123;defineReactive(target, key, target[key]);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span>(<span class="hljs-params">target, key, val</span>) </span>&#123;<span class="hljs-comment">// 深度监听 ——缺点： 深度监听需要递归到底，一次性计算量大</span>observer(val);<span class="hljs-comment">// 核心API</span><span class="hljs-built_in">Object</span>.defineProperty(target, key, &#123;get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> val;&#125;,set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newVal</span>) </span>&#123;<span class="hljs-keyword">if</span> (val !== newVal) &#123;<span class="hljs-comment">// 深度监听 ——缺点： 深度监听需要递归到底，一次性计算量大</span>observer(newVal);<span class="hljs-comment">// 更新值 （注意: val 一直在闭包中,此处设置完之后,再 get 时 拿到的也是最新的值）</span>val = newVal;<span class="hljs-comment">// 通知视图更新</span>updateView();&#125;&#125;&#125;)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateView</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">// ... 更新视图</span>&#125;<span class="hljs-comment">// 测试</span><span class="hljs-keyword">const</span> data = &#123;name: <span class="hljs-string">&#x27;zhangsan&#x27;</span>,age: <span class="hljs-number">20</span>&#125;observer(data);data.name = <span class="hljs-string">&#x27;lisi&#x27;</span>;data.age = <span class="hljs-number">21</span>;</code></pre><ol><li>如何监听对象、如何监听数组 ?</li><li>如何实现复杂对象的深度监听?<br>缺点： 深度监听需要递归到底，一次性计算量大</li></ol><h3 id="3、虚拟DOM（vdom）和-diff"><a href="#3、虚拟DOM（vdom）和-diff" class="headerlink" title="3、虚拟DOM（vdom）和 diff"></a>3、虚拟DOM（vdom）和 diff</h3><p>1、用 JS 模拟 DOM 结构</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;id1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>v-dom<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-size: 20px&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>a<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs javascript">vodom = &#123;tag: <span class="hljs-string">&#x27;div&#x27;</span>,props: &#123;className: <span class="hljs-string">&#x27;container&#x27;</span>,id: <span class="hljs-string">&#x27;id1&#x27;</span>&#125;,children: [&#123;tag: <span class="hljs-string">&#x27;p&#x27;</span>,children: <span class="hljs-string">&#x27;v-dom&#x27;</span>&#125;,&#123;tag: <span class="hljs-string">&#x27;ul&#x27;</span>,props: &#123;style: <span class="hljs-string">&#x27;font-size: 20px&#x27;</span>&#125;,children: [&#123;tag: <span class="hljs-string">&#x27;li&#x27;</span>,children: <span class="hljs-string">&#x27;a&#x27;</span>&#125;]&#125;]&#125;</code></pre><p>2、diff 算法</p><ul><li>diff 即对比，是一个广泛的概念，如 Linux diff命令、git diff等</li><li>两个 js 对象也可以做diff，如： <a href="https://github.com/cujojs/jiff">https://github.com/cujojs/jiff</a></li><li>树 diff 的时间复杂度是 O(n^3)</li><li>优化时间复杂度到 O(n)<ul><li>只比较同一层级，不跨级比较</li><li>tag 不相同，则直接删掉重建，不再深度比较</li><li>tag 和 key 都相同，则认为是相同的节点，不再深度比较</li></ul></li></ul><p>Vue2.x 的 diff 算法:</p><p>Vue3.x 的 diff 算法:</p><h3 id="4、模板编译"><a href="#4、模板编译" class="headerlink" title="4、模板编译"></a>4、模板编译</h3><ul><li>前置知识: with 语法</li><li>vue template complier 将模板编译为 render 函数</li><li>执行 render 函数生成 vnode</li></ul><ol><li><p>js with 语法</p><ul><li>改变 <code>&#123;&#125;</code> 内自由变量的查找规则，当做 obj 属性来查找</li><li>如果匹配不到 obj 属性，就会报错</li><li>with 要慎用，它打破了作用域规则，易读性变差</li></ul><img src="https://i.loli.net/2021/01/23/O3iAEV57wX6ZcFh.png" ></li><li><p>编译模板</p><ul><li>模板编译为 render 函数，执行 render 函数会返回 vnode</li><li>基于 vnode 再执行 patch 和 diff</li><li>使用 webpack vue-loader，会在开发环境下编译模板</li></ul></li><li><p>render 函数<br>vue 组件可以用 render 代替 template</p></li></ol><h3 id="5、组件渲染过程"><a href="#5、组件渲染过程" class="headerlink" title="5、组件渲染过程"></a>5、组件渲染过程</h3><p>初次渲染的过程：</p><ol><li>解析模板为 render 函数（或在开发环境已完成，vue-loader）</li><li>触发响应式，监听 data 属性 getter setter</li><li>执行 render 函数，生成 vnode，执行patch(elem, vnode)</li></ol><p>更新过程：</p><ol><li>修改 data，触发 setter （此前在 getter 中已被监听）</li><li>重新执行 render 函数，生成 newVnode</li><li>patch(oldVnode, newVnode)</li></ol><h3 id="6、前端路由"><a href="#6、前端路由" class="headerlink" title="6、前端路由"></a>6、前端路由</h3><ol><li><p>hash 模式</p><ul><li>hash 变化会触发页面跳转，即浏览器前进、后退</li><li>hash 变化不会刷新页面，SPA 必需的特点</li><li>hash 永远不会提交到 server 端</li></ul></li><li><p>history 模式</p><ul><li>用 url 规范的路由，但是跳转时不刷新页面</li><li>history.pushState : 将路由信息保存到 history 记录中</li><li>window.onpopstate : 用来监听浏览器前进后退, 找到路由对应的组件, 实现页面的跳转<br>history 模式需要后端配合，即 无论访问域名下的什么页面，都返回 index.html，将页面跳转的控制权交给前端</li></ul></li></ol><p>选择：</p><ol><li>一般 to B 用 hash 模式，对路由不敏感，成本低，不需要后端支持</li><li>一般 to C 用 history 模式</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>框架</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown Rules Detail</title>
    <link href="/2017/06/01/markDown/rulesInfo/"/>
    <url>/2017/06/01/markDown/rulesInfo/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/DavidAnson/markdownlint/blob/v0.22.0/doc/Rules.md#md012">markdownlint</a></p><p>规则<br>本文档包含所有规则的描述，它们要检查的内容以及违反规则的文档示例以及示例的更正版本。标题为击中 已弃用，但仍提供向后兼容性。</p><p>MD001-标题级别一次只能增加一个级别<br>标签：标题，标题</p><p>别名：标题增加，标题增加</p><p>当您跳过降价文档中的标题级别时，将触发此规则，例如：</p><p>＃ 标题1</p><h3 id="标题3"><a href="#标题3" class="headerlink" title="标题3"></a>标题3</h3><p>我们跳过了本文档中的第二级标题<br>使用多个标题级别时，嵌套标题一次只能增加一个级别：</p><p>＃ 标题1</p><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><h3 id="标题3-1"><a href="#标题3-1" class="headerlink" title="标题3"></a>标题3</h3><h4 id="标题4"><a href="#标题4" class="headerlink" title="标题4"></a>标题4</h4><h2 id="另一个标题2"><a href="#另一个标题2" class="headerlink" title="另一个标题2"></a>另一个标题2</h2><h3 id="另一个标题3"><a href="#另一个标题3" class="headerlink" title="另一个标题3"></a>另一个标题3</h3><p>原理：标题表示文档的结构，并且在跳过时可能会造成混淆-特别是对于可访问性方案。更多信息：https : //<a href="http://www.w3.org/WAI/tutorials/page-structure/headings/%E3%80%82">www.w3.org/WAI/tutorials/page-structure/headings/。</a></p><p>MD002-第一个标题应该是顶层标题<br>标签：标题，标题</p><p>别名：first-heading-h1，first-header-h1</p><p>参数：级别（数字；默认值1）</p><p>注意：MD002已被弃用，默认情况下处于禁用状态。 MD041 /第一行标题提供了改进的实现。</p><p>此规则旨在确保文档标题从顶层开始，并在文档的第一个标题不是h1标题时触发：</p><h2 id="这不是H1标题"><a href="#这不是H1标题" class="headerlink" title="这不是H1标题"></a>这不是H1标题</h2><h3 id="另一个标题"><a href="#另一个标题" class="headerlink" title="另一个标题"></a>另一个标题</h3><p>文档中的第一个标题应为h1标题：</p><p>＃ 从H1标题开始</p><h2 id="然后将H2用于小节"><a href="#然后将H2用于小节" class="headerlink" title="然后将H2用于小节"></a>然后将H2用于小节</h2><p>注意：level在外部添加h1的情况下，该参数可用于更改顶级（例如：到h2）。</p><p>理由：顶级标题通常充当文档的标题。更多信息：https : //cirosantilli.com/markdown-style-guide#top-level-header。</p><p>MD003-标题样式<br>标签：标题，标题</p><p>别名：标题样式，标题样式</p><p>参数：样式（“ consistent”，“ atx”，“ atx_closed”，“ setext”，“ setext_with_atx”，“ setext_with_atx_closed”；默认为“ consistent”）</p><p>在同一文档中使用不同的标题样式（atx，setext和“ closed” atx）时，将触发此规则：</p><p>＃  ATX风格H1</p><h2 id="封闭的ATX风格H2"><a href="#封闭的ATX风格H2" class="headerlink" title="封闭的ATX风格H2"></a>封闭的ATX风格H2</h2><h1 id="Setext样式H1"><a href="#Setext样式H1" class="headerlink" title="Setext样式H1"></a>Setext样式H1</h1><p>与文档中使用的标题样式保持一致：</p><p>＃  ATX风格H1</p><h2 id="ATX风格H2"><a href="#ATX风格H2" class="headerlink" title="ATX风格H2"></a>ATX风格H2</h2><p>setext_with_atx和setext_with_atx_closed文档样式允许具有setext样式标题的文档中级别为3或更高的atx样式标题：</p><h1 id="Setext样式H1-1"><a href="#Setext样式H1-1" class="headerlink" title="Setext样式H1"></a>Setext样式H1</h1><h2 id="Setext样式H2"><a href="#Setext样式H2" class="headerlink" title="Setext样式H2"></a>Setext样式H2</h2><h3 id="ATX风格H3"><a href="#ATX风格H3" class="headerlink" title="ATX风格H3"></a>ATX风格H3</h3><p>注意：配置的标题样式可以是要使用的特定样式（atx，atx_closed，setext，setext_with_atx，setext_with_atx_closed），或者只是要求用法在文档中保持一致。</p><p>基本原理：一致的格式设置使文档理解更加容易。</p><p>MD004-无序列表样式<br>标签：子弹，UL</p><p>别名：ul样式</p><p>参数：样式（“一致”，“星号”，“加号”，“破折号”，“子列表”；默认为“一致”）</p><p>当文档中用于无序列表项的符号与配置的无序列表样式不匹配时，将触发此规则：</p><p>*项目1<br> +项目2<br> -项目3<br>要解决此问题，请为整个文档中的列表项使用配置的样式：</p><p>*项目1<br> *项目2<br> *项目3<br>配置的列表样式可以是要使用的特定符号（星号，加号，破折号），可以要求文档中的用法必须一致，或者可以要求每个子列表具有与其父列表不同的一致符号。</p><p>例如，以下内容对sublist样式有效，因为最外面的缩进使用星号，中间的缩进使用加号，而最里面的缩进使用破折号：</p><p>*项目1<br>   +项目2<br>     -项目3<br>   +项目4<br> *项目4</p><ul><li>5项<br>基本原理：一致的格式设置使文档理解更加容易。</li></ul><p>MD005-同一级别的列表项缩进不一致<br>标签：项目符号，ul，缩进</p><p>别名：列表缩进</p><p>可修复：大多数违规行为可以通过工具修复</p><p>当列表项被解析为相同级别但没有相同的缩进时，将触发此规则：</p><p>*项目1<br>   *嵌套项目1<br>   *嵌套项目2<br>    *未对齐的项目<br>通常，此规则会因输入错误而触发。更正列表的缩进以解决该问题：</p><p>*项目1<br>   *嵌套项目1<br>   *嵌套项目2<br>   *嵌套项目3<br>顺序排列的列表标记通常左对齐，以使所有项目都具有相同的起始列：</p><p>…<br> 8.项目<br>9.项目<br>10.项目<br>11.项目<br>…<br>此规则还支持列表标记的右对齐，以使所有项目都具有相同的结束列：</p><p>…<br>  8.项目<br> 9.项目<br>10.项目<br>11.项目<br>…<br>理由：违反此规则可能会导致内容渲染不正确。</p><p>MD006-考虑在行的开头开始项目符号列表<br>标签：项目符号，ul，缩进</p><p>别名：ul-start-left</p><p>可修复：大多数违规行为可以通过工具修复</p><p>当顶层列表不在行首时触发此规则：</p><p>一些文字</p><p>  *清单项目<br>  *清单项目<br>要解决此问题，请确保不缩进顶层列表项：</p><p>一些测试</p><p>*清单项目<br>*清单项目<br>注意：在以下情况下会触发此规则，因为解析器无法识别无序子列表。没有按照外部有序列表的要求嵌套3个字符，而是创建了一个顶级无序列表。</p><p>1.清单项目<br>  -清单项目<br>  -清单项目<br>1.清单项目<br>原理：从行首开始列出列表意味着，当使用编辑器的缩进功能或Tab键进行缩进时，嵌套列表项都可以缩进相同的数量。在列表中以1个空格开始表示第一个嵌套列表的缩进小于第二个列表的缩进（如果使用4个空格键，则为3个字符；如果使用2个空格键，则为1个字符）。</p><p>MD007-无序列表缩进<br>标签：项目符号，ul，缩进</p><p>别名：ul-indent</p><p>参数：indent，start_indented（数字；默认为2，布尔值；默认为false）</p><p>可修复：大多数违规行为可以通过工具修复</p><p>如果列表项未缩进配置的空格数（默认值：2），则会触发此规则。</p><p>例：</p><p>*列表项<br>   *嵌套列表项缩进3个空格<br>更正的示例：</p><p>*列表项<br>  *嵌套列表项缩进2个空格<br>注意：仅当子列表的父列表也都是无序的时，此规则才适用于子列表（否则，有序列表的额外缩进会干扰该规则）。</p><p>该start_indented参数允许列表的第一级缩进配置的空格数，而不是从零开始（MD006的倒数）。</p><p>原理：缩进2个空格可以使嵌套列表的内容与父列表内容的开头在列表标记后使用单个空格时保持一致。缩进4个空格与代码块一致，并且使编辑者更容易实现。此外，这对于需要4位缩进的多重降价解析器可能是一个兼容性问题。更多信息：https : //cirosantilli.com/markdown-style-guide#indentation-of-content-inside-lists 和<a href="http://support.markedapp.com/discussions/problems/21-sub-lists-not-indenting%E3%80%82">http://support.markedapp.com/discussions/problems/21-sub-lists-not-indenting。</a></p><p>MD009-尾随空格<br>标签：空白</p><p>别名：无尾迹空间</p><p>参数：br_spaces，list_item_empty_lines，严格（数字；默认为2，布尔值；默认为false，布尔值；默认为false）</p><p>可修复：大多数违规行为可以通过工具修复</p><p>在以意外空格结尾的任何行上都会触发此规则。要解决此问题，请从行尾删除尾随空格。</p><p>注意：缩进和带围栏的代码块中允许尾随空格，因为某些语言需要它。</p><p>该br_spaces参数允许例外的尾随空格的具体数目，通常用来插入一个明确的换行符。默认值允许2个空格指示硬中断（<br>元素）。</p><p>注意：必须br_spaces将此参数设置为&gt; = 2才能生效。设置br_spaces为1的行为与0相同，不允许任何尾随空格。</p><p>默认情况下，即使使用了允许的空格数，该规则也不会触发，即使它不会造成硬中断（例如，在段落的末尾）。要同时报告此类实例，请将strict参数设置为true。</p><p>文字文字文字<br>文字[2个空格]<br>通常不需要使用空格来缩进列表项内的空白行，但是某些解析器需要使用空格。将list_item_empty_lines参数设置true 为允许此操作（即使strict是true）：</p><p>-清单项目文字<br>  [2个空格]<br>  清单项目文字<br>基本原理：除非用于创建换行符，否则尾随空格没有任何用途，并且不会影响内容的呈现。</p><p>MD010-硬标签<br>标签：空格，hard_tab</p><p>别名：无困难</p><p>参数：code_blocks（布尔值；默认为true）</p><p>可修复：大多数违规行为可以通过工具修复</p><p>该规则由包含硬制表符而不是使用空格缩进的任何行触发。要解决此问题，请用空格替换所有硬标签字符。</p><p>例：</p><p>一些文字</p><pre><code>*用于缩进列表项的硬标签字符</code></pre><p>更正的示例：</p><p>一些文字</p><pre><code>*用于缩进列表项的空格</code></pre><p>您可以选择针对代码块排除此规则。为此，请将code_blocks参数设置 为false。默认情况下包括代码块，因为工具对制表符的处理通常是不一致的（例如：使用4个空格对8个空格）。</p><p>原理：硬标签通常由不同的编辑者不一致地显示，并且比空格更难使用。</p><p>MD011-反向链接语法<br>标签：链接</p><p>别名：无反向链接</p><p>可修复：大多数违规行为可以通过工具修复</p><p>当遇到看似链接的文本，但语法似乎已颠倒（[]和()颠倒）时，将触发此规则：</p><p>（错误的链接语法）[<a href="https://www.example.com/]">https://www.example.com/]</a><br>要解决此问题，请交换[]和()：</p><p>[正确的链接语法]（<a href="https://www.example.com/%EF%BC%89">https://www.example.com/）</a><br>注意：Markdown Extra样式的脚注不会触发此规则：</p><p>对于（例如）[^ 1]<br>理由：反向链接不呈现为可用链接。</p><p>MD012-多个连续的空白行<br>标签：空格，blank_lines</p><p>别名：无多个空白</p><p>参数：最大值（数字；默认值1）</p><p>可修复：大多数违规行为可以通过工具修复</p><p>当文档中有多个连续的空白行时，将触发此规则：</p><p>一些文字在这里</p><p>一些更多的文字在这里<br>要解决此问题，请删除有问题的行：</p><p>一些文字在这里</p><p>一些更多的文字在这里<br>注意：如果代码块内有多个连续的空白行，则不会触发此规则。</p><p>注意：该maximum参数可用于配置连续空白行的最大数量。</p><p>基本原理：除代码块外，空行没有任何作用，也不影响内容的呈现。</p><p>MD013-线长<br>标签：line_length</p><p>别名：行长</p><p>参数：line_length，heading_line_length，code_block_line_length，code_blocks，表，标题，标头，strict，stern（数字； * _ length，布尔值默认为80；默认为true（strict / stern除外，默认为false））</p><p>如果headings未提供，headers将使用（不推荐使用）。</p><p>当行数超过配置的行时line_length（默认值：80个字符），将触发此规则。要解决此问题，请将行分成多行。要为标题设置不同的最大长度，请使用 heading_line_length。要为代码块设置不同的最大长度，请使用 code_block_line_length</p><p>当没有超出配置的行长的空白时，此规则将是一个例外。这样一来，您仍然可以包含长网址之类的项目，而不会被迫在中间将其破坏。要禁用此异常，请将strict参数设置为 true在任何行太长时报告问题。要警告行太长且可以修复但允许行不带空格的行，请将stern参数设置为true。</p><p>例如（假设正常行为）：</p><p>如果这条线是最大长度<br>这行是可以的，因为超出该长度没有空格<br>这行是违反的，因为有<br>这行也可以，因为没有空格<br>在strict或stern模式下，上面的两条中间线是冲突。第三行在strict模式下是违反行为，但在stern模式下是允许的。</p><p>您可以选择针对代码块，表或标题排除此规则。要做到这一点，设置code_blocks，tables或headings参数（S）为false。</p><p>默认情况下，此规则中包括代码块，因为它通常是文档可读性的要求，并且暂时与代码规则兼容。尽管如此，某些语言还是不适合短线。</p><p>基本原理：在某些编辑器中，很难排长行。更多信息：https : //cirosantilli.com/markdown-style-guide#line-wrapping。</p><p>MD014-命令前使用美元符号而不显示输出<br>标签：代码</p><p>别名：commands-show-output</p><p>可修复：大多数违规行为可以通过工具修复</p><p>当有代码块显示要键入的shell命令且所有shell命令前面都带有美元符号（$）时，将触发此规则：</p><p>$ ls<br>$ cat foo<br>$少吧<br>在这种情况下，美元符号是不必要的，因此不应包括在内：</p><p>ls<br>猫富<br>少吧<br>在带有美元符号的命令前显示输出不会触发此规则：</p><p>$ ls<br>富吧<br>$ cat foo<br>你好，世界<br>$猫吧<br>巴兹<br>因为某些命令不会产生输出，所以如果某些 命令没有输出，则不会违反：</p><p>$ mkdir测试<br>mkdir：创建目录“ test”<br>$ ls测试<br>原理：如果不需要时省略美元符号，则复制/粘贴起来会更容易，并且噪音也更少。有关 更多信息，请参见 <a href="https://cirosantilli.com/markdown-style-guide#dollar-signs-in-shell-code%E3%80%82">https://cirosantilli.com/markdown-style-guide#dollar-signs-in-shell-code。</a></p><p>MD018-atx样式标题上的散列后没有空格<br>标签：标题，标题，atx，空格</p><p>别名：无遗失空间atx</p><p>可修复：大多数违规行为可以通过工具修复</p><p>当atx样式标题中的井号字符后缺少空格时，将触发此规则：</p><p>＃标题1</p><p>##标题2<br>要解决此问题，请将标题文本与井号字符分开一个空格：</p><p>＃ 标题1</p><h2 id="标题2-1"><a href="#标题2-1" class="headerlink" title="标题2"></a>标题2</h2><p>理由：违反此规则可能会导致内容渲染不正确。</p><p>MD019-atx样式标题上的散列后有多个空格<br>标签：标题，标题，atx，空格</p><p>别名：no-multiple-space-atx</p><p>可修复：大多数违规行为可以通过工具修复</p><p>当在atx样式标题中使用多个空格将标题文本与哈希字符分开时，将触发此规则：</p><p>＃  标题1</p><h2 id="标题2-2"><a href="#标题2-2" class="headerlink" title="标题2"></a>标题2</h2><p>要解决此问题，请将标题文本与井号字符分开一个空格：</p><p>＃ 标题1</p><h2 id="标题2-3"><a href="#标题2-3" class="headerlink" title="标题2"></a>标题2</h2><p>理由：多余的空间没有目的，并且不会影响内容的呈现。</p><p>MD020-封闭的atx样式标题上的哈希内无空格<br>标签：标题，标题，atx_closed，空格</p><p>别名：无缺失的封闭式atx</p><p>可修复：大多数违规行为可以通过工具修复</p><p>当封闭的atx样式标题中的哈希字符内缺少空格时，将触发此规则：</p><p>＃标题1＃</p><p>##标题2 ##<br>要解决此问题，请将标题文本与井号字符分开一个空格：</p><p>＃ 标题1＃</p><h2 id="标题2-4"><a href="#标题2-4" class="headerlink" title="标题2"></a>标题2</h2><p>注意：如果标题的任一侧缺少空格，则将触发此规则。</p><p>理由：违反此规则可能会导致内容渲染不正确。</p><p>MD021-封闭的atx样式标题上的哈希内有多个空格<br>标签：标题，标题，atx_closed，空格</p><p>别名：no-multiple-spaces-closed-atx</p><p>可修复：大多数违规行为可以通过工具修复</p><p>当在封闭的atx样式标题中使用多个空格将标题文本与哈希字符分开时，将触发此规则：</p><p>＃  标题1＃</p><h2 id="标题2-5"><a href="#标题2-5" class="headerlink" title="标题2"></a>标题2</h2><p>要解决此问题，请将标题文本与井号字符分开一个空格：</p><p>＃ 标题1＃</p><h2 id="标题2-6"><a href="#标题2-6" class="headerlink" title="标题2"></a>标题2</h2><p>注意：如果标题的任一侧包含多个空格，则将触发此规则。</p><p>理由：多余的空间没有目的，并且不会影响内容的呈现。</p><p>MD022-标题应由空白行包围<br>标签：标题，标题，blank_lines</p><p>别名：标题周围为空白，标题周围为空白</p><p>参数：lines_above，lines_below（数字；默认值为1）</p><p>可修复：大多数违规行为可以通过工具修复</p><p>当标题（任何样式）未在前面或后面没有至少一个空白行时，将触发此规则：</p><p>＃ 标题1<br>一些文字</p><p>一些文字</p><h2 id="标题2-7"><a href="#标题2-7" class="headerlink" title="标题2"></a>标题2</h2><p>要解决此问题，请确保所有标题之前和之后都有空白行（除非标题位于文档的开头或结尾）：</p><p>＃ 标题1</p><p>一些文字</p><p>一些文字</p><h2 id="标题2-8"><a href="#标题2-8" class="headerlink" title="标题2"></a>标题2</h2><p>的lines_above和lines_below参数可用于指定不同数量的空白行每个标题的上方或下方（包括0）。</p><p>注意：如果lines_above或lines_below配置为需要多个空白行，则还应自定义MD012 /无多个空白。</p><p>基本原理：除了美学原因外，包括kramdown在内的某些解析器也不会解析以前没有空行的标题，而是将其解析为常规文本。</p><p>MD023-标题必须从行首开始<br>标签：标题，标题，空格</p><p>别名：heading-start-left，header-start-left</p><p>可修复：大多数违规行为可以通过工具修复</p><p>当标题缩进一个或多个空格时，将触发此规则：</p><p>一些文字</p><p>  ＃缩进标题<br>要解决此问题，请确保所有标题均始于该行的开头：</p><p>一些文字</p><p>＃ 标题<br>原理：不在行首的标题将不会被解析为标题，而是显示为常规文本。</p><p>MD024-具有相同内容的多个标题<br>标签：标题，标题</p><p>别名：无重复标题，无重复标题</p><p>参数：siblings_only，allow_different_nesting（布尔值；默认值false）</p><p>如果文档中具有相同文本的多个标题将触发此规则：</p><p>＃ 一些文字</p><h2 id="一些文字"><a href="#一些文字" class="headerlink" title="一些文字"></a>一些文字</h2><p>要解决此问题，请确保每个标题的内容都不同：</p><p>＃ 一些文字</p><h2 id="更多文字"><a href="#更多文字" class="headerlink" title="更多文字"></a>更多文字</h2><p>如果将参数siblings_only（或allow_different_nesting）设置为true，则允许对非同级标题进行标题重复（在更改日志中很常见）：</p><p>＃ 更改日志</p><h2 id="1-0-0"><a href="#1-0-0" class="headerlink" title="1.0.0"></a>1.0.0</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><h2 id="2-0-0"><a href="#2-0-0" class="headerlink" title="2.0.0"></a>2.0.0</h2><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>原理：某些降价解析器会根据标题名称为标题生成锚点；具有相同内容的标题可能会引起问题。</p><p>MD025-同一文档中的多个顶级标题<br>标签：标题，标题</p><p>别名：单标题，单H1</p><p>参数：level，front_matter_title（数字；默认值为1，字符串；默认值为“ ^ \ s *”？title“？\ s * [：=]”）</p><p>当使用顶层标题（文件的第一行是h1标题）并且文档中使用了多个h1标题时，将触发此规则：</p><p>＃ 顶级标题</p><p>＃ 另一个顶层标题<br>要修复，请对文档进行结构化，以便有一个h1标题作为该文档的标题，而所有以后的标题均为h2或更低级别的标题：</p><p>＃ 标题</p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><h2 id="另一个标题-1"><a href="#另一个标题-1" class="headerlink" title="另一个标题"></a>另一个标题</h2><p>注意：level在外部添加h1的情况下，该参数可用于更改顶级（例如：到h2）。</p><p>如果存在YAML前件并包含一个title属性（通常与博客文章一起使用），则此规则将其视为顶层标题，并会报告任何后续的顶层标题违规。要在最前面使用其他属性名称，请通过front_matter_title参数指定正则表达式的文本。要禁用此规则使用前的事情，指定””为front_matter_title。</p><p>原理：顶级标题是文件第一行中的h1，并用作文档的标题。如果使用此约定，则文档的标题不能超过一个，并且整个文档都应包含在此标题中。</p><p>MD026-标题中的标点符号<br>标签：标题，标题</p><p>别名：无拖尾标点</p><p>参数：标点符号（字符串；默认为“。，;：!！。，；：！”）</p><p>可修复：大多数违规行为可以通过工具修复</p><p>在具有指定的标准或全角标点字符之一作为行中最后一个字符的任何标题上触发此规则：</p><p>＃ 这是一个标题。<br>要解决此问题，请删除结尾的标点符号：</p><p>＃ 这是一个标题<br>注意：该punctuation参数可用于指定在标题末尾算作标​​点符号的字符。例如，您可以将其更改 “.,;:”为允许以感叹号结尾的标题。默认情况下允许使用问号，因为它在FAQ样式文档的标题中很常见。将punctuation参数设置为””允许所有字符-等同于禁用规则。</p><p>注：尾随分号 HTML实体引用 一样&copy;，&#169;和&#x000A9;此规则忽略。</p><p>理由：标题并非完整的句子。更多信息：https : //cirosantilli.com/markdown-style-guide#punctuation-at-the-end-of-headers</p><p>MD027-块引用符号后的多个空格<br>标签：blockquote，空格，缩进</p><p>别名：no-multiple-space-blockquote</p><p>可修复：大多数违规行为可以通过工具修复</p><p>当blockquote（&gt;）符号后有多个空格时，将触发此规则：</p><blockquote><p> 这是缩进不好的块式报价<br> 应该只能有一个。<br>要解决此问题，请删除所有多余的空间：</p></blockquote><blockquote><p>这是带有正确<br>缩进的blockquote 。<br>基本原理：一致的格式设置使文档理解更加容易。</p></blockquote><p>MD028-引用内的空白行<br>标签：块引用，空格</p><p>别名：无空格的引用</p><p>当两个blockquote块之间用空行隔开时，将触发此规则：</p><blockquote><p>这是一个引号<br>，后面紧跟着</p></blockquote><blockquote><p>此blockquote。不幸的是<br>在某些解析器中，它们被视为相同的blockquote。<br>要解决此问题，请确保彼此相邻的所有块引用之间都包含一些文本：</p></blockquote><blockquote><p>这是一个大引用。</p></blockquote><p>吉米也说：</p><blockquote><p>这也是blockquote。<br>或者，如果应该使用相同的引号，则在空白行的开头添加blockquote符号：</p></blockquote><blockquote><p>这是一个大引用。</p><p>这是相同的块引用。<br>原理：某些降价解析器会将两个由一个或多个空行分隔的块引用视为同一块引用，而其他一些则将它们视为单独的块引用。</p></blockquote><p>MD029-有序列表项的前缀<br>标签：ol</p><p>别名：ol-prefix</p><p>参数：样式（“一个”，“有序”，“一个或一个有序”，“零”；默认为“一个或一个有序”）</p><p>对于不以“ 1”开头的有序列表，将触发此规则。或没有以数字顺序增加的前缀（取决于配置的样式）。很少使用“ 0”的模式。也支持作为第一个前缀或所有前缀。</p><p>有效样式示例（如果样式配置为“一个”）：</p><p>1.这样做。<br>1.这样做。<br>1.完成。<br>如果样式配置为“有序”，则为有效列表的示例：</p><p>1.这样做。<br>2.这样做。<br>3.完成。<br>0。<br>1.这样做。<br>2.完成。<br>将样式配置为“ one_or_ordered”时，所有三个示例均有效。</p><p>有效样式示例（如果样式配置为“零”）：</p><p>0。<br>0。<br>0.完成。<br>所有样式的无效列表示例：</p><p>1.这样做。<br>3.完成。<br>此规则支持前缀为0的有序列表项以统一缩进：</p><p>…<br> 08.项目<br>09.项目<br>10.项目<br>11.项目<br>…<br>注意：对于以下情况，此规则将报告违规情况，其中在两个列表项之间出现缩进的代码块（或类似的代码块），并在其中“破坏”两个列表：</p><p>1.第一名单</p><p>文字<br>代码块</p><pre><code class="hljs plain">1.第二清单解决方法是缩进代码块，使其按预期成为前面的列表项的一部分：1.第一名单   文字   代码块</code></pre><p>2.仍然是第一名<br>基本原理：一致的格式设置使文档理解更加容易。</p><p>MD030-列表标记后的空格<br>标签：ol，ul，空格</p><p>别名：列表标记空间</p><p>参数：ul_single，ol_single，ul_multi，ol_multi（数字；默认值为1）</p><p>可修复：大多数违规行为可以通过工具修复</p><p>该规则检查列表标记（例如“ -”，“ *”，“ +”或“ 1.”）与列表项文本之间的空格数。</p><p>检查的空格数取决于使用的文档样式，但是默认值是任何列表标记后的1个空格：</p><ul><li>Foo</li><li>酒吧</li><li>Baz</li></ul><ol><li><p>Foo</p></li><li><p>Bar</p></li><li><p>Baz</p></li><li><p>Foo</p><ul><li>Bar</li></ul></li><li><p>Baz<br>文档样式可以根据列表中每个项目的内容是由单个段落还是由多个段落（包括子列表和代码块）组成，分别更改无序列表项和有序列表项后的空格数）。</p></li></ol><p>例如，<a href="https://cirosantilli.com/markdown-style-guide#spaces-after-list-marker%E4%B8%8A%E7%9A%84%E6%A0%B7%E5%BC%8F%E6%8C%87%E5%8D%97">https://cirosantilli.com/markdown-style-guide#spaces-after-list-marker上的样式指南</a> 指定，如果列表中的每个项目都适合单个段落，则应在列表标记后使用1个空格。 ，但如果列表中有多个内容段落，则使用2或3个空格（分别用于有序列表和无序列表）：</p><ul><li><p>Foo</p></li><li><p>酒吧</p></li><li><p>Baz<br>与</p></li><li><p>富</p><p>  第二段</p></li><li><p>  酒吧<br>要么</p></li></ul><ol><li><p>Foo</p><p> 第二段</p></li><li><p> 酒吧<br>要解决此问题，请确保在列表标记之后为所选文档样式使用了正确的空格数。</p></li></ol><p>理由：违反此规则可能会导致内容渲染不正确。</p><p>MD031-带栅栏的代码块应该用空白行包围<br>标签：代码，blank_lines</p><p>别名：围栏周围的空白</p><p>参数：list_items（布尔值；默认为true）</p><p>可修复：大多数违规行为可以通过工具修复</p><p>当受防护的代码块不在空白代码行之前或之后时，将触发此规则：</p><p>一些文本</p><pre><code class="hljs plain">代码块</code></pre><pre><code class="hljs plain">另一个代码块</code></pre><p>更多文本<br>要解决此问题，请确保所有受防护的代码块之前和之后均具有空白行（除非该块位于文档的开头或结尾）：</p><p>一些文字</p><pre><code class="hljs plain">码块</code></pre><pre><code class="hljs plain">的另一个代码块</code></pre><p>一些文字<br>将list_items参数设置false为禁用此列表项规则。如果有必要创建包含代码围栏的严格列表，则禁用列表的此行为可能很有用 。</p><p>基本原理：除了美学上的原因外，包括kramdown在内的某些解析器也不会解析前后没有空白行的受防护的代码块。</p><p>MD032-列表应由空白行包围<br>标签：项目符号，ul，ol，blank_lines</p><p>别名：空白列表</p><p>可修复：大多数违规行为可以通过工具修复</p><p>当（任何种类的）列表不在空行之前或之后时，将触发此规则：</p><p>一些文本<br>*一些<br>*列表</p><p>1.一些<br>2。清单<br>一些文字<br>要解决此问题，请确保所有列表的前后都有空白行（除非该块位于文档的开头或结尾）：</p><p>一些文字</p><p>*一些<br>*清单</p><p>1.一些<br>2.清单</p><p>一些文字<br>基本原理：除了美学原因外，包括kramdown在内的某些解析器也不会解析列表前后没有空白行的列表。</p><p>MD033-内联HTML<br>标签：HTML</p><p>别名：no-inline-html</p><p>参数：allowed_elements（字符串数组；默认为空）</p><p>每当降价文档中使用原始HTML时，都会触发此规则：</p><h1>内联HTML标题</h1>要解决此问题，请使用“纯”降价，而不要包含原始HTML：<p>＃ 降价标题<br>注意：要允许特定的HTML元素，请使用’allowed_elements’参数。</p><p>基本原理：markdown允许使用原始HTML，但是对于那些希望其文档仅包含“纯” markdown的人或那些以HTML以外的方式呈现markdown文档的人而言，此规则也包括在内。</p><p>MD034-使用的裸URL<br>标签：链接，URL</p><p>别名：裸URL</p><p>可修复：大多数违规行为可以通过工具修复</p><p>只要给出的URL被尖括号包围，就会触发此规则：</p><p>有关更多信息，请参见<a href="https://www.example.com/%E3%80%82">https://www.example.com/。</a><br>要解决此问题，请在URL周围添加尖括号：</p><p>有关更多信息，请参见<a href="https://www.example.com/">https://www.example.com/</a>。<br>注意：要使用裸URL而不将其转换为链接，请将其括在代码块中，否则在某些降价解析器中将对其进行转换：</p><p><a href="https://www.example.com/">https://www.example.com</a><br>注：以下情形并不会触发此规则，以避免冲突MD011/ no-reversed-links：</p><p>[<a href="https://www.example.com]">https://www.example.com]</a><br>在裸链接周围使用引号不会触发此规则，或者：</p><p>“ <a href="https://www.example.com”/">https://www.example.com”</a><br>‘<a href="https://www.example.com&/#39;">https://www.example.com&#39;</a><br>基本原理：没有尖括号，许多Markdown解析器不会将URL转换为链接。</p><p>MD035-水平尺样式<br>标签：小时</p><p>别名：hr样式</p><p>参数：样式（“ consistent”，“ —”，“ ***”或其他指定水平线的字符串；默认为“ consistent”）</p><p>当在文档中使用不一致样式的水平规则时，将触发此规则：</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-bullet">-</span> <span class="hljs-bullet">-</span> <span class="hljs-bullet">-</span><span class="hljs-string">***</span><span class="hljs-string">*</span> <span class="hljs-string">*</span> <span class="hljs-string">*</span><span class="hljs-string">****</span></code></pre><p>要解决此问题，请确保文档中使用的所有水平尺都一致，或者如果配置了此规则，则匹配给定样式：</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-meta">---</span></code></pre><p>注意：默认情况下，此规则配置为仅要求文档中的所有水平规则都相同，并且如果任何水平规则与文档中遇到的第一个不同，则将触发此规则。如果要配置规则以匹配特定样式，则给“样式”选项提供的参数是一个字符串，其中包含允许的确切水平规则文本。</p><p>基本原理：一致的格式设置使文档理解更加容易。</p><p>MD036-使用强调代替标题<br>标签：标题，标题，重点</p><p>别名：不强调标题，不强调标题</p><p>参数：标点符号（字符串；默认为“。，;：！？。，；；：！？”）</p><p>此检查查找使用强调（即，粗体或斜体）文本分隔各节的情况，而应使用标题代替：</p><pre><code class="hljs markdown"><span class="hljs-strong">**我的文件**</span>小学二年级奥数试题及答案小学奥数网...<span class="hljs-emphasis">_另一节_</span>奉献精英，sed做eiusmod。要解决此问题，请使用markdown标题而不是强调文本来表示部分：＃ 我的文件</code></pre><p>小学二年级奥数试题及答案小学奥数网…</p><h2 id="另一部分"><a href="#另一部分" class="headerlink" title="另一部分"></a>另一部分</h2><p>奉献精英，sed做eiusmod。<br>注意：此规则查找完全由强调文字组成的单行段落。它不会针对常规文本，强调多行的段落或以标点符号结尾的段落（普通或全角）使用。与规则MD026相似，您可以配置将哪些字符识别为标点符号。</p><p>基本原理：使用强调而不是标题可以防止工具推断文档的结构。更多信息：https : //cirosantilli.com/markdown-style-guide#emphasis-vs-headers。</p><p>MD037-重点标记内的空格<br>标签：空格，重点</p><p>别名：强调中没有空格</p><p>可修复：大多数违规行为可以通过工具修复</p><p>当使用强调标记（粗体，斜体）时会触发此规则，但是它们在标记和文本之间有空格：</p><p>这是一些<strong>粗体</strong>文本。</p><p>这是一些<em>斜体</em>文本。</p><p>这是____粗体字。</p><p>这是更多的_斜体_文本。<br>要解决此问题，请删除重点标记周围的空格：</p><p>这是一些“粗体”文本。</p><p>这是一些<em>斜体</em>文本。</p><p>这是更多的__bold__文本。</p><p>这是更多的_italic_文本。<br>基本原理：仅当星号/下划线未完全被空格包围时，才强调强调。该规则试图检测它们被空格包围的位置，但是强调的文字似乎是作者想要的。</p><p>MD038-代码跨度元素内的空格<br>标签：空格，代码</p><p>别名：代码中无空格</p><p>可修复：大多数违规行为可以通过工具修复</p><p>对于与反引号相邻的空格的代码跨度元素，将触发此规则：</p><p><code>一些文字</code></p><p><code>一些文字</code><br>要解决此问题，请删除反引号附近的所有空格：</p><p>一些文字<br>注意：规范允许使用一个前导和尾随空格，并自动对其进行修剪（以允许嵌入反引号）：</p><p><code>反引号</code><br>注意：如果用于将代码跨标记与嵌入式反引号分开，则允许使用单个前导或尾随空格：</p><p>``嵌入反引号’’<br>理由：违反此规则可能会导致内容渲染不正确。</p><p>MD039-链接文本内的空格<br>标签：空格，链接</p><p>别名：链接中没有空格</p><p>可修复：大多数违规行为可以通过工具修复</p><p>在链接文本周围有空格的链接上触发此规则：</p><p>[链接]（<a href="https://www.example.com/%EF%BC%89">https://www.example.com/）</a><br>要解决此问题，请删除链接文本周围的空格：</p><p>[链接]（<a href="https://www.example.com/%EF%BC%89">https://www.example.com/）</a><br>基本原理：一致的格式设置使文档理解更加容易。</p><p>MD040-带围栏的代码块应指定一种语言<br>标签：代码，语言</p><p>别名：栅栏代码语言</p><p>使用受防护的代码块但未指定语言时触发此规则：</p><pre><code class="hljs awk">＃！<span class="hljs-regexp">/斌/</span>庆典回声世界，你好</code></pre><p>要解决此问题，请将语言说明符添加到代码块中：</p><p>``<br>＃！/ bin / bash<br>echo Hello world</p><pre><code class="hljs clean">基本原理：通过使用正确的代码语法高亮显示，指定一种语言可以改善内容呈现。更多信息：https : <span class="hljs-comment">//cirosantilli.com/markdown-style-guide#option-code-fenced。</span>MD041-文件中的第一行应为顶层标题标签：标题，标题别名：first-line-heading，first-line-h1参数：level，front_matter_title（数字；默认值为<span class="hljs-number">1</span>，字符串；默认值为“ ^ \ s *”？title“？\ s * [：=]”）该规则旨在确保文档具有标题，并在文件的第一行不是顶级（h1）标题时触发：这是一个没有标题的文件要解决此问题，请在文件开头添加一个顶级标题：＃ 带有标题的文件这是一个具有顶级标题的文件注意：level在外部添加h1的情况下，该参数可用于更改顶级（例如：到h2）。如果存在YAML前件并包含一个 title属性（通常用于博客文章），则此规则不会报告违规。要在最前面使用其他属性名称，请通过front_matter_title参数指定正则表达式的文本。要禁用此规则使用前的事情，指定<span class="hljs-string">&quot;&quot;</span>为front_matter_title。理由：顶级标题通常充当文档的标题。更多信息：https : <span class="hljs-comment">//cirosantilli.com/markdown-style-guide#top-level-header。</span>MD042-无空链接标签：链接别名：无空链接遇到空链接时将触发此规则：[一个空链接]（）要解决违规问题，请为链接提供目标位置：[有效链接]（https:<span class="hljs-comment">//example.com/）</span>空片段将触发以下规则：[一个空片段]（＃）但是非空片段不会：[有效片段]（＃fragment）原理：空链接不会指向任何地方，因此不能用作链接。MD043-必需的标题结构标签：标题，标题别名：必填标题，必填标题参数：标题，标题（字符串数组；默认null为禁用）如果headings未提供，headers将使用（不推荐使用）。当文件中的标题与传递给该规则的标题数组不匹配时，将触发此规则。它可用于对一组文件强制执行标准标题结构。严格要求以下结构：＃ 头## 项目### 详细将headings参数设置为：[     “＃头”，     “ ##项”，     “ ###细节” ]允许具有以下结构的可选标题：＃ 头## 项### 详细信息（可选）## 脚### 注意（可选）使用<span class="hljs-string">&quot;*&quot;</span>含义为“零个或多个未指定标题”的特殊值<span class="hljs-string">&quot;+&quot;</span>或含义为“一个或多个未指定标题”的特殊值，并将headings参数设置 为：[     “＃Head ”，     “ ## Item ”，     “ * ”，     “ ## Foot ”，     “ * ” ]当检测到错误时，此规则将输出第一个有问题的标题的行号（否则，将输出文件的最后一个行号）。请注意，尽管headings为简单起见，该参数使用“ ## Text” ATX标题样式，但文件可以使用任何受支持的标题样式。理由：项目可能希望在一组相似的内容上实施一致的文档结构。MD044-正确的名称应具有正确的大写标签：拼写别名：专有名称参数：名称，code_blocks（字符串数组； default null，boolean； default true）可修复：大多数违规行为可以通过工具修复当names数组中的任何字符串不具有指定的大写字母时，将触发此规则。它可以用于对项目和产品的名称强制使用标准的大写字母。例如，语言“ JavaScript”通常是用大写的“ J”和“ S”写的，尽管有时“ s”或“ j”以小写形式出现。要强制使用大写字母，请在names数组中指定所需的字母大小写：[     “ JavaScript ” ]将code_blocks参数设置false为禁用此规则的代码块。理由：专有名称的大写错误通常是一个错误。MD045-图片应具有替代文字（替代文字）标签：辅助功能，图像别名：无替代文本当图像缺少备用文本（替代文本）信息时，将触发此规则。备用文本通常在内联中指定为：！[替代文字]（image.jpg）或使用以下参考语法：！[替代文字] [ref]...[ ref ]：image.jpg“可选标题”W3C， Wikipedia和 其他位置提供了编写替代文本的指南。理由：替代文本对于可访问性很重要，并为可能看不到它的人们描述了图像的内容。MD046-代码块样式标签：代码别名：代码块样式参数：样式（“ consistent”，“ fenced”，“ indented”；默认为“ consistent”）在同一文档中使用不需要或不同的代码块样式时，将触发此规则。在默认配置中，此规则报告对以下文档的违反：Some text.    # Indented <span class="hljs-keyword">code</span>More text.```ruby# Fenced <span class="hljs-keyword">code</span></code></pre><p>More text.<br>要解决违反此规则的问题，请使用一致的样式（缩进或代码围栏）。</p><p>指定的样式可以是特定的（）fenced，也可以indented仅要求文档中的用法保持一致（consistent）。</p><p>基本原理：一致的格式设置使文档理解更加容易。</p><p>MD047-文件应以单个换行符结尾<br>标签：blank_lines</p><p>别名：单行换行</p><p>可修复：大多数违规行为可以通过工具修复</p><p>当文件末尾没有单个换行符时，将触发此规则。</p><p>触发规则的示例：</p><p>＃ 标题</p><p>该文件结尾没有换行符。[EOF]<br>要解决违规问题，请在文件末尾添加换行符：</p><p>＃ 标题</p><p>该文件以换行符结尾。<br>[EOF]<br>基本原理：某些程序无法处理以换行符结尾的文件。更多信息：https : //unix.stackexchange.com/questions/18743/whats-the-point-in-adding-a-new-line-to-the-end-of-a-file。</p><p>MD048-代码围栏样式<br>标签：代码</p><p>别名：栅栏样式</p><p>参数：样式（“ consistent”，“ tilde”，“ backtick”；默认为“ consistent”）</p><p>当文档中用于受防护代码块的符号与配置的代码防护样式不匹配时，将触发此规则：</p><p>红宝石<br>＃围栏代码</p><pre><code class="hljs asciidoc">~~~红宝石＃围栏代码~~~要解决此问题，请在整个文档中使用配置的代码围栏样式：红宝石＃围栏代码</code></pre><p>红宝石<br>＃围栏代码</p><pre><code>配置的列表样式可以是要使用的特定符号（反引号，波浪号），也可以要求文档中的用法必须一致。基本原理：一致的格式设置使文档理解更加容易。</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue step 1 —— Vue初级使用</title>
    <link href="/2017/04/08/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue-step1/"/>
    <url>/2017/04/08/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue-step1/</url>
    
    <content type="html"><![CDATA[<h2 id="一、基本特性"><a href="#一、基本特性" class="headerlink" title="一、基本特性"></a>一、基本特性</h2><h3 id="1、-computed-和-watch"><a href="#1、-computed-和-watch" class="headerlink" title="1、 computed 和 watch"></a>1、 computed 和 watch</h3><ul><li>computed 有缓存，data 不变则不会重新计算</li><li>watch 如何深度监听</li><li>watch 监听时引用类型， 拿不到 oldVal</li></ul><h3 id="2、-v-if-和-v-for-不能同时使用"><a href="#2、-v-if-和-v-for-不能同时使用" class="headerlink" title="2、 v-if 和 v-for 不能同时使用"></a>2、 v-if 和 v-for 不能同时使用</h3><p>v-for 比 v-if 优先级更高</p><p>v-if 和 v-show 的区别：</p><ul><li>v-show 是通过 CSS 的display:none 的方式控制</li><li>v-if 是通过 vue 本身的机制控制组件是否显示或销毁</li></ul><p>当组件频繁显示、隐藏的时候，推荐使用 v-show</p><h3 id="3、事件event"><a href="#3、事件event" class="headerlink" title="3、事件event"></a>3、事件event</h3><ul><li>event 参数，自定义参数 -&gt; 不传参数时，触发的第一个参数默认是event对象，传参时 用 $event 占位，表示 event 对象(mouseEvent对象)</li><li>事件修饰符修饰符, 按键修饰符, 表单修饰符<ul><li>事件修饰符<ul><li>v-on:click.stop=”doThis” 阻止单击事件继续传播</li><li>v-on:submit.prevent=”onSubmit” 提交事件不再重载页面</li><li>v-on:click.stop.prevent=”doThis” 修饰符可以串联</li><li>v-on:submit.prevent 只有修饰符</li><li>v-on:click.capture 添加事件监听时使用事件捕捉模式,即内部元素触发的事件先在此处理, 然后才交由内部元素进行处理</li><li>v-on:clikc.self 只当在event.target 是当前元素自身时触发处理函数,即事件不是从内部元素触发的</li></ul></li><li>按键修饰符<ul><li>@click.ctrl=”onClick” 即使 Alt 或 Shift 被一同按下时也会触发</li><li>@click.ctrl.exact=”onCtrlClick” 有且只有 Ctrl 被按下时才触发</li><li>@click.exact=”onClick” 没有任何修饰符被按下时才触发</li></ul></li><li>表单修饰符<ul><li>v-modle.lazy</li><li>v-modle.trim</li><li>v-modle.number</li></ul></li></ul></li><li>【观察】事件被绑定到哪里<ul><li>event.target 事件绑定的对象, 事件被挂在到当前元素,是与原生DOM事件是一样</li><li>event.currentTarget 事件触发对象, 是与原生DOM事件是一样</li></ul></li></ul><h3 id="4、自定义事件"><a href="#4、自定义事件" class="headerlink" title="4、自定义事件"></a>4、自定义事件</h3><p>使用场景： 当两个组件没有关系，或者嵌套层级比较深（兄弟组件之间通讯）</p><ul><li>绑定事件: event.$on(eventName, eventTarget)</li><li>触发事件: event.$emit(eventName, params)<br>(event是Vue实例, eventName是自定义和触发的自定义事件名称, eventTarget是绑定自定义事件最终执行的函数, params是触发事件时传递给自定义事件的参数)</li></ul><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- index.vue --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Input</span> @<span class="hljs-attr">add</span>=<span class="hljs-string">&quot;addHandler&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">List</span> <span class="hljs-attr">:list</span>=<span class="hljs-string">&quot;list&quot;</span> @<span class="hljs-attr">delete</span>=<span class="hljs-string">&quot;deleteHandler&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">import</span> Input <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Input&#x27;</span></span><span class="javascript"><span class="hljs-keyword">import</span> List <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./List&#x27;</span></span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>    components: &#123;        Input,        List    &#125;,<span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span>            list: [                &#123;<span class="javascript">                    id: <span class="hljs-string">&#x27;id-1&#x27;</span>,</span><span class="javascript">                    title: <span class="hljs-string">&#x27;标题1&#x27;</span></span>                &#125;            ]        &#125;    &#125;,    methods: &#123;<span class="javascript">        <span class="hljs-function"><span class="hljs-title">addHandler</span>(<span class="hljs-params">title</span>)</span> &#123;</span><span class="javascript">            <span class="hljs-built_in">this</span>.list.push(&#123;</span><span class="javascript">                id: <span class="hljs-string">`id-<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>`</span>,</span>                title            &#125;)        &#125;,<span class="javascript">        <span class="hljs-function"><span class="hljs-title">deleteHandler</span>(<span class="hljs-params">id</span>)</span> &#123;</span><span class="javascript">            <span class="hljs-built_in">this</span>.list = <span class="hljs-built_in">this</span>.list.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.id !== id)</span>        &#125;    &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Input.vue --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;title&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addTitle&quot;</span>&gt;</span>add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">import</span> event <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./event&#x27;</span></span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><span class="javascript">            title: <span class="hljs-string">&#x27;&#x27;</span></span>        &#125;    &#125;,    methods: &#123;<span class="javascript">        <span class="hljs-function"><span class="hljs-title">addTitle</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-built_in">this</span>.title)</span><span class="javascript">            <span class="hljs-comment">// 调用自定义事件</span></span><span class="javascript">            event.$emit(<span class="hljs-string">&#x27;onAddTitle&#x27;</span>, <span class="hljs-built_in">this</span>.title)</span><span class="javascript">            <span class="hljs-built_in">this</span>.title = <span class="hljs-string">&#x27;&#x27;</span></span>        &#125;    &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- List.vue --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>                &#123;&#123;item.title&#125;&#125;                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;deleteItem(item.id)&quot;</span>&gt;</span>删除<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">import</span> event <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./event&#x27;</span></span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>    props: &#123;        list: &#123;<span class="javascript">            type: <span class="hljs-built_in">Array</span>,</span><span class="javascript">            <span class="hljs-function"><span class="hljs-title">default</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">                <span class="hljs-keyword">return</span> []</span>            &#125;        &#125;    &#125;,<span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">        <span class="hljs-keyword">return</span> &#123; &#125;</span>    &#125;,<span class="javascript">    <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">        <span class="hljs-comment">// 绑定自定义事件</span></span><span class="javascript">        event.$on(<span class="hljs-string">&#x27;onAddTitle&#x27;</span>, <span class="hljs-built_in">this</span>.addTitleHandler)</span>    &#125;,    methods: &#123;<span class="javascript">        <span class="hljs-function"><span class="hljs-title">deleteItem</span>(<span class="hljs-params">id</span>)</span> &#123;</span><span class="javascript">            <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;delete&#x27;</span>, id)</span>        &#125;,<span class="javascript">        <span class="hljs-function"><span class="hljs-title">addTitleHandler</span>(<span class="hljs-params">title</span>)</span> &#123;</span><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;on add title&#x27;</span>, title)</span>        &#125;    &#125;,<span class="javascript">    <span class="hljs-function"><span class="hljs-title">beforeDestroy</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">        <span class="hljs-comment">// 及时销毁，否则可能造成内存泄露</span></span><span class="javascript">        event.$off(<span class="hljs-string">&#x27;onAddTitle&#x27;</span>, <span class="hljs-built_in">this</span>.addTitleHandler)</span>    &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// event.js</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Vue()</code></pre><h3 id="5、-生命周期"><a href="#5、-生命周期" class="headerlink" title="5、 生命周期"></a>5、 生命周期</h3><ul><li>挂载阶段<br>父Created -&gt; 子Created -&gt; 子Mounted -&gt; 父Mounted</li><li>更新阶段<br>父BeforeUpdate -&gt; 子BeforeUpdate -&gt; 子Updated -&gt; 父Updated</li><li>销毁阶段<br>父BeforeDestroy -&gt; 子BeforeDestroy -&gt; 子Destroy -&gt; 父Destroy</li></ul><h2 id="二、高级特性"><a href="#二、高级特性" class="headerlink" title="二、高级特性"></a>二、高级特性</h2><ul><li>自定义 v-model</li><li>$nextTick</li><li>slot</li><li>动态、异步组件</li><li>keep-alive</li><li>mixin</li></ul><h3 id="1、-自定义-v-model"><a href="#1、-自定义-v-model" class="headerlink" title="1、 自定义 v-model"></a>1、 自定义 v-model</h3><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>vue 高级特性<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 自定义 v-model --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">CustomVModel</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">import</span> CustomVModel <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./CustomVModel&#x27;</span></span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>  components: &#123;    CustomVModel  &#125;,<span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">    <span class="hljs-keyword">return</span> &#123; </span><span class="javascript">      name: <span class="hljs-string">&#x27;123321&#x27;</span>,</span>    &#125;  &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 子组件 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 例如：vue 颜色选择 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;text1&quot;</span></span><span class="hljs-tag">    @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;change1&#x27;, $event.target.value)&quot;</span></span><span class="hljs-tag">  &gt;</span>  <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">    1. 上面的 input 使用了 :value 而不是 v-model</span><span class="hljs-comment">    2. 上面的 change1 和 model.event1 要对应起来</span><span class="hljs-comment">    3. text1 属性对应起来</span><span class="hljs-comment">  --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>  model: &#123;<span class="javascript">    prop: <span class="hljs-string">&#x27;text1&#x27;</span>, <span class="hljs-comment">// 对应 props text1</span></span><span class="javascript">    event: <span class="hljs-string">&#x27;change1&#x27;</span></span>  &#125;,  props: &#123;<span class="javascript">    text1: <span class="hljs-built_in">String</span>,</span><span class="javascript">    <span class="hljs-function"><span class="hljs-title">default</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span></span>    &#125;  &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h3 id="2、-nextTick"><a href="#2、-nextTick" class="headerlink" title="2、$nextTick"></a>2、$nextTick</h3><ul><li>Vue 是异步渲染</li><li>data 改变之后， DOM 不会立刻渲染</li><li>$nextTick 会在 DOM 渲染之后被触发, 以获取最新的 DOM 节点</li></ul><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$nextTick(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// 可以获取最新的 data 值和 DOM 元素</span>&#125;)</code></pre><h3 id="3、slot"><a href="#3、slot" class="headerlink" title="3、slot"></a>3、slot</h3><p>作用：父组件向子组件插入一段内容</p><p>解释：插槽就是在子组件中提供给父组件使用的一个占位符，用 <code>&lt;slot&gt;&lt;/slot&gt;</code> 表示，父组件可以在这个占位符中填充任何模板代码，如 HTML、组件等，填充的内容会替换子组件的 <code>&lt;slot&gt;&lt;/slot&gt;</code> 标签。</p><p>具名插槽：具名插槽其实就是给插槽取个名字。一个子组件可以放多个插槽，而且可以放在不同的地方，而父组件填充内容时，可以根据这个名字把内容填充到对应插槽中。<br><img src="https://i.loli.net/2021/01/03/2y6t5E8V3SgGads.png" ></p><p>作用域插槽：作用域插槽其实就是带数据的插槽，即带参数的插槽，简单的来说就是子组件提供给父组件的参数，该参数仅限于插槽中使用，父组件可根据子组件传过来的插槽数据来进行不同的方式展现和填充插槽内容。</p><h3 id="4、动态组件"><a href="#4、动态组件" class="headerlink" title="4、动态组件"></a>4、动态组件</h3><ul><li>用法 <code>:is= &quot;componentName&quot;</code></li><li>需要根据数据，动态渲染的场景。即组件类型不确定</li></ul><h3 id="5、异步组件"><a href="#5、异步组件" class="headerlink" title="5、异步组件"></a>5、异步组件</h3><ul><li>import() 函数</li><li>按需加载，异步加载大组件</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 异步组件 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">FormDemo</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;showFormDemo&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showFormDemo = true&quot;</span>&gt;</span>show form demo<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>  components: &#123;<span class="javascript">    <span class="hljs-comment">// 异步组件, 在需要使用的时候才加载</span></span><span class="javascript">    FormDemo: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../BaseUse/FormDemo&#x27;</span>)</span>  &#125;,<span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><span class="javascript">      showFormDemo: <span class="hljs-literal">false</span></span>    &#125;  &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h3 id="6、keep-alive"><a href="#6、keep-alive" class="headerlink" title="6、keep-alive"></a>6、keep-alive</h3><p>比如，当用v-if控制组件时，组件不会重复Destroy 和 Mounted<br>适用场景: Tab切换的场景…</p><h3 id="7、mixin"><a href="#7、mixin" class="headerlink" title="7、mixin"></a>7、mixin</h3><ul><li>多个组件有相同的逻辑, 抽离出来</li><li>mixin 并不是完美解决方案, 会有一些问题<ul><li>变量来源不明确，阅读代码增加困难</li><li>多个 mixin 会造成命名冲突</li><li>mixin 和组件可能出现多对多的关系，复杂度较高</li></ul></li><li>Vue 3 提出的 Composition API 旨在解决这个问题</li></ul><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 会把引入的 mixin 中data、mounted、method与 原来组件进行融合到一起--&gt;</span><span class="hljs-comment">&lt;!-- mixin中的 mounted 优先于 原来组件的 mounted 执行 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;name&#125;&#125; &#123;&#123;city&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showName&quot;</span>&gt;</span>显示姓名<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">import</span> myMixin <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mixin&#x27;</span></span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="javascript">    mixins: [myMixin], <span class="hljs-comment">// 可以添加多个，会自动合并起来</span></span><span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><span class="javascript">            name: <span class="hljs-string">&#x27;123&#x27;</span>,</span>        &#125;    &#125;,    methods: &#123;    &#125;,<span class="javascript">    <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;component mounted&#x27;</span>, <span class="hljs-built_in">this</span>.name)</span>    &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// mixin.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> &#123;            city: <span class="hljs-string">&#x27;北京&#x27;</span>        &#125;    &#125;,    methods: &#123;        <span class="hljs-function"><span class="hljs-title">showName</span>(<span class="hljs-params"></span>)</span> &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)        &#125;    &#125;,    <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;mixin mounted&#x27;</span>, <span class="hljs-built_in">this</span>.name)    &#125;&#125;</code></pre><h2 id="三、vuex-和-vue-router"><a href="#三、vuex-和-vue-router" class="headerlink" title="三、vuex 和 vue-router"></a>三、vuex 和 vue-router</h2><h3 id="1、Vuex"><a href="#1、Vuex" class="headerlink" title="1、Vuex"></a>1、Vuex</h3><ul><li>state</li><li>getters</li><li>action</li><li>mutation</li></ul><img src="https://i.loli.net/2021/01/03/N7OtYVuJECdBazI.png" ><p>Actions 是异步操作，可以调用 Backend API</p><h3 id="2、vue-router"><a href="#2、vue-router" class="headerlink" title="2、vue-router"></a>2、vue-router</h3><ul><li>路由模式: hash、H5 history</li><li>路由配置: 动态路由、懒加载</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>框架</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React step 2 —— React高级特性</title>
    <link href="/2017/01/29/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React-step2/"/>
    <url>/2017/01/29/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React-step2/</url>
    
    <content type="html"><![CDATA[<h2 id="1、vDom和diff"><a href="#1、vDom和diff" class="headerlink" title="1、vDom和diff"></a>1、vDom和diff</h2><p>diff:</p><ul><li>只比较同一层级，不跨级比较</li><li>tag 不相同，则直接删掉重建，不再深度比较</li><li>tag 和 key 相同则认为是相同的节点，不再深度比较</li></ul><p>vdom:</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> elem = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;abc&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.clickHandle&#125;</span> &gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>text<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;imgUrl&#125;/</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-comment">// 通过(https://www.babeljs.cn/)babel转义后的结果是:</span><span class="hljs-meta">&quot;use strict&quot;</span>;<span class="hljs-keyword">const</span> elem = React.createElement(<span class="hljs-string">&quot;div&quot;</span>, &#123;className: <span class="hljs-string">&quot;abc&quot;</span>,onClick: (<span class="hljs-keyword">void</span> <span class="hljs-number">0</span>).clickHandle&#125;,React.createElement(<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;text&quot;</span>),React.createElement(<span class="hljs-string">&quot;img&quot;</span>, &#123; <span class="hljs-attr">src</span>: imgUrl &#125;));<span class="hljs-comment">// 即vNode的格式为</span>React.createElement(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-literal">null</span>, [child1, child2, child3])React.createElement(<span class="hljs-string">&#x27;div&#x27;</span>, &#123;...&#125;, child1, child2, child3)React.createElement(List, <span class="hljs-literal">null</span>, child1, child2, <span class="hljs-string">&#x27;text字符串&#x27;</span>)</code></pre><h2 id="2、JSX的本质"><a href="#2、JSX的本质" class="headerlink" title="2、JSX的本质"></a>2、JSX的本质</h2><ul><li>JSX 即 createElement 函数（即h函数），执行生成vnode</li><li>第一个参数 可能是组件，也可能是 html 的tag</li><li>对于组件名，首字母必须大写（React的规定）</li><li>最后通过执行 patch(elem, vnode) 和 patch(vnode, newVnode)</li></ul><h2 id="3、合成事件-SyntheticEvent"><a href="#3、合成事件-SyntheticEvent" class="headerlink" title="3、合成事件 SyntheticEvent"></a>3、合成事件 SyntheticEvent</h2><h3 id="（1）DOM事件的机制现象"><a href="#（1）DOM事件的机制现象" class="headerlink" title="（1）DOM事件的机制现象"></a>（1）DOM事件的机制现象</h3><ol><li>React的 event 是 SyntheticEvent(合成事件)，是模拟出来 DOM 事件所有能力</li><li>event.nativeEvent 是原生事件对象</li><li>绑定对象: React所有的事件都被挂在到 document 上 —— event.currentTarget =&gt; 指向绑定元素，React绑定的对象是document（DOM原生事件和Vue的绑定对象是 element）</li><li>触发对象: React 与原生对象的触发对象是一样的 —— event.target =&gt; 指向触发的对象，React触发的对象是 element （与原生事件一样）</li></ol><h3 id="（2）绑定和触发的顺序"><a href="#（2）绑定和触发的顺序" class="headerlink" title="（2）绑定和触发的顺序"></a>（2）绑定和触发的顺序</h3><p><img src="https://i.loli.net/2020/12/31/pYmSe3xXwfCA2yB.png" alt="SyntheticEvent.png"></p><p>1、DOM事件触发后，由于冒泡机制，最终会冒泡的顶层的 document 上<br>2、由于 React 所有的事件都是绑定在 document 上，于是 React 会统一生成一个 SyntheticEvent 对象（实例化成统一的react Event）<br>3、然后 SyntheticEvent 对象会对事件进行 dispatchEvent (派发事件)<br>4、所谓的 dispatchEvent (派发事件)，就是根据 event.target 找到触发的组件对象，在通过组件对象的绑定关系，触发执行绑定函数(再把合成事件的event对象传递进来，通过参数接收)</p><h3 id="（3）React-为何要使用合成事件机制？"><a href="#（3）React-为何要使用合成事件机制？" class="headerlink" title="（3）React 为何要使用合成事件机制？"></a>（3）React 为何要使用合成事件机制？</h3><ol><li>更好的兼容性和跨平台</li></ol><ul><li>自己实现的一套事件机制，尽可能的摆脱了 Document 的事件逻辑，可以更好的实现兼容性和跨平台</li><li>如果需要迁移到其他平台，只需要修改与 DOM 之间的关系就可以了，降低了对平台的依赖性</li></ul><ol start="2"><li>挂在到 Document 上，减少内存消耗，避免频繁解绑，减少了事件对 DOM 的依赖</li><li>方便事件的统一管理（如事务机制）</li></ol><ul><li>将事件统一挂在到一个对象上，有一个统一入口，方便管理</li></ul><h2 id="4、-setState-和-batchUpdate"><a href="#4、-setState-和-batchUpdate" class="headerlink" title="4、 setState 和 batchUpdate"></a>4、 setState 和 batchUpdate</h2><ul><li>setState 主流程</li><li>batchUpdate 机制</li><li>transaction （事务）机制</li></ul><p>主流程图：</p><img src="https://i.loli.net/2021/01/01/unmj1FWvMrRVTw3.png" height="80%" width="80%"><p>当 isBatchingUpdates = false 时，会把组件保存到 dirtyComponents 中，因此当我们需要更新时，需要更新dirtyComonents 组件，执行组件的更新和渲染</p><p>主流程分析图：<br><img src="https://i.loli.net/2021/01/01/6g3hDPmwix5kyAl.png" > </p><p>React在钩子函数和执行的事件中，首先会初始化一个变量 isBatchingUpdates = true， 到结束时 isBatchingUpdates = false。<br>而 setTimeout 由于宏任务 后执行，因此在执行时 isBatchingUpdates = false，因此执行setState后可以同步拿到最新的state的值。</p><p>原生DOM事件中的 setState：<br>原生的DOM事件在注册时，React并未用 isBatchingUpdates 变量进行管理</p><img src="https://i.loli.net/2021/01/01/tuiyK9vIDY6UNhe.png" ><ol><li>setState 是<strong>异步还是同步</strong>？</li></ol><ul><li>setState无所谓异步还是同步</li><li>看是否能命中 batchUpdate 机制</li><li>通过判断 isBatchingUpdates 看是否命中</li></ul><ol start="2"><li> 哪些能命中 batchUpdate 机制</li></ol><ul><li>React的生命周期函数（和它调用的函数）</li><li>React中注册的事件（和它调用的函数）</li><li>React可以”管理“的入口</li></ul><ol start="3"><li>哪些不能命中 batchUpdate 机制</li></ol><ul><li>setTimeout setInterval 等（和它调用的函数）</li><li>自定义的DOM事件（和它调用的函数）</li><li>React ”管不到“的入口</li></ul><h2 id="5、fiber"><a href="#5、fiber" class="headerlink" title="5、fiber"></a>5、fiber</h2><p>组件渲染流程：</p><ol><li>解析 props ，自定义state</li><li>执行 render() 函数，通过解析JSX结构生成 vnode</li><li>通过 patch(elem, vnode) vnode</li></ol><p>组件更新流程：</p><ol><li>通过 setState(newState) 生成 dirtyComponents （可能有子组件）</li><li>遍历dirtyComponents所有的组件， render() 生成newVnode</li><li>调用patch(vnode, newVnode)渲染</li></ol><p>对以上的patch 拆分为两个阶段：</p><ol><li>reconciliation 阶段： 执行diff算法， 纯JS机选</li><li>commit 阶段： 将diff结果渲染DOM</li></ol><p>可能会有新能问题：</p><ul><li>JS 是单线程， 且和DOM渲染共用一个线程</li><li>当组件足够复杂，组件更新时计算和渲染都压力大</li><li>同时再有DOM操作需求（动画、鼠标拖拽等）， 将卡顿</li></ul><p>解决方案—— fiber：</p><ul><li>将 reconciliation 阶段进行任务拆分（commit阶段无法拆分），拆分为多个任务片段</li><li>DOM需要渲染时暂停 reconciliation 拆分的任务，空闲时间恢复计算</li><li>判断浏览器DOM需要更新渲染的API： window.requestIdleCallback (有些浏览器不支持，因此fiber不是支持所有浏览器)</li></ul><h2 id="6、React事务机制"><a href="#6、React事务机制" class="headerlink" title="6、React事务机制"></a>6、React事务机制</h2><p>。。。</p>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>参考链接</title>
    <link href="/2016/08/25/text/test/"/>
    <url>/2016/08/25/text/test/</url>
    
    <content type="html"><![CDATA[<h3 id="一：写作"><a href="#一：写作" class="headerlink" title="一：写作"></a>一：写作</h3><ol><li><a href="https://mp.weixin.qq.com/s/N7lemFt-z9ADA2JfuxdXAg">写了 200 多篇文章后，我总结的写作心得</a></li><li><a href="https://www.mdnice.com/">Markdown-让排版变 Nice</a></li><li><a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></li><li><a href="https://zhuanlan.zhihu.com/p/35668237">超详细Hexo+Github博客搭建小白教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/26625249">GitHub+Hexo 搭建个人网站详细教程</a></li><li><a href="https://github.com/litten/hexo-theme-yilia">hexo-theme-yilia:简洁优雅</a></li><li><a href="https://sm.ms/">sm.ms图床</a></li><li><a href="https://portal.qiniu.com/kodo/bucket/resource?bucketName=blog628">七牛云 - 图床</a></li><li><a href="https://imliyan.com/blogs/article/React%20Hooks%20%E7%9A%84%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84/">React Hooks 的链表结构</a></li><li><a href="https://www.jianshu.com/p/44e211829447?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation">hexo文章加密 - 简书</a></li><li><a href="https://blog.csdn.net/lhban108?spm=1010.2135.3001.5113">CSDN</a></li><li><a href="https://juejin.cn/user/3210229686214887/activities">掘金</a></li><li><a href="https://blog.csdn.net/peng2hui1314/article/details/104755498/">_markdown 代码块 高亮</a></li><li><a href="https://github.com/DavidAnson/markdownlint/blob/v0.22.0/doc/Rules.md#md012">markdownlint</a></li><li><a href="https://www.itying.com/koa/article-index-id-100.html">koa2 网站开启gzip压缩 ，koa-compress实现网页gizp压缩</a></li><li><a href="https://word2md.com/">Word to Markdown</a></li><li><a href="https://blog.jijian.link/2020-02-26/hexo-article-code-add-unfold/">hexo 文章中代码模块添加展开收起效果</a></li></ol><h3 id="二、微前端"><a href="#二、微前端" class="headerlink" title="二、微前端"></a>二、微前端</h3><ol><li><a href="https://github.com/phodal/microfrontends">微前端的那些事儿</a></li><li><a href="https://umijs.org/zh/">umi</a></li><li><a href="https://github.com/umijs/qiankun">乾坤-阿里的微前端解决方案</a></li><li><a href="micro-frontends.org">micro-frontends-将微服务理念扩展到前端开发</a></li><li><a href="https://developer.aliyun.com/article/742576">标准微前端架构在蚂蚁的落地实践</a><br> <a href="https://developer.aliyun.com/live/1849?spm=a2c6h.12873581.0.0.10433e5fn2gGJp&groupCode=alibabaf2e">视频</a><br> <a href="https://github.com/d2forum/14th">ppt</a></li><li><a href="https://v.youku.com/v_show/id_XNDUwNTY5MzQyNA==.html?spm=a2h1n.8251843.playList.5!5~5~A&f=52355444&o=1">云生态新物种—微前端架构体系</a></li><li><a href="https://developer.aliyun.com/article/736701?spm=a2c6h.12873581.0.0.48b070cavvdFFK">拥抱云时代的前端开发架构—微前端</a></li><li><a href="https://developer.aliyun.com/live/1852?spm=a2c6h.12873581.0.0.18593e5fw12YZw&groupCode=alibabaf2e">微前端沙盒体系|视频（头条）</a></li><li><a href="https://insights.thoughtworks.cn/micro-frontends-1/">「微前端」- 将微服务理念扩展到前端开发-理论篇</a></li><li><a href="https://insights.thoughtworks.cn/micro-frontends-2/">「微前端」- 将微服务理念扩展到前端开发-实战篇</a></li><li><a href="https://tech.meituan.com/2018/09/06/fe-tiny-spa.html">用微前端的方式搭建类单页应用</a></li><li><a href="https://zhuanlan.zhihu.com/p/78362028">可能是你见过最完善的微前端解决方案</a></li><li><a href="https://zhuanlan.zhihu.com/p/95085796">微前端的核心价值</a></li><li><a href="https://zhuanlan.zhihu.com/p/101164985">微前端方案 icestark 的现在与未来</a></li><li><a href="https://mp.weixin.qq.com/s/GgVo5KyZPlEsEeICcPyuLA">Bifrost微前端框架及其在美团闪购中的实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==">网易严选企业级微前端解决方案与落地实践</a></li><li><a href="https://mp.weixin.qq.com/s/PQ-aK1h0bCr5h4jYfoIypw">微服务全流程各组件详细对比分析</a></li><li><a href="https://zhuanlan.zhihu.com/p/98874926">网易云音乐前端模块动态下发系统</a></li><li><a href="https://mp.weixin.qq.com/s/iLdAH9p2-S8pFyZrNzYaNg">前端微服务在字节跳动的打磨与应用</a></li><li><a href="https://zhuanlan.zhihu.com/p/100135298">微前端</a></li><li><a href="http://gitlab.qima-inc.com/wsc-node/wsc-pc-base">wsc-pc-base</a></li><li><a href="https://github.com/iuap-design/blog/issues/382">微前端架构推进参考资料汇总</a></li><li><a href="http://www.imooc.com/article/304768">微前端入门-最容易看懂的微前端知识</a></li></ol><h3 id="三、SSR"><a href="#三、SSR" class="headerlink" title="三、SSR"></a>三、SSR</h3><ol><li><a href="https://segmentfault.com/a/1190000020417285">React SSR 服务端渲染和同构原理</a></li><li><a href="https://umijs.org/zh-CN/docs/ssr#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%9F">服务端渲染（SSR）</a></li><li><a href="https://tech.youzan.com/server-side-render/">如何搭建一个高可用的服务端渲染工程</a></li><li><a href="https://ssr.vuejs.org/zh/guide/#%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA-vue-%E5%AE%9E%E4%BE%8B">基本用法 | Vue SSR 指南</a></li><li><a href="https://juejin.im/post/6844903777766473742">从零开始React服务器渲染（SSR）同构（基于Koa）</a></li><li><a href="https://www.njleonzhang.com/2018/07/30/vue-ssr-2.html">从零开始搭建 Vue SSR DEMO 2</a></li><li><a href="http://blog.poetries.top/2018/11/18/react-ssr/?utm_source=tuicool&utm_medium=referral">从零到一搭建React SSR工程架构(一)</a></li><li><a href="http://blog.poetries.top/2018/11/18/react-ssr/">从零到一搭建React SSR工程架构(一)</a></li><li><a href="http://cn.redux.js.org/docs/recipes/ServerRendering.html">服务端渲染 · GitBook</a></li><li><a href="http://blog.poetries.top/2018/11/18/react-ssr-next/">使用Next搭建React SSR工程架构之基础篇(二)</a></li><li><a href="https://www.processon.com/view/link/5e87e026e4b03bfcd07e1f4b">Beauty-wap SSR流程</a></li><li><a href="https://zhuanlan.zhihu.com/p/61348429">Vue SSR深度剖析 - 知乎</a></li></ol><h3 id="四、算法"><a href="#四、算法" class="headerlink" title="四、算法"></a>四、算法</h3><ol><li><a href="https://bitable.feishu.cn/appcnlq6r9VAV97JiYD52EE0ewh?table=tbluaB2ERhhgZEKD&view=vew5uodacp">飞书</a></li><li><a href="https://mp.weixin.qq.com/s/ldXid67Hs3l-z3HePiaMBw">树+8道前端算法面试高频题解</a></li><li><a href="https://leetcode-cn.com/problems/same-tree/solution/yi-tao-quan-fa-shua-diao-nge-bian-li-shu-de-wen--2/">二叉树全解</a></li><li><a href="https://visualgo.net/zh">VisuAlgo - 数据结构和算法动态可视化</a></li></ol><h3 id="五、基础"><a href="#五、基础" class="headerlink" title="五、基础"></a>五、基础</h3><ol><li><a href="https://hit-alibaba.github.io/interview/basic/network/">计算机网络 · 笔试面试知识整理</a></li><li><a href="https://juejin.cn/post/6844904132210655245">你真的懂Promise吗</a></li><li><a href="https://cloud.tencent.com/developer/article/1443036">啥是单点登陆</a></li><li><a href="https://mp.weixin.qq.com/s/ov4j486HLQcNPK-nYi24oA">面试官：什么是单点登录</a></li><li><a href="https://baidu.github.io/amis/docs/index">amis - 低代码前端框架</a></li><li><a href="https://www.cnblogs.com/ypppt/p/13114244.html">css条纹背景</a></li><li><a href="https://www.jstips.co/zh_CN/">Js Tips - A JavaScript tip per day!</a></li><li><a href="https://github.com/woai3c/Front-end-articles/blob/master/monitor.md">前端性能和错误监控</a></li><li><a href="https://juejin.cn/post/6844903781889474567#heading-1">Node.js环境性能监控</a></li><li><a href="https://mp.weixin.qq.com/s/305rLgscSJCQq8zQ_g4GMg">Web 前端监控</a></li><li><a href="https://www.yuque.com/tianma630/nd8ugf/omyuai">饷店直播性能监控方案</a></li><li><a href="https://segmentfault.com/a/1190000022633988">前端都该懂的浏览器工作原理，你懂了吗</a></li><li><a href="https://mp.weixin.qq.com/s/klZ6j3Gj9cwHGQFys6Hdjg">浏览器相关原理(面试题)详细总结一</a></li><li><a href="https://mp.weixin.qq.com/s/HqADCzMGlIFDNnMRLsPTAA">浏览器相关原理(面试题)详细总结二</a></li><li><a href="https://mp.weixin.qq.com/s/1HxTHI6X39lhZZT1O6k9ww">由一道腾讯面试题吃透 V8 引擎的垃圾回收</a></li><li><a href="https://juejin.im/post/5b6ea54cf265da0f6436f77a">Vue实现左右菜单联动实现（更新） - 掘金</a></li><li><a href="https://blog.csdn.net/mm_hello11/article/details/89048147">vue中使用better-scroll实现滑动以及左右联动效果</a></li><li><a href="https://segmentfault.com/a/1190000015169748">vue左右侧联动滚动</a></li><li><a href="https://juejin.im/post/6844903999058116615">2019再谈移动端position fixed - 掘金</a></li><li><a href="https://segmentfault.com/a/1190000010510291">深入探究iOS下fixed定位导致的问题</a></li><li><a href="https://www.cnblogs.com/xiaohuochai/p/5289653.html">深入理解CSS溢出overflow</a></li><li><a href="https://www.cnblogs.com/coco1s/p/7358830.html">不受控制的 position:fixed</a></li></ol><h3 id="六、框架"><a href="#六、框架" class="headerlink" title="六、框架"></a>六、框架</h3><ol><li><a href="https://juejin.im/post/6844903582622285831">React Fiber</a></li><li><a href="https://segmentfault.com/a/1190000019067303">使用React Hook提高代码复用性 - 思否</a></li><li><a href="https://segmentfault.com/a/1190000039021724">深入理解React Diff算法 - SegmentFault 思否</a></li><li><a href="https://github.com/neroneroffy/react-source-code-debug/blob/master/docs/render%E9%98%B6%E6%AE%B5/beginWork%E9%98%B6%E6%AE%B5/Diff%E7%AE%97%E6%B3%95.md">react-source-code-debug/Diff算法</a></li><li><a href="https://juejin.cn/post/6867745889184972814#heading-15">烤透 React Hook</a></li></ol><h3 id="七、interview"><a href="#七、interview" class="headerlink" title="七、interview"></a>七、interview</h3><ol><li><a href="https://mp.weixin.qq.com/s/GhteLYdIN_l8P5W9uucjdQ">高频前端开发面试问题及答案整理</a></li><li><a href="https://github.com/huruji/FE-Interview">GitHub - huruji/FE-Interview</a></li><li><a href="https://github.com/paddingme/Front-end-Web-Development-Interview-Question">GitHub - 前端面试集锦</a></li><li><a href="https://github.com/qiu-deqing/FE-interview">GitHub - 收集的前端面试题和答案</a></li><li><a href="https://github.com/LuckyWinty/fe-weekly-questions/issues?page=1&q=is:issue+is:open">interview题</a></li><li><a href="https://juejin.cn/post/6917635279423537165#heading-2">前端170面试题+答案学习整理</a></li><li><a href="https://mp.weixin.qq.com/s/jfOJ81bFQiLcgIDD0eC08Q">新出炉大厂面试题100道整理(原题 + 精讲 1.2万字)</a></li><li><a href="https://github.com/azl397985856/leetcode">GitHub leetcode题解</a></li><li><a href="https://github.com/ljianshu/Blog">GitHub - ljianshu/Blog</a></li><li><a href="https://github.com/lgwebdream/FE-Interview/blob/master/summarry/all.md">github-FE-Interview</a></li><li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md">Daily-Interview-Question</a></li><li><a href="https://jobs.bytedance.com/referral/pc/position/application?token=MjsxNjE1MjExNTQ0MzI3OzY3ODE4NDczMzQ2NTA1MjkyOTQ7NjkzNzI3Njk2ODY2NDYzMTU4OQ">字节-飞书-内推</a></li><li><a href="https://careers.tencent.com/jobdesc.html?postId=65770">岗位详情 | 腾讯招聘</a></li></ol><h3 id="八、工具"><a href="#八、工具" class="headerlink" title="八、工具"></a>八、工具</h3><ol><li><a href="https://www.processon.com/">ProcessOn - 在线作图，思维导图，流程图</a></li><li><a href="https://www.jianshu.com/p/b51d05e965bf">Mac终端快捷键 &amp; Mac OSX 快捷键</a></li><li><a href="https://juejin.im/post/6844903999758401549">史上最贴心前端脚手架开发辅导</a></li><li><a href="https://juejin.im/post/6844903526947110919">基于node.js的脚手架工具开发经历</a></li><li><a href="https://segmentfault.com/a/1190000006190814">从零开始搭建一款前端脚手架工具</a></li><li><a href="https://imweb.io/topic/59ffc48c1f0e50753869bf91">自制前端脚手架 - 腾讯Web前端</a></li><li><a href="https://developers.weixin.qq.com/community/develop/article/doc/000e08e632c2f8847b39b67dc51813">如何写一个自己的脚手架</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>React step 1 —— React初级使用</title>
    <link href="/2016/04/08/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React-step1/"/>
    <url>/2016/04/08/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React-step1/</url>
    
    <content type="html"><![CDATA[<h2 id="一、事件"><a href="#一、事件" class="headerlink" title="一、事件"></a>一、事件</h2><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReserveBoard</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;      <span class="hljs-built_in">super</span>(props);<span class="hljs-built_in">this</span>.state = &#123;name: <span class="hljs-string">&#x27;张三&#x27;</span>&#125;<span class="hljs-comment">// 需要修改this的指向</span><span class="hljs-comment">// this.click1 = this.click1.bind(this);</span>&#125;render () &#123;<span class="hljs-keyword">return</span> (&lt;div&gt;&lt;span onClick=&#123;<span class="hljs-built_in">this</span>.click1&#125;&gt;&#123;<span class="hljs-built_in">this</span>.state.name&#125;&lt;/span&gt;&lt;span onClick=&#123;<span class="hljs-built_in">this</span>.click2(<span class="hljs-string">&#x27;param1&#x27;</span>, <span class="hljs-string">&#x27;param2&#x27;</span>)&#125;&gt;&#123;<span class="hljs-built_in">this</span>.state.name&#125;&lt;/span&gt;&lt;/div&gt;)&#125;<span class="hljs-function"><span class="hljs-title">click1</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-comment">// 会报错，因为 this 是undefined</span><span class="hljs-built_in">this</span>.setState(&#123;name: <span class="hljs-string">&#x27;李四&#x27;</span>&#125;)&#125;click2 = <span class="hljs-function">(<span class="hljs-params">id, name, event</span>) =&gt;</span> &#123;<span class="hljs-comment">// 事件传参: 前面参数是触发事件是传递的参数, 最后增加了一个参数, 是合成的 event 对象</span><span class="hljs-comment">// 不会报错，可正常执行，this指向正确</span><span class="hljs-built_in">this</span>.setState(&#123;name: <span class="hljs-string">&#x27;李四&#x27;</span>&#125;)<span class="hljs-built_in">console</span>.log(event);event.preventDefault(); <span class="hljs-comment">// 阻止默认行为</span>event.stopPropagation(); <span class="hljs-comment">// 阻止冒泡</span><span class="hljs-built_in">console</span>.log(event.target); <span class="hljs-comment">// 指向 触发的对象 React触发的对象是 element （与原生事件一样）</span><span class="hljs-built_in">console</span>.log(event.currentTarget); <span class="hljs-comment">// 指向 绑定元素， 假象！！ React绑定的对象是document （与原生事件不一样）</span><span class="hljs-comment">// event不是原始的event对象,原生的event是 MouseEvent,它的构造函数是 SyntheticEvent (组合事件)</span>&#125;&#125;</code></pre><p>结论：</p><ul><li><strong>Vue</strong><ul><li>event 是原生的</li><li>事件被挂在到当前元素(触发也指向当前元素), 和DOM事件是一样的</li></ul></li><li><strong>React</strong><ul><li>event 事件的构造函数是 SyntheticEvent, 是模拟出来 DOM 事件的所有能力</li><li>event.nativeEvent 是原生事件对象</li><li>所有的事件都挂在到 document上, 和DOM 事件不一样, 和vue也不一样.(触发对象是和vue、DOM原生事件的对象一样)</li></ul></li></ul><h2 id="二、setState"><a href="#二、setState" class="headerlink" title="二、setState"></a>二、setState</h2><ul><li>1、React中的state是<strong>不可变值</strong></li></ul><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.state.a = <span class="hljs-string">&#x27;aaa&#x27;</span>;<span class="hljs-built_in">this</span>.setState(&#123;&#125;);<span class="hljs-comment">// 这种写法是错误的</span></code></pre><ul><li>2、setState<strong>可能是异步更新</strong><ul><li>在setTimeout中 和 原生事件（自定义的DOM事件）中，setState是同步的</li><li>其他情况是异步的</li></ul></li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// constructor</span><span class="hljs-built_in">this</span>.state = &#123;a: <span class="hljs-string">&#x27;123&#x27;</span>,&#125;<span class="hljs-comment">// 其他函数中</span><span class="hljs-built_in">this</span>.setState(&#123;a: <span class="hljs-string">&#x27;456&#x27;</span>,&#125;, <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 456 // （1）setState 回调函数中是可以拿到最新值</span>&#125;)<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 123  // （2）正常使用时 setState 是异步的</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">this</span>.setState(&#123;a: <span class="hljs-string">&#x27;789&#x27;</span>,&#125;)<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 789  // （3）在setTimeout中 setState是同步的</span>&#125;, <span class="hljs-number">0</span>)Document.body.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">this</span>.setState(&#123;a: <span class="hljs-string">&#x27;aaa&#x27;</span>,&#125;)<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// aaa // （4）在原生DOm事件 setState是同步的</span>&#125;)</code></pre><ul><li>3、setState<strong>可能会被合并</strong></li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// constructor</span><span class="hljs-built_in">this</span>.state = &#123;a: <span class="hljs-number">0</span>,&#125;<span class="hljs-comment">// 其他函数中</span><span class="hljs-comment">// （1）连续多次对一个值进行操作，结果会被合并 最终 a = 1</span><span class="hljs-built_in">this</span>.setState(&#123;a: <span class="hljs-built_in">this</span>.state.a + <span class="hljs-number">1</span>&#125;)<span class="hljs-built_in">this</span>.setState(&#123;a: <span class="hljs-built_in">this</span>.state.a + <span class="hljs-number">1</span>&#125;)<span class="hljs-built_in">this</span>.setState(&#123;a: <span class="hljs-built_in">this</span>.state.a + <span class="hljs-number">1</span>&#125;)<span class="hljs-comment">// （2）但是在函数中，执行结果不会被合并</span><span class="hljs-built_in">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">prevState, props</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> &#123;a: prevState.a + <span class="hljs-number">1</span>&#125;&#125;)<span class="hljs-built_in">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">prevState, props</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> &#123;a: prevState.a + <span class="hljs-number">1</span>&#125;&#125;)<span class="hljs-built_in">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">prevState, props</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> &#123;a: prevState.a + <span class="hljs-number">1</span>&#125;&#125;)</code></pre><h2 id="三、生命周期"><a href="#三、生命周期" class="headerlink" title="三、生命周期"></a>三、生命周期</h2><p><a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram">http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram</a></p><p> 常用的生命周期：<br><img src="https://i.loli.net/2020/12/28/cUJPSIX6vCGab8e.png" ></p><p>包含不常用的：<br><img src="https://i.loli.net/2020/12/28/cUJPSIX6vCGab8e.png" ></p><p>最适合访问初始化接口数据的生命周期是: componentDidMount</p><h2 id="四、高级特性"><a href="#四、高级特性" class="headerlink" title="四、高级特性"></a>四、高级特性</h2><h3 id="1、函数组件"><a href="#1、函数组件" class="headerlink" title="1、函数组件"></a>1、函数组件</h3><img src="https://i.loli.net/2020/12/29/I2LX4ea3t5RMlUB.png" ><p>函数组件的特点：</p><ul><li>纯函数： 输入props，输出JSX</li><li>没有实例，没有生命周期，因此没有state</li><li>不能扩展其他方法</li></ul><h3 id="2、受控组件-和-非受控组件"><a href="#2、受控组件-和-非受控组件" class="headerlink" title="2、受控组件 和 非受控组件"></a>2、受控组件 和 非受控组件</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 受控组件 与 非受控组件</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">demo1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<span class="hljs-built_in">super</span>(props);<span class="hljs-built_in">this</span>.state = &#123;name: <span class="hljs-string">&#x27;zhangsan&#x27;</span>,&#125;<span class="hljs-built_in">this</span>.fileInputRef = React.createRef(); <span class="hljs-comment">// 创建ref</span>&#125;changeVal = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<span class="hljs-built_in">this</span>.setState(&#123;name: e.target.value,&#125;)&#125;alertFIle = <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">const</span> elem = <span class="hljs-built_in">this</span>.fileInputRef.current; <span class="hljs-comment">// 通过ref获得DOM节点</span>alert(elem.files[<span class="hljs-number">0</span>].name);&#125;<span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> &lt;div&gt;&#123;<span class="hljs-comment">/* 受控组件 */</span>&#125;&lt;input value=&#123;<span class="hljs-built_in">this</span>.state.name&#125; onChange=&#123;<span class="hljs-built_in">this</span>.changeVal&#125; /&gt;&#123;<span class="hljs-comment">/* 非受控组件 */</span>&#125;&lt;input type=<span class="hljs-string">&quot;file&quot;</span> ref=&#123;<span class="hljs-built_in">this</span>.fileInputRef&#125; /&gt;&lt;button onClick=&#123;<span class="hljs-built_in">this</span>.alertFIle&#125;&gt;alert File&lt;/button&gt;&lt;/div&gt;&#125;&#125;</code></pre><p>使用场景：</p><ul><li>必须手动操作DOM元素，setState实现不了</li><li>文件上传 <code>&lt;input type=file&gt;</code></li><li>某些富文本编辑器，需要传入DOM元素</li></ul><p>如何选择：</p><ul><li>优先使用受控组件，符合React设计原则 （数据驱动视图）</li><li>必须操作DOM的时候，再使用非受控组件</li></ul><h3 id="3、Portals"><a href="#3、Portals" class="headerlink" title="3、Portals"></a>3、Portals</h3><p>问题：组件默认会按照既定层次嵌套渲染，如何让组件渲染到父组件以外？</p><pre><code class="hljs javascript"><span class="hljs-comment">// 父组件 index.js</span><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">import</span> PortalsDemo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./PortalsDemo&#x27;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdvancedUse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<span class="hljs-built_in">super</span>(props)&#125;<span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> &lt;div&gt;         &lt;PortalsDemo&gt; Modal 内容 &lt;/PortalsDemo&gt;&lt;/div&gt;&#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> AdvancedUse<span class="hljs-comment">// 子组件</span><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span> <span class="hljs-comment">// 需要用到 ReactDOM.createPortal API</span><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./style.css&#x27;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<span class="hljs-built_in">super</span>(props)<span class="hljs-built_in">this</span>.state = &#123;&#125;&#125;<span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-comment">// // 正常渲染</span><span class="hljs-comment">// return &lt;div className=&quot;modal&quot;&gt;</span><span class="hljs-comment">//     &#123;this.props.children&#125;  &#123;/* vue slot */&#125;</span><span class="hljs-comment">// &lt;/div&gt;</span><span class="hljs-comment">// 使用 Portals 渲染到 body 上。 // fixed 元素要放在 body 上，有更好的浏览器兼容性。</span><span class="hljs-keyword">return</span> ReactDOM.createPortal(&lt;div className=<span class="hljs-string">&quot;modal&quot;</span>&gt;&#123;<span class="hljs-built_in">this</span>.props.children&#125;&lt;/div&gt;,<span class="hljs-built_in">document</span>.body <span class="hljs-comment">// 需要挂在到的 DOM 节点</span>)&#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App</code></pre><p>Portals 使用场景</p><ul><li>overflow: hiddem</li><li>父组件 z-index 值太小</li><li>fixed 需要放在body的第一层</li></ul><h3 id="4、content"><a href="#4、content" class="headerlink" title="4、content"></a>4、content</h3><p>问题: 公共信息（语言、主题等）如何传递给每个组件<br>用 props 太繁琐， 用redux 小题大做</p><pre><code class="hljs JS"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-comment">// 创建 Context 填入默认值（任何一个 js 变量）</span><span class="hljs-keyword">const</span> ThemeContext = React.createContext(<span class="hljs-string">&#x27;light&#x27;</span>)<span class="hljs-comment">// 底层组件 - 函数是组件</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ThemeLink</span> (<span class="hljs-params">props</span>) </span>&#123;    <span class="hljs-comment">// const theme = this.context // 会报错。函数式组件没有实例，即没有 this</span>    <span class="hljs-comment">// 函数式组件可以使用 Consumer</span>    <span class="hljs-keyword">return</span> &lt;ThemeContext.Consumer&gt;        &#123; <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>link&#x27;s theme is &#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span> &#125;    &lt;/ThemeContext.Consumer&gt;&#125;<span class="hljs-comment">// 底层组件 - class 组件</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThemedButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-comment">// 指定 contextType 读取当前的 theme context。</span>    <span class="hljs-comment">// static contextType = ThemeContext</span> <span class="hljs-comment">// 也可以用 ThemedButton.contextType = ThemeContext</span>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// React 会往上找到最近的 theme Provider，然后使用它的值。</span>        <span class="hljs-keyword">const</span> theme = <span class="hljs-built_in">this</span>.context         <span class="hljs-keyword">return</span> &lt;div&gt;            &lt;p&gt;button<span class="hljs-string">&#x27;s theme is &#123;theme&#125;&lt;/p&gt;</span><span class="hljs-string">        &lt;/div&gt;</span><span class="hljs-string">    &#125;</span><span class="hljs-string">&#125;</span><span class="hljs-string">// 指定 contextType 读取当前的 theme context。</span><span class="hljs-string">ThemedButton.contextType = ThemeContext</span><span class="hljs-string"></span><span class="hljs-string">// 中间的组件再也不必指明往下传递 theme 了。</span><span class="hljs-string">function Toolbar(props) &#123;</span><span class="hljs-string">    return (</span><span class="hljs-string">        &lt;div&gt;</span><span class="hljs-string">            &lt;ThemedButton /&gt;</span><span class="hljs-string">            &lt;ThemeLink /&gt;</span><span class="hljs-string">        &lt;/div&gt;</span><span class="hljs-string">    )</span><span class="hljs-string">&#125;</span><span class="hljs-string"></span><span class="hljs-string">// 根组件</span><span class="hljs-string">class App extends React.Component &#123;</span><span class="hljs-string">    constructor(props) &#123;</span><span class="hljs-string">        super(props)</span><span class="hljs-string">        this.state = &#123;</span><span class="hljs-string">            theme: &#x27;</span>light<span class="hljs-string">&#x27;</span><span class="hljs-string">        &#125;</span><span class="hljs-string">    &#125;</span><span class="hljs-string">    render() &#123;</span><span class="hljs-string">        return &lt;ThemeContext.Provider value=&#123;this.state.theme&#125;&gt;</span><span class="hljs-string">            &lt;Toolbar /&gt;</span><span class="hljs-string">            &lt;hr/&gt;</span><span class="hljs-string">            &lt;button onClick=&#123;this.changeTheme&#125;&gt;change theme&lt;/button&gt;</span><span class="hljs-string">        &lt;/ThemeContext.Provider&gt;</span><span class="hljs-string">    &#125;</span><span class="hljs-string">    changeTheme = () =&gt; &#123;</span><span class="hljs-string">        this.setState(&#123;</span><span class="hljs-string">            theme: this.state.theme === &#x27;</span>light<span class="hljs-string">&#x27; ? &#x27;</span>dark<span class="hljs-string">&#x27; : &#x27;</span>light<span class="hljs-string">&#x27;</span><span class="hljs-string">        &#125;)</span><span class="hljs-string">    &#125;</span><span class="hljs-string">&#125;</span><span class="hljs-string"></span><span class="hljs-string">export default App</span><span class="hljs-string"></span></code></pre><h3 id="5、异步组件"><a href="#5、异步组件" class="headerlink" title="5、异步组件"></a>5、异步组件</h3><ul><li>import()</li><li>React.lazy</li><li>React.Suspense</li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-comment">// 通过React.lazy()方法 对import引入的组件进行懒加载</span><span class="hljs-keyword">const</span> ContextDemo = React.lazy(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./ContextDemo&#x27;</span>))<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;        <span class="hljs-built_in">super</span>(props)    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> &lt;div&gt;            &lt;p&gt;引入一个动态组件&lt;/p&gt;            &lt;hr /&gt;&#123;<span class="hljs-comment">/* React.Suspense 使用懒加载引入的组件 */</span>&#125;            &lt;React.Suspense fallback=&#123;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&#125;&gt;                &lt;ContextDemo/&gt;            &lt;/React.Suspense&gt;        &lt;/div&gt;    &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App</code></pre><h2 id="五、React性能优化"><a href="#五、React性能优化" class="headerlink" title="五、React性能优化"></a>五、React性能优化</h2><h3 id="1、shouldComponentUpdate"><a href="#1、shouldComponentUpdate" class="headerlink" title="1、shouldComponentUpdate"></a>1、shouldComponentUpdate</h3><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">shouldComponentUpdate</span>(<span class="hljs-params">nextProps, nextState</span>)</span> &#123;<span class="hljs-keyword">if</span> (nextState.count !== <span class="hljs-built_in">this</span>.state.count) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 可以渲染 // 默认返回true</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 不重复渲染</span>&#125;</code></pre><p>为什么React不在源码中直接进行 state 对比，如果没有改变就不渲染，而是要给开发者这个操作的权利？</p><ul><li>React 默认： 父组件更新，子组件则无条件也更新！！ 因此性能优化对React更加重要</li><li>shouldComponentUpdate 一定要配合<strong>不可变值</strong>的前提来使用。（如果违反了不可变值的规则，shouldComponentUpdate中对比this.state与nextState中的值时，this.state === nextState，因此无法更新页面）</li><li>可不考虑使用shouldComponentUpdate， 性能优化时再考虑</li></ul><h3 id="2、-PureComponent-和-memo"><a href="#2、-PureComponent-和-memo" class="headerlink" title="2、 PureComponent 和 memo"></a>2、 PureComponent 和 memo</h3><ul><li>PureComponent(纯组件) shouldComponentUpdate 中实现了浅比较</li><li>memo 函数组件中的 PureComponent</li><li>浅比较已经适用大部分场景（尽量不要做深度比较）</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// 普通组件 extends React.Component</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Input</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123; &#125;<span class="hljs-comment">// 纯组件 extends React.PureComponent</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">PureComponent</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">shouldComponentUpdate</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-comment">// React.PureComponent 默认做了一个浅比较的操作</span>&#125;&#125;<span class="hljs-comment">// 函数组件的使用方式： 先定义函数组件，再用React.memo()包装一下</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>(<span class="hljs-params">props</span>) </span>&#123;<span class="hljs-comment">/* 使用 props 渲染 */</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">areEquals</span>(<span class="hljs-params">prevProps, nextProps</span>) </span>&#123;<span class="hljs-comment">// 类似于 shouldComponentUpdate 的函数</span><span class="hljs-comment">/* 如果把 nextProps 传入 render 方法的返回结果与 将 prevProps 传入 render 方法的返回结果一致 则返回true， 否则返回false */</span>&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> React.memo(MyComponent, areEquals);</code></pre><h3 id="3、-immutable-js"><a href="#3、-immutable-js" class="headerlink" title="3、 immutable.js"></a>3、 immutable.js</h3><ul><li>彻底拥抱“<strong>不可变值</strong>”</li><li>基于共享数据（不是深拷贝），速度好</li><li>缺点是 有一定的学习和迁移成本，按需使用</li></ul><h2 id="六、高阶组件-HOC-和-Render-Props"><a href="#六、高阶组件-HOC-和-Render-Props" class="headerlink" title="六、高阶组件 HOC 和 Render Props"></a>六、高阶组件 HOC 和 Render Props</h2><h3 id="1、-HOC"><a href="#1、-HOC" class="headerlink" title="1、 HOC"></a>1、 HOC</h3><ul><li>mixin 已被React弃用</li><li>使用了高阶组件 HOC</li><li>Render Props</li><li>高阶组件不是一种功能，而是一种模式</li><li>redux connect 是高阶组件</li></ul><img src="https://i.loli.net/2020/12/29/I2LX4ea3t5RMlUB.png"  width="100%" height="100%"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-comment">// 高阶组件</span><span class="hljs-keyword">const</span> withMouse = <span class="hljs-function">(<span class="hljs-params">Component</span>) =&gt;</span> &#123;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">withMouseComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;        <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;            <span class="hljs-built_in">super</span>(props)            <span class="hljs-built_in">this</span>.state = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> &#125;        &#125;          handleMouseMove = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;            <span class="hljs-built_in">this</span>.setState(&#123;                x: event.clientX,                y: event.clientY            &#125;)        &#125;          <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;            <span class="hljs-keyword">return</span> (                &lt;div style=&#123;&#123; <span class="hljs-attr">height</span>: <span class="hljs-string">&#x27;500px&#x27;</span> &#125;&#125; onMouseMove=&#123;<span class="hljs-built_in">this</span>.handleMouseMove&#125;&gt;                    &#123;<span class="hljs-comment">/* 1.透传所有 props; 2.增加 mouse 属性 */</span>&#125;                    &lt;Component &#123;...this.props&#125; mouse=&#123;<span class="hljs-built_in">this</span>.state&#125;/&gt;                &lt;/div&gt;            )        &#125;    &#125;    <span class="hljs-keyword">return</span> withMouseComponent&#125;<span class="hljs-keyword">const</span> App = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> a = props.a    <span class="hljs-keyword">const</span> &#123; x, y &#125; = props.mouse <span class="hljs-comment">// 接收 mouse 属性</span>    <span class="hljs-keyword">return</span> (        &lt;div style=&#123;&#123; <span class="hljs-attr">height</span>: <span class="hljs-string">&#x27;500px&#x27;</span> &#125;&#125;&gt;            &lt;h1&gt;The mouse position is (&#123;x&#125;, &#123;y&#125;)&lt;/h1&gt;            &lt;p&gt;&#123;a&#125;&lt;/p&gt;        &lt;/div&gt;    )&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> withMouse(App) <span class="hljs-comment">// 返回高阶函数</span></code></pre><h3 id="2、Render-Props"><a href="#2、Render-Props" class="headerlink" title="2、Render Props"></a>2、Render Props</h3><img src="https://i.loli.net/2020/12/30/iLBsy15Y6ZTP9Gu.png" ><p><strong>HOC与 Render Props的对比</strong></p><ul><li>HOC： 模式简单，但是会增加组件层级</li><li>Render Props： 代码简洁，学习成本较高</li></ul><h2 id="七、-Redux"><a href="#七、-Redux" class="headerlink" title="七、 Redux"></a>七、 Redux</h2><h3 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h3><ul><li>store state</li><li>action</li><li>单向数据流</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// https://www.redux.org.cn/</span><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 这是一个 reducer，形式为 (state, action) =&gt; state 的纯函数。</span><span class="hljs-comment"> * 描述了 action 如何把 state 转变成下一个 state。</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * state 的形式取决于你，可以是基本类型、数组、对象、</span><span class="hljs-comment"> * 甚至是 Immutable.js 生成的数据结构。惟一的要点是</span><span class="hljs-comment"> * 当 state 变化时需要返回全新的对象，而不是修改传入的参数。</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 下面例子使用 `switch` 语句和字符串来做判断，但你可以写帮助类(helper)</span><span class="hljs-comment"> * 根据不同的约定（如方法映射）来判断，只要适用你的项目即可。</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">counter</span>(<span class="hljs-params">state = <span class="hljs-number">0</span>, action</span>) </span>&#123;  <span class="hljs-keyword">switch</span> (action.type) &#123;  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;INCREMENT&#x27;</span>:    <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span>;  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;DECREMENT&#x27;</span>:    <span class="hljs-keyword">return</span> state - <span class="hljs-number">1</span>;  <span class="hljs-keyword">default</span>:    <span class="hljs-keyword">return</span> state;  &#125;&#125;<span class="hljs-comment">// 创建 Redux store 来存放应用的状态。</span><span class="hljs-comment">// =&gt; =&gt; =&gt; =&gt; 【 API 是 &#123; subscribe, dispatch, getState &#125; 】！！！</span><span class="hljs-keyword">let</span> store = createStore(counter);<span class="hljs-comment">// 可以手动订阅更新，也可以事件绑定到视图层。</span>store.subscribe(<span class="hljs-function">() =&gt;</span>  <span class="hljs-built_in">console</span>.log(store.getState()));<span class="hljs-comment">// 改变内部 state 惟一方法是 dispatch(派遣) 一个 action。</span><span class="hljs-comment">// action 可以被序列化，用日记记录和储存下来，后期还可以以回放的方式执行</span>store.dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span> &#125;);<span class="hljs-comment">// 1</span>store.dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span> &#125;);<span class="hljs-comment">// 2</span>store.dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;DECREMENT&#x27;</span> &#125;);<span class="hljs-comment">// 1</span></code></pre><p>单向数据流的概述：</p><ol><li>dispatch(action): 通过 dispatch 一个 action 改变 state 的值</li><li>reducer -&gt; newState: 通过 reducer 生成一个新的 state</li><li>subscribe 触发通知: 通过 subscribe 触发通知，进行视图的更新</li></ol><h3 id="2、异步action"><a href="#2、异步action" class="headerlink" title="2、异步action"></a>2、异步action</h3><p>第一步: 引用中间件 redux-thunk （或者redux-promise、redux-saga）</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span>;<span class="hljs-keyword">import</span> rootReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducers/index&#x27;</span>;<span class="hljs-comment">// 创建 store 时 , 作为中间件引入 redux-thunk</span><span class="hljs-keyword">const</span> store = createStore(rootReducer, applyMiddleware(thunk));</code></pre><p>第二步: 在同步返回的 action 对象 替换为 异步返回函数, 其中有 dispatch 参数</p><img src="https://i.loli.net/2020/12/30/aAXwmZgs2I6jfFu.png" ><h3 id="3、redux-数据流"><a href="#3、redux-数据流" class="headerlink" title="3、redux 数据流"></a>3、redux 数据流</h3><img src="https://i.loli.net/2020/12/30/1XfzRaJ8dYcnT6x.png" ><p>中间件的调用顺序：<br><img src="https://i.loli.net/2020/12/30/luqEbTaCHQL3Iwf.png" ></p>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
