

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="海霸">
  <meta name="keywords" content="">
  <title>算法汇总 - 628</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>628 blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="算法汇总">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-03-07 14:40" pubdate>
        March 7, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      32.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      480
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">算法汇总</h1>
            
            <div class="markdown-body">
              <h2 id="一-排序和二分搜索"><a href="#一-排序和二分搜索" class="headerlink" title="一 排序和二分搜索"></a>一 排序和二分搜索</h2><p>1冒泡排序 - 2选择排序 - 3插入排序(3-2 希尔排序) - 4归并排序 - 5快速排序 - 6二分搜索<br>7x的平方根 - 8猜数字大小</p>
<table>
<thead>
<tr>
<th>排序类型</th>
<th>平均情况</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>辅助空间</th>
<th>稳定性</th>
<th>思路</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
<td>比较所有相邻元素，如果第一个比第二个大，则交换它们</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>不稳定</td>
<td>找到最小值，与第一位互换</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
<td>对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(n logn)</td>
<td>O(n logn)</td>
<td>O(n logn)</td>
<td>O(n)</td>
<td>稳定</td>
<td>从中间一分为二，排序后再合并</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(n logn)</td>
<td>O(n logn)</td>
<td>O(n²)</td>
<td>O(n logn)</td>
<td>不稳定</td>
<td>选择一个基准，比基准大的放在左边数组，小的放在右边数组，依次递归，再合并</td>
</tr>
</tbody></table>
<p>Array.prototype.srot:<br>Chrome 长度 <code>&lt;= 10</code> 的数组使用的是<strong>插入排序</strong>(稳定排序算法) ，<code>&gt;10</code> 的数组使用的是<strong>快速排序</strong>。快速排序是不稳定的排序算法<br> Firefox 用的 <strong>归并排序</strong></p>
<p> 冒泡排序：稳定，</p>
<h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1 冒泡排序"></a>1 冒泡排序</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 1 冒泡排序-稳定-平均 O(n^2) [时间: O(n)&lt;O(n^2) 空间: O(1)]</span>
<span class="hljs-comment">// (1) 比较所有相邻元素，如果第一个比第二个大，则交换它们</span>
<span class="hljs-comment">// (2) 一轮下来，可以保证最后一个数是最大的</span>
<span class="hljs-comment">// (3) 执行 n-1 轮，就可以完成排序</span>
<span class="hljs-built_in">Array</span>.prototype.bubbleSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">this</span>.length; j++) &#123;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-built_in">this</span>.length - <span class="hljs-number">1</span> - j; i++) &#123;
			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>[i] &gt; <span class="hljs-built_in">this</span>[i + <span class="hljs-number">1</span>]) &#123;
				<span class="hljs-keyword">const</span> tem = <span class="hljs-built_in">this</span>[i];
				<span class="hljs-built_in">this</span>[i] = <span class="hljs-built_in">this</span>[i + <span class="hljs-number">1</span>];
				<span class="hljs-built_in">this</span>[i + <span class="hljs-number">1</span>] = tem;
			&#125;
		&#125;
	&#125;
&#125;</code></pre>

<pre><code class="hljs javascript"><span class="hljs-comment">// 2 选择排序-不稳定-时间: O(n^2) 空间: O(1)</span>
<span class="hljs-comment">// 选出最小值后需要交换位置,位置一变就会变得不稳定</span>
<span class="hljs-comment">// (1) 找到数组中的最小值，选中它并将其放置到第一位，</span>
<span class="hljs-comment">// (2) 接着找到第二小的值，选中它并将其放置到第二位</span>
<span class="hljs-comment">// (3) 以此类推，执行 n-1 轮</span>
<span class="hljs-built_in">Array</span>.prototype.selectSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length - <span class="hljs-number">1</span>; i++ ) &#123;
		<span class="hljs-keyword">let</span> indexMin = i;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i; j &lt; <span class="hljs-built_in">this</span>.length; j++) &#123;
			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>[j] &lt; <span class="hljs-built_in">this</span>[indexMin]) &#123;
				indexMin = j;
			&#125;
		&#125;
		<span class="hljs-keyword">if</span> (indexMin !== i) &#123;
			<span class="hljs-keyword">const</span> tem = <span class="hljs-built_in">this</span>[i];
			<span class="hljs-built_in">this</span>[i] = <span class="hljs-built_in">this</span>[indexMin];
			<span class="hljs-built_in">this</span>[indexMin] = tem;
		&#125;
	&#125;
&#125;</code></pre>

<pre><code class="hljs javascript"><span class="hljs-comment">// 3 插入排序 稳定 平均 O(n^2)[时间: O(n)&lt;O(n^2) 空间: O(1)]</span>
<span class="hljs-comment">// 原理是通过构建有序序列，对于未排序数据，在已排序序列中 从后向前 扫描，找到相应位置并插入。</span>
<span class="hljs-comment">// (1) 从第二个数开始往前比</span>
<span class="hljs-comment">// (2) 如果前面的数字比它大 就往后排</span>
<span class="hljs-comment">// (3) 以此类推 进行到最后一个数字</span>
<span class="hljs-built_in">Array</span>.prototype.insertSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;
		<span class="hljs-keyword">const</span> tem = <span class="hljs-built_in">this</span>[i];
		<span class="hljs-keyword">let</span> j = i;
		<span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span>) &#123;
			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>[j - <span class="hljs-number">1</span>] &gt; tem) &#123;
				<span class="hljs-built_in">this</span>[j] = <span class="hljs-built_in">this</span>[j - <span class="hljs-number">1</span>];
				j--;
			&#125; <span class="hljs-keyword">else</span> &#123;
				<span class="hljs-keyword">break</span>;
			&#125;
		&#125;
		<span class="hljs-built_in">this</span>[j] = tem;
	&#125;
&#125;

<span class="hljs-comment">// 3-2 希尔排序 / 缩小增量排序</span>
<span class="hljs-comment">// 是 插入排序 的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</span>
<span class="hljs-comment">// (1)选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</span>
<span class="hljs-comment">// (2)按增量序列个数k，对序列进行k 趟排序；</span>
<span class="hljs-comment">// (3)每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。</span>
<span class="hljs-comment">//		仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shellSort</span>(<span class="hljs-params">arr</span>) </span>&#123;
    <span class="hljs-keyword">var</span> len = arr.length;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k = <span class="hljs-built_in">Math</span>.floor(len / <span class="hljs-number">2</span>); k &gt; <span class="hljs-number">0</span>; k = <span class="hljs-built_in">Math</span>.floor(k / <span class="hljs-number">2</span>)) &#123;
        <span class="hljs-comment">// 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = k; i &lt; len; i++) &#123;
            varj = i;
            <span class="hljs-keyword">var</span> current = arr[i];
            <span class="hljs-keyword">while</span>(j - k &gt;= <span class="hljs-number">0</span> &amp;&amp; current &lt; arr[j - k]) &#123;
                 arr[j] = arr[j - k];
                 j = j - k;
            &#125;
            arr[j] = current;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> arr;
&#125;</code></pre>

<pre><code class="hljs javascript"><span class="hljs-comment">// 4 归并排序 稳定 时间:O(n logn) 空间:O(n)</span>
<span class="hljs-comment">// 分而治之</span>
<span class="hljs-comment">//（1）把长度为n的输入序列分成两个长度为n/2的子序列</span>
<span class="hljs-comment">// (2) 对这两个子序列分别采用归并排序</span>
<span class="hljs-comment">// (3) 将两个排序好的子序列合并成一个最终的排序序列</span>
<span class="hljs-built_in">Array</span>.prototype.mergeSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
	<span class="hljs-keyword">const</span> rec = <span class="hljs-function"><span class="hljs-params">arr</span> =&gt;</span> &#123;
		<span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">1</span>) &#123;
			<span class="hljs-keyword">return</span> arr;
		&#125;
		<span class="hljs-comment">// 除二取整: arr.length &gt;&gt;&gt; 1</span>
		<span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>);
		<span class="hljs-keyword">const</span> left = arr.slice(<span class="hljs-number">0</span>, mid);
		<span class="hljs-keyword">const</span> right = arr.slice(mid, arr.length);
		
		<span class="hljs-keyword">const</span> orderLeft = rec(left);
		<span class="hljs-keyword">const</span> orderRight = rec(right);

		<span class="hljs-keyword">const</span> res = [];
		<span class="hljs-keyword">while</span>(orderLeft.length || orderRight.length) &#123;
			<span class="hljs-keyword">if</span> (orderLeft.length &amp;&amp; orderRight.length) &#123;
				res.push(orderLeft[<span class="hljs-number">0</span>] &lt; orderRight[<span class="hljs-number">0</span>] ?
					orderLeft.shift() : orderRight.shift());
			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (orderLeft.length) &#123;
				res.push(orderLeft.shift());
			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (orderRight.length) &#123;
				res.push(orderRight.shift());
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> res;
	&#125;
	<span class="hljs-keyword">const</span> res = rec(<span class="hljs-built_in">this</span>);
	res.forEach(<span class="hljs-function">(<span class="hljs-params">n, i</span>) =&gt;</span> <span class="hljs-built_in">this</span>[i] = n);
&#125;</code></pre>

<pre><code class="hljs javascript"><span class="hljs-comment">// 5 快速排序 不稳定 平均: O(n logn)</span>
<span class="hljs-comment">// 时间:O(n logn) &lt; O(n²) 空间:O(n logn)</span>
<span class="hljs-comment">// 排序过程中位置会发生变化,位置一变就会变得不稳定</span>
<span class="hljs-comment">// 分而治之：将选择一个基准，比基准大的放在左边数组，小的放在右边数组，依次递归，再合并</span>
<span class="hljs-built_in">Array</span>.prototype.quickSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
	<span class="hljs-keyword">const</span> rec = <span class="hljs-function"><span class="hljs-params">arr</span> =&gt;</span> &#123;
		<span class="hljs-keyword">if</span>(arr.length &lt; <span class="hljs-number">2</span>) &#123;
			<span class="hljs-keyword">return</span> arr;
		&#125;
		<span class="hljs-keyword">const</span> left = [];
		<span class="hljs-keyword">const</span> right = [];
		<span class="hljs-keyword">const</span> mid = arr[<span class="hljs-number">0</span>];
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;
			<span class="hljs-keyword">if</span> (arr[i] &lt; mid) &#123;
				left.push(arr[i]);
			&#125; <span class="hljs-keyword">else</span> &#123;
				right.push(arr[i])
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> [...rec(left), mid, ...rec(right)];
	&#125;;

	<span class="hljs-keyword">const</span> res = rec(<span class="hljs-built_in">this</span>);
	res.forEach(<span class="hljs-function">(<span class="hljs-params">n, i</span>) =&gt;</span> <span class="hljs-built_in">this</span>[i] = n);
&#125;</code></pre>

<h3 id="6-二分搜索"><a href="#6-二分搜索" class="headerlink" title="6 二分搜索"></a>6 二分搜索</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 6 二分搜索 O(logN)</span>
<span class="hljs-built_in">Array</span>.prototype.binarySearch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;
	<span class="hljs-keyword">let</span> low = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> high = <span class="hljs-built_in">this</span>.length - <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span>(low &lt;= high) &#123;
		<span class="hljs-comment">// 除二取整: (high + low) &gt;&gt;&gt; 1</span>
		<span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor((high + low) / <span class="hljs-number">2</span>);
		<span class="hljs-keyword">const</span> element = <span class="hljs-built_in">this</span>[mid];
		<span class="hljs-keyword">if</span> (element &lt; item) &#123;
			low = mid + <span class="hljs-number">1</span>;
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element &gt; item) &#123;
			high = mid - <span class="hljs-number">1</span>;
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-keyword">return</span> mid;
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
&#125;</code></pre>

<pre><code class="hljs javascript"><span class="hljs-comment">// 7 x 的平方根</span>
<span class="hljs-keyword">var</span> mySqrt = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>&#123;
	<span class="hljs-comment">// 时间复杂度: O(log N)</span>
    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) &#123;
        <span class="hljs-keyword">return</span> x;
    &#125;
    <span class="hljs-keyword">let</span> low = <span class="hljs-number">1</span>;
	 <span class="hljs-comment">// 除二取整</span>
    <span class="hljs-keyword">let</span> higt = x &gt;&gt;&gt; <span class="hljs-number">1</span>; 
    <span class="hljs-keyword">while</span>(low + <span class="hljs-number">1</span> &lt; higt) &#123;
        <span class="hljs-comment">// Math.floor((low + higt) / 2);</span>
        <span class="hljs-keyword">const</span> mid = (low + higt) &gt;&gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">const</span> s = x / mid;
        <span class="hljs-keyword">if</span> (s === mid) &#123;
            <span class="hljs-keyword">return</span> mid;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &gt; mid) &#123;
            low = mid;
        &#125; <span class="hljs-keyword">else</span> &#123;
            higt = mid;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> x / higt &gt;= higt ? higt : low;
&#125;;</code></pre>

<pre><code class="hljs javascript"><span class="hljs-comment">// 8 猜数字大小 二分搜索 时间 O(logN) 空间 O(1)</span>
<span class="hljs-keyword">var</span> guessNumber = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;
    <span class="hljs-keyword">let</span> low = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> high = n;
    <span class="hljs-keyword">while</span>(high &gt;= low) &#123;
		 <span class="hljs-comment">// 除以二并取整</span>
		 <span class="hljs-comment">// Math.floor((low + high) / 2);</span>
        <span class="hljs-keyword">const</span> mid = (low + high) &gt;&gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">const</span> res = guess(mid);
        <span class="hljs-keyword">if</span> (res === -<span class="hljs-number">1</span>) &#123;
            <span class="hljs-comment">// 比mid 小,搜索 0 - mid 范围</span>
            high = mid - <span class="hljs-number">1</span>;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res === <span class="hljs-number">1</span>) &#123;
            <span class="hljs-comment">// 比mid 大,搜索 mid - n 范围</span>
            low = mid + <span class="hljs-number">1</span>;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res === <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">return</span> mid;
        &#125;
    &#125;
&#125;;

<span class="hljs-comment">// 解法二</span>
<span class="hljs-comment">// 猜数字大小,分而治之 ,时间O(logN),空间O(logN)</span>
<span class="hljs-keyword">var</span> guessNumber = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;
	<span class="hljs-keyword">const</span> rec = <span class="hljs-function">(<span class="hljs-params">low, high</span>) =&gt;</span> &#123;
		<span class="hljs-keyword">if</span> (low &gt; high) &#123;
			<span class="hljs-keyword">return</span>;
		&#125;
		<span class="hljs-comment">// 除二取整</span>
		<span class="hljs-keyword">const</span> mid = (low + high) &gt;&gt;&gt; <span class="hljs-number">1</span>;
		<span class="hljs-keyword">const</span> res = guess(mid);
		<span class="hljs-keyword">if</span> (res === <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 猜对了</span>
			<span class="hljs-keyword">return</span> mid;
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res === <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//比mid大</span>
			<span class="hljs-keyword">return</span> rec(mid + <span class="hljs-number">1</span>, high);
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res === -<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//比mid小</span>
			<span class="hljs-keyword">return</span> rec(low, mid - <span class="hljs-number">1</span>);
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> rec(<span class="hljs-number">1</span>, n);
&#125;;</code></pre>

<h2 id="二-树"><a href="#二-树" class="headerlink" title="二 树"></a>二 树</h2><p>1 树深度优先/广度优先<br>2 二叉树深度优先/广度优先 - 二叉树<br>3 先序/4中序/5后序<br>6 二叉树的最大深度<br>7 二叉树的最小深度<br>8 二叉树的层序遍历<br>9 二叉树的锯齿形层序遍历<br>10 相同的树<br>11 翻转二叉树<br>12 二叉树的层序遍历II （自底向上）<br>13 二叉树中第二小的节点<br>14 把二叉搜索树转换为累加树 (从二叉搜索树到更大和树)<br>15 二叉搜索树中的搜索 （从 二叉搜索树找到 给定值 的子树）<br>16 N叉树的最大深度<br>17 N叉树的前序遍历<br>18 N叉树的后序遍历<br>19 递增顺序查找树 （按中序遍历 重新排列树，使树中最左边的结点现在是树的根）<br>20 二叉树所有路径<br>21 另一个树的子树 ( 树s 中是否包含和 树t)<br>22 从前序与中序遍历序列构造二叉树<br>23 从中序与后序遍历序列构造二叉树<br>24 平衡二叉树 —— 判断是不是平衡二叉树<br>25 有序链表转换平衡二叉树<br>26 路径总和 Ⅰ II</p>
<h3 id="1-树-深度优先"><a href="#1-树-深度优先" class="headerlink" title="1 树 - 深度优先"></a>1 树 - 深度优先</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 1 树 - 深度优先</span>
<span class="hljs-keyword">const</span> dfs = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;
	<span class="hljs-comment">// 访问节点数据</span>
	<span class="hljs-built_in">console</span>.log(root.val);
	<span class="hljs-comment">// 递归 访问子节点</span>
	root.children.forEach(dfs);
&#125;
dfs(tree);

<span class="hljs-comment">// 树 - 广度优先</span>
<span class="hljs-keyword">const</span> bfs = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;
	<span class="hljs-comment">// 先把各节点入队</span>
	<span class="hljs-keyword">const</span> q = [root];
	<span class="hljs-keyword">while</span>(q.length &gt; <span class="hljs-number">0</span>) &#123;
		<span class="hljs-comment">// 出队</span>
		<span class="hljs-keyword">const</span> n = q.shift();
		<span class="hljs-comment">// 访问节点数据</span>
		<span class="hljs-built_in">console</span>.log(n.val);
		<span class="hljs-keyword">if</span> (n.children) &#123;
			n.children.forEach(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;
				q.push(child);
			&#125;)
		&#125;
	&#125;
&#125;
bfs(tree);</code></pre>

<pre><code class="hljs javascript"><span class="hljs-comment">// 2 二叉树 - 深度/广度优先遍历</span>
<span class="hljs-comment">// 深度1 - 打印结果</span>
<span class="hljs-keyword">const</span> dfs = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;
	<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;
	<span class="hljs-comment">// 访问节点数据</span>
	<span class="hljs-built_in">console</span>.log(root.val);
	dfs(root.left);
	dfs(root.right)
&#125;
<span class="hljs-comment">// 深度2 - 递归版 - 收集并返回结果</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs2</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (!root) &#123;
		<span class="hljs-keyword">return</span> [];
	&#125;
	<span class="hljs-keyword">const</span> res = []
	<span class="hljs-keyword">const</span> rec = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tree</span>) </span>&#123;
		<span class="hljs-comment">// console.log(tree.val);</span>
		res.push(tree.val);
		<span class="hljs-keyword">if</span> (tree.left) rec(tree.left);
		<span class="hljs-keyword">if</span> (tree.right) rec(tree.right);
	&#125;
	rec(root);
	<span class="hljs-keyword">return</span> res;
&#125;
<span class="hljs-comment">// 深度3 - 非递归版 - 收集并返回结果</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs3</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (!root) &#123;
		<span class="hljs-keyword">return</span> [];
	&#125;
	<span class="hljs-keyword">const</span> res = []
	<span class="hljs-keyword">const</span> stack = [root];
	<span class="hljs-keyword">while</span>(stack.length) &#123;
		<span class="hljs-keyword">const</span> item = stack.pop();
		<span class="hljs-comment">// console.log(item.val);</span>
		res.push(item.val);
		<span class="hljs-keyword">if</span> (item.right) &#123;
			stack.push(item.right);
		&#125;
		<span class="hljs-keyword">if</span> (item.left) &#123;
			stack.push(item.left);
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;
<span class="hljs-comment">// 广度 - 收集并返回结果</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fbs</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];
	<span class="hljs-keyword">const</span> res = [];
	<span class="hljs-keyword">const</span> stack = [root];
	<span class="hljs-keyword">while</span>(stack.length) &#123;
		<span class="hljs-keyword">const</span> item = stack.shift();
		<span class="hljs-comment">// console.log(item.val);</span>
		res.push(item.val);
		<span class="hljs-keyword">if</span> (item.left) &#123;
			stack.push(item.left);
		&#125;
		<span class="hljs-keyword">if</span> (item.right) &#123;
			stack.push(item.right);
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;</code></pre>

<pre><code class="hljs javascript"><span class="hljs-comment">// 3先序遍历: 根 -&gt; 左 -&gt; 右</span>
<span class="hljs-comment">// 递归版1 - 打印结果</span>
<span class="hljs-keyword">const</span> preorder = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;
	<span class="hljs-keyword">if</span> (!root) &#123;
		<span class="hljs-keyword">return</span>;
	&#125;
	<span class="hljs-built_in">console</span>.log(root.val);
	preorder(root.left);
	preorder(root.right);
&#125;
<span class="hljs-comment">// 递归版2 - 收集并返回结果</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preorder2</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (!root) &#123;
		<span class="hljs-keyword">return</span> [];
	&#125;
	<span class="hljs-keyword">const</span> res = []
	<span class="hljs-keyword">const</span> stack = [root];
	<span class="hljs-keyword">while</span>(stack.length) &#123;
		<span class="hljs-keyword">const</span> item = stack.pop();
		<span class="hljs-comment">// console.log(item.val);</span>
		res.push(item.val);
		<span class="hljs-keyword">if</span> (item.right) &#123;
			stack.push(item.right);
		&#125;
		<span class="hljs-keyword">if</span> (item.left) &#123;
			stack.push(item.left);
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;

<span class="hljs-comment">// 3先序遍历: 根 -&gt; 左 -&gt; 右</span>
<span class="hljs-comment">// 非递归版</span>
<span class="hljs-keyword">const</span> preorder2 = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;
	<span class="hljs-keyword">if</span> (!root) &#123;
		<span class="hljs-keyword">return</span> [];
	&#125;
	<span class="hljs-keyword">const</span> res = []
	<span class="hljs-keyword">const</span> stack = [root];
	<span class="hljs-keyword">while</span>(stack.length) &#123;
		<span class="hljs-keyword">const</span> item = stack.pop();
		<span class="hljs-comment">// console.log(item.val);</span>
		res.push(item.val);
		<span class="hljs-keyword">if</span> (item.right) &#123;
			stack.push(item.right);
		&#125;
		<span class="hljs-keyword">if</span> (item.left) &#123;
			stack.push(item.left);
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;</code></pre>

<pre><code class="hljs javascript"><span class="hljs-comment">// 4中序遍历: 左 -&gt; 根 -&gt; 右</span>
<span class="hljs-comment">// 中序 - 递归版1 -  打印结果</span>
<span class="hljs-keyword">const</span> inorder = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;
	<span class="hljs-keyword">if</span> (!root) &#123;
		<span class="hljs-keyword">return</span>;
	&#125;
	<span class="hljs-keyword">if</span> (root.left) inorder(root.left);
	<span class="hljs-built_in">console</span>.log(root.val);
	<span class="hljs-keyword">if</span> (root.right) inorder(root.right);
&#125;
<span class="hljs-comment">// 中序 - 递归版2 - 收集并返回结果</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inorder2</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> [];
	<span class="hljs-keyword">const</span> res = [];
	<span class="hljs-keyword">const</span> rec = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tr</span>) </span>&#123;
		<span class="hljs-keyword">if</span> (tr.left) rec(tr.left);
		<span class="hljs-comment">// console.log(tr.val);</span>
		res.push(tr.val);
		<span class="hljs-keyword">if</span> (tr.right) rec(tr.right);
	&#125;
	rec(root);
	<span class="hljs-keyword">return</span> res;
&#125;
<span class="hljs-comment">// 4中序遍历: 左 -&gt; 根 -&gt; 右</span>
<span class="hljs-comment">// 中序 -&gt; 非递归版</span>
<span class="hljs-keyword">const</span> inorder3 = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;
	<span class="hljs-keyword">if</span> (!root) &#123;
		<span class="hljs-keyword">return</span> [];
	&#125;
	<span class="hljs-keyword">const</span> stack = [];
	<span class="hljs-keyword">const</span> res = [];
	<span class="hljs-keyword">let</span> p = root;
	<span class="hljs-keyword">while</span> (stack.length || p) &#123;
		<span class="hljs-keyword">while</span>(p) &#123;
			stack.push(p);
			p = p.left;
		&#125;
		<span class="hljs-keyword">const</span> item = stack.pop();
		<span class="hljs-comment">// console.log(item.val);</span>
		res.push(item.val);
		p = item.right;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;</code></pre>

<pre><code class="hljs javascript"><span class="hljs-comment">// 5后序遍历: 左 -&gt; 右 &gt; 根</span>
<span class="hljs-comment">// 后序遍历 -&gt; 递归版1 -  打印结果</span>
<span class="hljs-keyword">const</span> postorder = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;
	<span class="hljs-keyword">if</span> (!root) &#123;
		<span class="hljs-keyword">return</span>;
	&#125;
	postorder(root.left);
	postorder(root.right);
	<span class="hljs-comment">// 访问当前节点</span>
	<span class="hljs-built_in">console</span>.log(root.val);
&#125;
<span class="hljs-comment">// 后序遍历 -&gt; 递归版2 - 收集并返回结果</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postorder2</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> [];
	<span class="hljs-keyword">const</span> res = [];
	<span class="hljs-keyword">const</span> rec = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tr</span>) </span>&#123;
		<span class="hljs-keyword">if</span> (tr.left) rec(tr.left);
		<span class="hljs-keyword">if</span> (tr.right) rec(tr.right);
		<span class="hljs-comment">// console.log(tr.val);</span>
		res.push(tr.val);
	&#125;
	rec(root);
	<span class="hljs-keyword">return</span> res;
&#125;
<span class="hljs-comment">// 后序遍历 -&gt; 非递归版 - 收集并返回结果</span>
<span class="hljs-keyword">const</span> postorder3 = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;
	<span class="hljs-keyword">if</span> (!root) &#123;
		<span class="hljs-keyword">return</span> [];
	&#125;
	<span class="hljs-keyword">const</span> res = [];
	<span class="hljs-keyword">const</span> outputStack = [];
	<span class="hljs-keyword">const</span> stack = [root];
	<span class="hljs-keyword">while</span> (stack.length) &#123;
		<span class="hljs-keyword">const</span> item = stack.pop();
		outputStack.push(item);
		<span class="hljs-keyword">if</span> (item.left) stack.push(item.left);
		<span class="hljs-keyword">if</span> (item.right) stack.push(item.right);
	&#125; 
	<span class="hljs-keyword">while</span>(outputStack.length) &#123;
		<span class="hljs-keyword">const</span> item = outputStack.pop();
		<span class="hljs-comment">// 访问当前节点</span>
		<span class="hljs-comment">// console.log(item.val);</span>
		res.push(item.val);
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;</code></pre>

<h3 id="6-二叉树的最大深度"><a href="#6-二叉树的最大深度" class="headerlink" title="6 二叉树的最大深度"></a>6 二叉树的最大深度</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 6 题: 二叉树的最大深度 104</span>
<span class="hljs-comment">// 给定一个二叉树，找出其最大深度。</span>
<span class="hljs-comment">// 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</span>
<span class="hljs-comment">// 说明: 叶子节点是指没有子节点的节点。</span>
<span class="hljs-comment">// 示例：</span>
<span class="hljs-comment">// 给定二叉树 [3,9,20,null,null,15,7]，</span>
<span class="hljs-comment">//     3</span>
<span class="hljs-comment">//    / \</span>
<span class="hljs-comment">//   9  20</span>
<span class="hljs-comment">//     /  \</span>
<span class="hljs-comment">//    15   7</span>
<span class="hljs-comment">// 返回它的最大深度 3 。</span>
<span class="hljs-keyword">var</span> maxDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">const</span> dpt = <span class="hljs-function">(<span class="hljs-params">root, l</span>) =&gt;</span> &#123;
		<span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;
			res = <span class="hljs-built_in">Math</span>.max(res, l)
		&#125;
		<span class="hljs-keyword">if</span> (root.left) dpt(root.left, l + <span class="hljs-number">1</span>);
		<span class="hljs-keyword">if</span> (root.right) dpt(root.right, l + <span class="hljs-number">1</span>);
	&#125;
	dpt(root, <span class="hljs-number">1</span>)
	<span class="hljs-keyword">return</span> res;
&#125;;</code></pre>

<pre><code class="hljs javascript"><span class="hljs-comment">// 7 题: 二叉树的最小深度 111</span>
<span class="hljs-comment">// 给定一个二叉树，找出其最小深度。</span>
<span class="hljs-comment">// 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</span>
<span class="hljs-comment">// 说明：叶子节点是指没有子节点的节点。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">//     3</span>
<span class="hljs-comment">//    / \</span>
<span class="hljs-comment">//   9  20</span>
<span class="hljs-comment">//     /  \</span>
<span class="hljs-comment">//    15   7</span>
<span class="hljs-comment">// 输入：root = [3,9,20,null,null,15,7]</span>
<span class="hljs-comment">// 输出：2</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：root = [2,null,3,null,4,null,5,null,6]</span>
<span class="hljs-comment">// 输出：5</span>
<span class="hljs-comment">// 解法一 深度遍历法</span>
<span class="hljs-keyword">var</span> minDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
   <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> res = <span class="hljs-literal">Infinity</span>;
	<span class="hljs-keyword">const</span> dpt = <span class="hljs-function">(<span class="hljs-params">root, l</span>) =&gt;</span> &#123;
		<span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;
			res = <span class="hljs-built_in">Math</span>.min(res, l);
		&#125;
		<span class="hljs-keyword">if</span> (root.left) dpt(root.left, l + <span class="hljs-number">1</span>); 
		<span class="hljs-keyword">if</span> (root.right) dpt(root.right, l + <span class="hljs-number">1</span>); 
	&#125;

	dpt(root, <span class="hljs-number">1</span>);
	<span class="hljs-keyword">return</span> res;
&#125;;

<span class="hljs-comment">// 解法二 广度优先遍历</span>
<span class="hljs-keyword">var</span> minDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-keyword">const</span> stack = [[root, <span class="hljs-number">1</span>]];
	<span class="hljs-keyword">while</span> (stack.length) &#123;
		<span class="hljs-keyword">const</span> [n, l] = stack.shift();
		<span class="hljs-keyword">if</span> (!n.left &amp;&amp; !n.right) &#123;
			<span class="hljs-keyword">return</span> l;
		&#125;
		<span class="hljs-keyword">if</span> (n.left) stack.push([n.left, l + <span class="hljs-number">1</span>]);
		<span class="hljs-keyword">if</span> (n.right) stack.push([n.right, l + <span class="hljs-number">1</span>]);
	&#125;
&#125;;</code></pre>

<pre><code class="hljs javascript"><span class="hljs-comment">// 8 二叉树的层序遍历 102</span>
<span class="hljs-comment">// 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</span>
<span class="hljs-comment">// 示例：</span>
<span class="hljs-comment">// 二叉树：[3,9,20,null,null,15,7],</span>
<span class="hljs-comment">//     3</span>
<span class="hljs-comment">//    / \</span>
<span class="hljs-comment">//   9  20</span>
<span class="hljs-comment">//     /  \</span>
<span class="hljs-comment">//    15   7</span>
<span class="hljs-comment">// 返回其层序遍历结果：</span>
<span class="hljs-comment">// [</span>
<span class="hljs-comment">//   [3],</span>
<span class="hljs-comment">//   [9,20],</span>
<span class="hljs-comment">//   [15,7]</span>
<span class="hljs-comment">// ]</span>
<span class="hljs-comment">// 广度优先遍历 【推荐 二颗星】</span>
<span class="hljs-keyword">var</span> levelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];
	<span class="hljs-keyword">var</span> stack = [[root, <span class="hljs-number">0</span>]];
	<span class="hljs-keyword">var</span> res = [];
	<span class="hljs-keyword">while</span> (stack.length) &#123;
		<span class="hljs-keyword">var</span> [n, level] = stack.shift();
		<span class="hljs-keyword">if</span> (!res[level]) &#123;
			res.push([n.val]);
		&#125; <span class="hljs-keyword">else</span> &#123;
			res[level].push(n.val);
		&#125;
		<span class="hljs-keyword">if</span> (n.left) stack.push([n.left, level + <span class="hljs-number">1</span>]);
		<span class="hljs-keyword">if</span> (n.right) stack.push([n.right, level + <span class="hljs-number">1</span>]); 
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;;
<span class="hljs-comment">// 广度优先遍历-每次清空当前层级数据【推荐 三星】</span>
<span class="hljs-keyword">var</span> levelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];
	<span class="hljs-keyword">const</span> stack = [root];
	<span class="hljs-keyword">const</span> res = [];
	<span class="hljs-keyword">while</span>(stack.length) &#123;
		res.push([]);
		<span class="hljs-keyword">let</span> len = stack.length;
		<span class="hljs-keyword">while</span>(len--) &#123;
			<span class="hljs-keyword">const</span> n = stack.shift();
			res[res.length - <span class="hljs-number">1</span>].push(n.val);
			<span class="hljs-keyword">if</span> (n.left) stack.push(n.left);
			<span class="hljs-keyword">if</span> (n.right) stack.push(n.right);
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;;

<span class="hljs-comment">// 递归写法</span>
<span class="hljs-keyword">var</span> levelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];
	<span class="hljs-keyword">let</span> res = []
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root, depth</span>) </span>&#123;
		<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;
			<span class="hljs-keyword">if</span> (!res[depth]) &#123;
				res[depth] = []
			&#125;
			traversal(root.left, depth + <span class="hljs-number">1</span>)
			res[depth].push(root.val)
			traversal(root.right, depth + <span class="hljs-number">1</span>)
		&#125;
	&#125;
	traversal(root, <span class="hljs-number">0</span>)
	<span class="hljs-keyword">return</span> res;
&#125;;</code></pre>

<pre><code class="hljs javascript"><span class="hljs-comment">// 9 二叉树的锯齿形层序遍历 103</span>
<span class="hljs-comment">// 给定一个二叉树，返回其节点值的锯齿形层序遍历</span>
<span class="hljs-comment">//（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</span>
<span class="hljs-comment">// 例如：</span>
<span class="hljs-comment">// 给定二叉树 [3,9,20,null,null,15,7],</span>

<span class="hljs-comment">//     3</span>
<span class="hljs-comment">//    / \</span>
<span class="hljs-comment">//   9  20</span>
<span class="hljs-comment">//     /  \</span>
<span class="hljs-comment">//    15   7</span>
<span class="hljs-comment">// 返回锯齿形层序遍历如下：</span>
<span class="hljs-comment">// [</span>
<span class="hljs-comment">//   [3],</span>
<span class="hljs-comment">//   [20,9],</span>
<span class="hljs-comment">//   [15,7]</span>
<span class="hljs-comment">// ]</span>
<span class="hljs-keyword">var</span> zigzagLevelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];
	<span class="hljs-keyword">let</span> res = [];
	<span class="hljs-keyword">let</span> stack = [root];
	<span class="hljs-keyword">while</span>(stack.length) &#123;
        <span class="hljs-keyword">let</span> len = stack.length;
        res.push([]);
        <span class="hljs-keyword">while</span>(len--) &#123;
		    <span class="hljs-keyword">const</span> n = stack.shift();
            res[res.length - <span class="hljs-number">1</span>].push(n.val);
            <span class="hljs-keyword">if</span> (n.left) stack.push(n.left);
            <span class="hljs-keyword">if</span> (n.right) stack.push(n.right);
        &#125;
	&#125;
	res.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> index % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? item : item.reverse());
	<span class="hljs-keyword">return</span> res;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 10 相同的树 100</span>
<span class="hljs-comment">// 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</span>
<span class="hljs-comment">// 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：p = [1,2,3], q = [1,2,3]</span>
<span class="hljs-comment">// 输出：true</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：p = [1,2], q = [1,null,2]</span>
<span class="hljs-comment">// 输出：false</span>
<span class="hljs-keyword">var</span> isSameTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">p, q</span>) </span>&#123;
	<span class="hljs-keyword">if</span>(!p &amp;&amp; !q) &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	&#125;
	<span class="hljs-keyword">if</span>(p &amp;&amp; q &amp;&amp; p.val === q.val &amp;&amp;
		isSameTree(p.left, q.left) &amp;&amp;
		isSameTree(p.right, q.right
	)) &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
&#125;;</code></pre>

<h3 id="11-翻转二叉树"><a href="#11-翻转二叉树" class="headerlink" title="11 翻转二叉树"></a>11 翻转二叉树</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 11 翻转二叉树 226</span>
<span class="hljs-comment">// 翻转一棵二叉树。</span>
<span class="hljs-comment">// 示例：</span>
<span class="hljs-comment">// 输入：</span>
<span class="hljs-comment">//      4</span>
<span class="hljs-comment">//    /   \</span>
<span class="hljs-comment">//   2     7</span>
<span class="hljs-comment">//  / \   / \</span>
<span class="hljs-comment">// 1   3 6   9</span>
<span class="hljs-comment">// 输出：</span>
<span class="hljs-comment">//      4</span>
<span class="hljs-comment">//    /   \</span>
<span class="hljs-comment">//   7     2</span>
<span class="hljs-comment">//  / \   / \</span>
<span class="hljs-comment">// 9   6 3   1</span>
<span class="hljs-keyword">var</span> invertTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-comment">// 时间复杂度: O(N)</span>
	<span class="hljs-comment">// 空间复杂度: O(h)  h是树的高度 </span>
	<span class="hljs-keyword">if</span>(!root) &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	&#125;
	<span class="hljs-keyword">return</span> &#123;
		val: root.val,
		left: invertTree(root.right),
		right: invertTree(root.left),
	&#125;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 12 二叉树的层序遍历 II 107</span>
<span class="hljs-comment">// 自底向上</span>
<span class="hljs-comment">// 给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</span>
<span class="hljs-comment">// 例如：</span>
<span class="hljs-comment">// 给定二叉树 [3,9,20,null,null,15,7],</span>
<span class="hljs-comment">//     3</span>
<span class="hljs-comment">//    / \</span>
<span class="hljs-comment">//   9  20</span>
<span class="hljs-comment">//     /  \</span>
<span class="hljs-comment">//    15   7</span>
<span class="hljs-comment">// 返回其自底向上的层序遍历为：</span>
<span class="hljs-comment">// [</span>
<span class="hljs-comment">//   [15,7],</span>
<span class="hljs-comment">//   [9,20],</span>
<span class="hljs-comment">//   [3]</span>
<span class="hljs-comment">// ]</span>
<span class="hljs-comment">// 解法一 递归写法</span>
<span class="hljs-keyword">var</span> levelOrderBottom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];
	<span class="hljs-keyword">let</span> res = []
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root, depth</span>) </span>&#123;
		<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;
			<span class="hljs-keyword">if</span> (!res[depth]) &#123;
				res[depth] = []
			&#125;
			traversal(root.left, depth + <span class="hljs-number">1</span>)
			res[depth].push(root.val)
			traversal(root.right, depth + <span class="hljs-number">1</span>)
		&#125;
	&#125;
	traversal(root, <span class="hljs-number">0</span>)
	<span class="hljs-keyword">return</span> res.reverse()
&#125;
<span class="hljs-comment">// 解法二 广度优先 非递归</span>
<span class="hljs-keyword">var</span> levelOrderBottom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];
	<span class="hljs-keyword">const</span> stack = [root];
	<span class="hljs-keyword">const</span> res = [];
	<span class="hljs-keyword">while</span>(stack.length) &#123;
		res.push([]);
		<span class="hljs-keyword">let</span> len = stack.length;
		<span class="hljs-keyword">while</span>(len--) &#123;
			<span class="hljs-keyword">const</span> n = stack.shift();
			res[res.length - <span class="hljs-number">1</span>].push(n.val);
			<span class="hljs-keyword">if</span> (n.left) stack.push(n.left);
			<span class="hljs-keyword">if</span> (n.right) stack.push(n.right);
		&#125;
	&#125;
    <span class="hljs-keyword">return</span> res.reverse();
&#125;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 13 二叉树中第二小的节点 671</span>
<span class="hljs-comment">// 给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0</span>
<span class="hljs-comment">// 如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</span>
<span class="hljs-comment">// 更正式地说，root.val = min(root.left.val, root.right.val) 总成立。</span>
<span class="hljs-comment">// 给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">//      2</span>
<span class="hljs-comment">//    /   \</span>
<span class="hljs-comment">//   2     5</span>
<span class="hljs-comment">//        / \</span>
<span class="hljs-comment">//       5   7</span>
<span class="hljs-comment">// 输入：root = [2,2,5,null,null,5,7]</span>
<span class="hljs-comment">// 输出：5</span>
<span class="hljs-comment">// 解释：最小的值是 2 ，第二小的值是 5 。</span>
<span class="hljs-keyword">var</span> findSecondMinimumValue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
  <span class="hljs-keyword">let</span> arr = [];
  (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;
      traversal(root.left)
      arr.push(root.val)
      traversal(root.right)
    &#125;
  &#125;)(root)
  <span class="hljs-keyword">let</span> _arr = [...new <span class="hljs-built_in">Set</span>(arr)].sort()
  <span class="hljs-keyword">return</span> _arr[<span class="hljs-number">1</span>] ? _arr[<span class="hljs-number">1</span>] : -<span class="hljs-number">1</span>
&#125;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 14 把二叉搜索树转换为累加树 1038</span>
<span class="hljs-comment">// 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree）</span>
<span class="hljs-comment">// 使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</span>
<span class="hljs-comment">// 提醒一下，二叉搜索树满足下列约束条件：</span>
<span class="hljs-comment">//  - 节点的左子树仅包含键 小于 节点键的节点。</span>
<span class="hljs-comment">//  - 节点的右子树仅包含键 大于 节点键的节点。</span>
<span class="hljs-comment">//  - 左右子树也必须是二叉搜索树。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</span>
<span class="hljs-comment">// 输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：root = [0,null,1]</span>
<span class="hljs-comment">// 输出：[1,null,1]</span>
<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入：root = [1,0,2]</span>
<span class="hljs-comment">// 输出：[3,3,2]</span>
<span class="hljs-comment">// 示例 4：</span>
<span class="hljs-comment">// 输入：root = [3,2,4,1]</span>
<span class="hljs-comment">// 输出：[7,9,4,10]</span>
<span class="hljs-keyword">var</span> bstToGst = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root</span>) </span>&#123;
		<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;
			traversal(root.right);
			root.val += sum;
			sum = root.val;
			traversal(root.left);
		&#125;
	&#125;
	traversal(root);
	<span class="hljs-keyword">return</span> root;
&#125;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 15 二叉搜索树中的搜索 700</span>
<span class="hljs-comment">// 给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点</span>
<span class="hljs-comment">// 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</span>
<span class="hljs-comment">// 例如，</span>
<span class="hljs-comment">// 给定二叉搜索树:</span>

<span class="hljs-comment">//         4</span>
<span class="hljs-comment">//        / \</span>
<span class="hljs-comment">//       2   7</span>
<span class="hljs-comment">//      / \</span>
<span class="hljs-comment">//     1   3</span>
<span class="hljs-comment">// 和值: 2</span>
<span class="hljs-comment">// 你应该返回如下子树:</span>

<span class="hljs-comment">//       2     </span>
<span class="hljs-comment">//      / \   </span>
<span class="hljs-comment">//     1   3</span>
<span class="hljs-comment">// 在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。</span>
<span class="hljs-keyword">var</span> searchBST = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, val</span>) </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root</span>) </span>&#123;
		<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;
			<span class="hljs-keyword">if</span> (root.val === val) &#123;
				<span class="hljs-keyword">return</span> root;
			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &lt; val) &#123;
				<span class="hljs-keyword">return</span> traversal(root.right);
			&#125; <span class="hljs-keyword">else</span> &#123;
				<span class="hljs-keyword">return</span> traversal(root.left);
			&#125;
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-keyword">return</span> root;
		&#125;
  &#125;
  <span class="hljs-keyword">return</span> traversal(root);
&#125;</code></pre>

<h3 id="16-N叉树的最大深度"><a href="#16-N叉树的最大深度" class="headerlink" title="16 N叉树的最大深度"></a>16 N叉树的最大深度</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 16 N叉树的最大深度 559</span>
<span class="hljs-comment">// 给定一个 N 叉树，找到其最大深度。</span>
<span class="hljs-comment">// 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</span>
<span class="hljs-comment">// N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：root = [1,null,3,2,4,null,5,6]</span>
<span class="hljs-comment">// 输出：3</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]</span>
<span class="hljs-comment">// 输出：5</span>
<span class="hljs-keyword">var</span> maxDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	&#125;
	<span class="hljs-keyword">let</span> depth = <span class="hljs-number">1</span>;
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root, curDepth</span>) </span>&#123;
		<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;
			<span class="hljs-keyword">if</span> (curDepth &gt; depth) &#123;
				depth = curDepth;
			&#125;
			root.children.forEach(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> traversal(child, curDepth + <span class="hljs-number">1</span>));
		&#125;
	&#125;
	traversal(root, <span class="hljs-number">1</span>);
	<span class="hljs-keyword">return</span> depth;
&#125;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 17 N叉树的前序遍历 589</span>
<span class="hljs-comment">// 给定一个 N 叉树，返回其节点值的 前序遍历 。</span>
<span class="hljs-comment">// N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</span>
<span class="hljs-comment">// 进阶：</span>
<span class="hljs-comment">// 递归法很简单，你可以使用迭代法完成此题吗?</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：root = [1,null,3,2,4,null,5,6]</span>
<span class="hljs-comment">// 输出：[1,3,5,6,2,4]</span>
<span class="hljs-comment">// 解法一：递归</span>
<span class="hljs-keyword">var</span> preorder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-keyword">const</span> res = [];
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root</span>) </span>&#123;
		<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;
			res.push(root.val);
			root.children.forEach(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> traversal(child));
		&#125;
	&#125;
	traversal(root);
	<span class="hljs-keyword">return</span> res;
&#125;
<span class="hljs-comment">// 解法二： 迭代</span>
<span class="hljs-keyword">var</span> preorder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];
	<span class="hljs-keyword">let</span> array = [];
	<span class="hljs-keyword">let</span> stack = [root];
	<span class="hljs-keyword">while</span> (stack.length) &#123;
		<span class="hljs-keyword">let</span> len = stack.length;
		<span class="hljs-keyword">let</span> node = stack.shift(); <span class="hljs-comment">// 弹出栈中第一个，先进先出</span>
		array.push(node.val);
		<span class="hljs-keyword">if</span> (node.children.length &gt; <span class="hljs-number">0</span>) &#123;
			<span class="hljs-comment">// 这里有别于层序遍历，用 node.children 连接 queue</span>
			<span class="hljs-comment">// 而不是 queue.concat(node.children)这样就实现了前序遍历的效果</span>
			stack = node.children.concat(stack);
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> array;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 18 N叉树的后序遍历 590</span>
<span class="hljs-comment">// 给定一个 N 叉树，返回其节点值的 后序遍历 。</span>
<span class="hljs-comment">// N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</span>
<span class="hljs-comment">// 进阶：</span>
<span class="hljs-comment">// 递归法很简单，你可以使用迭代法完成此题吗?</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：root = [1,null,3,2,4,null,5,6]</span>
<span class="hljs-comment">// 输出：[5,6,3,2,4,1]</span>
<span class="hljs-comment">// 解法一：递归</span>
<span class="hljs-keyword">var</span> postorder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-keyword">const</span> res = [];
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root</span>) </span>&#123;
		<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;
			root.children.forEach(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;
				<span class="hljs-built_in">arguments</span>.callee(child);
			&#125;)
			res.push(root.val);
		&#125;
	&#125;
	traversal(root);
	<span class="hljs-keyword">return</span> res;
&#125;
<span class="hljs-comment">// 解法二：迭代</span>
<span class="hljs-keyword">var</span> postorder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];
	<span class="hljs-keyword">let</span> res = [];
	<span class="hljs-keyword">let</span> stack = [root];
	<span class="hljs-keyword">while</span> (stack.length) &#123;
		<span class="hljs-keyword">let</span> node = stack.pop(); <span class="hljs-comment">// 弹出最后面的一个元素</span>
		<span class="hljs-keyword">if</span> (node.children.length &gt; <span class="hljs-number">0</span>) &#123;
			stack = stack.concat(node.children);
		&#125;
		res.unshift(node.val); <span class="hljs-comment">// 节点先进后出，数值压栈存储</span>
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 19 递增顺序查找树 897</span>
<span class="hljs-comment">// 给你一个树，请你 按中序遍历 重新排列树，使树中最左边的结点现在是树的根</span>
<span class="hljs-comment">// 并且每个结点没有左子结点，只有一个右子结点。</span>
<span class="hljs-comment">// 示例 ：</span>
<span class="hljs-comment">// 输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]</span>
<span class="hljs-comment">//        5</span>
<span class="hljs-comment">//       / \</span>
<span class="hljs-comment">//     3    6</span>
<span class="hljs-comment">//    / \    \</span>
<span class="hljs-comment">//   2   4    8</span>
<span class="hljs-comment">//  /        / \ </span>
<span class="hljs-comment">// 1        7   9</span>
<span class="hljs-comment">// 输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]</span>
<span class="hljs-comment">//  1</span>
<span class="hljs-comment">//   \</span>
<span class="hljs-comment">//    2</span>
<span class="hljs-comment">//     \</span>
<span class="hljs-comment">//      3</span>
<span class="hljs-comment">//       \</span>
<span class="hljs-comment">//        4</span>
<span class="hljs-comment">//         \</span>
<span class="hljs-comment">//          5</span>
<span class="hljs-comment">//           \</span>
<span class="hljs-comment">//            6</span>
<span class="hljs-comment">//             \</span>
<span class="hljs-comment">//              7</span>
<span class="hljs-comment">//               \</span>
<span class="hljs-comment">//                8</span>
<span class="hljs-comment">//                 \</span>
<span class="hljs-comment">//                  9  </span>
<span class="hljs-keyword">var</span> increasingBST = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-keyword">const</span> arr = [];
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span> (<span class="hljs-params">root</span>) </span>&#123;
		<span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;
			traversal(root.left);
			arr.push(root.val);
			traversal(root.right);
		&#125;
	&#125;
	traversal(root);
	<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> TreeNode(arr[<span class="hljs-number">0</span>]);
	<span class="hljs-keyword">let</span> currentNode = res;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;
		currentNode.left = <span class="hljs-literal">null</span>;
		currentNode.right = <span class="hljs-keyword">new</span> TreeNode(arr[i + <span class="hljs-number">1</span>]);
		currentNode = currentNode.right;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 20 二叉树的所有路径 257</span>
<span class="hljs-comment">// 给定一个二叉树，返回所有从根节点到叶子节点的路径。</span>
<span class="hljs-comment">// 说明: 叶子节点是指没有子节点的节点。</span>
<span class="hljs-comment">// 例如：</span>
<span class="hljs-comment">// 输入:</span>
<span class="hljs-comment">//    1</span>
<span class="hljs-comment">//  /   \</span>
<span class="hljs-comment">// 2     3</span>
<span class="hljs-comment">//  \</span>
<span class="hljs-comment">//   5</span>
<span class="hljs-comment">// 输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span>
<span class="hljs-comment">// 解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3</span>
<span class="hljs-keyword">var</span> binaryTreePaths = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];
	<span class="hljs-keyword">const</span> res = [];
	<span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">root, str = <span class="hljs-string">&#x27;&#x27;</span></span>) =&gt;</span> &#123;
		<span class="hljs-keyword">if</span> (root.left) dfs(root.left, str + root.val + <span class="hljs-string">&#x27;-&gt;&#x27;</span>);
		<span class="hljs-keyword">if</span> (root.right) dfs(root.right, str + root.val + <span class="hljs-string">&#x27;-&gt;&#x27;</span>);
		<span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right) res.push(str + root.val);
		<span class="hljs-keyword">return</span>; 
	&#125;
	dfs(root);
	<span class="hljs-keyword">return</span> res;
&#125;;</code></pre>

<h3 id="21-另一个树的子树"><a href="#21-另一个树的子树" class="headerlink" title="21 另一个树的子树"></a>21 另一个树的子树</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 21 另一个树的子树 257</span>
<span class="hljs-comment">// 给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树</span>
<span class="hljs-comment">// s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</span>
<span class="hljs-comment">// 示例 1:</span>
<span class="hljs-comment">// 给定的树 s:</span>
<span class="hljs-comment">//      3</span>
<span class="hljs-comment">//     / \</span>
<span class="hljs-comment">//    4   5</span>
<span class="hljs-comment">//   / \</span>
<span class="hljs-comment">//  1   2</span>
<span class="hljs-comment">// 给定的树 t：</span>
<span class="hljs-comment">//    4 </span>
<span class="hljs-comment">//   / \</span>
<span class="hljs-comment">//  1   2</span>
<span class="hljs-comment">// 返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</span>

<span class="hljs-comment">// 示例 2:</span>
<span class="hljs-comment">// 给定的树 s：</span>
<span class="hljs-comment">//      3</span>
<span class="hljs-comment">//     / \</span>
<span class="hljs-comment">//    4   5</span>
<span class="hljs-comment">//   / \</span>
<span class="hljs-comment">//  1   2</span>
<span class="hljs-comment">//     /</span>
<span class="hljs-comment">//    0</span>
<span class="hljs-comment">// 给定的树 t：</span>
<span class="hljs-comment">//    4</span>
<span class="hljs-comment">//   / \</span>
<span class="hljs-comment">//  1   2</span>
<span class="hljs-comment">// 返回 false</span>

<span class="hljs-keyword">var</span> isSubtree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (!s) &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	&#125;
	<span class="hljs-keyword">if</span> (isSameTree(s, t)) &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	&#125;
	<span class="hljs-keyword">return</span> isSubtree(s.left, t) || isSubtree(s.right, t); <span class="hljs-comment">// 有一个true就true</span>
&#125;;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSameTree</span>(<span class="hljs-params">s, t</span>) </span>&#123; <span class="hljs-comment">// 100题</span>
	<span class="hljs-keyword">if</span> (!s &amp;&amp; !t) &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	&#125;;
	<span class="hljs-keyword">if</span> (!s || !t ) &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	&#125;
	<span class="hljs-keyword">return</span> s.val == t.val &amp;&amp; isSameTree(s.left, t.left) &amp;&amp; isSameTree(s.right, t.right);
&#125;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 22 从前序与中序遍历序列构造二叉树 105</span>
<span class="hljs-comment">// 根据一棵树的前序遍历与中序遍历构造二叉树。</span>
<span class="hljs-comment">// 注意:</span>
<span class="hljs-comment">// 你可以假设树中没有重复的元素。</span>

<span class="hljs-comment">// 例如，给出</span>
<span class="hljs-comment">// 前序遍历 preorder = [3,9,20,15,7]</span>
<span class="hljs-comment">// 中序遍历 inorder = [9,3,15,20,7]</span>
<span class="hljs-comment">// 返回如下的二叉树：</span>
<span class="hljs-comment">//     3</span>
<span class="hljs-comment">//    / \</span>
<span class="hljs-comment">//   9  20</span>
<span class="hljs-comment">//     /  \</span>
<span class="hljs-comment">//    15   7</span>
<span class="hljs-keyword">var</span> buildTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">preorder, inorder</span>) </span>&#123;
	<span class="hljs-keyword">if</span>(!inorder.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	<span class="hljs-keyword">const</span> rootVal = preorder[<span class="hljs-number">0</span>];
	<span class="hljs-keyword">const</span> rootIndex = inorder.indexOf(rootVal);
	<span class="hljs-keyword">let</span> root = <span class="hljs-keyword">new</span> TreeNode(rootVal);
	root.left = buildTree(preorder.slice(<span class="hljs-number">1</span>, rootIndex + <span class="hljs-number">1</span>),inorder.slice(<span class="hljs-number">0</span>, rootIndex));
	root.right = buildTree(preorder.slice(rootIndex + <span class="hljs-number">1</span>),inorder.slice(rootIndex + <span class="hljs-number">1</span>));
	<span class="hljs-keyword">return</span> root;
	<span class="hljs-comment">// 解法二</span>
	<span class="hljs-comment">// let build = (inorder) =&gt; &#123;</span>
	<span class="hljs-comment">// 	if(!inorder || !inorder.length) return null;</span>
	<span class="hljs-comment">// 	const rootVal = preorder.shift();</span>
	<span class="hljs-comment">// 	const rootIndex = inorder.indexOf(rootVal);</span>
	<span class="hljs-comment">// 	let root = new TreeNode(rootVal);</span>
	<span class="hljs-comment">// 	root.left = build(inorder.slice(0, rootIndex));</span>
	<span class="hljs-comment">// 	root.right = build(inorder.slice(rootIndex + 1));</span>
	<span class="hljs-comment">// 	return root</span>
	<span class="hljs-comment">// &#125;</span>
	<span class="hljs-comment">// return build(inorder)</span>
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 23 从中序与后序遍历序列构造二叉树 106</span>
<span class="hljs-comment">// 根据一棵树的前序遍历与中序遍历构造二叉树。</span>
<span class="hljs-comment">// 注意:</span>
<span class="hljs-comment">// 你可以假设树中没有重复的元素。</span>

<span class="hljs-comment">// 例如，给出</span>
<span class="hljs-comment">// 前序遍历 preorder = [3,9,20,15,7]</span>
<span class="hljs-comment">// 中序遍历 inorder = [9,3,15,20,7]</span>
<span class="hljs-comment">// 返回如下的二叉树：</span>
<span class="hljs-comment">//     3</span>
<span class="hljs-comment">//    / \</span>
<span class="hljs-comment">//   9  20</span>
<span class="hljs-comment">//     /  \</span>
<span class="hljs-comment">//    15   7</span>
<span class="hljs-keyword">var</span> buildTree = <span class="hljs-function">(<span class="hljs-params">inorder, postorder</span>) =&gt;</span> &#123;
	<span class="hljs-keyword">if</span>(!inorder.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	<span class="hljs-keyword">const</span> rootVal = postorder.pop();
	<span class="hljs-keyword">const</span> rootIndex = inorder.indexOf(rootVal);
	<span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> TreeNode(rootVal);
	root.left = buildTree(inorder.slice(<span class="hljs-number">0</span>, rootIndex), postorder.slice(<span class="hljs-number">0</span>, rootIndex));
	root.right = buildTree(inorder.slice(rootIndex + <span class="hljs-number">1</span>), postorder.slice(rootIndex));
	<span class="hljs-keyword">return</span> root;
&#125;;
</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 24 平衡二叉树 110</span>
<span class="hljs-comment">// 给定一个二叉树，判断它是否是高度平衡的二叉树。</span>
<span class="hljs-comment">// 本题中，一棵高度平衡二叉树定义为：</span>
<span class="hljs-comment">// 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：root = [3,9,20,null,null,15,7]</span>
<span class="hljs-comment">// 输出：true</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：root = [1,2,2,3,3,null,null,4,4]</span>
<span class="hljs-comment">// 输出：false</span>
<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入：root = []</span>
<span class="hljs-comment">// 输出：true</span>
<span class="hljs-comment">// 解法一</span>
<span class="hljs-keyword">var</span> isBalanced = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(!root || root.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">const</span> maxLeft = getMaxLevel(root.left);
    <span class="hljs-keyword">const</span> maxRight = getMaxLevel(root.right);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.abs(maxLeft - maxRight) &lt;= <span class="hljs-number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);
&#125;;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMaxLevel</span>(<span class="hljs-params">root</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> max = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">const</span> dp = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, l</span>) </span>&#123;
        <span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right)  max = <span class="hljs-built_in">Math</span>.max(max, l);
        <span class="hljs-keyword">if</span> (root.left) dp(root.left, l + <span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span> (root.right) dp(root.right, l + <span class="hljs-number">1</span>);
    &#125;
    dp(root, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span> max;
&#125;

<span class="hljs-comment">// 解法二</span>
<span class="hljs-keyword">const</span> isBalanced = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;
    <span class="hljs-comment">// 获取当前节点高度的递归函数</span>
    <span class="hljs-keyword">const</span> getH = <span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> &#123;
        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-comment">// 返回左右节点的最大高度+1,（+1:根节点）</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(getH(root.left), getH(root.right)) + <span class="hljs-number">1</span>;
    &#125;;
    <span class="hljs-comment">// 能递归到达这里，这个子树肯定是平衡二叉树</span>
    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-comment">// 平衡二叉树的条件：</span>
    <span class="hljs-keyword">return</span> (
        <span class="hljs-comment">// 1. 根节点的左右节点高度差不超过1</span>
        <span class="hljs-built_in">Math</span>.abs(getH(root.left) - getH(root.right)) &lt;= <span class="hljs-number">1</span> &amp;&amp;
        <span class="hljs-comment">// 2. 左子树是平衡二叉树</span>
        isBalanced(root.left) &amp;&amp;
        <span class="hljs-comment">// 3. 右子树是平衡二叉树</span>
        isBalanced(root.right)
    );
&#125;;

<span class="hljs-comment">// 解法三</span>
<span class="hljs-keyword">var</span> isBalanced = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;
    <span class="hljs-keyword">return</span> balanced(root) !== -<span class="hljs-number">1</span>
&#125;;
<span class="hljs-keyword">var</span> balanced = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">const</span> left = balanced(node.left)
    <span class="hljs-keyword">const</span> right = balanced(node.right)
    <span class="hljs-keyword">if</span> (left === -<span class="hljs-number">1</span> || right === -<span class="hljs-number">1</span> || <span class="hljs-built_in">Math</span>.abs(left - right) &gt; <span class="hljs-number">1</span>) &#123;
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(left, right) + <span class="hljs-number">1</span>
&#125;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 25 有序链表转换平衡二叉树 109</span>
<span class="hljs-comment">// 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</span>
<span class="hljs-comment">// 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</span>
<span class="hljs-comment">// 示例:</span>
<span class="hljs-comment">// 给定的有序链表： [-10, -3, 0, 5, 9],</span>
<span class="hljs-comment">// 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span>
<span class="hljs-comment">//       0</span>
<span class="hljs-comment">//      / \</span>
<span class="hljs-comment">//    -3   9</span>
<span class="hljs-comment">//    /   /</span>
<span class="hljs-comment">//  -10  5</span>
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Definition for singly-linked list.</span>
<span class="hljs-comment"> * function ListNode(val, next) &#123;</span>
<span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span>
<span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span>
<span class="hljs-comment"> * &#125;</span>
<span class="hljs-comment"> */</span>
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Definition for a binary tree node.</span>
<span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span>
<span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span>
<span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span>
<span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span>
<span class="hljs-comment"> * &#125;</span>
<span class="hljs-comment"> */</span>
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span>
<span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;TreeNode&#125;</span></span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">var</span> sortedListToBST = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTree</span>(<span class="hljs-params">head, end</span>) </span>&#123;
		<span class="hljs-keyword">if</span> (head === end) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
		<span class="hljs-keyword">let</span> p1 = head; <span class="hljs-comment">// 慢指针，中间节点</span>
		<span class="hljs-keyword">let</span> p2 = head; <span class="hljs-comment">// 快指针，结束节点</span>
		<span class="hljs-keyword">while</span>(p2 !== end) &#123;
			p2 = p2.next;
			<span class="hljs-keyword">if</span> (p2 !== end) &#123;
					p1 = p1.next;
					p2 = p2.next;
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(p1.val, getTree(head, p1), getTree(p1.next, end))
	&#125;
	<span class="hljs-keyword">return</span> getTree(head, <span class="hljs-literal">null</span>)
&#125;;</code></pre>

<h3 id="26-路径总和"><a href="#26-路径总和" class="headerlink" title="26 路径总和"></a>26 路径总和</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 26-1 路径总和 Ⅰ 112</span>
<span class="hljs-comment">// 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。</span>
<span class="hljs-comment">// 实例</span>
<span class="hljs-comment">// 输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span>
<span class="hljs-comment">// 输出：true</span>
<span class="hljs-keyword">var</span> hasPathSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, sum</span>) </span>&#123;
	<span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	<span class="hljs-keyword">let</span> res = <span class="hljs-literal">false</span>;
	<span class="hljs-keyword">const</span> dpt = <span class="hljs-function">(<span class="hljs-params">root, s</span>) =&gt;</span> &#123;
		<span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right &amp;&amp; s === sum) &#123;
			res = <span class="hljs-literal">true</span>;
		&#125;
		<span class="hljs-keyword">if</span> (root.left) &#123;
			dpt(root.left, s + root.left.val)
		&#125;
		<span class="hljs-keyword">if</span> (root.right) &#123;
			dpt(root.right, s + root.right.val)
		&#125;
	&#125;
	dpt(root, root.val);
	<span class="hljs-keyword">return</span> res;
&#125;;

<span class="hljs-comment">// 26-2 路径总和 ⅠⅠ 113</span>
<span class="hljs-comment">// 给你二叉树的根节点 root 和一个整数目标和 targetSum</span>
<span class="hljs-comment">// 找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</span>
<span class="hljs-comment">// 实例1：</span>
<span class="hljs-comment">// 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span>
<span class="hljs-comment">// 输出：[[5,4,11,2],[5,8,4,5]]</span>
<span class="hljs-keyword">var</span> pathSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, targetSum</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];
	<span class="hljs-keyword">const</span> res = [];
	<span class="hljs-keyword">const</span> dp = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, arr</span>) </span>&#123;
		<span class="hljs-keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;
			<span class="hljs-keyword">const</span> sum = arr.reduce(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + cur);
			<span class="hljs-keyword">if</span> (sum == targetSum) &#123;
					res.push(arr);
			&#125;
			<span class="hljs-keyword">return</span>;
		&#125;
		<span class="hljs-keyword">if</span> (root.left) dp(root.left, [...arr, root.left.val]);
		<span class="hljs-keyword">if</span> (root.right) dp(root.right, [...arr, root.right.val]);
	&#125;
	dp(root, [root.val]);
	<span class="hljs-keyword">return</span> res;
&#125;;
</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 27  填充每个节点的下一个右侧节点指针 116</span>
<span class="hljs-comment">// 给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。</span>
<span class="hljs-comment">// 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</span>
<span class="hljs-comment">// 初始状态下，所有 next 指针都被设置为 NULL。</span>
<span class="hljs-comment">// 实例1：</span>
<span class="hljs-comment">// 输入：root = [1,2,3,4,5,6,7]</span>
<span class="hljs-comment">// 输出：[1,#,2,3,#,4,5,6,7,#]</span>
<span class="hljs-comment">// 解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#x27;#&#x27; 标志着每一层的结束。</span>

<span class="hljs-comment">// 进阶：</span>
<span class="hljs-comment">// 1. 你只能使用常量级额外空间。</span>
<span class="hljs-comment">// 2. 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</span>

<span class="hljs-keyword">var</span> connect = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
	<span class="hljs-comment">// 解法一: 广度遍历</span>
	<span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	<span class="hljs-keyword">const</span> stack = [root];
	<span class="hljs-keyword">while</span>(stack.length) &#123;
		<span class="hljs-keyword">let</span> len = stack.length;
		<span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>;
		<span class="hljs-keyword">while</span>(len) &#123;
			<span class="hljs-keyword">const</span> item = stack.shift();
			<span class="hljs-keyword">if</span> (item &amp;&amp; item.left) stack.push(item.left);
			<span class="hljs-keyword">if</span> (item &amp;&amp; item.right) stack.push(item.right);
			<span class="hljs-keyword">if</span> (pre) pre.next = item;
			pre = item;
			len--;
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> root;

	<span class="hljs-comment">// 解法二: 递归 </span>
	<span class="hljs-comment">// 解法二更符合题目中进阶的要求</span>
	<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	<span class="hljs-keyword">if</span> (root.left) root.left.next = root.right;
	<span class="hljs-keyword">if</span> (root.right &amp;&amp; root.next) root.right.next = root.next.left;
	connect(root.left);
	connect(root.right);
	<span class="hljs-keyword">return</span> root;
&#125;;</code></pre>

<h2 id="三-数组"><a href="#三-数组" class="headerlink" title="三 数组"></a>三 数组</h2><p>1 全排列 ——（给定一个 没有重复 nums，返回其所有可能的全排列）<br>2 全排列II ——（给定一个 可能重复 的数组 nums ，返回所有不重复的全排列）<br>3 子集 ——（给你一个整数数组 nums，返回所有子集数组）<br>4 子集II ——（给定一个可能重复数组 nums，返回所有子集数组）<br>5 组合总和 ——（从无重复数组 nums 中找到和 为target 的所有子数组）<br>6 组合总和II ——（从可能重复数组 nums 中找到和 为target 的所有子数组）<br>7 组合 ——（给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合）<br>8 优美的排列<br>9 优美的排列II<br>10 电话号码的字母组合 —— (从一个仅包含数字2-9的字符串，返回所有它能表示的字母组合)<br>11 括号生成 —— (数字 n 代表生成括号的对数，找到所有 有效的 括号组合)<br>12 盛最多水的容器 ——（从数组中找到 盛最多水的 两个值）<br>13 三数之和 ——（三数之和为0）<br>14 删除有序数组中的重复项<br>15 加一<br>16 移动零 —— （把数组 nums 的所有 0 移动到数组的末尾）<br>17 最小栈 —— （设计一个栈，支持push/pop/top/操作，以及检索到最小元素的栈）<br>18 跳跃游戏 —— （nums元素代表可以跳跃的最大长度，判断是否能够到达最后一个下标）<br>19 跳跃游戏 II —— （nums元素代表可以跳跃的最大长度，判断是否能够到达最后一个下标）<br>20 最大子序和 —— （从数组中找到最大和的连续子数组的和）<br>21 最接近的三数之和 —— （找出 nums 中的三个整数的和与 target 最接近）<br>22 四数之和<br>23 字母异位词分组 —— 字符串数组，将包含相同字母项组合在一起<br>24 最长连续递增序列 —— 找到数组中找到 最长且 连续递增 的子序列<br>25 最长递增子序列 —— 找到其中最长严格递增子序列的长度<br>26 寻找两个正序数组的中位数 - 找到两个正序数组的中位数<br>27 和为K的子数组 —— 找到数组中和为 k 的连续的子数组的个数<br>28 两数之和 II - 输入有序数组 —— 升序的有序数组中找到和为target的目标<br>29 合并区间 —— 合并二维数组中区间重复的项<br>30 插入区间 —— 将一个区间数组 插入 到另一个 二维区间数组中<br>31 搜索旋转排序数组 —— 从已排序的数组中找到 指定的值<br>32 在排序数组中查找元素的第一个和最后一个位置<br>33 下一个排列 —— 找到数组的下一个更大的值<br>34 旋转图像<br>35 螺旋矩阵 —— 把二维数组(m * n) 按照 顺时针螺旋顺序 旋转</p>
<h3 id="1-全排列"><a href="#1-全排列" class="headerlink" title="1 全排列"></a>1 全排列</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 1 全排列 46</span>
<span class="hljs-comment">// 给定一个 没有重复 数字的序列，返回其所有可能的全排列。</span>
<span class="hljs-comment">// 示例:</span>
<span class="hljs-comment">// 输入: [1,2,3]</span>
<span class="hljs-comment">// 输出:</span>
<span class="hljs-comment">// [</span>
<span class="hljs-comment">//   [1,2,3],</span>
<span class="hljs-comment">//   [1,3,2],</span>
<span class="hljs-comment">//   [2,1,3],</span>
<span class="hljs-comment">//   [2,3,1],</span>
<span class="hljs-comment">//   [3,1,2],</span>
<span class="hljs-comment">//   [3,2,1]</span>
<span class="hljs-comment">// ]</span>
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span>
<span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">var</span> permute = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;
	<span class="hljs-comment">// 时间复杂度：O(!n) ; !n = 1 x 2 x 3 x ... x (n-1) x n</span>
	<span class="hljs-comment">// 空间复杂度：O(n)</span>
	<span class="hljs-keyword">const</span> res = [];
	<span class="hljs-keyword">const</span> backtrck = <span class="hljs-function"><span class="hljs-params">path</span> =&gt;</span> &#123;
		<span class="hljs-keyword">if</span> (path.length === nums.length) &#123;
			res.push(path);
			<span class="hljs-keyword">return</span>;
		&#125;
		nums.forEach(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> &#123;
			<span class="hljs-keyword">if</span> (path.includes(n)) <span class="hljs-keyword">return</span>;
			backtrck(path.concat(n));
		&#125;)
	&#125;
	backtrck([]);
	<span class="hljs-keyword">return</span> res;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 2 全排列II 47</span>
<span class="hljs-comment">// 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：nums = [1,1,2]</span>
<span class="hljs-comment">// 输出：</span>
<span class="hljs-comment">// [[1,1,2],</span>
<span class="hljs-comment">//  [1,2,1],</span>
<span class="hljs-comment">//  [2,1,1]]</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：nums = [1,2,3]</span>
<span class="hljs-comment">// 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span>
<span class="hljs-keyword">var</span> permuteUnique = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;
	<span class="hljs-keyword">const</span> len = nums.length;
	<span class="hljs-keyword">const</span> res = [];
	<span class="hljs-keyword">const</span> used = [];
	nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b)
	<span class="hljs-keyword">const</span> backtrack = <span class="hljs-function">(<span class="hljs-params">deepStack</span>) =&gt;</span> &#123;
		<span class="hljs-keyword">if</span> (deepStack.length === len) &#123;
			res.push(deepStack.slice())
			<span class="hljs-keyword">return</span>
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;
			<span class="hljs-comment">// 当前选项与上一项相同、且上一项存在、且没有被使用过，则忽略</span>
			<span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] === nums[i] &amp;&amp; i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; !used[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span> 
			<span class="hljs-keyword">if</span> (used[i]) <span class="hljs-keyword">continue</span> <span class="hljs-comment">// 使用过便不再使用</span>
			deepStack.push(nums[i])
			used[i] = <span class="hljs-literal">true</span>
			backtrack(deepStack)
			deepStack.pop()
			used[i] = <span class="hljs-literal">false</span>
		&#125;
	&#125;
	backtrack([])
	<span class="hljs-keyword">return</span> res
&#125;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 3 子集 78</span>
<span class="hljs-comment">// 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</span>
<span class="hljs-comment">// 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：nums = [1,2,3]</span>
<span class="hljs-comment">// 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span>

<span class="hljs-comment">// 解法一： 回溯</span>
<span class="hljs-keyword">var</span> subsets = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;
    <span class="hljs-comment">// 时间复杂度：O(2^n) 因为每个元素都有两种可能（存在或不存在）</span>
    <span class="hljs-comment">// 空间复杂度：O(n)</span>
	<span class="hljs-keyword">const</span> res = [];
	<span class="hljs-keyword">const</span> backtrack = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr, len, startIndex</span>) </span>&#123;
		<span class="hljs-keyword">if</span> (arr.length === len) &#123;
			res.push(arr);
			<span class="hljs-keyword">return</span>;
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = startIndex; index &lt; nums.length; index++) &#123;
			backtrack([...arr, nums[index]], len, index + <span class="hljs-number">1</span>);
		&#125;
	&#125;
	<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">while</span> (i &lt;= nums.length) &#123;
		backtrack([], i, <span class="hljs-number">0</span>);
		i++;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;;
<span class="hljs-comment">// 解法二 迭代 动态规划</span>
<span class="hljs-comment">// 重复将新的元素加入到上一个结果集中的每个子集当中去</span>
<span class="hljs-comment">// 形成n个新的子集，再全部加入到结果集中去</span>
<span class="hljs-keyword">var</span> subsets = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;
	<span class="hljs-keyword">let</span> res = [[]];
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;
		<span class="hljs-keyword">let</span> len = res.length;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; len; j++)&#123;
			<span class="hljs-keyword">let</span> sub = res[j].slice();
			sub.push(nums[i]);
			res.push(sub);
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;;
<span class="hljs-comment">// 解法三 递归</span>
<span class="hljs-keyword">const</span> subsets = <span class="hljs-function">(<span class="hljs-params">nums</span>) =&gt;</span> &#123;
	<span class="hljs-keyword">const</span> res = [];
	<span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">index, list</span>) =&gt;</span> &#123;
		res.push(list.slice());     <span class="hljs-comment">// 调用子递归前，加入解集</span>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = index; i &lt; nums.length; i++) &#123; <span class="hljs-comment">// 枚举出所有可选的数</span>
			list.push(nums[i]);       <span class="hljs-comment">// 选这个数</span>
			dfs(i + <span class="hljs-number">1</span>, list);         <span class="hljs-comment">// 基于选这个数，继续递归，传入的是i+1，不是index+1</span>
			list.pop();               <span class="hljs-comment">// 撤销选这个数</span>
		&#125;
	&#125;;
	dfs(<span class="hljs-number">0</span>, []);
	<span class="hljs-keyword">return</span> res;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 4 子集II  90.</span>
<span class="hljs-comment">// 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</span>
<span class="hljs-comment">// 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：nums = [1,2,2]</span>
<span class="hljs-comment">// 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span>
<span class="hljs-keyword">var</span> subsetsWithDup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (nums.length==<span class="hljs-number">0</span>)&#123;
		<span class="hljs-keyword">return</span> [nums];
	&#125;
	<span class="hljs-keyword">if</span> (nums.length==<span class="hljs-number">1</span>)&#123;
		<span class="hljs-keyword">return</span> [[],nums];
	&#125;
	nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b); <span class="hljs-comment">// 先排序</span>
	<span class="hljs-keyword">let</span> result = [[]]; <span class="hljs-comment">// 记录全部子数组</span>
	<span class="hljs-keyword">let</span> lastLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录上一个元素添加前，result的长度</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;
		<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;
		<span class="hljs-comment">// 当遇到重复元素时，从上一个元素添加前</span>
		<span class="hljs-comment">// result的长度处，开始每一个子数组都添加该元素</span>
		<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>])&#123;
			j = lastLength;
		&#125;
		<span class="hljs-keyword">let</span> n = result.length;
		<span class="hljs-comment">// 保持lastLength的更新</span>
		lastLength = result.length;
		<span class="hljs-comment">// 如果不是重复元素，j初始为0,从result开头，每个子数组都添加上该元素</span>
		<span class="hljs-keyword">for</span> (; j &lt; n; j++)&#123;
			result.push([...result[j],nums[i]])
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> result;
&#125;;
<span class="hljs-comment">// 解法二 </span>
<span class="hljs-keyword">var</span> subsetsWithDup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;
	<span class="hljs-keyword">let</span> n = nums.length;
	nums = nums.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> a - b&#125;);
	<span class="hljs-keyword">let</span> tmpPath = [];
	<span class="hljs-keyword">let</span> res = [];
	<span class="hljs-keyword">let</span> hash = &#123;&#125;
	<span class="hljs-keyword">let</span> backtrack = <span class="hljs-function">(<span class="hljs-params">tmpPath,start</span>) =&gt;</span> &#123;
		res.push(tmpPath);
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = start;i &lt; n;i++)&#123;
			<span class="hljs-keyword">if</span>(hash[i] || (i &gt; <span class="hljs-number">0</span> &amp;&amp; !hash[i-<span class="hljs-number">1</span>] &amp;&amp; nums[i-<span class="hljs-number">1</span>] == nums[i])) <span class="hljs-keyword">continue</span>;
			hash[i] = <span class="hljs-literal">true</span>;
			tmpPath.push(nums[i]);
			backtrack(tmpPath.slice(),i+<span class="hljs-number">1</span>);
			hash[i] = <span class="hljs-literal">false</span>;
			tmpPath.pop();
		&#125; 
	&#125;
	backtrack(tmpPath,<span class="hljs-number">0</span>);
	<span class="hljs-keyword">return</span> res;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 5 组合总和 39</span>
<span class="hljs-comment">// 给定一个无重复元素的数组 candidates 和一个目标数 target </span>
<span class="hljs-comment">// 找出 candidates 中所有可以使数字和为 target 的组合。</span>
<span class="hljs-comment">// candidates 中的数字可以无限制重复被选取。</span>
<span class="hljs-comment">// 说明：</span>
<span class="hljs-comment">// 所有数字（包括 target）都是正整数。</span>
<span class="hljs-comment">// 解集不能包含重复的组合。 </span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：candidates = [2,3,6,7], target = 7,</span>
<span class="hljs-comment">// 所求解集为：</span>
<span class="hljs-comment">// [</span>
<span class="hljs-comment">//   [7],</span>
<span class="hljs-comment">//   [2,2,3]</span>
<span class="hljs-comment">// ]</span>
<span class="hljs-keyword">var</span> combinationSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums,target</span>) </span>&#123;
	<span class="hljs-keyword">let</span> res = [];
	<span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> dfs = <span class="hljs-function">(<span class="hljs-params">subArr, sum, start</span>) =&gt;</span> &#123;
		<span class="hljs-keyword">if</span>(sum &gt; target) <span class="hljs-keyword">return</span>;
		<span class="hljs-keyword">if</span>(sum  == target)&#123;
			<span class="hljs-comment">//这里不能直接push subArr这个数组，对于js这门语言来说，可以充分利用js的...运算符</span>
			res.push([...subArr]);
			<span class="hljs-keyword">return</span>;
		&#125;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i  = start ; i &lt; nums.length ; i++)&#123;
			<span class="hljs-keyword">let</span> temp = sum;
			sum = sum + nums[i];
			subArr.push(nums[i]);
			dfs(subArr, sum,i);
			<span class="hljs-comment">//回到之前的状态，对于数组来讲就是pop，对于sum来讲可以用一个变量来记录以前的值</span>
			subArr.pop(nums[i]);
			sum = temp;
		&#125;
	&#125;
	dfs([], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
	<span class="hljs-keyword">return</span> res;
&#125;;
<span class="hljs-comment">// 解法二</span>
<span class="hljs-keyword">var</span> combinationSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">candidates, target</span>) </span>&#123;
	<span class="hljs-keyword">let</span> n = candidates.length;
	<span class="hljs-keyword">let</span> res = [];
	<span class="hljs-keyword">let</span> tmpPath = [];
	<span class="hljs-keyword">let</span> backtrack = <span class="hljs-function">(<span class="hljs-params">tmpPath,target,start</span>) =&gt;</span> &#123;
		<span class="hljs-keyword">if</span>(target &lt; <span class="hljs-number">0</span>)&#123;
			<span class="hljs-keyword">return</span>;
		&#125;
		<span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)&#123;
			res.push(tmpPath);
			<span class="hljs-keyword">return</span>;
		&#125;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = start;i &lt; n;i++)&#123;
			tmpPath.push(candidates[i]);
			backtrack(tmpPath.slice(),target - candidates[i],i);
			tmpPath.pop();
		&#125;
	&#125;
	backtrack(tmpPath, target, <span class="hljs-number">0</span>);
	<span class="hljs-keyword">return</span> res;
&#125;;</code></pre>

<h3 id="6-组合总和-II"><a href="#6-组合总和-II" class="headerlink" title="6 组合总和 II"></a>6 组合总和 II</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 6 组合总和 II 40</span>
<span class="hljs-comment">// 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span>
<span class="hljs-comment">// candidates 中的每个数字在每个组合中只能使用一次。</span>
<span class="hljs-comment">// 说明：</span>
<span class="hljs-comment">// 所有数字（包括目标数）都是正整数。</span>
<span class="hljs-comment">// 解集不能包含重复的组合。 </span>
<span class="hljs-comment">// 示例 1:</span>
<span class="hljs-comment">// 输入: candidates = [10,1,2,7,6,1,5], target = 8,</span>
<span class="hljs-comment">// 所求解集为:</span>
<span class="hljs-comment">// [</span>
<span class="hljs-comment">//   [1, 7],</span>
<span class="hljs-comment">//   [1, 2, 5],</span>
<span class="hljs-comment">//   [2, 6],</span>
<span class="hljs-comment">//   [1, 1, 6]</span>
<span class="hljs-comment">// ]</span>
<span class="hljs-keyword">var</span> combinationSum2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">candidates, target</span>) </span>&#123;
	<span class="hljs-keyword">let</span> n = candidates.length;
	<span class="hljs-keyword">let</span> res = [];
	<span class="hljs-keyword">let</span> tmpPath = [];
	candidates = candidates.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> a - b&#125;)
	<span class="hljs-keyword">let</span> backtrack = <span class="hljs-function">(<span class="hljs-params">tmpPath,target,start</span>) =&gt;</span> &#123;
		<span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)&#123;
			res.push(tmpPath);
			<span class="hljs-keyword">return</span>;
		&#125;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = start;i &lt; n;i++)&#123;
			<span class="hljs-keyword">if</span>(target &lt; candidates[i]) <span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">if</span>(i &gt; start &amp;&amp; candidates[i-<span class="hljs-number">1</span>] == candidates[i]) <span class="hljs-keyword">continue</span>;
			tmpPath.push(candidates[i]);
			backtrack(tmpPath.slice(),target - candidates[i],i + <span class="hljs-number">1</span>);
			tmpPath.pop();
		&#125;
	&#125;
	backtrack(tmpPath,target,<span class="hljs-number">0</span>);
	<span class="hljs-keyword">return</span> res;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 7 组合 77</span>
<span class="hljs-comment">// 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。</span>
<span class="hljs-comment">// 示例:</span>
<span class="hljs-comment">// 输入: n = 4, k = 2</span>
<span class="hljs-comment">// 输出:</span>
<span class="hljs-comment">// [</span>
<span class="hljs-comment">//   [2,4],</span>
<span class="hljs-comment">//   [3,4],</span>
<span class="hljs-comment">//   [2,3],</span>
<span class="hljs-comment">//   [1,2],</span>
<span class="hljs-comment">//   [1,3],</span>
<span class="hljs-comment">//   [1,4],</span>
<span class="hljs-comment">// ]</span>
<span class="hljs-comment">// 解法一 动态规划</span>
<span class="hljs-keyword">var</span> combine = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n, k</span>) </span>&#123;
	<span class="hljs-keyword">var</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;
		dp[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(k+<span class="hljs-number">1</span>);
		dp[i][<span class="hljs-number">0</span>] = [[]];
	&#125;
	<span class="hljs-built_in">console</span>.log(dp);
	<span class="hljs-comment">// i：1~n</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;
		<span class="hljs-comment">//j：1～i/k</span>
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>;j &lt;= i &amp;&amp; j &lt;= k ;j++)&#123;
			dp[i][j] = [];
			<span class="hljs-comment">// 从 i-1 个里选 j 个</span>
			<span class="hljs-comment">// 即从上题解法的：从 n-1 个里选 k个</span>
			<span class="hljs-keyword">if</span>(i &gt; j)&#123;
					<span class="hljs-keyword">var</span> tmpA = dp[i-<span class="hljs-number">1</span>][j];
					<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> t = <span class="hljs-number">0</span>;t&lt;tmpA.length;t++)&#123;
						dp[i][j].push(tmpA[t]);
					&#125;
			&#125;
			<span class="hljs-comment">// 从 i-1 个里选 j-1个</span>
			<span class="hljs-keyword">var</span> tmpB = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];
			<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> z = <span class="hljs-number">0</span>; z &lt; tmpB.length; z++)&#123;
					<span class="hljs-comment">// 这里注意不能修改dp[i-1][j-1]的原数组元素，需要深拷贝</span>
					<span class="hljs-keyword">var</span> tmpC = [].concat(tmpB[z]);
					tmpC.push(i);
					dp[i][j].push(tmpC);
			&#125;
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> dp[n][k];
&#125;;

<span class="hljs-comment">// 解法二：迭代回溯</span>
<span class="hljs-keyword">var</span> combine = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n, k</span>) </span>&#123;
	<span class="hljs-keyword">var</span> result = [];
	<span class="hljs-keyword">var</span> subresult = [];
	<span class="hljs-comment">// 初始化k个数字的临时组合各个元素为0</span>
	<span class="hljs-comment">// 便于++对应 n的1，2，3，4..n</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> r = <span class="hljs-number">0</span>; r &lt; k; r++)&#123;
		subresult[r] = <span class="hljs-number">0</span>;
	&#125;
	<span class="hljs-comment">// n的总个数达不到k组合的个数 不可能实现</span>
	<span class="hljs-keyword">if</span>(n &lt; k)&#123;
		<span class="hljs-keyword">return</span> result;
	&#125;
	<span class="hljs-comment">// 迭代索引</span>
	<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>)&#123;
		<span class="hljs-comment">// 当前数字加一 对于回溯中 subresult push 一个新的i 即为上一个i+1</span>
		subresult[i]++;
		<span class="hljs-comment">// 当i循环到n时，此时 i=n+1 </span>
		<span class="hljs-comment">// i-- 对应回溯的函数调用执行栈的逆序出栈 即回到上一层的组合状态操作</span>
		<span class="hljs-keyword">if</span>(subresult[i] &gt; n)&#123;
			i--;
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == k -<span class="hljs-number">1</span>)&#123;
			<span class="hljs-comment">// 索引从0开始 i == k-1 相等于 回溯i从1开始后i==k 的情况</span>
			result.push(subresult.slice(<span class="hljs-number">0</span>));
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-comment">// 对于回溯外层for循环的下一层i操作 即start</span>
			++i;
			<span class="hljs-comment">// 相当于回溯的pop操作 去掉新加的值 退回上一层的值重新递归 此处为迭代</span>
			subresult[i] = subresult[i-<span class="hljs-number">1</span>];
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> result;
&#125;;

<span class="hljs-comment">// 解法三 </span>
<span class="hljs-keyword">var</span> combine = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n, k</span>) </span>&#123;
	<span class="hljs-keyword">var</span> result = [];
	<span class="hljs-keyword">var</span> subresult = [];
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combineSub</span>(<span class="hljs-params">start,subresult</span>)</span>&#123;
		<span class="hljs-keyword">if</span>(subresult.length == k)&#123;
			result.push(subresult.slice(<span class="hljs-number">0</span>));
			<span class="hljs-keyword">return</span>;
		&#125;
		<span class="hljs-keyword">var</span> len = subresult.length;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i= start;i&lt;=n-(k-len)+<span class="hljs-number">1</span>;i++)&#123;
			subresult.push(i);
			combineSub(i+<span class="hljs-number">1</span>,subresult);
			subresult.pop();            
		&#125;   
	&#125;
	combineSub(<span class="hljs-number">1</span>,subresult);
	<span class="hljs-keyword">return</span> result;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 8 优美的排列 526</span>
<span class="hljs-comment">// 假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组</span>
<span class="hljs-comment">// 使得数组的第 i 位 (1 &lt;= i &lt;= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：</span>
<span class="hljs-comment">// 第 i 位的数字能被 i 整除</span>
<span class="hljs-comment">// i 能被第 i 位上的数字整除</span>
<span class="hljs-comment">// 现在给定一个整数 N，请问可以构造多少个优美的排列？</span>

<span class="hljs-comment">// 示例1:</span>
<span class="hljs-comment">// 输入: 2</span>
<span class="hljs-comment">// 输出: 2</span>
<span class="hljs-comment">// 解释: </span>
<span class="hljs-comment">// 第 1 个优美的排列是 [1, 2]:</span>
<span class="hljs-comment">//   第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除</span>
<span class="hljs-comment">//   第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除</span>
<span class="hljs-comment">// 第 2 个优美的排列是 [2, 1]:</span>
<span class="hljs-comment">//   第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除</span>
<span class="hljs-comment">//   第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除</span>
<span class="hljs-comment">// 说明:</span>
<span class="hljs-comment">// N 是一个正整数，并且不会超过15。</span>

<span class="hljs-keyword">var</span> countArrangement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) </span>&#123;
	<span class="hljs-comment">// visited[num]表示num是否被使用</span>
	<span class="hljs-comment">// 每次循环都通过visited去找下一个符合要求的数字 找到后索引值加一</span>
	<span class="hljs-comment">// 一个for循环中每个数字只使用一次 使用完成以后需要释放 即visited[num] = false</span>
	<span class="hljs-comment">// arr.fill(value[, start[, end]])</span>
	<span class="hljs-comment">// value 填充值</span>
	<span class="hljs-keyword">let</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(N+<span class="hljs-number">1</span>).fill(<span class="hljs-literal">false</span>);
	<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> dfs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) </span>&#123;
		<span class="hljs-keyword">if</span> (index &gt; N) &#123;
			++res;
			<span class="hljs-keyword">return</span>;
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>; num &lt;= N; ++num) &#123;
			<span class="hljs-keyword">if</span> (!visited[num] &amp;&amp; (num % index === <span class="hljs-number">0</span> || index % num === <span class="hljs-number">0</span>)) &#123;
			visited[num] = <span class="hljs-literal">true</span>;
			dfs(index+<span class="hljs-number">1</span>)
			visited[num] = <span class="hljs-literal">false</span>;
			&#125;
		&#125;
	&#125; 
	dfs(<span class="hljs-number">1</span>)
	<span class="hljs-keyword">return</span> res;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 9 优美的排列II 667</span>
<span class="hljs-comment">// 给你两个整数 n 和 k ，请你构造一个答案列表 answer ，该列表应当包含从 1 到 n 的 n 个不同正整数</span>
<span class="hljs-comment">// 并同时满足下述条件：</span>
<span class="hljs-comment">// 假设该列表是 answer = [a1, a2, a3, ... , an] </span>
<span class="hljs-comment">// 那么列表 [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] 中应该有且仅有 k 个不同整数。</span>
<span class="hljs-comment">// 返回列表 answer 。如果存在多种答案，只需返回其中 任意一种 。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：n = 3, k = 1</span>
<span class="hljs-comment">// 输出：[1, 2, 3]</span>
<span class="hljs-comment">// 解释：[1, 2, 3] 包含 3 个范围在 1-3 的不同整数，并且 [1, 1] 中有且仅有 1 个不同整数：1</span>
<span class="hljs-comment">// 示例 2：</span>

<span class="hljs-comment">// 输入：n = 3, k = 2</span>
<span class="hljs-comment">// 输出：[1, 3, 2]</span>
<span class="hljs-comment">// 解释：[1, 3, 2] 包含 3 个范围在 1-3 的不同整数，并且 [2, 1] 中有且仅有 2 个不同整数：1 和 2</span>
<span class="hljs-comment">// 提示：</span>
<span class="hljs-comment">// 1 &lt;= k &lt; n &lt;= 104</span>

<span class="hljs-keyword">var</span> constructArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n, k</span>) </span>&#123;
	<span class="hljs-comment">// 寻找规律：</span>
	<span class="hljs-comment">// 使用k+1个数字，即可组成k个差值，剩余的部分直接使用差值为1顺序填充即可</span>
	<span class="hljs-comment">// [1, 1**+k**, 1+k**-(k-1), 1+k-(k-1)+(k-1-1)**,,,]</span>
	<span class="hljs-keyword">let</span> result = [<span class="hljs-number">1</span>];
	<span class="hljs-keyword">let</span> i = k;
	<span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// true为正，false为负</span>
	<span class="hljs-keyword">while</span> (result.length &lt;= k) &#123;
		num = flag ? num + i : num - i;
		result.push(num);
		i--;
		flag = !flag;
	&#125;
	<span class="hljs-comment">// 基数已经准备好，进行剩余部分的填充</span>
	num = result.length + <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (num &lt;= n) &#123;
		result.push(num++);
	&#125;
	<span class="hljs-keyword">return</span> result;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 10 电话号码的字母组合 17</span>
<span class="hljs-comment">// 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</span>
<span class="hljs-comment">// 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：digits = &quot;23&quot;</span>
<span class="hljs-comment">// 输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：digits = &quot;&quot;</span>
<span class="hljs-comment">// 输出：[]</span>
<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入：digits = &quot;2&quot;</span>
<span class="hljs-comment">// 输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span>
<span class="hljs-keyword">var</span> letterCombinations = <span class="hljs-function">(<span class="hljs-params">digits</span>) =&gt;</span> &#123;
	<span class="hljs-keyword">if</span> (!digits.length) <span class="hljs-keyword">return</span> [];
	<span class="hljs-keyword">const</span> map = [<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;def&#x27;</span>, <span class="hljs-string">&#x27;ghi&#x27;</span>, <span class="hljs-string">&#x27;jkl&#x27;</span>, <span class="hljs-string">&#x27;mno&#x27;</span>, <span class="hljs-string">&#x27;pqrs&#x27;</span>, <span class="hljs-string">&#x27;tuv&#x27;</span>, <span class="hljs-string">&#x27;wxyz&#x27;</span>];
	<span class="hljs-keyword">let</span> result = [];
	<span class="hljs-keyword">const</span> backtrack = <span class="hljs-function">(<span class="hljs-params">str, index</span>) =&gt;</span> &#123;
		<span class="hljs-comment">// 1 如果单个字符串到底了，那就添加它</span>
		<span class="hljs-keyword">if</span> (index === digits.length) &#123;
			result.push(str);
			<span class="hljs-keyword">return</span>;
		&#125;
		<span class="hljs-comment">// 2 获取当前数字对应的字母</span>
		<span class="hljs-keyword">const</span> currentStr = map[<span class="hljs-built_in">Number</span>(digits[index])];
		<span class="hljs-comment">// 3 遍历这串字母，将其添加到下一次遍历中，同时位置向后挪一</span>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; currentStr.length; i++) &#123;
			backtrack(str + currentStr[i], index + <span class="hljs-number">1</span>);
		&#125;
	&#125;;
	<span class="hljs-comment">// 回溯</span>
	backtrack(<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-number">0</span>);
	<span class="hljs-keyword">return</span> result;
&#125;;
<span class="hljs-comment">// 解法二： 暴力枚举</span>
<span class="hljs-keyword">var</span> letterCombinations = <span class="hljs-function">(<span class="hljs-params">digits</span>) =&gt;</span> &#123;
	<span class="hljs-keyword">if</span> (!digits.length) <span class="hljs-keyword">return</span> [];
	<span class="hljs-keyword">const</span> map = [<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;def&#x27;</span>, <span class="hljs-string">&#x27;ghi&#x27;</span>, <span class="hljs-string">&#x27;jkl&#x27;</span>, <span class="hljs-string">&#x27;mno&#x27;</span>, <span class="hljs-string">&#x27;pqrs&#x27;</span>, <span class="hljs-string">&#x27;tuv&#x27;</span>, <span class="hljs-string">&#x27;wxyz&#x27;</span>];
	<span class="hljs-keyword">let</span> result = map[<span class="hljs-built_in">Number</span>(digits[<span class="hljs-number">0</span>])].split(<span class="hljs-string">&#x27;&#x27;</span>);
	<span class="hljs-keyword">const</span> backtrack = <span class="hljs-function">(<span class="hljs-params">prev, next</span>) =&gt;</span> &#123;
		<span class="hljs-comment">// 1 设置 temp 获取当前的组合</span>
		<span class="hljs-keyword">let</span> temp = [];
		<span class="hljs-comment">// 2 暴力遍历添加</span>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; prev.length; i++) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; next.length; j++) &#123;
				temp.push(prev[i] + next[j]);
			&#125;
		&#125;
		<span class="hljs-comment">// 3 返回拼接后的组合</span>
		<span class="hljs-keyword">return</span> temp;
	&#125;;
	<span class="hljs-comment">// 遍历字符串</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; digits.length; i++) &#123;
		<span class="hljs-comment">// 1 获取下一项添加的</span>
		<span class="hljs-keyword">const</span> next = map[<span class="hljs-built_in">Number</span>(digits[i])];
		<span class="hljs-comment">// 2 组合后返回给 result</span>
		result = backtrack(result, next);
	&#125;
	<span class="hljs-keyword">return</span> result;
&#125;;</code></pre>

<h3 id="11-括号生成-22"><a href="#11-括号生成-22" class="headerlink" title="11 括号生成 22"></a>11 括号生成 22</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 11 括号生成 22</span>
<span class="hljs-comment">// 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：n = 3</span>
<span class="hljs-comment">// 输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span>
<span class="hljs-comment">// 递归</span>
<span class="hljs-keyword">var</span> generateParenthesis = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;
	<span class="hljs-keyword">let</span> list = []
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generate</span>(<span class="hljs-params">left, right, s</span>) </span>&#123;
		<span class="hljs-comment">//  终止条件：如果左右括弧都用完则结束</span>
		<span class="hljs-keyword">if</span> (left === n &amp;&amp; right === n) &#123;
			list.push(s)
			<span class="hljs-keyword">return</span>
		&#125;
		<span class="hljs-comment">// 如果左括弧未用完则继续增加左括弧</span>
		<span class="hljs-keyword">if</span> (left &lt; n) &#123;
			generate(left + <span class="hljs-number">1</span>, right, s + <span class="hljs-string">&quot;(&quot;</span>)
		&#125;
		<span class="hljs-comment">// 如果右括弧少于左括弧则继续增加右括弧</span>
		<span class="hljs-keyword">if</span> (left &gt; right) &#123;
			generate(left, right + <span class="hljs-number">1</span>, s + <span class="hljs-string">&quot;)&quot;</span>)
		&#125;
	&#125;
	generate(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>)
	<span class="hljs-keyword">return</span> list
&#125;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 12 盛最多水的容器 11</span>
<span class="hljs-comment">// 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) </span>
<span class="hljs-comment">//在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)</span>
<span class="hljs-comment">// 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span>
<span class="hljs-comment">// 说明：你不能倾斜容器。</span>
<span class="hljs-comment">// 输入：[1,8,6,2,5,4,8,3,7]</span>
<span class="hljs-comment">// 输出：49 </span>
<span class="hljs-comment">// 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：height = [1,1]</span>
<span class="hljs-comment">// 输出：1</span>
<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入：height = [4,3,2,1,4]</span>
<span class="hljs-comment">// 输出：16</span>
<span class="hljs-comment">// 示例 4：</span>
<span class="hljs-comment">// 输入：height = [1,2,1]</span>
<span class="hljs-comment">// 输出：2</span>
<span class="hljs-keyword">var</span> maxArea = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">height</span>) </span>&#123;
	<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> right = height.length - <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (left &lt; right) &#123;
		<span class="hljs-keyword">const</span> area = <span class="hljs-built_in">Math</span>.min(height[left], height[right]) * (right - left);
		res = <span class="hljs-built_in">Math</span>.max(res, area);
		<span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;
			left++;
		&#125; <span class="hljs-keyword">else</span> &#123;
			right--;
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 13 三数之和 15</span>
<span class="hljs-comment">// 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c </span>
<span class="hljs-comment">// 使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</span>
<span class="hljs-comment">// 注意：答案中不可以包含重复的三元组。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：nums = [-1,0,1,2,-1,-4]</span>
<span class="hljs-comment">// 输出：[[-1,-1,2],[-1,0,1]]</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：nums = []</span>
<span class="hljs-comment">// 输出：[]</span>
<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入：nums = [0]</span>
<span class="hljs-comment">// 输出：[]</span>
<span class="hljs-keyword">var</span> threeSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">3</span>) &#123;
		<span class="hljs-keyword">return</span> [];
	&#125;

	<span class="hljs-keyword">const</span> res = [];

	<span class="hljs-keyword">let</span> arr = [...nums];
	arr = arr.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);

	<span class="hljs-keyword">if</span>(arr[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>) &#123;
		<span class="hljs-keyword">return</span> [];
	&#125;

	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">2</span>; i++) &#123;
		<span class="hljs-keyword">const</span> target = <span class="hljs-number">0</span> - arr[i];

		<span class="hljs-keyword">let</span> p1 = i + <span class="hljs-number">1</span>;
		<span class="hljs-keyword">let</span> p2 = arr.length - <span class="hljs-number">1</span>;
		<span class="hljs-keyword">while</span> (p1 &lt; p2) &#123;
			<span class="hljs-keyword">if</span> (arr[p1] + arr[p2] === target) &#123;
				<span class="hljs-keyword">const</span> subArr = [arr[i], arr[p1], arr[p2]];
				<span class="hljs-keyword">if</span> (!isIncludes(res, subArr)) &#123;
					res.push(subArr);
				&#125;
				p1++;
			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[p1] + arr[p2] &lt; target) &#123;
				p1++;
			&#125; <span class="hljs-keyword">else</span> &#123;
				p2--;
			&#125;
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;

<span class="hljs-keyword">var</span> isIncludes = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr, subArr</span>) </span>&#123;
	<span class="hljs-keyword">if</span>(!arr.length) &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	&#125;
	<span class="hljs-keyword">return</span> arr.some(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item[<span class="hljs-number">0</span>] === subArr[<span class="hljs-number">0</span>] &amp;&amp; item[<span class="hljs-number">1</span>] === subArr[<span class="hljs-number">1</span>] &amp;&amp; item[<span class="hljs-number">2</span>] === subArr[<span class="hljs-number">2</span>])
&#125;

<span class="hljs-comment">// 扩展:从长度为 n 的数组中找到 长度为 m 的所有子集</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSub</span>(<span class="hljs-params">nums, m</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (nums.length &lt; m) <span class="hljs-keyword">return</span> []; 
	<span class="hljs-keyword">const</span> res = [];
	<span class="hljs-keyword">const</span> backtrck = <span class="hljs-function">(<span class="hljs-params">arr, i</span>) =&gt;</span> &#123;
		<span class="hljs-keyword">if</span> (arr.length === m) &#123;
			res.push(arr);
			<span class="hljs-keyword">return</span>;
		&#125;
		nums.forEach(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;
			<span class="hljs-keyword">if</span> (index &gt; i) &#123;
				backtrck([...arr, item], index);
			&#125; <span class="hljs-keyword">else</span> &#123;
				<span class="hljs-keyword">return</span>;
			&#125;
		&#125;)
	&#125;
	backtrck([], -<span class="hljs-number">1</span>);
	<span class="hljs-keyword">return</span> res;
&#125;
</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 14 删除有序数组中的重复项 26</span>
<span class="hljs-comment">// 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</span>
<span class="hljs-comment">// 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</span>
<span class="hljs-comment">// 说明:</span>
<span class="hljs-comment">// 为什么返回数值是整数，但输出的答案是数组呢?</span>
<span class="hljs-comment">// 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</span>
<span class="hljs-comment">// 你可以想象内部操作如下:</span>
<span class="hljs-comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span>
<span class="hljs-comment">// int len = removeDuplicates(nums);</span>
<span class="hljs-comment">// 在函数里修改输入数组对于调用者是可见的。</span>
<span class="hljs-comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span>
<span class="hljs-comment">// for (int i = 0; i &lt; len; i++) &#123;</span>
<span class="hljs-comment">//     print(nums[i]);</span>
<span class="hljs-comment">// &#125;</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：nums = [1,1,2]</span>
<span class="hljs-comment">// 输出：2, nums = [1,2]</span>
<span class="hljs-comment">// 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 </span>
<span class="hljs-comment">// 不需要考虑数组中超出新长度后面的元素。</span>
<span class="hljs-keyword">var</span> removeDuplicates = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;
	<span class="hljs-keyword">let</span> p1 = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> p2 = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">while</span> (p2 &lt; nums.length) &#123;
		<span class="hljs-keyword">if</span> (nums[p1] !== nums[p2]) &#123;
			p1++;
			nums[p1] = nums[p2];
		&#125;
		p2++;
	&#125;
	<span class="hljs-keyword">while</span>(nums.length &gt; p1 + <span class="hljs-number">1</span>)&#123;
	nums.length--;
	&#125;
	<span class="hljs-comment">// 返回的是实际的长度，因为下标是从0开始的</span>
	<span class="hljs-keyword">return</span> p1 + <span class="hljs-number">1</span>;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 15 加一 66</span>
<span class="hljs-comment">// 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</span>
<span class="hljs-comment">// 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</span>
<span class="hljs-comment">// 你可以假设除了整数 0 之外，这个整数不会以零开头。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：digits = [1,2,3]</span>
<span class="hljs-comment">// 输出：[1,2,4]</span>
<span class="hljs-comment">// 解释：输入数组表示数字 123。</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：digits = [4,3,2,1]</span>
<span class="hljs-comment">// 输出：[4,3,2,2]</span>
<span class="hljs-comment">// 解释：输入数组表示数字 4321。</span>
<span class="hljs-keyword">var</span> plusOne = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">digits</span>) </span>&#123;
	<span class="hljs-keyword">let</span> carry = <span class="hljs-literal">false</span>;
	digits[digits.length - <span class="hljs-number">1</span>] ++;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = digits.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;
		<span class="hljs-keyword">if</span>(carry) digits[i]++;
		carry = digits[i] &gt; <span class="hljs-number">9</span>;
		digits[i] %= <span class="hljs-number">10</span>;
	&#125;
	<span class="hljs-keyword">if</span>(carry) digits.unshift(<span class="hljs-number">1</span>);
	<span class="hljs-keyword">return</span> digits;
&#125;;

</code></pre>

<h3 id="16-移动零"><a href="#16-移动零" class="headerlink" title="16 移动零"></a>16 移动零</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 16 移动零 283</span>
<span class="hljs-comment">// 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</span>
<span class="hljs-comment">// 示例:</span>
<span class="hljs-comment">// 输入: [0,1,0,3,12]</span>
<span class="hljs-comment">// 输出: [1,3,12,0,0]</span>
<span class="hljs-comment">// 说明:</span>
<span class="hljs-comment">// 必须在原数组上操作，不能拷贝额外的数组。</span>
<span class="hljs-comment">// 尽量减少操作次数。</span>
<span class="hljs-keyword">var</span> moveZeroes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;
	<span class="hljs-keyword">let</span> p = <span class="hljs-number">0</span>;
	<span class="hljs-comment">// 把所有的非0移到前面</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
		<span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 遇到非0项</span>
			nums[p] = nums[i]; <span class="hljs-comment">// 覆盖到p上</span>
			p++;    <span class="hljs-comment">// j后移</span>
		&#125;
	&#125;
	<span class="hljs-comment">// 剩下的位置赋为0</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = p; i &lt; nums.length; i++) &#123;
		nums[i] = <span class="hljs-number">0</span>;
	&#125;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 17 最小栈 155</span>
<span class="hljs-comment">// 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</span>
<span class="hljs-comment">// push(x) —— 将元素 x 推入栈中。</span>
<span class="hljs-comment">// pop() —— 删除栈顶的元素。</span>
<span class="hljs-comment">// top() —— 获取栈顶元素。</span>
<span class="hljs-comment">// getMin() —— 检索栈中的最小元素。</span>
<span class="hljs-keyword">var</span> MinStack = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">this</span>.stack = [];
    <span class="hljs-built_in">this</span>.min_stack = [];
&#125;;
MinStack.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;
    <span class="hljs-built_in">this</span>.stack.push(val);
    <span class="hljs-keyword">if</span> (val &lt;= <span class="hljs-built_in">this</span>.getMin() || <span class="hljs-built_in">this</span>.min_stack.length == <span class="hljs-number">0</span>) &#123;
        <span class="hljs-built_in">this</span>.min_stack.push(val);
    &#125;
&#125;;
MinStack.prototype.pop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">let</span> out = <span class="hljs-built_in">this</span>.stack.pop();
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.getMin() == out) &#123;
        <span class="hljs-built_in">this</span>.min_stack.pop();
    &#125;
&#125;;
MinStack.prototype.top = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stack[<span class="hljs-built_in">this</span>.stack.length - <span class="hljs-number">1</span>];
&#125;;
MinStack.prototype.getMin = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.min_stack[<span class="hljs-built_in">this</span>.min_stack.length - <span class="hljs-number">1</span>];
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 18 跳跃游戏 55</span>
<span class="hljs-comment">// 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</span>
<span class="hljs-comment">// 数组中的每个元素代表你在该位置可以跳跃的最大长度。</span>
<span class="hljs-comment">// 判断你是否能够到达最后一个下标。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：nums = [2,3,1,1,4]</span>
<span class="hljs-comment">// 输出：true</span>
<span class="hljs-comment">// 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：nums = [3,2,1,0,4]</span>
<span class="hljs-comment">// 输出：false</span>
<span class="hljs-comment">// 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span>
<span class="hljs-comment">// 解法一： 贪心算法</span>
<span class="hljs-keyword">var</span> canJump = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;
	<span class="hljs-comment">// maxStep 代表跳到的最远的距离</span>
	<span class="hljs-keyword">let</span> maxStep = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
		<span class="hljs-comment">// 如果遍历的到的索引已经比最远能到到的距离还要大</span>
		<span class="hljs-comment">// 说明根本没有机会再继续走下去</span>
		<span class="hljs-keyword">if</span> (i &gt; maxStep) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
		&#125;
		maxStep = <span class="hljs-built_in">Math</span>.max(maxStep, i + nums[i]);
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;;
<span class="hljs-comment">// 解法二：</span>
<span class="hljs-comment">// 1、起跳点：当前位置</span>
<span class="hljs-comment">// 2、最大可能：跳一次能影响的最大长度</span>
<span class="hljs-comment">// 3、return 起跳点+最大可能 &gt;= 终点</span>
<span class="hljs-keyword">var</span> canJump = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;
	<span class="hljs-keyword">if</span>(nums.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>;) &#123;
		<span class="hljs-comment">// i: 起跳点</span>
		<span class="hljs-keyword">if</span>(nums[i] === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
		<span class="hljs-keyword">let</span> n = nums[i];
		<span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= nums[i]; j++) &#123;
			<span class="hljs-keyword">let</span> m = j + nums[i+j];
			<span class="hljs-keyword">if</span>(m &gt; n) &#123;
				n = m;
				index = j; <span class="hljs-comment">// 最大可能时的位移长度</span>
			&#125;
		&#125;
		<span class="hljs-keyword">if</span>(i + n &gt;= nums.length - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		i += index;
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 19 跳跃游戏 II 45</span>
<span class="hljs-comment">// 给定一个非负整数数组，你最初位于数组的第一个位置。</span>
<span class="hljs-comment">// 数组中的每个元素代表你在该位置可以跳跃的最大长度。</span>
<span class="hljs-comment">// 你的目标是使用最少的跳跃次数到达数组的最后一个位置。</span>
<span class="hljs-comment">// 假设你总是可以到达数组的最后一个位置。</span>

<span class="hljs-comment">// 示例 1:</span>
<span class="hljs-comment">// 输入: [2,3,1,1,4]</span>
<span class="hljs-comment">// 输出: 2</span>
<span class="hljs-comment">// 解释: 跳到最后一个位置的最小跳跃数是 2。</span>
<span class="hljs-comment">//      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span>
<span class="hljs-comment">// 示例 2:</span>
<span class="hljs-comment">// 输入: [2,3,0,1,4]</span>
<span class="hljs-comment">// 输出: 2</span>

<span class="hljs-comment">// 贪心算法 动态规划</span>
<span class="hljs-comment">// 从第一项出发，用最少的步数跳到最后一项</span>
<span class="hljs-comment">// (1)遍历一个可抵达的区间，从中选出能跳最远的点</span>
<span class="hljs-comment">// (2)就有了新的可抵达的区间，然后跳跃一次，进入新的区间继续遍历寻求最优解</span>
<span class="hljs-keyword">var</span> jump = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;
	<span class="hljs-comment">// 记录当前能去到的最远的位置</span>
	<span class="hljs-comment">// 遍历每个点都会求能跳到的最远位置，与它比较，如果把它大就更新它</span>
	<span class="hljs-keyword">let</span> p1 = <span class="hljs-number">0</span>; <span class="hljs-comment">// farthestPos</span>
	<span class="hljs-keyword">let</span> p2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// endOfCanReach</span>
	<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;
		p1 = <span class="hljs-built_in">Math</span>.max(p1, i + nums[i]);
		<span class="hljs-keyword">if</span> (i === p2) &#123; 
			<span class="hljs-comment">// 可抵达区间的右端位置</span>
			p2 = p1;
			res++;
		&#125;
		<span class="hljs-comment">// 一旦新的可抵达区间触碰到nums数组的边界，则直接break，不用对区间的点遍历了</span>
		<span class="hljs-keyword">if</span> (p2 &gt;= nums.length - <span class="hljs-number">1</span>) &#123;
			<span class="hljs-keyword">break</span>;
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 20 最大子序和 53</span>
<span class="hljs-comment">// 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素）</span>
<span class="hljs-comment">// 返回其最大和。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span>
<span class="hljs-comment">// 输出：6</span>
<span class="hljs-comment">// 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 </span>
<span class="hljs-comment">// 动态规划</span>

<span class="hljs-keyword">var</span> maxSubArray = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;
	<span class="hljs-keyword">let</span> ans = nums[<span class="hljs-number">0</span>];
	<span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) &#123;
		<span class="hljs-comment">// if(sum &gt; 0) &#123; 可以写成这样</span>
		<span class="hljs-keyword">if</span>(sum + num &gt; num )&#123;
			sum = sum + num;
		&#125; <span class="hljs-keyword">else</span> &#123;
			sum = num;
		&#125;
		ans = <span class="hljs-built_in">Math</span>.max(ans, sum);
	&#125;;
	<span class="hljs-keyword">return</span> ans;
&#125;;
</code></pre>

<h3 id="21-最接近的三数之和"><a href="#21-最接近的三数之和" class="headerlink" title="21 最接近的三数之和"></a>21 最接近的三数之和</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 21 最接近的三数之和 16</span>
<span class="hljs-comment">// 给定一个包括 n 个整数的数组 nums 和 一个目标值 target,找出 nums 中的三个整数</span>
<span class="hljs-comment">// 使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</span>
<span class="hljs-comment">// 示例：</span>
<span class="hljs-comment">// 输入：nums = [-1,2,1,-4], target = 1</span>
<span class="hljs-comment">// 输出：2</span>
<span class="hljs-comment">// 解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</span>

<span class="hljs-keyword">var</span> threeSumClosest = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;
	nums = nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);
	<span class="hljs-keyword">let</span> res = nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>];
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;
		<span class="hljs-keyword">let</span> p1 = i + <span class="hljs-number">1</span>;
		<span class="hljs-keyword">let</span> p2 = nums.length - <span class="hljs-number">1</span>;
		<span class="hljs-keyword">while</span> (p1 &lt; p2) &#123;
			<span class="hljs-keyword">const</span> sum = nums[i] + nums[p1] + nums[p2];
			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(target - sum) &lt; <span class="hljs-built_in">Math</span>.abs(target - res)) &#123;
				res = sum;
			&#125;
			<span class="hljs-keyword">if</span> (target &gt; sum) &#123;
				p1++;
			&#125; <span class="hljs-keyword">else</span> &#123;
				p2--;
			&#125;
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 22 四数之和 18</span>
<span class="hljs-comment">// 给定一个包含 n 个整数的数组 nums 和一个目标值 target</span>
<span class="hljs-comment">// 判断 nums 中是否存在四个元素 a，b，c 和 d </span>
<span class="hljs-comment">// 使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</span>
<span class="hljs-comment">// 注意：答案中不可以包含重复的四元组。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：nums = [1,0,-1,0,-2,2], target = 0</span>
<span class="hljs-comment">// 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：nums = [], target = 0</span>
<span class="hljs-comment">// 输出：[]</span>
<span class="hljs-keyword">var</span> fourSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;
    <span class="hljs-keyword">const</span> res = [&#123;&#125;, []];
    nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = nums.length, key; i &lt; len - <span class="hljs-number">3</span>; i++) &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i + <span class="hljs-number">1</span>; j &lt; len - <span class="hljs-number">2</span>; j++) &#123;
            <span class="hljs-keyword">let</span> l = j + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">let</span> r = len - <span class="hljs-number">1</span>;
            <span class="hljs-keyword">const</span> sum = nums[i] + nums[j];
            <span class="hljs-keyword">while</span> (l &lt; r) &#123;
                <span class="hljs-keyword">if</span> (sum + nums[l] + nums[r] === target) &#123;
                    <span class="hljs-keyword">const</span> key = <span class="hljs-string">&#x27;&#x27;</span> + nums[i] + nums[j] + nums[l] + nums[r];
                    <span class="hljs-keyword">if</span> (!res[<span class="hljs-number">0</span>][key]) &#123;
                        res[<span class="hljs-number">0</span>][key] = <span class="hljs-number">1</span>;
                        res[<span class="hljs-number">1</span>].push([nums[i], nums[j], nums[l], nums[r]]);
                    &#125;
                    r--;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-keyword">if</span> (!(sum + nums[l] + nums[r] &gt; target &amp;&amp; r--)) &#123;
                        l++;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> res[<span class="hljs-number">1</span>];
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 23 字母异位词分组 49</span>
<span class="hljs-comment">// 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</span>
<span class="hljs-comment">// 示例:</span>
<span class="hljs-comment">// 输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span>
<span class="hljs-comment">// 输出:</span>
<span class="hljs-comment">// [</span>
<span class="hljs-comment">//   [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span>
<span class="hljs-comment">//   [&quot;nat&quot;,&quot;tan&quot;],</span>
<span class="hljs-comment">//   [&quot;bat&quot;]</span>
<span class="hljs-comment">// ]</span>
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">strs</span></span></span>
<span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[][]&#125;</span></span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">var</span> groupAnagrams = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">strs</span>) </span>&#123;
	<span class="hljs-keyword">const</span> hashTable = &#123;&#125;;
	<span class="hljs-comment">// 这个方法需要排序，因此不是很优，但是很直观，容易想到</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;
		<span class="hljs-keyword">const</span> str = strs[i];
		<span class="hljs-keyword">const</span> key = str.split(<span class="hljs-string">&quot;&quot;</span>).sort().join(<span class="hljs-string">&quot;&quot;</span>);
		<span class="hljs-keyword">if</span> (!hashTable[key]) &#123;
			hashTable[key] = [str];
		&#125; <span class="hljs-keyword">else</span> &#123;
			hashTable[key].push(str);
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.values(hashTable);
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 24 最长连续递增序列 674</span>
<span class="hljs-comment">// 给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</span>
<span class="hljs-comment">// 连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定</span>
<span class="hljs-comment">// 如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] </span>
<span class="hljs-comment">// 那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：nums = [1,3,5,4,7]</span>
<span class="hljs-comment">// 输出：3</span>
<span class="hljs-comment">// 解释：最长连续递增序列是 [1,3,5], 长度为3。</span>
<span class="hljs-comment">// 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 </span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：nums = [2,2,2,2,2]</span>
<span class="hljs-comment">// 输出：1</span>
<span class="hljs-comment">// 解释：最长连续递增序列是 [2], 长度为1。</span>
<span class="hljs-comment">// 解法一：贪心算法</span>
<span class="hljs-keyword">var</span> findLengthOfLCIS = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-keyword">const</span> n = nums.length;
	<span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> right = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">let</span> res = <span class="hljs-number">1</span>
	<span class="hljs-keyword">let</span> maxLen = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (right &lt; n) &#123;
		<span class="hljs-keyword">if</span> (nums[right] &gt; nums[left])&#123;
			maxLen++;
		&#125; <span class="hljs-keyword">else</span> &#123;
			maxLen = <span class="hljs-number">1</span>;
		&#125;
		left++;
		right++;
		res = <span class="hljs-built_in">Math</span>.max(res, maxLen);
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;;
<span class="hljs-comment">// 解法二：双指针</span>
<span class="hljs-comment">// var findLengthOfLCIS = function(nums) &#123;</span>
<span class="hljs-comment">// 	if(!nums.length) return 0;</span>
<span class="hljs-comment">// 	let res = 0;</span>
<span class="hljs-comment">// 	let left = 0;</span>
<span class="hljs-comment">// 	let right = 0;</span>
<span class="hljs-comment">// 	while(right &lt; nums.length) &#123;</span>
<span class="hljs-comment">// 		while(nums[right + 1] &gt; nums[right]) &#123;</span>
<span class="hljs-comment">// 			right++;</span>
<span class="hljs-comment">// 		&#125;</span>
<span class="hljs-comment">// 		const sub = nums.slice(left, right + 1);</span>
<span class="hljs-comment">// 		res = Math.max(res, sub.length);</span>
<span class="hljs-comment">// 		right++;</span>
<span class="hljs-comment">// 		left = right;</span>
<span class="hljs-comment">// 	&#125;</span>
<span class="hljs-comment">// 	return res;</span>
<span class="hljs-comment">// &#125;</span></code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 25 最长递增子序列 300</span>
<span class="hljs-comment">// 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</span>
<span class="hljs-comment">// 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：nums = [10,9,2,5,3,7,101,18]</span>
<span class="hljs-comment">// 输出：4</span>
<span class="hljs-comment">// 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：nums = [0,1,0,3,2,3]</span>
<span class="hljs-comment">// 输出：4</span>
<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入：nums = [7,7,7,7,7,7,7]</span>
<span class="hljs-comment">// 输出：1</span>
<span class="hljs-comment">// 动态规划</span>
<span class="hljs-keyword">var</span> lengthOfLIS = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (!nums.length) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">const</span> temArr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(nums.length);
	<span class="hljs-keyword">let</span> res = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span>(i &lt; nums.length) &#123;
		temArr[i] = <span class="hljs-number">1</span>;
		<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;
			<span class="hljs-keyword">let</span> m = i - <span class="hljs-number">1</span>;
			<span class="hljs-keyword">while</span>(m &gt; -<span class="hljs-number">1</span>) &#123;
				<span class="hljs-keyword">if</span> (nums[i] &gt; nums[m] &amp;&amp; temArr[m] + <span class="hljs-number">1</span> &gt; temArr[i]) &#123;
					temArr[i] = temArr[m] + <span class="hljs-number">1</span>;
					res = <span class="hljs-built_in">Math</span>.max(res, temArr[i])
				&#125;
				m--;
			&#125;
		&#125;
		i++;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;;</code></pre>

<h3 id="26-寻找两个正序数组的中位数"><a href="#26-寻找两个正序数组的中位数" class="headerlink" title="26 寻找两个正序数组的中位数"></a>26 寻找两个正序数组的中位数</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 26 寻找两个正序数组的中位数 4</span>
<span class="hljs-comment">// 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2</span>
<span class="hljs-comment">// 请你找出并返回这两个正序数组的 中位数 。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：nums1 = [1,3], nums2 = [2]</span>
<span class="hljs-comment">// 输出：2.00000</span>
<span class="hljs-comment">// 解释：合并数组 = [1,2,3] ，中位数 2</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：nums1 = [1,2], nums2 = [3,4]</span>
<span class="hljs-comment">// 输出：2.50000</span>
<span class="hljs-comment">// 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</span>
<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入：nums1 = [0,0], nums2 = [0,0]</span>
<span class="hljs-comment">// 输出：0.00000</span>
<span class="hljs-comment">// 示例 4：</span>
<span class="hljs-comment">// 输入：nums1 = [], nums2 = [1]</span>
<span class="hljs-comment">// 输出：1.00000</span>
<span class="hljs-comment">// 示例 5：</span>
<span class="hljs-comment">// 输入：nums1 = [2], nums2 = []</span>
<span class="hljs-comment">// 输出：2.00000</span>
<span class="hljs-comment">//  </span>
<span class="hljs-comment">// 提示：</span>
<span class="hljs-comment">// nums1.length == m</span>
<span class="hljs-comment">// nums2.length == n</span>
<span class="hljs-comment">// 0 &lt;= m &lt;= 1000</span>
<span class="hljs-comment">// 0 &lt;= n &lt;= 1000</span>
<span class="hljs-comment">// 1 &lt;= m + n &lt;= 2000</span>
<span class="hljs-comment">// -106 &lt;= nums1[i], nums2[i] &lt;= 106</span>
<span class="hljs-keyword">var</span> findMedianSortedArrays = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums1, nums2</span>) </span>&#123;
	<span class="hljs-keyword">let</span> m = nums1.length;
	<span class="hljs-keyword">let</span> n = nums2.length;
	<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> newArr = [];
	<span class="hljs-keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;
		<span class="hljs-keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;
			newArr.push(nums1[i++]);
		&#125; <span class="hljs-keyword">else</span> &#123;
			newArr.push(nums2[j++]);
		&#125;
	&#125;
	newArr = newArr.concat(i &lt; m ? nums1.slice(i) : nums2.slice(j));
	<span class="hljs-keyword">const</span> len = newArr.length;
	<span class="hljs-keyword">if</span> (len % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) &#123;
		<span class="hljs-keyword">return</span> (newArr[len / <span class="hljs-number">2</span>] + newArr[len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>]) / <span class="hljs-number">2</span>;
	&#125; <span class="hljs-keyword">else</span> &#123;
		<span class="hljs-keyword">return</span> newArr[<span class="hljs-built_in">Math</span>.floor(len / <span class="hljs-number">2</span>)];
	&#125;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 27 和为K的子数组 560</span>
<span class="hljs-comment">// 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</span>
<span class="hljs-comment">// 示例 1 :</span>
<span class="hljs-comment">// 输入:nums = [1,1,1], k = 2</span>
<span class="hljs-comment">// 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span>
<span class="hljs-comment">// 说明 :</span>
<span class="hljs-comment">// 数组的长度为 [1, 20,000]。</span>
<span class="hljs-comment">// 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</span>
<span class="hljs-keyword">var</span> subarraySum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;
	<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> sum1 = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> sum2 = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
	map.set(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= nums.length; i++) &#123;
		sum1 += nums[i];
		sum2 = sum1 - k;
		<span class="hljs-keyword">if</span> (map.has(sum2)) &#123;
			res += map.get(sum2);
		&#125;
		<span class="hljs-keyword">let</span> sumCnt = map.get(sum1) || <span class="hljs-number">0</span>;
		map.set(sum1, sumCnt + <span class="hljs-number">1</span>);
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;;
</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 28 两数之和 II - 输入有序数组 167</span>
<span class="hljs-comment">// 给定一个已按照 升序排列  的整数数组 numbers</span>
<span class="hljs-comment">// 请你从数组中找出两个数满足相加之和等于目标数 target 。</span>
<span class="hljs-comment">// 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。</span>
<span class="hljs-comment">// numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。</span>
<span class="hljs-comment">// 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：numbers = [2,7,11,15], target = 9</span>
<span class="hljs-comment">// 输出：[1,2]</span>
<span class="hljs-comment">// 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：numbers = [2,3,4], target = 6</span>
<span class="hljs-comment">// 输出：[1,3]</span>
<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入：numbers = [-1,0], target = -1</span>
<span class="hljs-comment">// 输出：[1,2]</span>
<span class="hljs-keyword">var</span> twoSum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">numbers, target</span>) </span>&#123;
	<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numbers.length; i++) &#123;
		<span class="hljs-keyword">let</span> tmp = target - numbers[i]
		<span class="hljs-keyword">if</span> (map.has(tmp)) &#123;
			<span class="hljs-keyword">return</span> [map.get(tmp) + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>]
		&#125;
		map.set(numbers[i], i)
	&#125;
&#125;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 29 合并区间 56</span>
<span class="hljs-comment">// 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi]</span>
<span class="hljs-comment">// 请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span>
<span class="hljs-comment">// 输出：[[1,6],[8,10],[15,18]]</span>
<span class="hljs-comment">// 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：intervals = [[1,4],[4,5]]</span>
<span class="hljs-comment">// 输出：[[1,5]]</span>
<span class="hljs-comment">// 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span>
<span class="hljs-keyword">var</span> merge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">intervals</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (intervals.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];
	intervals.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);
	<span class="hljs-keyword">const</span> mergeArr = [intervals[<span class="hljs-number">0</span>]];
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;
		<span class="hljs-keyword">const</span> item = intervals[i];
		<span class="hljs-keyword">const</span> last = mergeArr[mergeArr.length - <span class="hljs-number">1</span>];
		<span class="hljs-keyword">if</span> (last[<span class="hljs-number">1</span>] &gt;= item[<span class="hljs-number">0</span>]) &#123;
			last[<span class="hljs-number">1</span>] = <span class="hljs-built_in">Math</span>.max(item[<span class="hljs-number">1</span>], last[<span class="hljs-number">1</span>]);
		&#125; <span class="hljs-keyword">else</span> &#123;
			mergeArr.push(item);
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> mergeArr;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 30 插入区间 57</span>
<span class="hljs-comment">// 给你一个 无重叠的 ，按照区间起始端点排序的区间列表。</span>
<span class="hljs-comment">// 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</span>

<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：intervals = [[1,3],[6,9]], newInterval = [2,5]</span>
<span class="hljs-comment">// 输出：[[1,5],[6,9]]</span>

<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]</span>
<span class="hljs-comment">// 输出：[[1,2],[3,10],[12,16]]</span>
<span class="hljs-comment">// 解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</span>

<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入：intervals = [], newInterval = [5,7]</span>
<span class="hljs-comment">// 输出：[[5,7]]</span>

<span class="hljs-comment">// 示例 4：</span>
<span class="hljs-comment">// 输入：intervals = [[1,5]], newInterval = [2,3]</span>
<span class="hljs-comment">// 输出：[[1,5]]</span>

<span class="hljs-comment">// 示例 5：</span>
<span class="hljs-comment">// 输入：intervals = [[1,5]], newInterval = [2,7]</span>
<span class="hljs-comment">// 输出：[[1,7]]</span>

<span class="hljs-keyword">var</span> insert = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">intervals, newInterval</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (intervals.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [newInterval];
	<span class="hljs-comment">// 最左侧</span>
	<span class="hljs-keyword">if</span> (newInterval[<span class="hljs-number">1</span>] &lt; intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]) &#123;
		<span class="hljs-keyword">return</span> [newInterval, ...intervals];
	&#125;
	<span class="hljs-comment">// 最右侧</span>
	<span class="hljs-keyword">if</span> (newInterval[<span class="hljs-number">0</span>] &gt; intervals[intervals.length - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) &#123;
		<span class="hljs-keyword">return</span> [...intervals, newInterval];
	&#125;
	<span class="hljs-keyword">let</span> leftSub = [];
	<span class="hljs-keyword">let</span> midSub = [];
	<span class="hljs-keyword">let</span> rifhtSub = [];
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; intervals.length; i++) &#123;
		<span class="hljs-comment">// 左侧 有重叠</span>
		<span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &lt;= newInterval[<span class="hljs-number">0</span>] &amp;&amp; newInterval[<span class="hljs-number">0</span>] &lt;= intervals[i][<span class="hljs-number">1</span>]) &#123;
			midSub[<span class="hljs-number">0</span>] = intervals[i][<span class="hljs-number">0</span>];
			leftSub = intervals.slice(<span class="hljs-number">0</span>, i);
		&#125;
		<span class="hljs-comment">// 右侧 有重叠</span>
		<span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &lt;= newInterval[<span class="hljs-number">1</span>] &amp;&amp; newInterval[<span class="hljs-number">1</span>] &lt;= intervals[i][<span class="hljs-number">1</span>]) &#123;
			midSub[<span class="hljs-number">1</span>] = intervals[i][<span class="hljs-number">1</span>];
			rifhtSub = intervals.slice(i + <span class="hljs-number">1</span>);
		&#125;
		<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;
			<span class="hljs-comment">// 左侧 无重叠，在区间中</span>
			<span class="hljs-keyword">if</span> (intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt; newInterval[<span class="hljs-number">0</span>] &amp;&amp; newInterval[<span class="hljs-number">0</span>] &lt; intervals[i][<span class="hljs-number">0</span>]) &#123;
					midSub[<span class="hljs-number">0</span>] = newInterval[<span class="hljs-number">0</span>];
					leftSub = intervals.slice(<span class="hljs-number">0</span>, i);
			&#125;
			<span class="hljs-comment">// 右侧 无重叠，在区间中</span>
			<span class="hljs-keyword">if</span> (intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt; newInterval[<span class="hljs-number">1</span>] &amp;&amp;  newInterval[<span class="hljs-number">1</span>] &lt; intervals[i][<span class="hljs-number">0</span>]) &#123;
					midSub[<span class="hljs-number">1</span>] = newInterval[<span class="hljs-number">1</span>];
					rifhtSub = intervals.slice(i);
			&#125;
		&#125;
		<span class="hljs-comment">// 超出左侧边界</span>
		<span class="hljs-keyword">if</span> (newInterval[<span class="hljs-number">0</span>] &lt; intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]) &#123;
			midSub[<span class="hljs-number">0</span>] = newInterval[<span class="hljs-number">0</span>];
		&#125;
		<span class="hljs-comment">// 超出右侧边界</span>
		<span class="hljs-keyword">if</span> (i === intervals.length - <span class="hljs-number">1</span> &amp;&amp; newInterval[<span class="hljs-number">1</span>] &gt; intervals[i][<span class="hljs-number">1</span>]) &#123;
			midSub[<span class="hljs-number">1</span>] = newInterval[<span class="hljs-number">1</span>];
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> [...leftSub, midSub, ...rifhtSub];
&#125;;</code></pre>

<h3 id="31-搜索旋转排序数组"><a href="#31-搜索旋转排序数组" class="headerlink" title="31 搜索旋转排序数组"></a>31 搜索旋转排序数组</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 31 搜索旋转排序数组 I 33 / II 81</span>
<span class="hljs-comment">// 整数数组 nums 按升序排列，数组中的值 互不相同 。</span>
<span class="hljs-comment">// 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，</span>
<span class="hljs-comment">// 使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</span>
<span class="hljs-comment">// （下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</span>
<span class="hljs-comment">// 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，</span>
<span class="hljs-comment">// 则返回它的下标，否则返回 -1 。</span>

<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：nums = [4,5,6,7,0,1,2], target = 0</span>
<span class="hljs-comment">// 输出：4</span>

<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：nums = [4,5,6,7,0,1,2], target = 3</span>
<span class="hljs-comment">// 输出：-1</span>

<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入：nums = [1], target = 0</span>
<span class="hljs-comment">// 输出：-1</span>

<span class="hljs-keyword">var</span> search = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;
	<span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> end = nums.length - <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span>(start &lt;= end) &#123;
		<span class="hljs-keyword">const</span> mid = start + <span class="hljs-built_in">Math</span>.floor((end - start) / <span class="hljs-number">2</span>);
		<span class="hljs-keyword">if</span> (nums[mid] === target) &#123;
			<span class="hljs-keyword">return</span> mid;
		&#125;
		<span class="hljs-keyword">if</span> (nums[mid] &gt;= nums[start]) &#123;
			<span class="hljs-keyword">if</span> (target &gt;= nums[start] &amp;&amp; target &lt; nums[mid]) &#123;
					end = mid - <span class="hljs-number">1</span>;
			&#125; <span class="hljs-keyword">else</span> &#123;
					start = mid + <span class="hljs-number">1</span>;
			&#125;
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-keyword">if</span> (target &lt;= nums[end] &amp;&amp; target &gt; nums[mid]) &#123;
					start = mid + <span class="hljs-number">1</span>;
			&#125; <span class="hljs-keyword">else</span> &#123;
					end = mid - <span class="hljs-number">1</span>;
			&#125;
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
&#125;;

<span class="hljs-comment">// 搜索旋转排序数组 II 81</span>
<span class="hljs-comment">// 已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。</span>

<span class="hljs-comment">// 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，</span>
<span class="hljs-comment">// 使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</span>
<span class="hljs-comment">// （下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] </span>
<span class="hljs-comment">// 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。</span>
<span class="hljs-comment">// 给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。</span>
<span class="hljs-comment">// 如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</span>

<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：nums = [2,5,6,0,0,1,2], target = 0</span>
<span class="hljs-comment">// 输出：true</span>

<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：nums = [2,5,6,0,0,1,2], target = 3</span>
<span class="hljs-comment">// 输出：false</span>

<span class="hljs-keyword">var</span> search = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;
	<span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>
	<span class="hljs-keyword">let</span> end = nums.length - <span class="hljs-number">1</span>
	<span class="hljs-keyword">while</span> (start &lt;= end) &#123;
		<span class="hljs-comment">// let mid = start + ((end - start) &gt;&gt; 1)</span>
		<span class="hljs-keyword">let</span> mid = start + <span class="hljs-built_in">Math</span>.floor((end - start) / <span class="hljs-number">2</span>);

		<span class="hljs-keyword">if</span> (nums[mid] === target) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
		&#125;
		
		<span class="hljs-keyword">if</span> (nums[start] &gt; nums[mid]) &#123; 
			<span class="hljs-comment">// 左大于中, 最大值在左边</span>

			<span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; nums[end] &gt;= target) &#123; 
				start = mid + <span class="hljs-number">1</span>;
			&#125; <span class="hljs-keyword">else</span> &#123;
				end = mid - <span class="hljs-number">1</span>;
			&#125;
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[start] &lt; nums[mid]) &#123;
			<span class="hljs-comment">// 左小于中, 说明左边是非递减的</span>

			<span class="hljs-keyword">if</span> (nums[start] &lt;= target &amp;&amp; nums[mid] &gt; target) &#123;
				end = mid - <span class="hljs-number">1</span>;
			&#125; <span class="hljs-keyword">else</span> &#123;
				start = mid + <span class="hljs-number">1</span>;
			&#125;
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-comment">// 左等于中, 无法判断</span>

			start++;
			<span class="hljs-keyword">if</span> (nums[end] === nums[mid]) &#123;
				end--;
			&#125;
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 32 在排序数组中查找元素的第一个和最后一个位置</span>
<span class="hljs-comment">// 给定一个按照升序排列的整数数组 nums，和一个目标值 target。</span>
<span class="hljs-comment">// 找出给定目标值在数组中的开始位置和结束位置。</span>
<span class="hljs-comment">// 如果数组中不存在目标值 target，返回 [-1, -1]。</span>

<span class="hljs-comment">// 示例 1：</span>

<span class="hljs-comment">// 输入：nums = [5,7,7,8,8,10], target = 8</span>
<span class="hljs-comment">// 输出：[3,4]</span>

<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：nums = [5,7,7,8,8,10], target = 6</span>
<span class="hljs-comment">// 输出：[-1,-1]</span>

<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入：nums = [], target = 0</span>
<span class="hljs-comment">// 输出：[-1,-1]</span>

<span class="hljs-keyword">var</span> searchRange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;

	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">search</span> (<span class="hljs-params">nums, target, flag</span>) </span>&#123;
		<span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">let</span> end = nums.length - <span class="hljs-number">1</span>;
		<span class="hljs-keyword">while</span> (start &lt;= end) &#123;
			<span class="hljs-keyword">let</span> mid = start + (<span class="hljs-built_in">Math</span>.floor((end - start) / <span class="hljs-number">2</span>));
			<span class="hljs-keyword">if</span> (nums[mid] === target) &#123;
				<span class="hljs-keyword">if</span> (flag) &#123;
					<span class="hljs-keyword">if</span> (mid === <span class="hljs-number">0</span> || nums[mid - <span class="hljs-number">1</span>] !== target) &#123;
						<span class="hljs-keyword">return</span> mid;
					&#125;
					end = mid - <span class="hljs-number">1</span>;
				&#125; <span class="hljs-keyword">else</span> &#123;
					<span class="hljs-keyword">if</span> (mid === nums.length - <span class="hljs-number">1</span> || nums[mid + <span class="hljs-number">1</span>] !== target) &#123;
						<span class="hljs-keyword">return</span> mid;
					&#125;
					start = mid + <span class="hljs-number">1</span>;
				&#125;
			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;
				end = mid - <span class="hljs-number">1</span>;
			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;
				start = mid + <span class="hljs-number">1</span>;
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
	&#125;
	<span class="hljs-keyword">return</span> [search(nums, target, <span class="hljs-literal">true</span>), search(nums, target, <span class="hljs-literal">false</span>)]
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 33 下一个排列 31</span>
<span class="hljs-comment">// 实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</span>
<span class="hljs-comment">// 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</span>
<span class="hljs-comment">// 必须 原地 修改，只允许使用额外常数空间。</span>

<span class="hljs-comment">// 示例 1：</span>

<span class="hljs-comment">// 输入：nums = [1,2,3]</span>
<span class="hljs-comment">// 输出：[1,3,2]</span>

<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：nums = [3,2,1]</span>
<span class="hljs-comment">// 输出：[1,2,3]</span>

<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入：nums = [1,1,5]</span>
<span class="hljs-comment">// 输出：[1,5,1]</span>

<span class="hljs-comment">// 示例 4：</span>
<span class="hljs-comment">// 输入：nums = [1]</span>
<span class="hljs-comment">// 输出：[1]</span>

<span class="hljs-comment">// 示例 5：</span>
<span class="hljs-comment">// 输入 [4,2,3,1]</span>
<span class="hljs-comment">// 输出 [4,3,1,2]</span>

<span class="hljs-comment">// 1 从右往左，找到第一个小于 它右边的 数字</span>
<span class="hljs-comment">// 2 把这个数字 与 它右边 互换</span>
<span class="hljs-comment">// 3 把它右边所有的数 翻转</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nextPermutation</span>(<span class="hljs-params">nums</span>) </span>&#123;
	<span class="hljs-comment">// 从右向左遍历，i从倒数第二开始是为了nums[index1+1]要存在</span>
	<span class="hljs-keyword">let</span> index1 = nums.length - <span class="hljs-number">2</span>;

	<span class="hljs-comment">// 寻找第一个小于右邻居的数</span>
	<span class="hljs-keyword">while</span> (index1 &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[index1] &gt;= nums[index1 + <span class="hljs-number">1</span>]) &#123;
		index1--;
	&#125;
	<span class="hljs-comment">// 这个数在数组中存在，从它身后挑一个数，和它换</span>
	<span class="hljs-keyword">if</span> (index1 &gt;= <span class="hljs-number">0</span>) &#123;
		<span class="hljs-comment">// 从最后一项，向左遍历                     </span>
		<span class="hljs-keyword">let</span> index2 = nums.length - <span class="hljs-number">1</span>;   
		<span class="hljs-comment">// 寻找第一个大于 nums[index1] 的数             </span>
		<span class="hljs-keyword">while</span> (index2 &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[index2] &lt;= nums[index1]) &#123;  
			index2--;
		&#125;
		<span class="hljs-comment">// 两数交换，实现变大</span>
		[nums[index1], nums[index2]] = [nums[index2], nums[index1]]; 
	&#125;

	<span class="hljs-comment">// 抹平另外两种情况：</span>
	<span class="hljs-comment">// 1、如果 index1 = -1，说明是递减排列，如 3 2 1，没有下一排列，直接翻转为最小排列：1 2 3</span>
	<span class="hljs-comment">// 2、[4,2,3,1] 预期结果 [4,3,1,2], 结果却是[4,3,2,1]</span>
	<span class="hljs-keyword">let</span> l = index1 + <span class="hljs-number">1</span>;           
	<span class="hljs-keyword">let</span> r = nums.length - <span class="hljs-number">1</span>;
	<span class="hljs-comment">// index1 右边的数进行翻转，使得变大的幅度小一些</span>
	<span class="hljs-keyword">while</span> (l &lt; r) &#123;                            
		[nums[l], nums[r]] = [nums[r], nums[l]];
		l++;
		r--;
	&#125;
&#125;
</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 34 旋转图像 48</span>
<span class="hljs-comment">// 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</span>
<span class="hljs-comment">// 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span>
<span class="hljs-comment">// 输出：[[7,4,1],[8,5,2],[9,6,3]]</span>

<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span>
<span class="hljs-comment">// 输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span>

<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入：matrix = [[1]]</span>
<span class="hljs-comment">// 输出：[[1]]</span>

<span class="hljs-comment">// 示例 4：</span>
<span class="hljs-comment">// 输入：matrix = [[1,2],[3,4]]</span>
<span class="hljs-comment">// 输出：[[3,1],[4,2]]</span>

<span class="hljs-keyword">var</span> rotate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>&#123;
	<span class="hljs-keyword">let</span> n = matrix.length
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i; j &lt; n - <span class="hljs-number">1</span> - i; j++) &#123;
			<span class="hljs-keyword">let</span> tmp = matrix[i][j];
			matrix[i][j] = matrix[n - <span class="hljs-number">1</span> - j][i];
			matrix[n - <span class="hljs-number">1</span> - j][i] = matrix[n - <span class="hljs-number">1</span> - i][n - <span class="hljs-number">1</span> - j];
			matrix[n - <span class="hljs-number">1</span> - i][n - <span class="hljs-number">1</span> -j] = matrix[j][n - <span class="hljs-number">1</span> - i];
			matrix[j][n - <span class="hljs-number">1</span> - i] = tmp;
		&#125;
	&#125;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 35 螺旋矩阵 54</span>
<span class="hljs-comment">// 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</span>

<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span>
<span class="hljs-comment">// 输出：[1,2,3,6,9,8,7,4,5]</span>

<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span>
<span class="hljs-comment">// 输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span>

<span class="hljs-keyword">var</span> spiralOrder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">matrix</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (matrix.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> []
	<span class="hljs-keyword">const</span> res = [];
	<span class="hljs-keyword">let</span> top = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> bottom = matrix.length - <span class="hljs-number">1</span>;
	<span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> right = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = left; i &lt;= right; i++) &#123;
			res.push(matrix[top][i]);
		&#125;
		top++;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = top; i &lt;= bottom; i++) &#123;
			res.push(matrix[i][right]);
		&#125;
		right--;
		<span class="hljs-keyword">if</span> (top &gt; bottom || left &gt; right) <span class="hljs-keyword">break</span>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = right; i &gt;= left; i--) &#123;
			res.push(matrix[bottom][i]);
		&#125;
		bottom--;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = bottom; i &gt;= top; i--) &#123;
			res.push(matrix[i][left]);
		&#125;
		left++;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;;
</code></pre>

<h2 id="四-字符串"><a href="#四-字符串" class="headerlink" title="四 字符串"></a>四 字符串</h2><p>1 验证回文串 —— 给定一个字符串，验证它是否是回文串<br>2 爬楼梯 —— 每次你可以爬 1 或 2 个台阶。求有多少种方法<br>3 打家劫舍 —— 数组n的最大和，其中每一项不能相互连续<br>4 最长回文子串 —— 找到字符串 s 中最长的回文子串<br>5 编辑距离 —— 计算将 word1 转换成 word2 所使用的最少操作数<br>6 无重复字符的最长子串 —— 找出其中不含有重复字符的 最长子串 的长度<br>7 整数转罗马数字<br>8 罗马数字转整数<br>9 最小路径和 —— 从二位数组 的 第一个 到 最后一个 的最小路径和<br>10 最长公共前缀 —— 字符串数组中的最长公共前缀<br>11 最小覆盖子串 —— 找到字符串 s 中最小覆盖 字符串的 t<br>12 单词拆分 —— 判断 s 是否可以被空格拆分为一个或多个在字典中出现的单词<br>13 100层丢鸡蛋 —— 有2个鸡蛋，从100层中丢下，找到刚好破的那一层<br>14 较大分组的位置 —— 找到字符串中 最大连续(同样)的 子串<br>15 下划线与驼峰互换<br>16 Z 字形变换 —— 将字符串按照 从上往下、从左到右进行 Z 字形排列<br>17 不同的路径 —— 从 m*n 表格的左上角移动到右下角，有多少种路径</p>
<h3 id="1-验证回文串"><a href="#1-验证回文串" class="headerlink" title="1 验证回文串"></a>1 验证回文串</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 1 验证回文串 125</span>
<span class="hljs-comment">// 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</span>
<span class="hljs-comment">// 说明：本题中，我们将空字符串定义为有效的回文串。</span>
<span class="hljs-comment">// 示例 1:</span>
<span class="hljs-comment">// 输入: &quot;A man, a plan, a canal: Panama&quot;</span>
<span class="hljs-comment">// 输出: true</span>
<span class="hljs-comment">// 示例 2:</span>
<span class="hljs-comment">// 输入: &quot;race a car&quot;</span>
<span class="hljs-comment">// 输出: false</span>
<span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;
	<span class="hljs-keyword">const</span> strArr = s.toLocaleLowerCase().match(<span class="hljs-regexp">/[A-Za-z0-9]+/g</span>);
	<span class="hljs-keyword">if</span>(!strArr) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	<span class="hljs-keyword">const</span> str = strArr.join(<span class="hljs-string">&#x27;&#x27;</span>);
	<span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> right = str.length - <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span>(left &lt; right)&#123;
		<span class="hljs-keyword">if</span>(str[left] === str[right])&#123;
			left++;
			right--;
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 2 爬楼梯 70</span>
<span class="hljs-comment">// 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</span>
<span class="hljs-comment">// 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</span>
<span class="hljs-comment">// 注意：给定 n 是一个正整数。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入： 2</span>
<span class="hljs-comment">// 输出： 2</span>
<span class="hljs-comment">// 解释： 有两种方法可以爬到楼顶。</span>
<span class="hljs-comment">// 1.  1 阶 + 1 阶</span>
<span class="hljs-comment">// 2.  2 阶</span>
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span>
<span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-comment">// 动态规划一： 时间复杂度 O(n) 空间复杂度：O(n)</span>
<span class="hljs-keyword">var</span> climbStairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;
	    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
	&#125;
	<span class="hljs-keyword">const</span> dp = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>];
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;
	<span class="hljs-comment">// 斐波那契数列 f(n) = f(n-1) + f(n-2)</span>
		dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];
	&#125;
	<span class="hljs-keyword">return</span> dp[n];
&#125;;

<span class="hljs-comment">// 动态规划二： 时间复杂度 O(n) 空间复杂度 O(1)</span>
<span class="hljs-keyword">var</span> climbStairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
	&#125;
	<span class="hljs-keyword">let</span> dp1 = <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录 n-2 的值</span>
	<span class="hljs-keyword">let</span> dp2 = <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录 n-1 的值</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;
		<span class="hljs-comment">// 将 n-1 的值赋值给 n-2</span>
		<span class="hljs-comment">// 将 n-1 和 n-2 的和, 赋值给 n-1</span>
		<span class="hljs-comment">// 即 完成了 f(n) = f(n-1) + f(n-2)</span>
		<span class="hljs-keyword">const</span> tem = dp1;
		dp1 = dp2;
		dp2 = tem + dp1;
	&#125;
	<span class="hljs-keyword">return</span> dp2;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 3 打家劫舍 198</span>
<span class="hljs-comment">// 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金</span>
<span class="hljs-comment">// 影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统</span>
<span class="hljs-comment">// 如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</span>
<span class="hljs-comment">// 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：[1,2,3,1]</span>
<span class="hljs-comment">// 输出：4</span>
<span class="hljs-comment">// 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span>
<span class="hljs-comment">//      偷窃到的最高金额 = 1 + 3 = 4 </span>
<span class="hljs-comment">// 动态规划解法一：</span>
<span class="hljs-keyword">var</span> rob = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;
	<span class="hljs-comment">// 解题步骤：</span>
	<span class="hljs-comment">// 1. 用 fn1(k) 代表 前k个房屋中能偷窃到的最大金额</span>
	<span class="hljs-comment">// 2. 用 fn2(k) 代表 第k个房屋中的金额</span>
	<span class="hljs-comment">// 3. fn1(k) = Math.max(fn1(k-2) + fn2(k), fn1(k-1))</span>
	<span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">0</span>) &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	&#125;
	<span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">1</span>) &#123;
		<span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];
	&#125;
	<span class="hljs-comment">// dp[0]代表第0个房屋的金额, dp[1]代表第1个房屋的金额</span>
	<span class="hljs-keyword">const</span> dp = [<span class="hljs-number">0</span>, nums[<span class="hljs-number">0</span>]];
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= nums.length; i++) &#123;
		dp[i] = <span class="hljs-built_in">Math</span>.max(dp[i - <span class="hljs-number">2</span>] + nums[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>]);
	&#125;
	<span class="hljs-keyword">return</span> dp[dp.length - <span class="hljs-number">1</span>];
&#125;;

<span class="hljs-comment">// 动态规划解法二：</span>
<span class="hljs-keyword">var</span> rob = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">0</span>) &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	&#125;
	<span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">1</span>) &#123;
		<span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];
	&#125;
	<span class="hljs-keyword">let</span> dp0 = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> dp1 = nums[<span class="hljs-number">0</span>];
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= nums.length; i++) &#123;
		<span class="hljs-keyword">const</span> tem = <span class="hljs-built_in">Math</span>.max(dp0 + nums[i - <span class="hljs-number">1</span>], dp1);
		dp0 = dp1;
		dp1 = tem;
	&#125;
	<span class="hljs-keyword">return</span> dp1;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 4 最长回文子串 5</span>
<span class="hljs-comment">// 给你一个字符串 s，找到 s 中最长的回文子串。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：s = &quot;babad&quot;</span>
<span class="hljs-comment">// 输出：&quot;bab&quot;</span>
<span class="hljs-comment">// 解释：&quot;aba&quot; 同样是符合题意的答案。</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：s = &quot;cbbd&quot;</span>
<span class="hljs-comment">// 输出：&quot;bb&quot;</span>

<span class="hljs-comment">// 解法一: 动态规划, 性能比较查</span>
<span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;
	<span class="hljs-keyword">let</span> len = s.length;
	<span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span>;
	<span class="hljs-comment">// 创建二维数组</span>
	<span class="hljs-keyword">let</span> dp = <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len),<span class="hljs-function">()=&gt;</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len).fill(<span class="hljs-number">0</span>)));
	<span class="hljs-comment">// 从字符串首部开始</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;
		<span class="hljs-comment">// 从字符串i前开始依次向前查找</span>
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i; j &gt;= <span class="hljs-number">0</span>; j--) &#123;
			dp[j][i] = s[i] == s[j] &amp;&amp; (i - j &lt; <span class="hljs-number">2</span> || dp[j + <span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>]);
			<span class="hljs-keyword">if</span>(dp[j][i] &amp;&amp; i - j + <span class="hljs-number">1</span> &gt; res.length) &#123;
				res = s.substring(j, i + <span class="hljs-number">1</span>);
			&#125;
		&#125;
	&#125;
	<span class="hljs-comment">// console.log(dp)</span>
	<span class="hljs-keyword">return</span> res
&#125;;

<span class="hljs-comment">// 解法二: 从中间往两边寻找, 性能更好</span>
<span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (s.length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;
	<span class="hljs-keyword">let</span> maxRes = <span class="hljs-number">0</span>, maxStr = <span class="hljs-string">&#x27;&#x27;</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;
		<span class="hljs-comment">// str1 是为了防止 &quot;aba&quot; 的情况</span>
		<span class="hljs-keyword">let</span> str1 = palindrome(s, i, i);
		<span class="hljs-comment">// str2 是为了防止 &quot;abba&quot; 的情况</span>
		<span class="hljs-keyword">let</span> str2 = palindrome(s, i, i + <span class="hljs-number">1</span>);   
		<span class="hljs-keyword">if</span> (str1.length &gt; maxRes) &#123;
			maxStr = str1;
			maxRes = str1.length;
		&#125;
		<span class="hljs-keyword">if</span> (str2.length &gt; maxRes) &#123;
			maxStr = str2;
			maxRes = str2.length;
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> maxStr;
&#125;;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">palindrome</span>(<span class="hljs-params">s, l, r</span>) </span>&#123;
	<span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.length &amp;&amp; s[l] === s[r]) &#123;
		l--;
		r++;
	&#125;
	<span class="hljs-keyword">return</span> s.slice(l + <span class="hljs-number">1</span>, r);
&#125;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 5 编辑距离 72</span>
<span class="hljs-comment">// 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</span>
<span class="hljs-comment">// 你可以对一个单词进行如下三种操作：</span>
<span class="hljs-comment">//  - 插入一个字符</span>
<span class="hljs-comment">//  - 删除一个字符</span>
<span class="hljs-comment">//  - 替换一个字符</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span>
<span class="hljs-comment">// 输出：3</span>
<span class="hljs-comment">// 解释：</span>
<span class="hljs-comment">// horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)</span>
<span class="hljs-comment">// rorse -&gt; rose (删除 &#x27;r&#x27;)</span>
<span class="hljs-comment">// rose -&gt; ros (删除 &#x27;e&#x27;)</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span>
<span class="hljs-comment">// 输出：5</span>
<span class="hljs-comment">// 解释：</span>
<span class="hljs-comment">// intention -&gt; inention (删除 &#x27;t&#x27;)</span>
<span class="hljs-comment">// inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)</span>
<span class="hljs-comment">// enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)</span>
<span class="hljs-comment">// exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)</span>
<span class="hljs-comment">// exection -&gt; execution (插入 &#x27;u&#x27;)</span>
<span class="hljs-keyword">var</span> minDistance = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">word1, word2</span>) </span>&#123;
	<span class="hljs-keyword">let</span> m = word1.length + <span class="hljs-number">1</span>;
	<span class="hljs-keyword">let</span> n = word2.length + <span class="hljs-number">1</span>;
	<span class="hljs-keyword">let</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(m);
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; m; k++) &#123;
		dp[k] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n);
	&#125;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++ ) &#123;
		dp[i][<span class="hljs-number">0</span>] =  i;
	&#125;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++ ) &#123;
		dp[<span class="hljs-number">0</span>][j] =  j;
	&#125;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; m; i++ ) &#123;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; n; j++ ) &#123;
			<span class="hljs-keyword">if</span>(word1[i-<span class="hljs-number">1</span>] == word2[j-<span class="hljs-number">1</span>]) &#123;
				dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]
			&#125; <span class="hljs-keyword">else</span> &#123;
				dp[i][j] = <span class="hljs-number">1</span> + <span class="hljs-built_in">Math</span>.min(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>])
			&#125;
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>]
&#125;;</code></pre>

<h3 id="6-无重复字符的最长子串"><a href="#6-无重复字符的最长子串" class="headerlink" title="6 无重复字符的最长子串"></a>6 无重复字符的最长子串</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 6 无重复字符的最长子串 3</span>
<span class="hljs-comment">// 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</span>
<span class="hljs-comment">// 示例 1:</span>
<span class="hljs-comment">// 输入: s = &quot;abcabcbb&quot;</span>
<span class="hljs-comment">// 输出: 3 </span>
<span class="hljs-comment">// 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span>
<span class="hljs-comment">// 示例 2:</span>
<span class="hljs-comment">// 输入: s = &quot;bbbbb&quot;</span>
<span class="hljs-comment">// 输出: 1</span>
<span class="hljs-comment">// 解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span>
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 解题思路：</span>
<span class="hljs-comment"> * 1、用双指针维护一个滑动窗口，从来剪切子串</span>
<span class="hljs-comment"> * 2、不断移动右指针，遇到重复字符串，就把左指针移动到重复字符串的下一位</span>
<span class="hljs-comment"> * 3、移动右指针的过程中，记录所有窗口的长度，并返回最大值</span>
<span class="hljs-comment"> * 时间复杂度： O(n)</span>
<span class="hljs-comment"> * 空间复杂度： O(m)  m是字符串s不重复字符的个数</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">var</span> lengthOfLongestSubstring = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;
	<span class="hljs-keyword">if</span>(!s) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
	<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;
		<span class="hljs-keyword">if</span> (m.has(s[i]) &amp;&amp; m.get(s[i]) &gt;= l) &#123;
			l = m.get(s[i]) + <span class="hljs-number">1</span>;
		&#125;
		m.set(s[i], i);
		res = <span class="hljs-built_in">Math</span>.max(res, i - l + <span class="hljs-number">1</span>);
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 7 整数转罗马数字 12</span>
<span class="hljs-comment">// 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</span>
<span class="hljs-comment">// 字符          数值</span>
<span class="hljs-comment">// I             1</span>
<span class="hljs-comment">// V             5</span>
<span class="hljs-comment">// X             10</span>
<span class="hljs-comment">// L             50</span>
<span class="hljs-comment">// C             100</span>
<span class="hljs-comment">// D             500</span>
<span class="hljs-comment">// M             1000</span>
<span class="hljs-comment">// 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。</span>
<span class="hljs-comment">// 27 写做  XXVII, 即为 XX + V + II 。</span>
<span class="hljs-comment">// 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，</span>
<span class="hljs-comment">// 例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。</span>
<span class="hljs-comment">// 同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</span>
<span class="hljs-comment">//  - I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</span>
<span class="hljs-comment">//  - X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </span>
<span class="hljs-comment">//  - C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</span>
<span class="hljs-comment">// 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</span>
<span class="hljs-comment">// 示例 1:</span>
<span class="hljs-comment">// 输入: 3</span>
<span class="hljs-comment">// 输出: &quot;III&quot;</span>
<span class="hljs-comment">// 示例 2:</span>
<span class="hljs-comment">// 输入: 4</span>
<span class="hljs-comment">// 输出: &quot;IV&quot;</span>
<span class="hljs-comment">// 示例 3:</span>
<span class="hljs-comment">// 输入: 9</span>
<span class="hljs-comment">// 输出: &quot;IX&quot;</span>
<span class="hljs-comment">// 示例 4:</span>
<span class="hljs-comment">// 输入: 58</span>
<span class="hljs-comment">// 输出: &quot;LVIII&quot;</span>
<span class="hljs-comment">// 解释: L = 50, V = 5, III = 3.</span>
<span class="hljs-comment">// 示例 5:</span>
<span class="hljs-comment">// 输入: 1994</span>
<span class="hljs-comment">// 输出: &quot;MCMXCIV&quot;</span>
<span class="hljs-comment">// 解释: M = 1000, CM = 900, XC = 90, IV = 4.</span>
<span class="hljs-comment">// var intToRoman = function (num) &#123;</span>
<span class="hljs-comment">//     let keys = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],</span>
<span class="hljs-comment">//         values = [&#x27;M&#x27;, &#x27;CM&#x27;, &#x27;D&#x27;, &#x27;CD&#x27;, &#x27;C&#x27;, &#x27;XC&#x27;, &#x27;L&#x27;, &#x27;XL&#x27;, &#x27;X&#x27;, &#x27;IX&#x27;, &#x27;V&#x27;, &#x27;IV&#x27;, &#x27;I&#x27;];</span>
<span class="hljs-comment">//     let res = &quot;&quot;;</span>
<span class="hljs-comment">//     for (let i = 0; i &lt; keys.length; i++) &#123;</span>
<span class="hljs-comment">//         while (num &gt;= keys[i]) &#123;</span>
<span class="hljs-comment">//             num -= keys[i];</span>
<span class="hljs-comment">//             res += values[i];</span>
<span class="hljs-comment">//         &#125;</span>
<span class="hljs-comment">//     &#125;</span>
<span class="hljs-comment">//     return res;</span>
<span class="hljs-comment">// &#125;;</span>
<span class="hljs-keyword">var</span> intToRoman = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) </span>&#123;
	<span class="hljs-keyword">let</span> keys = [<span class="hljs-number">1000</span>, <span class="hljs-number">900</span>, <span class="hljs-number">500</span>, <span class="hljs-number">400</span>, <span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">50</span>, <span class="hljs-number">40</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>];
	<span class="hljs-keyword">const</span> values = [<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-string">&#x27;CM&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;CD&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;XC&#x27;</span>,<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-string">&#x27;XL&#x27;</span>,<span class="hljs-string">&#x27;X&#x27;</span>,<span class="hljs-string">&#x27;IX&#x27;</span>,<span class="hljs-string">&#x27;V&#x27;</span>,<span class="hljs-string">&#x27;IV&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>];
	<span class="hljs-keyword">let</span> result = <span class="hljs-string">&#x27;&#x27;</span>;
	<span class="hljs-keyword">while</span>(num)&#123;
		<span class="hljs-keyword">if</span>(num &gt;= keys[<span class="hljs-number">0</span>])&#123;
			result += values[<span class="hljs-number">0</span>];
			num -= keys[<span class="hljs-number">0</span>];
		&#125;<span class="hljs-keyword">else</span>&#123;
			keys.shift();
			values.shift();
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> result;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 8 罗马数字转整数 13</span>
<span class="hljs-keyword">var</span> romanToInt = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;
	<span class="hljs-keyword">const</span> map = &#123;
		<span class="hljs-string">&quot;I&quot;</span>: <span class="hljs-number">1</span>,
		<span class="hljs-string">&quot;V&quot;</span>: <span class="hljs-number">5</span>,
		<span class="hljs-string">&quot;X&quot;</span>: <span class="hljs-number">10</span>,
		<span class="hljs-string">&quot;L&quot;</span>: <span class="hljs-number">50</span>,
		<span class="hljs-string">&quot;C&quot;</span>: <span class="hljs-number">100</span>,
		<span class="hljs-string">&quot;D&quot;</span>: <span class="hljs-number">500</span>,
		<span class="hljs-string">&quot;M&quot;</span>: <span class="hljs-number">1000</span>
	&#125;
	<span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++)&#123;
		map[s[i]] &lt; map[s[i+<span class="hljs-number">1</span>]] ?
			result -= map[s[i]] : result += map[s[i]];
	&#125;
	<span class="hljs-keyword">return</span> result;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 9 最小路径和 64</span>
<span class="hljs-comment">// 给定一个包含非负整数的 m x n 网格 grid ，</span>
<span class="hljs-comment">// 请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</span>
<span class="hljs-comment">// 说明：每次只能向下或者向右移动一步。</span>

<span class="hljs-comment">// 动态规划</span>
<span class="hljs-keyword">var</span> minPathSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">grid</span>) </span>&#123;
	<span class="hljs-keyword">let</span> m = grid.length;
	<span class="hljs-keyword">let</span> n = grid[<span class="hljs-number">0</span>].length;
	<span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(m);
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;
		arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-number">0</span>);
	&#125;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;
		<span class="hljs-keyword">const</span> subArr = grid[i];
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; subArr.length; j++) &#123;
			<span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>) &#123;
				arr[i][j] = j === <span class="hljs-number">0</span> ? subArr[<span class="hljs-number">0</span>] : arr[i][j - <span class="hljs-number">1</span>] + subArr[j];
			&#125; <span class="hljs-keyword">else</span> &#123;
				<span class="hljs-keyword">if</span> (j === <span class="hljs-number">0</span>) &#123;
					arr[i][j] = arr[i - <span class="hljs-number">1</span>][j] + subArr[j];
				&#125; <span class="hljs-keyword">else</span> &#123;
					<span class="hljs-keyword">const</span> tem = <span class="hljs-built_in">Math</span>.min(arr[i - <span class="hljs-number">1</span>][j], arr[i][j - <span class="hljs-number">1</span>]);
					arr[i][j] = subArr[j] + tem;
				&#125;
			&#125;
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> arr[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 10 最长公共前缀 14</span>
<span class="hljs-comment">// 编写一个函数来查找字符串数组中的最长公共前缀。</span>
<span class="hljs-comment">// 如果不存在公共前缀，返回空字符串 &quot;&quot;。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span>
<span class="hljs-comment">// 输出：&quot;fl&quot;</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span>
<span class="hljs-comment">// 输出：&quot;&quot;</span>
<span class="hljs-comment">// 解释：输入不存在公共前缀。</span>

<span class="hljs-keyword">var</span> longestCommonPrefix = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">strs</span>) </span>&#123;
	<span class="hljs-keyword">let</span> str = strs[<span class="hljs-number">0</span>]
	<span class="hljs-keyword">if</span>(!str) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>
	<span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++)&#123;
		<span class="hljs-keyword">let</span> flag = strs.every(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item[i] == str[i]);
		<span class="hljs-keyword">if</span> (flag) &#123;
			res += str[i];
		&#125;<span class="hljs-keyword">else</span> &#123;
			<span class="hljs-keyword">return</span> res;
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> res
&#125;;</code></pre>

<h3 id="11-最小覆盖子串"><a href="#11-最小覆盖子串" class="headerlink" title="11 最小覆盖子串"></a>11 最小覆盖子串</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 11 最小覆盖子串 76</span>
<span class="hljs-comment">// 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串</span>
<span class="hljs-comment">// 如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。</span>
<span class="hljs-comment">// 注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span>
<span class="hljs-comment">// 输出：&quot;BANC&quot;</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：s = &quot;a&quot;, t = &quot;a&quot;</span>
<span class="hljs-comment">// 输出：&quot;a&quot;</span>
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 用双指针维护一个滑动窗口</span>
<span class="hljs-comment"> * 移动右指针，直到找到包含t的所有子串，此时再移动左指针，尽量减少包含t的子串的长度。</span>
<span class="hljs-comment"> * 时间复杂度:  O(m + n) ,m是t的长度,n是s的长度</span>
<span class="hljs-comment"> * 空间复杂度:  O(m) ,m是t中不同字符的个数</span>
<span class="hljs-comment"> */</span>

<span class="hljs-keyword">var</span> minWindow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;
	<span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>; <span class="hljs-comment">// 左指针</span>
	<span class="hljs-keyword">let</span> r = <span class="hljs-number">0</span>; <span class="hljs-comment">// 右指针</span>
	<span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(); <span class="hljs-comment">// 保存t的map对象</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> t) &#123;
		m.set(item, m.has(item) ? m.get(item) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);
	&#125;
	<span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span>; <span class="hljs-comment">// 结果值</span>
	<span class="hljs-keyword">let</span> size = m.size; <span class="hljs-comment">// 记录</span>
	<span class="hljs-keyword">while</span>(r &lt; s.length)&#123;
		<span class="hljs-keyword">const</span> ri = s[r];
		<span class="hljs-comment">// 记录右指针移动中对 m 和 size 的影响</span>
		<span class="hljs-keyword">if</span> (m.has(ri)) &#123;
			m.set(ri, m.get(ri) - <span class="hljs-number">1</span>);
			<span class="hljs-keyword">if</span>(m.get(ri) === <span class="hljs-number">0</span>) size-- ;
		&#125;
		<span class="hljs-comment">// 当 size = 0 表示 s 从 l 到 r 正好涵盖 t</span>
		<span class="hljs-keyword">while</span> (size === <span class="hljs-number">0</span>) &#123;
			<span class="hljs-comment">// 记录子串</span>
			<span class="hljs-keyword">let</span> sub = s.substring(l, r + <span class="hljs-number">1</span>);
			res = !res || sub.length &lt; res.length ? sub : res;
			<span class="hljs-comment">// 记录左指针移动中对 m 和 size 的影响</span>
			<span class="hljs-keyword">const</span> li = s[l];
			<span class="hljs-keyword">if</span> (m.has(li)) &#123;
				m.set(li, m.get(li) + <span class="hljs-number">1</span>);
				<span class="hljs-keyword">if</span>(m.get(li) === <span class="hljs-number">1</span>) size ++;
			&#125;
			l++;
		&#125;
		r++;
	&#125;
	<span class="hljs-keyword">return</span> res; 
&#125;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 12 单词拆分 139</span>
<span class="hljs-comment">// 给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</span>
<span class="hljs-comment">// 说明：</span>
<span class="hljs-comment">// 1. 拆分时可以重复使用字典中的单词。</span>
<span class="hljs-comment">// 2. 你可以假设字典中没有重复的单词。</span>

<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span>
<span class="hljs-comment">// 输出: true</span>
<span class="hljs-comment">// 解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span>

<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span>
<span class="hljs-comment">// 输出: true</span>
<span class="hljs-comment">// 解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span>
<span class="hljs-comment">//      注意你可以重复使用字典中的单词。</span>

<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span>
<span class="hljs-comment">// 输出: false</span>

<span class="hljs-comment">// 动态规划， 从后往前扫描</span>
<span class="hljs-keyword">var</span> wordBreak = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s, wordDict</span>) </span>&#123;
	<span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(wordDict);
	<span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(s.length + <span class="hljs-number">1</span>).fill(<span class="hljs-literal">false</span>);
	dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= s.length; i++) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;
			<span class="hljs-keyword">if</span> (dp[i] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">const</span> subStr = s.slice(j, i);
			<span class="hljs-keyword">if</span> (set.has(subStr) &amp;&amp; dp[j]) &#123;
				dp[i] = <span class="hljs-literal">true</span>;
				<span class="hljs-keyword">break</span>;
			&#125;
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> dp[s.length];
&#125;;

<span class="hljs-comment">// 解法二： DFS</span>
<span class="hljs-keyword">const</span> wordBreak = <span class="hljs-function">(<span class="hljs-params">s, wordDict</span>) =&gt;</span> &#123;
	<span class="hljs-keyword">const</span> len = s.length;
	<span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(wordDict);
	<span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len);

	<span class="hljs-keyword">const</span> dfs = <span class="hljs-function"><span class="hljs-params">startIndex</span> =&gt;</span> &#123;
		<span class="hljs-keyword">if</span> (startIndex == len) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		<span class="hljs-comment">// memo中有，就用memo中的</span>
		<span class="hljs-keyword">if</span> (buffer[startIndex] !== <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">return</span> buffer[startIndex];

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = startIndex + <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;
			<span class="hljs-keyword">const</span> subStr = s.slice(startIndex, i);
			<span class="hljs-keyword">if</span> (set.has(subStr) &amp;&amp; dfs(i)) &#123;
				buffer[startIndex] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 当前递归的结果存一下</span>
				<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
			&#125;
		&#125;
		buffer[startIndex] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 当前递归的结果存一下</span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	&#125;;
	<span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>);
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 13 100层丢鸡蛋</span>
<span class="hljs-comment">// 有2个鸡蛋，可能在任意一层丢下刚好会摔破</span>
<span class="hljs-comment">// 现在假设有num层，找到最少尝试的次数m</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFlort</span>(<span class="hljs-params">num</span>) </span>&#123;
	<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span>(i &lt; num) &#123;
		<span class="hljs-keyword">let</span> t = i;
		<span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">while</span>(t &gt; <span class="hljs-number">0</span> &amp;&amp; sum &lt; num) &#123;
			sum += t;
			<span class="hljs-keyword">if</span> (sum + (t - <span class="hljs-number">1</span>) &gt; num) &#123;
				<span class="hljs-keyword">return</span> i;
			&#125;
			t--;
		&#125;
		i++;
	&#125;
&#125;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 14 较大分组的位置 830</span>
<span class="hljs-comment">// 在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。</span>
<span class="hljs-comment">// 例如，在字符串 s = &quot;abbxxxxzyy&quot; 中，就含有 &quot;a&quot;, &quot;bb&quot;, &quot;xxxx&quot;, &quot;z&quot; 和 &quot;yy&quot; 这样的一些分组。</span>
<span class="hljs-comment">// 分组可以用区间 [start, end] 表示，其中 start 和 end </span>
<span class="hljs-comment">//    分别表示该分组的起始和终止位置的下标。上例中的 &quot;xxxx&quot; 分组用区间表示为 [3,6] 。</span>
<span class="hljs-comment">// 我们称所有包含大于或等于三个连续字符的分组为 较大分组 。</span>

<span class="hljs-comment">// 找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：s = &quot;abbxxxxzzy&quot;</span>
<span class="hljs-comment">// 输出：[[3,6]]</span>
<span class="hljs-comment">// 解释：&quot;xxxx&quot; 是一个起始于 3 且终止于 6 的较大分组。</span>

<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：s = &quot;abc&quot;</span>
<span class="hljs-comment">// 输出：[]</span>
<span class="hljs-comment">// 解释：&quot;a&quot;,&quot;b&quot; 和 &quot;c&quot; 均不是符合要求的较大分组。</span>

<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入：s = &quot;abcdddeeeeaabbbcd&quot;</span>
<span class="hljs-comment">// 输出：[[3,5],[6,9],[12,14]]</span>
<span class="hljs-comment">// 解释：较大分组为 &quot;ddd&quot;, &quot;eeee&quot; 和 &quot;bbb&quot;</span>

<span class="hljs-comment">// 示例 4：</span>
<span class="hljs-comment">// 输入：s = &quot;aba&quot;</span>
<span class="hljs-comment">// 输出：[]</span>

<span class="hljs-comment">// 解法一: 双指针</span>
<span class="hljs-keyword">var</span> largeGroupPositions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;
	<span class="hljs-keyword">let</span> res = [];
	<span class="hljs-keyword">if</span> (!s) <span class="hljs-keyword">return</span> res;
	<span class="hljs-keyword">let</span> p1 = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">while</span>(p1 &lt; s.length - <span class="hljs-number">1</span>) &#123;
		<span class="hljs-keyword">let</span> p2 = p1 + <span class="hljs-number">1</span>;
		<span class="hljs-keyword">while</span>(s[p1] === s[p2]) &#123;
			p2++;
		&#125;
		<span class="hljs-keyword">if</span>(p2 - p1 &gt;= <span class="hljs-number">3</span> ) &#123;
			res.push([p1, p2 - <span class="hljs-number">1</span>]);
			p1 = p2;
		&#125; <span class="hljs-keyword">else</span> &#123;
			p1++;
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;

<span class="hljs-comment">// 解法二: 正则:matchAll —— ([a-z])捕获小写字母，\1反向引用刚才捕获的字母，&#123;2,&#125;该字母又出现&gt;=2次</span>
<span class="hljs-keyword">var</span> largeGroupPositions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;
	<span class="hljs-keyword">const</span> res = [];
	<span class="hljs-keyword">const</span> iterator = s.matchAll(<span class="hljs-regexp">/([a-z])\1&#123;2,&#125;/g</span>);
	<span class="hljs-keyword">let</span> ite = iterator.next();
	<span class="hljs-comment">// ite.done = false,表示迭代器还没有结束</span>
	<span class="hljs-keyword">while</span> (!ite.done) &#123;
		<span class="hljs-comment">// res = &#123; done: false, value: &#123;0: &#x27;bbb&#x27;, 1: &#x27;b&#x27;, index: 2, input: &quot;aabbbcccdddddeeeeee&quot;&#125;&#125;</span>
		res.push([ite.value.index, ite.value.index + ite.value[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>])
		ite = iterator.next();
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;

<span class="hljs-comment">// 解法三 正则:replace  \1反向引用刚才捕获的字母，&#123;2,&#125;该字母又出现&gt;=2次</span>
<span class="hljs-keyword">var</span> largeGroupPositions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;
	<span class="hljs-keyword">const</span> r = [];
	s.replace(<span class="hljs-regexp">/([a-z])\1&#123;2,&#125;/g</span>, <span class="hljs-function">(<span class="hljs-params">a, _, i</span>)=&gt;</span> r.push([i, i + a.length - <span class="hljs-number">1</span>]));
	<span class="hljs-keyword">return</span> r;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 15 下划线与驼峰互换</span>

<span class="hljs-comment">// 解法一 正则 replace</span>
<span class="hljs-comment">// 1-1.驼峰式转下横线：</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerLine</span>(<span class="hljs-params">str</span>) </span>&#123;
	<span class="hljs-keyword">var</span> resStr = str.replace(<span class="hljs-regexp">/[A-Z]/g</span>, <span class="hljs-function"><span class="hljs-params">match</span> =&gt;</span> <span class="hljs-string">&quot;_&quot;</span> + match.toLowerCase());
	<span class="hljs-comment">//如果首字母是大写，执行replace时会多一个_ ,这里需要去掉</span>
  	<span class="hljs-keyword">if</span>(resStr.slice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) === <span class="hljs-string">&#x27;_&#x27;</span>) &#123; <span class="hljs-comment">// resStr.startsWith(&#x27;_&#x27;)</span>
  		resStr = resStr.slice(<span class="hljs-number">1</span>);
  	&#125;
	<span class="hljs-keyword">return</span> resStr;
&#125;;
<span class="hljs-comment">// test:</span>
toLowerLine(<span class="hljs-string">&quot;TestToLowerLine&quot;</span>);  <span class="hljs-comment">//test_to_lower_line</span>
toLowerLine(<span class="hljs-string">&quot;testToLowerLine&quot;</span>);  <span class="hljs-comment">//test_to_lower_line</span>

<span class="hljs-comment">// 1-2.下横线转驼峰式：</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toCamel</span>(<span class="hljs-params">str</span>) </span>&#123;
  	<span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/([^_])(?:_+([^_]))/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">match, $<span class="hljs-number">1</span>, $<span class="hljs-number">2</span></span>) </span>&#123;
		<span class="hljs-comment">// match=t_b, $1=t, $2=b</span>
		<span class="hljs-comment">// match=e_c, $1=e, $2=c</span>
		<span class="hljs-keyword">return</span> $<span class="hljs-number">1</span> + $<span class="hljs-number">2.</span>toUpperCase();
  	&#125;);
&#125;
<span class="hljs-comment">// test</span>
toCamel(<span class="hljs-string">&#x27;test_be_camel&#x27;</span>) <span class="hljs-comment">// testBeCamel</span>

<span class="hljs-comment">// 解法二: reduce</span>
<span class="hljs-comment">// 2-1.驼峰式转下横线：</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerLine</span>(<span class="hljs-params">str</span>)</span>&#123;
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.reduce.call(str, <span class="hljs-function">(<span class="hljs-params">pre, cur, index</span>) =&gt;</span> &#123;
		<span class="hljs-keyword">if</span>(<span class="hljs-regexp">/[A-Z]/</span>.test(cur))&#123;
			cur = cur.toLowerCase();
			<span class="hljs-keyword">return</span> index === <span class="hljs-number">0</span> ? pre + cur :  pre + <span class="hljs-string">&#x27;_&#x27;</span> + cur
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-keyword">return</span> pre + cur;
		&#125;
	&#125;, <span class="hljs-string">&#x27;&#x27;</span>)
&#125;
<span class="hljs-comment">// test</span>
toLowerLine(<span class="hljs-string">&#x27;TestToLowerLine&#x27;</span>); <span class="hljs-comment">// test_to_lower_line</span>

<span class="hljs-comment">// 2-2.下横线转驼峰式：</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toCamel</span>(<span class="hljs-params">str</span>) </span>&#123;
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.reduce.call(str, <span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> &#123;
		<span class="hljs-keyword">if</span> (pre.endsWith(<span class="hljs-string">&#x27;_&#x27;</span>)) &#123;
			<span class="hljs-keyword">return</span> pre.substring(<span class="hljs-number">0</span>, pre.length - <span class="hljs-number">1</span>) + cur.toUpperCase();
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-keyword">return</span> pre + cur;
		&#125;
	&#125;)
&#125;
<span class="hljs-comment">// test</span>
toCamel(<span class="hljs-string">&#x27;test_to_camel&#x27;</span>); <span class="hljs-comment">// testToCamel</span>

<span class="hljs-comment">// 解法三: Array.map()</span>
<span class="hljs-comment">// 3-1.驼峰式转下横线：</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerLine</span>(<span class="hljs-params">arr</span>)</span>&#123;
	<span class="hljs-comment">// return [].map.call(arr, doLowerLine).join(&#x27;&#x27;);</span>
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.map.call(arr, <span class="hljs-function">(<span class="hljs-params">val, index</span>) =&gt;</span> &#123;
		<span class="hljs-keyword">if</span>(<span class="hljs-regexp">/[A-Z]/</span>.test(val))&#123;
			<span class="hljs-keyword">return</span> index === <span class="hljs-number">0</span> ? val.toLowerCase() : <span class="hljs-string">&#x27;_&#x27;</span> + val.toLowerCase();
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-keyword">return</span> val;
		&#125;
	&#125;).join(<span class="hljs-string">&#x27;&#x27;</span>);
&#125;</code></pre>

<h3 id="16-Z-字形变换"><a href="#16-Z-字形变换" class="headerlink" title="16 Z 字形变换"></a>16 Z 字形变换</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 16 Z 字形变换 6</span>
<span class="hljs-comment">// 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</span>
<span class="hljs-comment">// 比如输入字符串为 &quot;PAYPALISHIRING&quot; 行数为 3 时，排列如下：</span>
<span class="hljs-comment">// P   A   H   N</span>
<span class="hljs-comment">// A P L S I I G</span>
<span class="hljs-comment">// Y   I   R</span>
<span class="hljs-comment">// 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;PAHNAPLSIIGYIR&quot;。</span>

<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3</span>
<span class="hljs-comment">// 输出：&quot;PAHNAPLSIIGYIR&quot;</span>

<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4</span>
<span class="hljs-comment">// 输出：&quot;PINALSIGYAHRPI&quot;</span>
<span class="hljs-comment">// 解释：</span>
<span class="hljs-comment">// P     I    N</span>
<span class="hljs-comment">// A   L S  I G</span>
<span class="hljs-comment">// Y A   H R</span>
<span class="hljs-comment">// P     I</span>

<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入：s = &quot;A&quot;, numRows = 1</span>
<span class="hljs-comment">// 输出：&quot;A&quot;</span>
<span class="hljs-keyword">var</span> convert = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, numRows</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (numRows === <span class="hljs-number">1</span>) &#123;
		<span class="hljs-keyword">return</span> s;
	&#125;
	<span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(numRows).fill(<span class="hljs-string">&#x27;&#x27;</span>);
	<span class="hljs-keyword">const</span> n = <span class="hljs-number">2</span> * numRows - <span class="hljs-number">2</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;
		<span class="hljs-keyword">const</span> index = <span class="hljs-built_in">Math</span>.min(i % n, n - i % n);
		arr[index] += s[i]
	&#125;
	<span class="hljs-keyword">return</span> arr.join(<span class="hljs-string">&#x27;&#x27;</span>);
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 17 不同的路径 62</span>
<span class="hljs-comment">// 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</span>
<span class="hljs-comment">// 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</span>
<span class="hljs-comment">// 问总共有多少条不同的路径？</span>

<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：m = 3, n = 7</span>
<span class="hljs-comment">// 输出：28</span>

<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：m = 3, n = 2</span>
<span class="hljs-comment">// 输出：3</span>
<span class="hljs-comment">// 解释：</span>
<span class="hljs-comment">// 从左上角开始，总共有 3 条路径可以到达右下角。</span>
<span class="hljs-comment">// 1. 向右 -&gt; 向下 -&gt; 向下</span>
<span class="hljs-comment">// 2. 向下 -&gt; 向下 -&gt; 向右</span>
<span class="hljs-comment">// 3. 向下 -&gt; 向右 -&gt; 向下</span>

<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入：m = 7, n = 3</span>
<span class="hljs-comment">// 输出：28</span>

<span class="hljs-comment">// 示例 4：</span>
<span class="hljs-comment">// 输入：m = 3, n = 3</span>
<span class="hljs-comment">// 输出：6</span>

<span class="hljs-keyword">var</span> uniquePaths = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">m, n</span>) </span>&#123;
	<span class="hljs-comment">// 新建一个 m行 n列 的二维数组</span>
	<span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(m);
   <span class="hljs-comment">// 每一列的第一个值 置为1</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;
		arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n);
		arr[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
	&#125;
    <span class="hljs-comment">// 每一列的第一个值 置为1</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		arr[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;
	&#125;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;
			arr[i][j] = arr[i - <span class="hljs-number">1</span>][j] + arr[i][j - <span class="hljs-number">1</span>];
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> arr[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];
&#125;;

<span class="hljs-comment">// var uniquePaths = function(m, n) &#123;</span>
<span class="hljs-comment">// 	let res = 1;</span>
<span class="hljs-comment">// 	for (let x = n, y = 1; y &lt; m; ++x, ++y) &#123;</span>
<span class="hljs-comment">// 		res = Math.floor(res * x / y);</span>
<span class="hljs-comment">// 	&#125;</span>
<span class="hljs-comment">// 	return res;</span>
<span class="hljs-comment">// &#125;;</span></code></pre>

<h2 id="五-链表"><a href="#五-链表" class="headerlink" title="五 链表"></a>五 链表</h2><p>1 反转链表<br>2 两数相加<br>3 删除链表的倒数第 N 个结点<br>4 合并两个有序链表<br>5 两两交换链表中的节点 —— 给定一个链表，两两交换其中相邻的节点<br>6 相交链表 —— 找到两个单链表相交的起始节点<br>7 回文链表 —— 判断一个链表是否为回文链表<br>8 合并K个升序链表 —— 将n个升序链表合并的一个链表<br>9 排序链表 —— 将链表升序排列</p>
<h3 id="1-反转链表"><a href="#1-反转链表" class="headerlink" title="1 反转链表"></a>1 反转链表</h3><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1 反转链表 206</span>
<span class="hljs-comment">// 反转一个单链表。</span>
<span class="hljs-comment">// 示例:</span>
<span class="hljs-comment">// 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span>
<span class="hljs-comment">// 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span>
<span class="hljs-comment">// 进阶:</span>
<span class="hljs-comment">// 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</span>

<span class="hljs-keyword">var</span> reverseList = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;
    <span class="hljs-keyword">let</span> p1 = head;
    <span class="hljs-keyword">let</span> p2 = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">while</span>(p1) &#123;
        <span class="hljs-keyword">const</span> tmp = p1.next; 	<span class="hljs-comment">// 1. 临时存储当前指针后续内容</span>
        p1.next = p2;			<span class="hljs-comment">// 2. 反转链表</span>
        p2 = p1;					<span class="hljs-comment">// 3. 接收反转结果</span>
        p1 = tmp;					<span class="hljs-comment">// 4. 接回临时存储的后续内容</span>
    &#125;
    <span class="hljs-keyword">return</span> p2;
&#125;;

<span class="hljs-comment">// 反转链表 II 92</span>
<span class="hljs-comment">// 给你单链表的头指针 head 和两个整数 left 和 right ，</span>
<span class="hljs-comment">// 其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 </span>

<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：head = [1,2,3,4,5], left = 2, right = 4</span>
<span class="hljs-comment">// 输出：[1,4,3,2,5]</span>

<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：head = [5], left = 1, right = 1</span>
<span class="hljs-comment">// 输出：[5]</span>

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Definition for singly-linked list.</span>
<span class="hljs-comment"> * function ListNode(val, next) &#123;</span>
<span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span>
<span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span>
<span class="hljs-comment"> * &#125;</span>
<span class="hljs-comment"> */</span>
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">left</span></span></span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">right</span></span></span>
<span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span>
<span class="hljs-comment"> */</span>

<span class="hljs-comment">// 解法一: 把原链表 分割，再反转，再拼接</span>
<span class="hljs-keyword">var</span> reverseBetween = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head, left, right</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (left === right) <span class="hljs-keyword">return</span> head;
	<span class="hljs-keyword">let</span> p = head;
	<span class="hljs-keyword">let</span> res;
	<span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>;

	<span class="hljs-keyword">let</span> leftList = <span class="hljs-keyword">new</span> ListNode();
	<span class="hljs-keyword">let</span> p1 = leftList;

	<span class="hljs-keyword">let</span> midList = <span class="hljs-keyword">new</span> ListNode();
	<span class="hljs-keyword">let</span> p2 = midList;

	<span class="hljs-keyword">let</span> rightList = <span class="hljs-keyword">new</span> ListNode();
	<span class="hljs-keyword">let</span> p3 = rightList;

	<span class="hljs-comment">// 1 先找到 leftList、midList、rightList</span>
	<span class="hljs-keyword">while</span>(p) &#123;
		 <span class="hljs-keyword">if</span> (index &lt; left) &#123;
			  p1.next = <span class="hljs-keyword">new</span> ListNode(p.val);
			  p1 = p1.next;
		 &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &gt; right) &#123;
			  p3.next = <span class="hljs-keyword">new</span> ListNode(p.val);
			  p3 = p3.next;
		 &#125; <span class="hljs-keyword">else</span> &#123;
			  p2.next = <span class="hljs-keyword">new</span> ListNode(p.val);
			  p2 = p2.next;
		 &#125;
		 p = p.next;
		 index++;
	&#125;
	leftList = leftList.next;
	midList = midList.next;
	rightList = rightList.next;

	<span class="hljs-comment">// 2 将 midList 反转</span>
	<span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>;
	<span class="hljs-keyword">let</span> p4 = midList;
	<span class="hljs-keyword">while</span> (p4) &#123;
		<span class="hljs-keyword">let</span> tem = p4.next;
		p4.next = pre;
		pre = p4;
		p4 = tem;
	&#125;
	midList.next = rightList;

	<span class="hljs-comment">// 3 将 leftList、midList、rightList 组合 得到结果</span>
	<span class="hljs-keyword">if</span> (leftList) &#123;
		res = leftList;
		p1.next = pre;
	&#125; <span class="hljs-keyword">else</span> &#123;
		res = pre;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;;

<span class="hljs-comment">// 解法二: 找到反转的 位置，直接进行反转</span>
<span class="hljs-keyword">var</span> reverseBetween = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head, left, right</span>) </span>&#123;
	<span class="hljs-keyword">let</span> res = <span class="hljs-keyword">new</span> ListNode();
	res.next = head;

	<span class="hljs-keyword">let</span> pre = res;
	<span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (index &lt; left) &#123;
		pre = pre.next;
		index++;
	&#125;

	<span class="hljs-keyword">let</span> cur = pre.next;
	<span class="hljs-keyword">while</span>(index &lt; right) &#123;
		<span class="hljs-keyword">const</span> tem = cur.next;
		cur.next = tem.next;
		tem.next = pre.next;
		pre.next = tem;
		index++;
	&#125;

	<span class="hljs-keyword">return</span> res.next;
&#125;</code></pre>

<pre><code class="hljs javascript"><span class="hljs-comment">// 2 两数相加 (链表) 2</span>
<span class="hljs-comment">// 给你两个 非空 的链表，表示两个非负的整数</span>
<span class="hljs-comment">// 它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</span>
<span class="hljs-comment">// 请你将两个数相加，并以相同形式返回一个表示和的链表。</span>
<span class="hljs-comment">// 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：l1 = [2,4,3], l2 = [5,6,4]</span>
<span class="hljs-comment">// 输出：[7,0,8]</span>
<span class="hljs-comment">// 解释：342 + 465 = 807.</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：l1 = [0], l2 = [0]</span>
<span class="hljs-comment">// 输出：[0]</span>
<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span>
<span class="hljs-comment">// 输出：[8,9,9,9,0,0,0,1]</span>
<span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;
	<span class="hljs-keyword">const</span> l3 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);
	<span class="hljs-keyword">let</span> p1 = l1;
	<span class="hljs-keyword">let</span> p2 = l2;
	<span class="hljs-keyword">let</span> p3 = l3;
	<span class="hljs-keyword">let</span> carry = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">while</span>(p1 || p2) &#123;
		<span class="hljs-keyword">const</span> v1 = p1 ? p1.val : <span class="hljs-number">0</span>;
		<span class="hljs-keyword">const</span> v2 = p2 ? p2.val : <span class="hljs-number">0</span>;
		<span class="hljs-keyword">const</span> val = v1 + v2 + carry;
		carry = <span class="hljs-built_in">Math</span>.floor(val / <span class="hljs-number">10</span>);
		p3.next = <span class="hljs-keyword">new</span> ListNode(val % <span class="hljs-number">10</span>);
		<span class="hljs-keyword">if</span> (p1) p1 = p1.next;
		<span class="hljs-keyword">if</span> (p2) p2 = p2.next;
		p3 = p3.next;
	&#125;
	<span class="hljs-keyword">if</span> (carry) &#123;
		p3.next = <span class="hljs-keyword">new</span> ListNode(carry);
	&#125;
	<span class="hljs-keyword">return</span> l3.next;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 3 删除链表的倒数第 N 个结点  19</span>
<span class="hljs-comment">// 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</span>
<span class="hljs-comment">// 进阶：你能尝试使用一趟扫描实现吗？</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：head = [1,2,3,4,5], n = 2</span>
<span class="hljs-comment">// 输出：[1,2,3,5]</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：head = [1], n = 1</span>
<span class="hljs-comment">// 输出：[]</span>
<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入：head = [1,2], n = 1</span>
<span class="hljs-comment">// 输出：[1]]</span>
<span class="hljs-comment">// 找到删除节点的前一个节点</span>
<span class="hljs-keyword">var</span> removeNthFromEnd = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head, n</span>) </span>&#123;
	<span class="hljs-keyword">let</span> node = head;
	<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">while</span>(node) &#123;
		node = node.next;
		count++;
	&#125;
	count = count - n - <span class="hljs-number">1</span>;
	<span class="hljs-keyword">if</span> (count === -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> head.next;
	node = head;
	<span class="hljs-keyword">while</span>(count &gt; <span class="hljs-number">0</span>) &#123;
		node = node.next;
		count--;
	&#125;
	node.next = node.next.next;
	<span class="hljs-keyword">return</span> head;
&#125;;
</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 4 合并两个有序链表 21</span>
<span class="hljs-comment">// 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：l1 = [1,2,4], l2 = [1,3,4]</span>
<span class="hljs-comment">// 输出：[1,1,2,3,4,4]</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：l1 = [], l2 = []</span>
<span class="hljs-comment">// 输出：[]</span>
<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入：l1 = [], l2 = [0]</span>
<span class="hljs-comment">// 输出：[0]</span>
<span class="hljs-keyword">var</span> mergeTwoLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;
	<span class="hljs-keyword">let</span> l3 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-literal">null</span>);
	<span class="hljs-keyword">let</span> p1 = l1;
	<span class="hljs-keyword">let</span> p2 = l2;
	<span class="hljs-keyword">let</span> p3 = l3;
	<span class="hljs-keyword">while</span>(p1 &amp;&amp; p2) &#123;
		<span class="hljs-keyword">if</span> (p1.val &gt; p2.val) &#123;
			p3.next = p2;
			p2 = p2.next
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p1.val &lt;= p2.val) &#123;
			p3.next = p1;
			p1 = p1.next
		&#125;
		p3 = p3.next;
	&#125;
	p3.next = p1 ? p1 : p2;
	<span class="hljs-keyword">return</span> l3.next;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 5 两两交换链表中的节点 24</span>
<span class="hljs-comment">// 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</span>
<span class="hljs-comment">// 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：head = [1,2,3,4]</span>
<span class="hljs-comment">// 输出：[2,1,4,3]</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：head = []</span>
<span class="hljs-comment">// 输出：[]</span>
<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入：head = [1]</span>
<span class="hljs-comment">// 输出：[1]</span>
<span class="hljs-keyword">const</span> swapPairs = <span class="hljs-function">(<span class="hljs-params">head</span>) =&gt;</span> &#123;
	<span class="hljs-keyword">const</span> resNode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);
	resNode.next = head;
	<span class="hljs-keyword">let</span> prev = resNode;

	<span class="hljs-keyword">while</span> (head &amp;&amp; head.next) &#123;
		<span class="hljs-comment">// 临时保存head.next，因为head.next待会要改变</span>
		<span class="hljs-keyword">const</span> next = head.next;
		head.next = next.next;
		next.next = head;
		prev.next = next;  

		prev = head;      <span class="hljs-comment">// 指针更新</span>
		head = head.next; <span class="hljs-comment">// 指针更新</span>
	&#125;
	<span class="hljs-keyword">return</span> resNode.next;
&#125;;</code></pre>

<h3 id="6-相交链表"><a href="#6-相交链表" class="headerlink" title="6 相交链表"></a>6 相交链表</h3><pre><code class="hljs javaScript"><span class="hljs-comment">// 6 相交链表 160</span>
<span class="hljs-comment">// 编写一个程序，找到两个单链表相交的起始节点。</span>
<span class="hljs-comment">// 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span>

<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span>
<span class="hljs-comment">// 输出：Reference of the node with value = 8</span>
<span class="hljs-comment">// 输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span>
<span class="hljs-comment">// 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。</span>
<span class="hljs-comment">// 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span>

<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span>
<span class="hljs-comment">// 输出：Reference of the node with value = 2</span>
<span class="hljs-comment">// 输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span>
<span class="hljs-comment">// 从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span>
<span class="hljs-keyword">var</span> getIntersectionNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">headA, headB</span>) </span>&#123;
	<span class="hljs-comment">// 解法一: 对headA打标记</span>
	<span class="hljs-comment">// while(headA) &#123;</span>
	<span class="hljs-comment">//     headA.flag = true;</span>
	<span class="hljs-comment">//     headA = headA.next;</span>
	<span class="hljs-comment">// &#125;</span>
	<span class="hljs-comment">// while(headB) &#123;</span>
	<span class="hljs-comment">//     if(headB.flag) return headB;</span>
	<span class="hljs-comment">//     headB = headB.next;</span>
	<span class="hljs-comment">// &#125;</span>
	<span class="hljs-comment">// return null;</span>

	<span class="hljs-comment">// 解法二: 嵌套循环</span>
	<span class="hljs-comment">// let p1 = headA;</span>
	<span class="hljs-comment">// while(p1) &#123;</span>
	<span class="hljs-comment">//     let p2 = headB;</span>
	<span class="hljs-comment">//     while(p2) &#123;</span>
	<span class="hljs-comment">//         if (p1 === p2) &#123;</span>
	<span class="hljs-comment">//             return p1</span>
	<span class="hljs-comment">//         &#125;</span>
	<span class="hljs-comment">//         p2 = p2.next;</span>
	<span class="hljs-comment">//     &#125;</span>
	<span class="hljs-comment">//     p1 = p1.next;</span>
	<span class="hljs-comment">// &#125;</span>
	<span class="hljs-comment">// return null;</span>

	<span class="hljs-comment">// 解法三: 消除多余</span>
	<span class="hljs-keyword">let</span> p1 = headA;
	<span class="hljs-keyword">let</span> p2 = headB;
	<span class="hljs-keyword">while</span>(p1 || p2) &#123;
		<span class="hljs-keyword">if</span> (p1 === p2) &#123;
			<span class="hljs-keyword">return</span> p1;
		&#125;
		p1 = p1 === <span class="hljs-literal">null</span> ? headB : p1.next;
		p2 = p2 === <span class="hljs-literal">null</span> ? headA : p2.next;
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 7  回文链表 234</span>
<span class="hljs-comment">// 请判断一个链表是否为回文链表。</span>
<span class="hljs-comment">// 示例 1:</span>
<span class="hljs-comment">// 输入: 1-&gt;2</span>
<span class="hljs-comment">// 输出: false</span>
<span class="hljs-comment">// 示例 2:</span>
<span class="hljs-comment">// 输入: 1-&gt;2-&gt;2-&gt;1</span>
<span class="hljs-comment">// 输出: true</span>

<span class="hljs-comment">// 解法一</span>
<span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;
	<span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;&#x27;</span>;
	<span class="hljs-keyword">let</span> b = <span class="hljs-string">&#x27;&#x27;</span>;
	<span class="hljs-keyword">let</span> p = head;
	<span class="hljs-keyword">while</span>(p)&#123;
		a = a + p.val;
		b = p.val + b;
		p = p.next;
	&#125;
  	<span class="hljs-keyword">return</span> a === b;
&#125;;

<span class="hljs-comment">// 解法二</span>
<span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;
	<span class="hljs-keyword">let</span> left = head;
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverse</span>(<span class="hljs-params">right</span>) </span>&#123;
		<span class="hljs-keyword">if</span> (right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		<span class="hljs-keyword">let</span> res = traverse(right.next);
		res = res &amp;&amp; (right.val === left.val);
		left = left.next;
		<span class="hljs-keyword">return</span> res;
	&#125;
	<span class="hljs-keyword">return</span> traverse(head);
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 8 合并K个升序链表 23</span>
<span class="hljs-comment">// 给你一个链表数组，每个链表都已经按升序排列。</span>
<span class="hljs-comment">// 请你将所有链表合并到一个升序链表中，返回合并后的链表。</span>
<span class="hljs-comment">//  </span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：lists = [[1,4,5],[1,3,4],[2,6]]</span>
<span class="hljs-comment">// 输出：[1,1,2,3,4,4,5,6]</span>
<span class="hljs-comment">// 解释：链表数组如下：</span>
<span class="hljs-comment">// [</span>
<span class="hljs-comment">//   1-&gt;4-&gt;5,</span>
<span class="hljs-comment">//   1-&gt;3-&gt;4,</span>
<span class="hljs-comment">//   2-&gt;6</span>
<span class="hljs-comment">// ]</span>
<span class="hljs-comment">// 将它们合并到一个有序链表中得到。</span>
<span class="hljs-comment">// 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：lists = []</span>
<span class="hljs-comment">// 输出：[]</span>
<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入：lists = [[]]</span>
<span class="hljs-comment">// 输出：[]</span>
<span class="hljs-comment">/*</span>
<span class="hljs-comment">解法一：</span>
<span class="hljs-comment">	reduce，将链表数组中的每一个值放入新数组</span>
<span class="hljs-comment">	sort，以链表的val作参考冒泡排序</span>
<span class="hljs-comment">	reduceRight，从右向左遍历，将数组连成链表</span>
<span class="hljs-comment">*/</span>
<span class="hljs-comment">// 解法一：</span>
<span class="hljs-keyword">var</span> mergeKLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lists</span>) </span>&#123;
	<span class="hljs-keyword">return</span> lists.reduce(<span class="hljs-function">(<span class="hljs-params">p, n</span>) =&gt;</span> &#123;
		<span class="hljs-keyword">while</span> (n) &#123;
			p.push(n), n = n.next
		&#125;
		<span class="hljs-keyword">return</span> p
	&#125;, []).sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.val - b.val).reduceRight(<span class="hljs-function">(<span class="hljs-params">p, n</span>) =&gt;</span> (n.next = p, p = n, p), <span class="hljs-literal">null</span>)
&#125;;

<span class="hljs-comment">// 解法二：</span>
<span class="hljs-keyword">var</span> mergeKLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lists</span>) </span>&#123;
	<span class="hljs-keyword">let</span> mergeTwoLists = <span class="hljs-function">(<span class="hljs-params">l1, l2</span>) =&gt;</span> &#123;
		<span class="hljs-keyword">let</span> preHead = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);
		<span class="hljs-keyword">let</span> preNode = preHead;
		<span class="hljs-keyword">while</span>(l1 &amp;&amp; l2)&#123;
			<span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;
				preNode.next = l1;
				l1 = l1.next;
			&#125; <span class="hljs-keyword">else</span> &#123;
				preNode.next = l2;
				l2 = l2.next;
			&#125;
			preNode = preNode.next;
		&#125;
		preNode.next = l1 ? l1 : l2;
		<span class="hljs-keyword">return</span> preHead.next;
	&#125;
	<span class="hljs-keyword">let</span> n = lists.length;
	<span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	<span class="hljs-keyword">let</span> res = lists[<span class="hljs-number">0</span>];
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;
		<span class="hljs-keyword">if</span>(lists[i])&#123;
			res = mergeTwoLists(res, lists[i]);
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 9 排序链表148</span>
<span class="hljs-comment">// 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</span>

<span class="hljs-comment">// 解法一: 将对链表进行归并排序  比解法二更好、更快</span>
<span class="hljs-keyword">var</span> sortList = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (!head || !head.next) <span class="hljs-keyword">return</span> head;
	<span class="hljs-keyword">let</span> p = head;
	<span class="hljs-keyword">return</span> mergeList(p);
&#125;;

<span class="hljs-comment">// 归并排序 =&gt; o(n logn)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeList</span>(<span class="hljs-params">head</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (head.next) &#123;
		<span class="hljs-comment">// 找到中间节点</span>
		<span class="hljs-keyword">let</span> p1 = head;
		<span class="hljs-keyword">let</span> p2 = head.next;
		<span class="hljs-keyword">while</span>(p1 &amp;&amp; p2 &amp;&amp; p2.next) &#123;
			p1 = p1.next;
			p2 = p2.next.next;
		&#125;
		<span class="hljs-keyword">let</span> rightPart = p1.next;
		p1.next = <span class="hljs-literal">null</span>;

		<span class="hljs-keyword">const</span> left = mergeList(head);
		<span class="hljs-keyword">const</span> right = mergeList(rightPart);

		head = sortMerge(left, right);
	&#125;
	<span class="hljs-keyword">return</span> head;
&#125;

<span class="hljs-comment">// 合并两个有序链表</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sortMerge</span>(<span class="hljs-params">left, right</span>) </span>&#123;
	<span class="hljs-keyword">let</span> head = <span class="hljs-literal">null</span>;
	<span class="hljs-keyword">let</span> p = <span class="hljs-literal">null</span>;
	<span class="hljs-keyword">while</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) &#123;
		<span class="hljs-keyword">if</span> (left.val &lt; right.val) &#123;
			<span class="hljs-keyword">if</span> (!head) &#123;
				head = left;
				p = head;
			&#125; <span class="hljs-keyword">else</span> &#123;
				p.next = left;
				p = p.next;
			&#125;
			left = left.next;
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-keyword">if</span> (!head) &#123;
				head = right;
				p = head;
			&#125; <span class="hljs-keyword">else</span> &#123;
				p.next = right;
				p = p.next;
			&#125;
			right = right.next;
		&#125;
	&#125;
	p.next = left ? left : right;
	<span class="hljs-keyword">return</span> head;
&#125;

<span class="hljs-comment">// 解法二: 将链表转为数组,进行归并排序, 然后再转为链表</span>
<span class="hljs-keyword">var</span> sortList = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (!head || !head.next) <span class="hljs-keyword">return</span> head;
	<span class="hljs-keyword">let</span> p = head;
	<span class="hljs-keyword">let</span> arr = [];
	<span class="hljs-keyword">while</span>(p) &#123;
		arr.push(p);
		p = p.next;
	&#125;
	arr.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;
		item.next = <span class="hljs-literal">null</span>;
	&#125;)
	arr = mergeSort(arr);

	<span class="hljs-keyword">const</span> newHead = arr[<span class="hljs-number">0</span>];
	<span class="hljs-keyword">let</span> p1 = newHead;
	<span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span>(index &lt; arr.length) &#123;
		p1.next = arr[index];
		p1 = p1.next;
		index++;
	&#125;
	<span class="hljs-keyword">return</span> newHead;
&#125;;

<span class="hljs-keyword">var</span> mergeSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">1</span>) &#123;
		<span class="hljs-keyword">return</span> arr;
	&#125;
	<span class="hljs-keyword">const</span> mid = arr.length / <span class="hljs-number">2</span>;
	<span class="hljs-keyword">const</span> left = arr.slice(<span class="hljs-number">0</span>, mid);
	<span class="hljs-keyword">const</span> right = arr.slice(mid);

	<span class="hljs-keyword">let</span> leftPart = mergeSort(left);
	<span class="hljs-keyword">let</span> rightPart = mergeSort(right);

	<span class="hljs-keyword">const</span> res = [];
	<span class="hljs-keyword">while</span>(leftPart.length || rightPart.length) &#123;
		<span class="hljs-keyword">if</span> (leftPart.length &amp;&amp; rightPart.length) &#123;
			<span class="hljs-keyword">const</span> item = leftPart[<span class="hljs-number">0</span>].val &lt; rightPart[<span class="hljs-number">0</span>].val ? leftPart.shift() : rightPart.shift();
			res.push(item);
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (leftPart.length) &#123;
			res.push(leftPart.shift());
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rightPart.length) &#123;
			res.push(rightPart.shift());
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;</code></pre>

<h2 id="六-堆"><a href="#六-堆" class="headerlink" title="六 堆"></a>六 堆</h2><p>1 数组中的第K个最大元素<br>2 前K个高频元素<br>3 合并K个升序链表</p>
<p>堆是一种特殊的完全二叉树，所有的节点都大于等于（最大堆）或者 小于等于（最小堆）它的子节点。<br>堆的应用：</p>
<ul>
<li>堆能高效、快速的找出最大值和最小值——之间复杂度是 O(1)</li>
<li>找出第 K 个最大（小）值<ul>
<li>构建一个最小堆，并将元素一次插入堆中</li>
<li>当堆的容量超过 K，就删除堆顶</li>
<li>插入结束后，堆顶就是第 K 个最大元素</li>
</ul>
</li>
</ul>
<pre><code class="hljs javascript"><span class="hljs-comment">// 1 数组中的第K个最大元素 215</span>
<span class="hljs-comment">// 在未排序的数组中找到第 k 个最大的元素</span>
<span class="hljs-comment">// 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</span>
<span class="hljs-comment">// 示例 1:</span>
<span class="hljs-comment">// 输入: [3,2,1,5,6,4] 和 k = 2</span>
<span class="hljs-comment">// 输出: 5</span>
<span class="hljs-comment">// 示例 2:</span>
<span class="hljs-comment">// 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span>
<span class="hljs-comment">// 输出: 4</span>
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 解题思路：</span>
<span class="hljs-comment"> * 1、构建一个最小堆，并依次把数组的值插入堆中</span>
<span class="hljs-comment"> * 2、当堆的容量超过K， 就删除堆顶</span>
<span class="hljs-comment"> * 3、插入结束后，堆顶就是第K个最大元素</span>
<span class="hljs-comment"> * 时间复杂度： O(n * log(k))</span>
<span class="hljs-comment"> * 空间复杂度： O(k)</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinHead</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;
		<span class="hljs-built_in">this</span>.heap = [];
	&#125;
	<span class="hljs-function"><span class="hljs-title">insert</span>(<span class="hljs-params">value</span>)</span> &#123; <span class="hljs-comment">// 插入</span>
		<span class="hljs-built_in">this</span>.heap.push(value); <span class="hljs-comment">// 插入到底部</span>
		<span class="hljs-built_in">this</span>.shiftUp(<span class="hljs-built_in">this</span>.heap.length - <span class="hljs-number">1</span>);
	&#125;
	<span class="hljs-comment">// 删除堆顶</span>
	<span class="hljs-function"><span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span> &#123;
		<span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>] = <span class="hljs-built_in">this</span>.heap.pop();
		<span class="hljs-built_in">this</span>.shiftDown(<span class="hljs-number">0</span>); <span class="hljs-comment">// 下移操作</span>
	&#125;
	<span class="hljs-comment">// 获取堆顶</span>
	<span class="hljs-function"><span class="hljs-title">peek</span>(<span class="hljs-params"></span>)</span> &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>];
	&#125;
	<span class="hljs-comment">// 获取堆的大小</span>
	<span class="hljs-function"><span class="hljs-title">size</span>(<span class="hljs-params"></span>)</span> &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap.length;
	&#125;

	<span class="hljs-comment">// 获取父节点</span>
	<span class="hljs-function"><span class="hljs-title">getParentIndex</span>(<span class="hljs-params">i</span>)</span> &#123;
		<span class="hljs-comment">// return Math.floor((i - 1) / 2);</span>
		<span class="hljs-keyword">return</span> (i - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 把二进制的数字右移一位</span>
	&#125;
	<span class="hljs-comment">// 获取左侧子节点</span>
	<span class="hljs-function"><span class="hljs-title">getLeftIndex</span>(<span class="hljs-params">i</span>)</span> &#123;
		<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
	&#125;
	<span class="hljs-comment">// 获取右侧子节点</span>
	<span class="hljs-function"><span class="hljs-title">getRightIndex</span>(<span class="hljs-params">i</span>)</span> &#123;
		<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;
	&#125;
	<span class="hljs-comment">// 将两个节点的位置进行交换</span>
	<span class="hljs-function"><span class="hljs-title">swap</span>(<span class="hljs-params">i1, i2</span>)</span> &#123;
		<span class="hljs-keyword">const</span> temp = <span class="hljs-built_in">this</span>.heap[i1];
		<span class="hljs-built_in">this</span>.heap[i1] = <span class="hljs-built_in">this</span>.heap[i2];
		<span class="hljs-built_in">this</span>.heap[i2] = temp;
	&#125;
	<span class="hljs-comment">// 上移</span>
	<span class="hljs-function"><span class="hljs-title">shiftUp</span>(<span class="hljs-params">index</span>)</span> &#123;
		<span class="hljs-comment">// 递归的终点: 到达堆顶</span>
		<span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
		<span class="hljs-keyword">const</span> parentIndex = <span class="hljs-built_in">this</span>.getParentIndex(index);
		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.heap[parentIndex] &gt; <span class="hljs-built_in">this</span>.heap[index]) &#123;
			<span class="hljs-built_in">this</span>.swap(parentIndex, index);
			<span class="hljs-built_in">this</span>.shiftUp(parentIndex);
		&#125;
	&#125;
	<span class="hljs-comment">// 下移</span>
	<span class="hljs-function"><span class="hljs-title">shiftDown</span>(<span class="hljs-params">index</span>)</span> &#123;
		<span class="hljs-keyword">const</span> leftIndex = <span class="hljs-built_in">this</span>.getLeftIndex(index);
		<span class="hljs-keyword">const</span> rightIndex = <span class="hljs-built_in">this</span>.getRightIndex(index);
		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[leftIndex] &lt; <span class="hljs-built_in">this</span>.heap[index]) &#123;
			<span class="hljs-built_in">this</span>.swap(leftIndex, index);
			<span class="hljs-built_in">this</span>.shiftDown(leftIndex);
		&#125;
		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[rightIndex] &lt; <span class="hljs-built_in">this</span>.heap[index]) &#123;
			<span class="hljs-built_in">this</span>.swap(rightIndex, index);
			<span class="hljs-built_in">this</span>.shiftDown(rightIndex);
		&#125;
	&#125;
&#125;
<span class="hljs-keyword">var</span> findKthLargest = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;
	<span class="hljs-keyword">const</span> h1 = <span class="hljs-keyword">new</span> MinHead();
	nums.forEach(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> &#123;
		h1.insert(n);
		<span class="hljs-keyword">if</span>(h1.size() &gt; k) &#123;
			h1.pop();
		&#125;
	&#125;)
	<span class="hljs-keyword">return</span> h1.peek();
&#125;;

<span class="hljs-comment">// 解法二：排序</span>
<span class="hljs-keyword">let</span> findKthLargest = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;
	nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a).slice(<span class="hljs-number">0</span>, k);
	<span class="hljs-keyword">return</span> nums[k-<span class="hljs-number">1</span>]
&#125;;
<span class="hljs-comment">// 时间复杂度: O(n^2 log n) [Array.sort =&gt; O(n log n), Array.slice =&gt; O(n)]</span>
</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 2 前 K 个高频元素 347</span>
<span class="hljs-comment">// 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</span>
<span class="hljs-comment">// 示例 1:</span>
<span class="hljs-comment">// 输入: nums = [1,1,1,2,2,3], k = 2</span>
<span class="hljs-comment">// 输出: [1,2]</span>
<span class="hljs-comment">// 示例 2:</span>
<span class="hljs-comment">// 输入: nums = [1], k = 1</span>
<span class="hljs-comment">// 输出: [1]</span>
<span class="hljs-comment">// 提示：</span>
<span class="hljs-comment">// 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</span>
<span class="hljs-comment">// 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</span>
<span class="hljs-comment">// 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</span>
<span class="hljs-comment">// 你可以按任意顺序返回答案。</span>
<span class="hljs-keyword">var</span> topKFrequent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;
	<span class="hljs-comment">/**</span>
<span class="hljs-comment">    解法一：</span>
<span class="hljs-comment">        1、建立最小堆</span>
<span class="hljs-comment">		  2、当堆的容量超过K， 就删除堆顶</span>
<span class="hljs-comment">		  3、插入结束后，堆顶就是第K个最大元素</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">    时间复杂度： </span>
<span class="hljs-comment">        1、nums.forEach =&gt; O(n)</span>
<span class="hljs-comment">        2、map.forEach =&gt; O(n) 而 嵌套的 insert 和 pop 都是 logK, 结合起来就是 O(n log k)</span>
<span class="hljs-comment">        所以结合起来， 时间复杂度 就是 O(n log K) ，由于 k &lt; n 所有符合题目要求的</span>
<span class="hljs-comment">   */</span>
	<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
	nums.forEach(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> &#123;
		map.set(n, map.has(n) ? map.get(n) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);
	&#125;);
	<span class="hljs-keyword">const</span> h = <span class="hljs-keyword">new</span> MinHead();
	map.forEach(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;
		h.insert(&#123;value, key&#125;);
		<span class="hljs-keyword">if</span> (h.size() &gt; k) &#123;
			h.pop();
		&#125;
	&#125;)
	<span class="hljs-keyword">return</span> h.heap.map(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a.key)
    
&#125;;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinHead</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;
		<span class="hljs-built_in">this</span>.heap = [];
	&#125;
	<span class="hljs-function"><span class="hljs-title">insert</span>(<span class="hljs-params">value</span>)</span> &#123; <span class="hljs-comment">// 插入</span>
		<span class="hljs-built_in">this</span>.heap.push(value); <span class="hljs-comment">// 插入到底部</span>
		<span class="hljs-built_in">this</span>.shiftUp(<span class="hljs-built_in">this</span>.heap.length - <span class="hljs-number">1</span>); <span class="hljs-comment">// 上移</span>
	&#125;
	<span class="hljs-function"><span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 删除堆顶</span>
		<span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>] = <span class="hljs-built_in">this</span>.heap.pop(); 
		<span class="hljs-built_in">this</span>.shiftDown(<span class="hljs-number">0</span>); <span class="hljs-comment">// 下移</span>
	&#125;
	<span class="hljs-function"><span class="hljs-title">peek</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 获取堆顶</span>
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>];
	&#125;
	<span class="hljs-function"><span class="hljs-title">size</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 获取堆的大小</span>
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap.length;
	&#125;
	<span class="hljs-comment">// 获取父节点</span>
	<span class="hljs-function"><span class="hljs-title">getParentIndex</span>(<span class="hljs-params">i</span>)</span> &#123;
		<span class="hljs-comment">// return Math.floor((i - 1) / 2);</span>
		<span class="hljs-keyword">return</span> (i - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;
	&#125;
	<span class="hljs-comment">// 获取左侧子节点</span>
	<span class="hljs-function"><span class="hljs-title">getLeftIndex</span>(<span class="hljs-params">i</span>)</span> &#123;
		<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
	&#125;
	<span class="hljs-comment">// 获取右侧子节点</span>
	<span class="hljs-function"><span class="hljs-title">getRightIndex</span>(<span class="hljs-params">i</span>)</span> &#123;
		<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;
	&#125;
	<span class="hljs-comment">// 将两个节点的位置进行交换</span>
	<span class="hljs-function"><span class="hljs-title">swap</span>(<span class="hljs-params">i1, i2</span>)</span> &#123;
		<span class="hljs-keyword">const</span> temp = <span class="hljs-built_in">this</span>.heap[i1];
		<span class="hljs-built_in">this</span>.heap[i1] = <span class="hljs-built_in">this</span>.heap[i2];
		<span class="hljs-built_in">this</span>.heap[i2] = temp;
	&#125;
	<span class="hljs-function"><span class="hljs-title">shiftUp</span>(<span class="hljs-params">index</span>)</span> &#123; <span class="hljs-comment">// 上移</span>
		<span class="hljs-comment">// 递归的终点: 到达堆顶</span>
		<span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
		<span class="hljs-keyword">const</span> parentIndex = <span class="hljs-built_in">this</span>.getParentIndex(index);
		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.heap[parentIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[parentIndex].value &gt; <span class="hljs-built_in">this</span>.heap[index].value) &#123;
			<span class="hljs-built_in">this</span>.swap(parentIndex, index); <span class="hljs-comment">// 实现交换的方法</span>
			<span class="hljs-built_in">this</span>.shiftUp(parentIndex); <span class="hljs-comment">// 如果还是需要上移，则递归</span>
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-title">shiftDown</span>(<span class="hljs-params">index</span>)</span> &#123; <span class="hljs-comment">// 下移</span>
		<span class="hljs-keyword">const</span> leftIndex = <span class="hljs-built_in">this</span>.getLeftIndex(index);
		<span class="hljs-keyword">const</span> rightIndex = <span class="hljs-built_in">this</span>.getRightIndex(index);
		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[leftIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[leftIndex].value &lt; <span class="hljs-built_in">this</span>.heap[index].value) &#123;
			<span class="hljs-built_in">this</span>.swap(leftIndex, index);
			<span class="hljs-built_in">this</span>.shiftDown(leftIndex);
		&#125;
		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[rightIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[rightIndex].value &lt; <span class="hljs-built_in">this</span>.heap[index].value) &#123;
			<span class="hljs-built_in">this</span>.swap(rightIndex, index);
			<span class="hljs-built_in">this</span>.shiftDown(rightIndex);
		&#125;
	&#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment">解法二：</span>
<span class="hljs-comment">	1、将输入的数组进行统计，得到每个元素出现次数的二维数组（二维数组的第一项是元素，第二项是元素出现的次数）</span>
<span class="hljs-comment">	2、再将元素按照统计次数进行降序排列，数组的前K个就是所需要的结果</span>
<span class="hljs-comment">	3、但是这个解法 不符合 题目时间复杂度的要求</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">时间复杂度： </span>
<span class="hljs-comment">	1、nums.forEach =&gt; O(n)</span>
<span class="hljs-comment">	2、Array.sort =&gt; O(n log n)</span>
<span class="hljs-comment">	所以结合起来， 时间复杂度 就是 O(n log n) ，不符合题目要求的 时间复杂度必须优于 O(n log n)</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
nums.forEach(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> &#123;
	map.set(n, map.has(n) ? map.get(n) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);
&#125;);
<span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>.from(map).sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b[<span class="hljs-number">1</span>] - a[<span class="hljs-number">1</span>]);
<span class="hljs-keyword">return</span> arr.slice(<span class="hljs-number">0</span>, k).map(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n[<span class="hljs-number">0</span>]);</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 3合并K个升序链表 23</span>
<span class="hljs-comment">// 给你一个链表数组，每个链表都已经按升序排列。</span>
<span class="hljs-comment">// 请你将所有链表合并到一个升序链表中，返回合并后的链表。</span>
<span class="hljs-comment">//  </span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：lists = [[1,4,5],[1,3,4],[2,6]]</span>
<span class="hljs-comment">// 输出：[1,1,2,3,4,4,5,6]</span>
<span class="hljs-comment">// 解释：链表数组如下：</span>
<span class="hljs-comment">// [</span>
<span class="hljs-comment">//   1-&gt;4-&gt;5,</span>
<span class="hljs-comment">//   1-&gt;3-&gt;4,</span>
<span class="hljs-comment">//   2-&gt;6</span>
<span class="hljs-comment">// ]</span>
<span class="hljs-comment">// 将它们合并到一个有序链表中得到。</span>
<span class="hljs-comment">// 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：lists = []</span>
<span class="hljs-comment">// 输出：[]</span>
<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入：lists = [[]]</span>
<span class="hljs-comment">// 输出：[]</span>
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 时间复杂度： O(n) * logK // n是所有链表树的和，k是链表的数</span>
<span class="hljs-comment"> * 空间复杂度： O(k) // 中间遍历是 堆，堆的大小是K，k是链表的数</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">var</span> mergeKLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lists</span>) </span>&#123;
	<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);
	<span class="hljs-keyword">let</span> p = res;
	<span class="hljs-keyword">const</span> h = <span class="hljs-keyword">new</span> MinHead();
	lists.forEach(<span class="hljs-function"><span class="hljs-params">l</span> =&gt;</span> &#123;
		<span class="hljs-keyword">if</span>(l) h.insert(l);
	&#125;)
	<span class="hljs-keyword">while</span>(h.size()) &#123;
		<span class="hljs-keyword">const</span> n = h.pop(); <span class="hljs-comment">// 弹出堆顶（即lists中最小的那个链表节点）</span>
		p.next = n;
		p = p.next;
		<span class="hljs-keyword">if</span>(n.next) h.insert(n.next); <span class="hljs-comment">// 再把最小节点的下一个节点加到堆中</span>
	&#125;
	<span class="hljs-keyword">return</span> res.next;
    
&#125;;
<span class="hljs-comment">// 构建一个最小堆（堆中的元素时 链表的节点）</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinHead</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;
		<span class="hljs-built_in">this</span>.heap = [];
	&#125;
	<span class="hljs-comment">// 插入方法</span>
	<span class="hljs-function"><span class="hljs-title">insert</span>(<span class="hljs-params">value</span>)</span> &#123;
		<span class="hljs-built_in">this</span>.heap.push(value); <span class="hljs-comment">// 插入到底部</span>
		<span class="hljs-built_in">this</span>.shiftUp(<span class="hljs-built_in">this</span>.heap.length - <span class="hljs-number">1</span>); <span class="hljs-comment">// 上移操作</span>
	&#125;
	<span class="hljs-function"><span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 删除堆顶</span>
		<span class="hljs-comment">// 与原生的最小堆相比，需要做修改。 需要记住 top 的元素，并返回</span>
		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.size() === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap.shift();
		<span class="hljs-keyword">const</span> top = <span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>]; 
		<span class="hljs-comment">// 把原来heap中最末尾的推出来, 并赋值给堆顶</span>
		<span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>] = <span class="hljs-built_in">this</span>.heap.pop();
		<span class="hljs-built_in">this</span>.shiftDown(<span class="hljs-number">0</span>); <span class="hljs-comment">// 下移操作</span>
		<span class="hljs-keyword">return</span> top;
	&#125;
	<span class="hljs-comment">// 获取堆顶</span>
	<span class="hljs-function"><span class="hljs-title">peek</span>(<span class="hljs-params"></span>)</span> &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap[<span class="hljs-number">0</span>];
	&#125;
	<span class="hljs-comment">// 获取堆的大小</span>
	<span class="hljs-function"><span class="hljs-title">size</span>(<span class="hljs-params"></span>)</span> &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.heap.length;
	&#125;
	<span class="hljs-comment">// 获取父节点</span>
	<span class="hljs-function"><span class="hljs-title">getParentIndex</span>(<span class="hljs-params">i</span>)</span> &#123;
		<span class="hljs-comment">// 二进制操作，把二进制的数字右移一位</span>
		<span class="hljs-comment">// return Math.floor((i - 1) / 2);</span>
		<span class="hljs-keyword">return</span> (i - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;
	&#125;
	<span class="hljs-comment">// 获取左侧子节点</span>
	<span class="hljs-function"><span class="hljs-title">getLeftIndex</span>(<span class="hljs-params">i</span>)</span> &#123;
		<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
	&#125;
	<span class="hljs-comment">// 获取右侧子节点</span>
	<span class="hljs-function"><span class="hljs-title">getRightIndex</span>(<span class="hljs-params">i</span>)</span> &#123;
		<span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;
	&#125;
	<span class="hljs-comment">// 将两个节点的位置进行交换</span>
	<span class="hljs-function"><span class="hljs-title">swap</span>(<span class="hljs-params">i1, i2</span>)</span> &#123;
		<span class="hljs-keyword">const</span> temp = <span class="hljs-built_in">this</span>.heap[i1];
		<span class="hljs-built_in">this</span>.heap[i1] = <span class="hljs-built_in">this</span>.heap[i2];
		<span class="hljs-built_in">this</span>.heap[i2] = temp;
	&#125;
	<span class="hljs-function"><span class="hljs-title">shiftUp</span>(<span class="hljs-params">index</span>)</span> &#123; <span class="hljs-comment">// 上移</span>
		<span class="hljs-comment">// 递归的终点: 到达堆顶</span>
		<span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
		<span class="hljs-keyword">const</span> parentIndex = <span class="hljs-built_in">this</span>.getParentIndex(index);
		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.heap[parentIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[parentIndex].val &gt; <span class="hljs-built_in">this</span>.heap[index].val) &#123;
			<span class="hljs-built_in">this</span>.swap(parentIndex, index); <span class="hljs-comment">// 实现交换的方法</span>
			<span class="hljs-built_in">this</span>.shiftUp(parentIndex); <span class="hljs-comment">// 如果还是需要上移，则递归</span>
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-title">shiftDown</span>(<span class="hljs-params">index</span>)</span> &#123; <span class="hljs-comment">// 下移</span>
		<span class="hljs-keyword">const</span> leftIndex = <span class="hljs-built_in">this</span>.getLeftIndex(index);
		<span class="hljs-keyword">const</span> rightIndex = <span class="hljs-built_in">this</span>.getRightIndex(index);
		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[leftIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[leftIndex].val &lt; <span class="hljs-built_in">this</span>.heap[index].val) &#123;
			<span class="hljs-built_in">this</span>.swap(leftIndex, index);
			<span class="hljs-built_in">this</span>.shiftDown(leftIndex);
		&#125;
		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.heap[rightIndex] &amp;&amp; <span class="hljs-built_in">this</span>.heap[rightIndex].val &lt; <span class="hljs-built_in">this</span>.heap[index].val) &#123;
			<span class="hljs-built_in">this</span>.swap(rightIndex, index);
			<span class="hljs-built_in">this</span>.shiftDown(rightIndex);
		&#125;
	&#125;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">解法二：</span>
<span class="hljs-comment">	reduce，将链表数组中的每一个值放入新数组</span>
<span class="hljs-comment">	sort，以链表的val作参考冒泡排序</span>
<span class="hljs-comment">	reduceRight，从右向左遍历，将数组连成链表</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">var</span> mergeKLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lists</span>) </span>&#123;
	<span class="hljs-keyword">return</span> lists.reduce(<span class="hljs-function">(<span class="hljs-params">p, n</span>) =&gt;</span> &#123;
		<span class="hljs-keyword">while</span> (n) &#123;
			p.push(n), n = n.next
		&#125;
		<span class="hljs-keyword">return</span> p
	&#125;, []).sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.val - b.val).reduceRight(<span class="hljs-function">(<span class="hljs-params">p, n</span>) =&gt;</span> (n.next = p, p = n, p), <span class="hljs-literal">null</span>)
&#125;;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">解法三：</span>
<span class="hljs-comment">*/</span>
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Definition for singly-linked list.</span>
<span class="hljs-comment"> * function ListNode(val) &#123;</span>
<span class="hljs-comment"> *     this.val = val;</span>
<span class="hljs-comment"> *     this.next = null;</span>
<span class="hljs-comment"> * &#125;</span>
<span class="hljs-comment"> */</span>
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode[]&#125;</span> <span class="hljs-variable">lists</span></span></span>
<span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">var</span> mergeKLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lists</span>) </span>&#123;
	<span class="hljs-keyword">let</span> mergeTwoLists = <span class="hljs-function">(<span class="hljs-params">l1, l2</span>) =&gt;</span> &#123;
		<span class="hljs-keyword">let</span> preHead = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);
		<span class="hljs-keyword">let</span> preNode = preHead;
		<span class="hljs-keyword">while</span>(l1 &amp;&amp; l2)&#123;
			<span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;
				preNode.next = l1;
				l1 = l1.next;
			&#125; <span class="hljs-keyword">else</span> &#123;
				preNode.next = l2;
				l2 = l2.next;
			&#125;
			preNode = preNode.next;
		&#125;
		preNode.next = l1 ? l1 : l2;
		<span class="hljs-keyword">return</span> preHead.next;
	&#125;
	<span class="hljs-keyword">let</span> n = lists.length;
	<span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	<span class="hljs-keyword">let</span> res = lists[<span class="hljs-number">0</span>];
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;
		<span class="hljs-keyword">if</span>(lists[i])&#123;
			res = mergeTwoLists(res, lists[i]);
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;;</code></pre>

<h2 id="七-买卖股票"><a href="#七-买卖股票" class="headerlink" title="七 买卖股票"></a>七 买卖股票</h2><p>1 不限制交易次数，多次买卖一只股票<br>2 最多交易两次<br>3 可以交易k次<br>4 最佳买卖股票时机含冷冻期<br>5 买卖股票的最佳时机含手续费</p>
<pre><code class="hljs javaScript"><span class="hljs-comment">// 1 买卖股票的最佳时机 II 122</span>
<span class="hljs-comment">// 给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。</span>
<span class="hljs-comment">// 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</span>
<span class="hljs-comment">// 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span>
<span class="hljs-comment">// 示例 1:</span>
<span class="hljs-comment">// 输入: prices = [7,1,5,3,6,4]</span>
<span class="hljs-comment">// 输出: 7</span>
<span class="hljs-comment">// 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span>
<span class="hljs-comment">//      随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span>
<span class="hljs-comment">// 示例 2:</span>
<span class="hljs-comment">// 输入: prices = [1,2,3,4,5]</span>
<span class="hljs-comment">// 输出: 4</span>
<span class="hljs-comment">// 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span>
<span class="hljs-comment">//      注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span>
<span class="hljs-comment">// 示例 3:</span>
<span class="hljs-comment">// 输入: prices = [7,6,4,3,1]</span>
<span class="hljs-comment">// 输出: 0</span>
<span class="hljs-comment">// 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span>

<span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;
	<span class="hljs-comment">// 解法一: 统计找到最大利润</span>
	<span class="hljs-comment">// var min = prices[0];</span>
	<span class="hljs-comment">// var resArr = [];</span>
	<span class="hljs-comment">// var tem = 0;</span>
	<span class="hljs-comment">// for (let i = 1 ; i &lt; prices.length ; i++) &#123;</span>
	<span class="hljs-comment">//     if (prices[i] &gt; prices[i - 1]) &#123;</span>
	<span class="hljs-comment">//         tem = prices[i] - min</span>
	<span class="hljs-comment">//         if (i === prices.length - 1) &#123;</span>
	<span class="hljs-comment">//             resArr.push(tem)</span>
	<span class="hljs-comment">//         &#125;</span>
	<span class="hljs-comment">//     &#125; else &#123;</span>
	<span class="hljs-comment">//         resArr.push(tem)</span>
	<span class="hljs-comment">//         min = prices[i];</span>
	<span class="hljs-comment">//         tem = 0</span>
	<span class="hljs-comment">//     &#125;</span>
	<span class="hljs-comment">// &#125;</span>
	<span class="hljs-comment">// return resArr.reduce((x, y) =&gt; &#123;</span>
	<span class="hljs-comment">//     return x + y</span>
	<span class="hljs-comment">// &#125;, 0)</span>

	<span class="hljs-comment">// 解法二：贪心算法，只要有利润就赚</span>
	<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;
		<span class="hljs-keyword">if</span>(prices[i] &gt; prices[i - <span class="hljs-number">1</span>]) &#123;
			res += prices[i] - prices[i - <span class="hljs-number">1</span>];
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 2 买卖股票的最佳时机 III 123</span>
<span class="hljs-comment">// 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</span>
<span class="hljs-comment">// 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</span>
<span class="hljs-comment">// 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span>
<span class="hljs-comment">// 示例 1:</span>
<span class="hljs-comment">// 输入：prices = [3,3,5,0,0,3,1,4]</span>
<span class="hljs-comment">// 输出：6</span>
<span class="hljs-comment">// 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。</span>
<span class="hljs-comment">//      随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：prices = [1,2,3,4,5]</span>
<span class="hljs-comment">// 输出：4</span>
<span class="hljs-comment">// 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   </span>
<span class="hljs-comment">//      注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span>
<span class="hljs-comment">//      因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span>
<span class="hljs-comment">// 示例 3：</span>
<span class="hljs-comment">// 输入：prices = [7,6,4,3,1] </span>
<span class="hljs-comment">// 输出：0 </span>
<span class="hljs-comment">// 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</span>
<span class="hljs-comment">// 示例 4：</span>
<span class="hljs-comment">// 输入：prices = [1]</span>
<span class="hljs-comment">// 输出：0]</span>
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">prices</span></span></span>
<span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;
	<span class="hljs-keyword">if</span>(prices.length === <span class="hljs-number">0</span>)&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	&#125;
	<span class="hljs-comment">// 第一次 买入， 卖出的利润</span>
	<span class="hljs-keyword">let</span> firIn = -prices[<span class="hljs-number">0</span>];
	<span class="hljs-keyword">let</span> firOut = <span class="hljs-number">0</span>;
	<span class="hljs-comment">// 继第一次之后，第二次买入卖出的利润</span>
	<span class="hljs-keyword">let</span> secIn = -prices[<span class="hljs-number">0</span>];
	<span class="hljs-keyword">let</span> secOut = <span class="hljs-number">0</span>;
	<span class="hljs-comment">// 卖出时利润：求最大值（上次交易卖出时利润，本次交易卖出时利润）</span>
	<span class="hljs-comment">// 买入时利润：求最大值（上次买入时利润，本次买入时利润）</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;
		secOut = <span class="hljs-built_in">Math</span>.max(secOut, secIn + prices[i]);
		<span class="hljs-comment">// 第二次买入后的利润: 第一次卖出的利润 - prices[i]</span>
		secIn = <span class="hljs-built_in">Math</span>.max(secIn, firOut - prices[i]);
		firOut = <span class="hljs-built_in">Math</span>.max(firOut, firIn + prices[i]);
		<span class="hljs-comment">// 第一次买入后: 利润为 -prices[i]</span>
		firIn = <span class="hljs-built_in">Math</span>.max(firIn, -prices[i]);
	&#125;
	<span class="hljs-keyword">return</span> secOut
&#125;;


<span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;
	<span class="hljs-keyword">if</span> (prices.length === <span class="hljs-number">0</span>)&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	&#125;
	<span class="hljs-keyword">let</span> firIn = -prices[<span class="hljs-number">0</span>];
	<span class="hljs-keyword">let</span> firOut = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> secIn = -prices[<span class="hljs-number">0</span>];
	<span class="hljs-keyword">let</span> secOut = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;
		<span class="hljs-comment">// 第1次交易前 分支：什么都不做 或 买入 → 第1次交易后</span>
		firIn = <span class="hljs-built_in">Math</span>.max(firIn, -prices[i]);
		<span class="hljs-comment">// 第1次交易后 分支：什么都不做 或 卖出 → 第2次交易前</span>
		firOut = <span class="hljs-built_in">Math</span>.max(firOut, firIn + prices[i]);
		<span class="hljs-comment">// 第2次交易前 分支：什么都不做 或 买入 → 第2次交易后</span>
		secIn = <span class="hljs-built_in">Math</span>.max(secIn, firOut - prices[i]);
		<span class="hljs-comment">// 第2次交易后 分支：什么都不做 或 卖出 → 第3次交易前</span>
		secOut = <span class="hljs-built_in">Math</span>.max(secOut, secIn + prices[i]);
	&#125;
	<span class="hljs-keyword">return</span> secOut
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 3 买卖股票的最佳时机 IV 188</span>
<span class="hljs-comment">// 给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</span>
<span class="hljs-comment">// 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</span>
<span class="hljs-comment">// 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span>
<span class="hljs-comment">// 示例 1：</span>
<span class="hljs-comment">// 输入：k = 2, prices = [2,4,1]</span>
<span class="hljs-comment">// 输出：2</span>
<span class="hljs-comment">// 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</span>
<span class="hljs-comment">// 示例 2：</span>
<span class="hljs-comment">// 输入：k = 2, prices = [3,2,6,5,0,3]</span>
<span class="hljs-comment">// 输出：7</span>
<span class="hljs-comment">// 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。</span>
<span class="hljs-comment">//      随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</span>
<span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k, prices</span>) </span>&#123;
	<span class="hljs-keyword">let</span> n = prices.length;
	<span class="hljs-keyword">if</span> (k &gt; n / <span class="hljs-number">2</span>) &#123;
		k = <span class="hljs-built_in">Math</span>.floor(n / <span class="hljs-number">2</span>);
	&#125;
	<span class="hljs-comment">// 记录每次交易的利润</span>
	<span class="hljs-keyword">let</span> profit = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(k);
	<span class="hljs-comment">//初始化买入卖出时的利润</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt;= k; j++)&#123;
		profit[j] = &#123;
			<span class="hljs-keyword">in</span>: -prices[<span class="hljs-number">0</span>],
			out: <span class="hljs-number">0</span>
		&#125;;
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= k; j++)&#123;
			profit[j] = &#123;
				out: <span class="hljs-built_in">Math</span>.max(profit[j].out, profit[j].in + prices[i]), 
				<span class="hljs-keyword">in</span>: <span class="hljs-built_in">Math</span>.max(profit[j].in, profit[j - <span class="hljs-number">1</span>].out - prices[i])
			&#125;
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> profit[k].out;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 4 最佳买卖股票时机含冷冻期 309</span>
<span class="hljs-comment">// 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</span>
<span class="hljs-comment">// 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</span>
<span class="hljs-comment">// 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span>
<span class="hljs-comment">// 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</span>
<span class="hljs-comment">// 示例:</span>
<span class="hljs-comment">// 输入: [1,2,3,0,2]</span>
<span class="hljs-comment">// 输出: 3 </span>
<span class="hljs-comment">// 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span>

<span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;
	<span class="hljs-keyword">let</span> n = prices.length;
	<span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	&#125;
	<span class="hljs-keyword">let</span> dp = <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n),<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">2</span>));
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;
		<span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)&#123;
			dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
			dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[i];
			<span class="hljs-keyword">continue</span>;
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) &#123;
			dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">Math</span>.max(dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]+prices[i]);
			dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">Math</span>.max(dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], - prices[i]);
			<span class="hljs-keyword">continue</span>;
		&#125; <span class="hljs-keyword">else</span> &#123;
			dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">Math</span>.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);
			dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">Math</span>.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] - prices[i]);
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
&#125;;
<span class="hljs-comment">// 解法二</span>
<span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;
	<span class="hljs-keyword">if</span>(prices.length == <span class="hljs-number">0</span>)&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	&#125;
	<span class="hljs-keyword">let</span> inProfit = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> outProfit = -<span class="hljs-literal">Infinity</span>;
	<span class="hljs-keyword">let</span> pre = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i++)&#123;
		<span class="hljs-keyword">let</span> tmp = inProfit;
		inProfit = <span class="hljs-built_in">Math</span>.max(inProfit, outProfit + prices[i]);
		outProfit = <span class="hljs-built_in">Math</span>.max(outProfit, pre - prices[i]);
		pre = tmp;
	&#125;
	<span class="hljs-keyword">return</span> inProfit;
&#125;;</code></pre>

<pre><code class="hljs javaScript"><span class="hljs-comment">// 5 买卖股票的最佳时机含手续费 714</span>
<span class="hljs-comment">// 给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；</span>
<span class="hljs-comment">// 非负整数 fee 代表了交易股票的手续费用。</span>
<span class="hljs-comment">// 你可以无限次地完成交易，但是你每笔交易都需要付手续费。</span>
<span class="hljs-comment">// 如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</span>
<span class="hljs-comment">// 返回获得利润的最大值。</span>
<span class="hljs-comment">// 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</span>
<span class="hljs-comment">// 示例 1:</span>
<span class="hljs-comment">// 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2</span>
<span class="hljs-comment">// 输出: 8</span>
<span class="hljs-comment">// 解释: 能够达到的最大利润:  </span>
<span class="hljs-comment">// 在此处买入 prices[0] = 1</span>
<span class="hljs-comment">// 在此处卖出 prices[3] = 8</span>
<span class="hljs-comment">// 在此处买入 prices[4] = 4</span>
<span class="hljs-comment">// 在此处卖出 prices[5] = 9</span>
<span class="hljs-comment">// 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</span>

<span class="hljs-comment">// 解法一 动态规划</span>
<span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee</span>) </span>&#123;
	<span class="hljs-keyword">const</span> dp = [<span class="hljs-number">0</span>, -prices[<span class="hljs-number">0</span>]];
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>, t; i &lt; prices.length; i++) &#123;
		t = dp[<span class="hljs-number">0</span>] <span class="hljs-comment">// 中间变量可省略，因为当天买入卖出不影响结果</span>
		dp[<span class="hljs-number">0</span>] = <span class="hljs-built_in">Math</span>.max(dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>] + prices[i] - fee)
		dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">Math</span>.max(dp[<span class="hljs-number">1</span>], t - prices[i])
	&#125;
	<span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>] <span class="hljs-comment">// 最后一天，无股票 利润 &gt; 有股票时 利润</span>
&#125;;

<span class="hljs-comment">// 解法二：动态规划</span>
<span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee</span>) </span>&#123;
	<span class="hljs-comment">// 初始利润</span>
	<span class="hljs-keyword">var</span> getIn = <span class="hljs-number">0</span> - prices[<span class="hljs-number">0</span>];
	<span class="hljs-keyword">var</span> getOut = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++)&#123;
		<span class="hljs-comment">// 卖出： 当前买入状态时的利润 + 卖出的股票 - 手续费</span>
		getOut = <span class="hljs-built_in">Math</span>.max(getOut, getIn + prices[i] - fee); 
		<span class="hljs-comment">//买入： 当前卖出时的利润 - 买进的股票</span>
		getIn = <span class="hljs-built_in">Math</span>.max(getIn, getOut - prices[i]);     
	&#125;
	<span class="hljs-keyword">return</span> getOut;
&#125;;

<span class="hljs-comment">// 解法三：贪心算法</span>
<span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee</span>) </span>&#123;
	<span class="hljs-keyword">let</span> min = prices[<span class="hljs-number">0</span>];
	<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">while</span>(i &lt; prices.length) &#123;
		<span class="hljs-keyword">let</span> profit;
		<span class="hljs-keyword">if</span> (prices[i] &lt; min) &#123;
			min = prices[i];
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((profit = prices[i] - min - fee) &gt; <span class="hljs-number">0</span>) &#123;
			<span class="hljs-comment">// 两种情况：</span>
			<span class="hljs-comment">// 1 无股票时：profit = 今天价格 - 最低买入价格min - 手续费 &gt; 0，即有利润就卖</span>
			<span class="hljs-comment">// 2 有股票时：今天价格大于昨天价格。改今天卖。手续费昨天扣过，不再扣</span>
			<span class="hljs-comment">//		profit = pricep[i] - price[i - 1] = price[i] - (prices[i-1] - fee) - fee</span>
			<span class="hljs-comment">//    profit = 昨天利润 + 今天价格 - 新最低买入价格 - 手续费</span>
			<span class="hljs-comment">//    		 = 昨天利润 + 今天价格 - （昨天价格 - 手续费） - 手续费</span>
			<span class="hljs-comment">//    		 = 昨天利润 + 今天价格 - 昨天价格</span>
			res += profit;
			min = prices[i] - fee;
		&#125;
		i++;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;;</code></pre>

<h2 id="八-算法总结"><a href="#八-算法总结" class="headerlink" title="八 算法总结"></a>八 算法总结</h2><h3 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h3><p>分而治之是将一个问题<strong>分</strong>成多个和原问题相似的小问题，通过<strong>递归</strong>解决这些小问题，再将小问题的结果<strong>合并</strong>以解决原来的问题。</p>
<p>例题：反转二叉树、相同的树</p>
<p>场景一： 归并排序</p>
<ul>
<li>分：先把数组从中间一分为二</li>
<li>解：递归的对两个子数组进行归并排序</li>
<li>合：合并有序子数组</li>
</ul>
<p>场景二： 快速排序</p>
<ul>
<li>分：选基准，按基准把数组分成两个子数组</li>
<li>解：递归的对两个子数组进行快速排序</li>
<li>合：对两个子数组进行合并</li>
</ul>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动态规划是将一个问题分解为<strong>相互重叠</strong>的子问题，通过反复求解子问题，来解决原来的问题。</p>
<p>例题：斐波那契数列、连续子数组的最大和</p>
<p><strong>动态规划</strong> 与 <strong>分而治之</strong> 的区别：</p>
<ul>
<li>动态规划: 它们的子问题是<strong>相互重叠</strong>的</li>
<li>分而治之: 它们的子问题是<strong>完全独立</strong>的</li>
</ul>
<h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><p>回溯算法是一种<strong>渐进式</strong>寻找并构建问题解决方式的策略<br>回溯算法会先从一个可能的动作开始解决问题，如果不行，就回溯并选择另一个动作，直到将问题解决</p>
<p>例题：数组子集的全排列</p>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>期盼通过每个阶段的<strong>局部最优</strong>选择，从而达到全局的最优<br>结果并<strong>一定是最优</strong></p>
<p>例题：分发饼干、买卖股票的最佳时机</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/interview/">interview</a>
                    
                      <a class="hover-with-bg" href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/03/09/interview/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">js-设计模式</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/02/25/interview/js-consoleRes/">
                        <span class="hidden-mobile">打印结果</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>





  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
