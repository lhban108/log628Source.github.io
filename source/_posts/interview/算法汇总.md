---
title: 算法汇总
tags: [interview,算法]
## keywords: 博客文章密码
## password: 123123
## message:  输入密码，查看文章
---

## 一 排序和二分搜索

1冒泡排序 - 2选择排序 - 3插入排序(3-2 希尔排序) - 4归并排序 - 5快速排序 - 6二分搜索
7x的平方根 - 8猜数字大小

| 排序类型 | 平均情况 | 最好情况 | 最坏情况 | 辅助空间 | 稳定性 | 思路
| ------ | ------ | ------- | ------- | ------ | ------ | ------
| 冒泡排序 | O(n²) | O(n) | O(n²) | O(1) | 稳定 | 比较所有相邻元素，如果第一个比第二个大，则交换它们
| 选择排序 | O(n²) | O(n²) | O(n²) | O(1) | 不稳定 | 找到最小值，与第一位互换
| 插入排序 | O(n²) | O(n) | O(n²) | O(1) | 稳定 | 对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入
| 归并排序 | O(n logn) | O(n logn) | O(n logn) | O(n) | 稳定 | 从中间一分为二，排序后再合并
| 快速排序 | O(n logn) | O(n logn) | O(n²) | O(n logn) | 不稳定 | 选择一个基准，比基准大的放在左边数组，小的放在右边数组，依次递归，再合并

Array.prototype.srot:
Chrome 长度 `<= 10` 的数组使用的是**插入排序**(稳定排序算法) ，`>10` 的数组使用的是**快速排序**。快速排序是不稳定的排序算法
 Firefox 用的 **归并排序**

 冒泡排序：稳定，

### 1 冒泡排序

```javascript
// 1 冒泡排序-稳定-平均 O(n^2) [时间: O(n)<O(n^2) 空间: O(1)]
// (1) 比较所有相邻元素，如果第一个比第二个大，则交换它们
// (2) 一轮下来，可以保证最后一个数是最大的
// (3) 执行 n-1 轮，就可以完成排序
Array.prototype.bubbleSort = function() {
	for(let j = 0; j < this.length; j++) {
		for(let i = 0 ; i < this.length - 1 - j; i++) {
			if (this[i] > this[i + 1]) {
				const tem = this[i];
				this[i] = this[i + 1];
				this[i + 1] = tem;
			}
		}
	}
}
```

```javascript
// 2 选择排序-不稳定-时间: O(n^2) 空间: O(1)
// 选出最小值后需要交换位置,位置一变就会变得不稳定
// (1) 找到数组中的最小值，选中它并将其放置到第一位，
// (2) 接着找到第二小的值，选中它并将其放置到第二位
// (3) 以此类推，执行 n-1 轮
Array.prototype.selectSort = function() {
	for(let i = 0; i < this.length - 1; i++ ) {
		let indexMin = i;
		for(let j = i; j < this.length; j++) {
			if (this[j] < this[indexMin]) {
				indexMin = j;
			}
		}
		if (indexMin !== i) {
			const tem = this[i];
			this[i] = this[indexMin];
			this[indexMin] = tem;
		}
	}
}
```

```javascript
// 3 插入排序 稳定 平均 O(n^2)[时间: O(n)<O(n^2) 空间: O(1)]
// 原理是通过构建有序序列，对于未排序数据，在已排序序列中 从后向前 扫描，找到相应位置并插入。
// (1) 从第二个数开始往前比
// (2) 如果前面的数字比它大 就往后排
// (3) 以此类推 进行到最后一个数字
Array.prototype.insertSort = function() {
	for(let i = 1; i < this.length; i++) {
		const tem = this[i];
		let j = i;
		while(j > 0) {
			if (this[j - 1] > tem) {
				this[j] = this[j - 1];
				j--;
			} else {
				break;
			}
		}
		this[j] = tem;
	}
}

// 3-2 希尔排序 / 缩小增量排序
// 是 插入排序 的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。
// (1)选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
// (2)按增量序列个数k，对序列进行k 趟排序；
// (3)每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。
//		仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。
function shellSort(arr) {
    var len = arr.length;
    for(var k = Math.floor(len / 2); k > 0; k = Math.floor(k / 2)) {
        // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行
        for(var i = k; i < len; i++) {
            varj = i;
            var current = arr[i];
            while(j - k >= 0 && current < arr[j - k]) {
                 arr[j] = arr[j - k];
                 j = j - k;
            }
            arr[j] = current;
        }
    }
    return arr;
}
```

```javascript
// 4 归并排序 稳定 时间:O(n logn) 空间:O(n)
// 分而治之
//（1）把长度为n的输入序列分成两个长度为n/2的子序列
// (2) 对这两个子序列分别采用归并排序
// (3) 将两个排序好的子序列合并成一个最终的排序序列
Array.prototype.mergeSort = function() {
	const rec = arr => {
		if (arr.length === 1) {
			return arr;
		}
		// 除二取整: arr.length >>> 1
		const mid = Math.floor(arr.length / 2);
		const left = arr.slice(0, mid);
		const right = arr.slice(mid, arr.length);
		
		const orderLeft = rec(left);
		const orderRight = rec(right);

		const res = [];
		while(orderLeft.length || orderRight.length) {
			if (orderLeft.length && orderRight.length) {
				res.push(orderLeft[0] < orderRight[0] ?
					orderLeft.shift() : orderRight.shift());
			} else if (orderLeft.length) {
				res.push(orderLeft.shift());
			} else if (orderRight.length) {
				res.push(orderRight.shift());
			}
		}
		return res;
	}
	const res = rec(this);
	res.forEach((n, i) => this[i] = n);
}
```

```javascript
// 5 快速排序 不稳定 平均: O(n logn)
// 时间:O(n logn) < O(n²) 空间:O(n logn)
// 排序过程中位置会发生变化,位置一变就会变得不稳定
// 分而治之：将选择一个基准，比基准大的放在左边数组，小的放在右边数组，依次递归，再合并
Array.prototype.quickSort = function() {
	const rec = arr => {
		if(arr.length < 2) {
			return arr;
		}
		const left = [];
		const right = [];
		const mid = arr[0];
		for(let i = 1; i < arr.length; i++) {
			if (arr[i] < mid) {
				left.push(arr[i]);
			} else {
				right.push(arr[i])
			}
		}
		return [...rec(left), mid, ...rec(right)];
	};

	const res = rec(this);
	res.forEach((n, i) => this[i] = n);
}
```

### 6 二分搜索

```javascript
// 6 二分搜索 O(logN)
Array.prototype.binarySearch = function(item) {
	let low = 0;
	let high = this.length - 1;
	while(low <= high) {
		// 除二取整: (high + low) >>> 1
		const mid = Math.floor((high + low) / 2);
		const element = this[mid];
		if (element < item) {
			low = mid + 1;
		} else if (element > item) {
			high = mid - 1;
		} else {
			return mid;
		}
	}
	return -1;
}
```

```javascript
// 7 x 的平方根
var mySqrt = function(x) {
	// 时间复杂度: O(log N)
    if (x < 2) {
        return x;
    }
    let low = 1;
	 // 除二取整
    let higt = x >>> 1; 
    while(low + 1 < higt) {
        // Math.floor((low + higt) / 2);
        const mid = (low + higt) >>> 1;
        const s = x / mid;
        if (s === mid) {
            return mid;
        } else if (s > mid) {
            low = mid;
        } else {
            higt = mid;
        }
    }
    return x / higt >= higt ? higt : low;
};
```

```javascript
// 8 猜数字大小 二分搜索 时间 O(logN) 空间 O(1)
var guessNumber = function(n) {
    let low = 1;
    let high = n;
    while(high >= low) {
		 // 除以二并取整
		 // Math.floor((low + high) / 2);
        const mid = (low + high) >>> 1;
        const res = guess(mid);
        if (res === -1) {
            // 比mid 小,搜索 0 - mid 范围
            high = mid - 1;
        } else if (res === 1) {
            // 比mid 大,搜索 mid - n 范围
            low = mid + 1;
        } else if (res === 0) {
            return mid;
        }
    }
};

// 解法二
// 猜数字大小,分而治之 ,时间O(logN),空间O(logN)
var guessNumber = function(n) {
	const rec = (low, high) => {
		if (low > high) {
			return;
		}
		// 除二取整
		const mid = (low + high) >>> 1;
		const res = guess(mid);
		if (res === 0) { // 猜对了
			return mid;
		} else if (res === 1) {//比mid大
			return rec(mid + 1, high);
		} else if (res === -1) {//比mid小
			return rec(low, mid - 1);
		}
	}
	return rec(1, n);
};
```

## 二 树

1 树深度优先/广度优先
2 二叉树深度优先/广度优先 - 二叉树
3 先序/4中序/5后序
6 二叉树的最大深度
7 二叉树的最小深度
8 二叉树的层序遍历
9 二叉树的锯齿形层序遍历
10 相同的树
11 翻转二叉树
12 二叉树的层序遍历II （自底向上）
13 二叉树中第二小的节点
14 把二叉搜索树转换为累加树 (从二叉搜索树到更大和树)
15 二叉搜索树中的搜索 （从 二叉搜索树找到 给定值 的子树）
16 N叉树的最大深度
17 N叉树的前序遍历
18 N叉树的后序遍历
19 递增顺序查找树 （按中序遍历 重新排列树，使树中最左边的结点现在是树的根）
20 二叉树所有路径
21 另一个树的子树 ( 树s 中是否包含和 树t)
22 从前序与中序遍历序列构造二叉树
23 从中序与后序遍历序列构造二叉树
24 平衡二叉树 —— 判断是不是平衡二叉树
25 有序链表转换平衡二叉树
26 路径总和 Ⅰ II

### 1 树 - 深度优先

```javascript
// 1 树 - 深度优先
const dfs = root => {
	// 访问节点数据
	console.log(root.val);
	// 递归 访问子节点
	root.children.forEach(dfs);
}
dfs(tree);

// 树 - 广度优先
const bfs = root => {
	// 先把各节点入队
	const q = [root];
	while(q.length > 0) {
		// 出队
		const n = q.shift();
		// 访问节点数据
		console.log(n.val);
		if (n.children) {
			n.children.forEach(child => {
				q.push(child);
			})
		}
	}
}
bfs(tree);
```

```javascript
// 2 二叉树 - 深度/广度优先遍历
// 深度1 - 打印结果
const dfs = root => {
	if (!root) return;
	// 访问节点数据
	console.log(root.val);
	dfs(root.left);
	dfs(root.right)
}
// 深度2 - 递归版 - 收集并返回结果
function dfs2(root) {
	if (!root) {
		return [];
	}
	const res = []
	const rec = function(tree) {
		// console.log(tree.val);
		res.push(tree.val);
		if (tree.left) rec(tree.left);
		if (tree.right) rec(tree.right);
	}
	rec(root);
	return res;
}
// 深度3 - 非递归版 - 收集并返回结果
function dfs3(root) {
	if (!root) {
		return [];
	}
	const res = []
	const stack = [root];
	while(stack.length) {
		const item = stack.pop();
		// console.log(item.val);
		res.push(item.val);
		if (item.right) {
			stack.push(item.right);
		}
		if (item.left) {
			stack.push(item.left);
		}
	}
	return res;
}
// 广度 - 收集并返回结果
function fbs(root) {
	if (!root) return [];
	const res = [];
	const stack = [root];
	while(stack.length) {
		const item = stack.shift();
		// console.log(item.val);
		res.push(item.val);
		if (item.left) {
			stack.push(item.left);
		}
		if (item.right) {
			stack.push(item.right);
		}
	}
	return res;
}
```

```javascript
// 3先序遍历: 根 -> 左 -> 右
// 递归版1 - 打印结果
const preorder = root => {
	if (!root) {
		return;
	}
	console.log(root.val);
	preorder(root.left);
	preorder(root.right);
}
// 递归版2 - 收集并返回结果
function preorder2(root) {
	if (!root) {
		return [];
	}
	const res = []
	const stack = [root];
	while(stack.length) {
		const item = stack.pop();
		// console.log(item.val);
		res.push(item.val);
		if (item.right) {
			stack.push(item.right);
		}
		if (item.left) {
			stack.push(item.left);
		}
	}
	return res;
}

// 3先序遍历: 根 -> 左 -> 右
// 非递归版
const preorder2 = root => {
	if (!root) {
		return [];
	}
	const res = []
	const stack = [root];
	while(stack.length) {
		const item = stack.pop();
		// console.log(item.val);
		res.push(item.val);
		if (item.right) {
			stack.push(item.right);
		}
		if (item.left) {
			stack.push(item.left);
		}
	}
	return res;
}
```

```javascript
// 4中序遍历: 左 -> 根 -> 右
// 中序 - 递归版1 -  打印结果
const inorder = root => {
	if (!root) {
		return;
	}
	if (root.left) inorder(root.left);
	console.log(root.val);
	if (root.right) inorder(root.right);
}
// 中序 - 递归版2 - 收集并返回结果
function inorder2(root) {
	if(!root) return [];
	const res = [];
	const rec = function(tr) {
		if (tr.left) rec(tr.left);
		// console.log(tr.val);
		res.push(tr.val);
		if (tr.right) rec(tr.right);
	}
	rec(root);
	return res;
}
// 4中序遍历: 左 -> 根 -> 右
// 中序 -> 非递归版
const inorder3 = root => {
	if (!root) {
		return [];
	}
	const stack = [];
	const res = [];
	let p = root;
	while (stack.length || p) {
		while(p) {
			stack.push(p);
			p = p.left;
		}
		const item = stack.pop();
		// console.log(item.val);
		res.push(item.val);
		p = item.right;
	}
	return res;
}
```

```javascript
// 5后序遍历: 左 -> 右 > 根
// 后序遍历 -> 递归版1 -  打印结果
const postorder = root => {
	if (!root) {
		return;
	}
	postorder(root.left);
	postorder(root.right);
	// 访问当前节点
	console.log(root.val);
}
// 后序遍历 -> 递归版2 - 收集并返回结果
function postorder2(root) {
	if(!root) return [];
	const res = [];
	const rec = function(tr) {
		if (tr.left) rec(tr.left);
		if (tr.right) rec(tr.right);
		// console.log(tr.val);
		res.push(tr.val);
	}
	rec(root);
	return res;
}
// 后序遍历 -> 非递归版 - 收集并返回结果
const postorder3 = root => {
	if (!root) {
		return [];
	}
	const res = [];
	const outputStack = [];
	const stack = [root];
	while (stack.length) {
		const item = stack.pop();
		outputStack.push(item);
		if (item.left) stack.push(item.left);
		if (item.right) stack.push(item.right);
	} 
	while(outputStack.length) {
		const item = outputStack.pop();
		// 访问当前节点
		// console.log(item.val);
		res.push(item.val);
	}
	return res;
}
```

### 6 二叉树的最大深度

```javascript
// 6 题: 二叉树的最大深度 104
// 给定一个二叉树，找出其最大深度。
// 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
// 说明: 叶子节点是指没有子节点的节点。
// 示例：
// 给定二叉树 [3,9,20,null,null,15,7]，
//     3
//    / \
//   9  20
//     /  \
//    15   7
// 返回它的最大深度 3 。
var maxDepth = function(root) {
	if (!root) return 0;
	let res = 0;
	const dpt = (root, l) => {
		if (!root.left && !root.right) {
			res = Math.max(res, l)
		}
		if (root.left) dpt(root.left, l + 1);
		if (root.right) dpt(root.right, l + 1);
	}
	dpt(root, 1)
	return res;
};
```

```javascript
// 7 题: 二叉树的最小深度 111
// 给定一个二叉树，找出其最小深度。
// 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
// 说明：叶子节点是指没有子节点的节点。
// 示例 1：
//     3
//    / \
//   9  20
//     /  \
//    15   7
// 输入：root = [3,9,20,null,null,15,7]
// 输出：2
// 示例 2：
// 输入：root = [2,null,3,null,4,null,5,null,6]
// 输出：5
// 解法一 深度遍历法
var minDepth = function(root) {
   if (!root) return 0;
	let res = Infinity;
	const dpt = (root, l) => {
		if (!root.left && !root.right) {
			res = Math.min(res, l);
		}
		if (root.left) dpt(root.left, l + 1); 
		if (root.right) dpt(root.right, l + 1); 
	}

	dpt(root, 1);
	return res;
};

// 解法二 广度优先遍历
var minDepth = function(root) {
	if (!root) return 0;
	const stack = [[root, 1]];
	while (stack.length) {
		const [n, l] = stack.shift();
		if (!n.left && !n.right) {
			return l;
		}
		if (n.left) stack.push([n.left, l + 1]);
		if (n.right) stack.push([n.right, l + 1]);
	}
};
```

```javascript
// 8 二叉树的层序遍历 102
// 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
// 示例：
// 二叉树：[3,9,20,null,null,15,7],
//     3
//    / \
//   9  20
//     /  \
//    15   7
// 返回其层序遍历结果：
// [
//   [3],
//   [9,20],
//   [15,7]
// ]
// 广度优先遍历 【推荐 二颗星】
var levelOrder = function(root) {
	if (!root) return [];
	var stack = [[root, 0]];
	var res = [];
	while (stack.length) {
		var [n, level] = stack.shift();
		if (!res[level]) {
			res.push([n.val]);
		} else {
			res[level].push(n.val);
		}
		if (n.left) stack.push([n.left, level + 1]);
		if (n.right) stack.push([n.right, level + 1]); 
	}
	return res;
};
// 广度优先遍历-每次清空当前层级数据【推荐 三星】
var levelOrder = function(root) {
	if (!root) return [];
	const stack = [root];
	const res = [];
	while(stack.length) {
		res.push([]);
		let len = stack.length;
		while(len--) {
			const n = stack.shift();
			res[res.length - 1].push(n.val);
			if (n.left) stack.push(n.left);
			if (n.right) stack.push(n.right);
		}
	}
	return res;
};

// 递归写法
var levelOrder = function(root) {
	if (!root) return [];
	let res = []
	function traversal (root, depth) {
		if (root !== null) {
			if (!res[depth]) {
				res[depth] = []
			}
			traversal(root.left, depth + 1)
			res[depth].push(root.val)
			traversal(root.right, depth + 1)
		}
	}
	traversal(root, 0)
	return res;
};
```

```javascript
// 9 二叉树的锯齿形层序遍历 103
// 给定一个二叉树，返回其节点值的锯齿形层序遍历
//（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
// 例如：
// 给定二叉树 [3,9,20,null,null,15,7],

//     3
//    / \
//   9  20
//     /  \
//    15   7
// 返回锯齿形层序遍历如下：
// [
//   [3],
//   [20,9],
//   [15,7]
// ]
var zigzagLevelOrder = function(root) {
	if (!root) return [];
	let res = [];
	let stack = [root];
	while(stack.length) {
        let len = stack.length;
        res.push([]);
        while(len--) {
		    const n = stack.shift();
            res[res.length - 1].push(n.val);
            if (n.left) stack.push(n.left);
            if (n.right) stack.push(n.right);
        }
	}
	res.map((item, index) => index % 2 === 0 ? item : item.reverse());
	return res;
};
```

```javaScript
// 10 相同的树 100
// 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
// 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
// 示例 1：
// 输入：p = [1,2,3], q = [1,2,3]
// 输出：true
// 示例 2：
// 输入：p = [1,2], q = [1,null,2]
// 输出：false
var isSameTree = function(p, q) {
	if(!p && !q) {
		return true;
	}
	if(p && q && p.val === q.val &&
		isSameTree(p.left, q.left) &&
		isSameTree(p.right, q.right
	)) {
		return true;
	}
	return false;
};
```

### 11 翻转二叉树

```javaScript
// 11 翻转二叉树 226
// 翻转一棵二叉树。
// 示例：
// 输入：
//      4
//    /   \
//   2     7
//  / \   / \
// 1   3 6   9
// 输出：
//      4
//    /   \
//   7     2
//  / \   / \
// 9   6 3   1
var invertTree = function(root) {
	// 时间复杂度: O(N)
	// 空间复杂度: O(h)  h是树的高度 
	if(!root) {
		return null;
	}
	return {
		val: root.val,
		left: invertTree(root.right),
		right: invertTree(root.left),
	}
};
```

```javaScript
// 12 二叉树的层序遍历 II 107
// 自底向上
// 给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
// 例如：
// 给定二叉树 [3,9,20,null,null,15,7],
//     3
//    / \
//   9  20
//     /  \
//    15   7
// 返回其自底向上的层序遍历为：
// [
//   [15,7],
//   [9,20],
//   [3]
// ]
// 解法一 递归写法
var levelOrderBottom = function(root) {
	if (!root) return [];
	let res = []
	function traversal (root, depth) {
		if (root !== null) {
			if (!res[depth]) {
				res[depth] = []
			}
			traversal(root.left, depth + 1)
			res[depth].push(root.val)
			traversal(root.right, depth + 1)
		}
	}
	traversal(root, 0)
	return res.reverse()
}
// 解法二 广度优先 非递归
var levelOrderBottom = function(root) {
	if (!root) return [];
	const stack = [root];
	const res = [];
	while(stack.length) {
		res.push([]);
		let len = stack.length;
		while(len--) {
			const n = stack.shift();
			res[res.length - 1].push(n.val);
			if (n.left) stack.push(n.left);
			if (n.right) stack.push(n.right);
		}
	}
    return res.reverse();
}
```

```javaScript
// 13 二叉树中第二小的节点 671
// 给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0
// 如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。
// 更正式地说，root.val = min(root.left.val, root.right.val) 总成立。
// 给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。
// 示例 1：
//      2
//    /   \
//   2     5
//        / \
//       5   7
// 输入：root = [2,2,5,null,null,5,7]
// 输出：5
// 解释：最小的值是 2 ，第二小的值是 5 。
var findSecondMinimumValue = function(root) {
  let arr = [];
  (function traversal (root) {
    if (root !== null) {
      traversal(root.left)
      arr.push(root.val)
      traversal(root.right)
    }
  })(root)
  let _arr = [...new Set(arr)].sort()
  return _arr[1] ? _arr[1] : -1
}
```

```javaScript
// 14 把二叉搜索树转换为累加树 1038
// 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree）
// 使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。
// 提醒一下，二叉搜索树满足下列约束条件：
//  - 节点的左子树仅包含键 小于 节点键的节点。
//  - 节点的右子树仅包含键 大于 节点键的节点。
//  - 左右子树也必须是二叉搜索树。
// 示例 1：
// 输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
// 输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
// 示例 2：
// 输入：root = [0,null,1]
// 输出：[1,null,1]
// 示例 3：
// 输入：root = [1,0,2]
// 输出：[3,3,2]
// 示例 4：
// 输入：root = [3,2,4,1]
// 输出：[7,9,4,10]
var bstToGst = function(root) {
	let sum = 0;
	function traversal (root) {
		if (root !== null) {
			traversal(root.right);
			root.val += sum;
			sum = root.val;
			traversal(root.left);
		}
	}
	traversal(root);
	return root;
}
```

```javaScript
// 15 二叉搜索树中的搜索 700
// 给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点
// 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。
// 例如，
// 给定二叉搜索树:

//         4
//        / \
//       2   7
//      / \
//     1   3
// 和值: 2
// 你应该返回如下子树:

//       2     
//      / \   
//     1   3
// 在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。
var searchBST = function(root, val) {
  function traversal (root) {
		if (root !== null) {
			if (root.val === val) {
				return root;
			} else if (root.val < val) {
				return traversal(root.right);
			} else {
				return traversal(root.left);
			}
		} else {
			return root;
		}
  }
  return traversal(root);
}
```

### 16 N叉树的最大深度

```javaScript
// 16 N叉树的最大深度 559
// 给定一个 N 叉树，找到其最大深度。
// 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。
// N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。
// 示例 1：
// 输入：root = [1,null,3,2,4,null,5,6]
// 输出：3
// 示例 2：
// 输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
// 输出：5
var maxDepth = function(root) {
	if (root === null) {
		return 0;
	}
	let depth = 1;
	function traversal (root, curDepth) {
		if (root !== null) {
			if (curDepth > depth) {
				depth = curDepth;
			}
			root.children.forEach(child => traversal(child, curDepth + 1));
		}
	}
	traversal(root, 1);
	return depth;
}
```

```javaScript
// 17 N叉树的前序遍历 589
// 给定一个 N 叉树，返回其节点值的 前序遍历 。
// N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。
// 进阶：
// 递归法很简单，你可以使用迭代法完成此题吗?
// 示例 1：
// 输入：root = [1,null,3,2,4,null,5,6]
// 输出：[1,3,5,6,2,4]
// 解法一：递归
var preorder = function(root) {
	const res = [];
	function traversal (root) {
		if (root !== null) {
			res.push(root.val);
			root.children.forEach(child => traversal(child));
		}
	}
	traversal(root);
	return res;
}
// 解法二： 迭代
var preorder = function(root) {
	if (root === null) return [];
	let array = [];
	let stack = [root];
	while (stack.length) {
		let len = stack.length;
		let node = stack.shift(); // 弹出栈中第一个，先进先出
		array.push(node.val);
		if (node.children.length > 0) {
			// 这里有别于层序遍历，用 node.children 连接 queue
			// 而不是 queue.concat(node.children)这样就实现了前序遍历的效果
			stack = node.children.concat(stack);
		}
	}
	return array;
};
```

```javaScript
// 18 N叉树的后序遍历 590
// 给定一个 N 叉树，返回其节点值的 后序遍历 。
// N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。
// 进阶：
// 递归法很简单，你可以使用迭代法完成此题吗?
// 示例 1：
// 输入：root = [1,null,3,2,4,null,5,6]
// 输出：[5,6,3,2,4,1]
// 解法一：递归
var postorder = function(root) {
	const res = [];
	function traversal (root) {
		if (root !== null) {
			root.children.forEach(child => {
				arguments.callee(child);
			})
			res.push(root.val);
		}
	}
	traversal(root);
	return res;
}
// 解法二：迭代
var postorder = function(root) {
	if (root === null) return [];
	let res = [];
	let stack = [root];
	while (stack.length) {
		let node = stack.pop(); // 弹出最后面的一个元素
		if (node.children.length > 0) {
			stack = stack.concat(node.children);
		}
		res.unshift(node.val); // 节点先进后出，数值压栈存储
	}
	return res;
};
```

```javaScript
// 19 递增顺序查找树 897
// 给你一个树，请你 按中序遍历 重新排列树，使树中最左边的结点现在是树的根
// 并且每个结点没有左子结点，只有一个右子结点。
// 示例 ：
// 输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]
//        5
//       / \
//     3    6
//    / \    \
//   2   4    8
//  /        / \ 
// 1        7   9
// 输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]
//  1
//   \
//    2
//     \
//      3
//       \
//        4
//         \
//          5
//           \
//            6
//             \
//              7
//               \
//                8
//                 \
//                  9  
var increasingBST = function(root) {
	const arr = [];
	function traversal (root) {
		if (root !== null) {
			traversal(root.left);
			arr.push(root.val);
			traversal(root.right);
		}
	}
	traversal(root);
	const res = new TreeNode(arr[0]);
	let currentNode = res;
	for (let i = 0; i < arr.length - 1; i++) {
		currentNode.left = null;
		currentNode.right = new TreeNode(arr[i + 1]);
		currentNode = currentNode.right;
	}
	return res;
}
```

```javaScript
// 20 二叉树的所有路径 257
// 给定一个二叉树，返回所有从根节点到叶子节点的路径。
// 说明: 叶子节点是指没有子节点的节点。
// 例如：
// 输入:
//    1
//  /   \
// 2     3
//  \
//   5
// 输出: ["1->2->5", "1->3"]
// 解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
var binaryTreePaths = function(root) {
	if (!root) return [];
	const res = [];
	const dfs = (root, str = '') => {
		if (root.left) dfs(root.left, str + root.val + '->');
		if (root.right) dfs(root.right, str + root.val + '->');
		if (!root.left && !root.right) res.push(str + root.val);
		return; 
	}
	dfs(root);
	return res;
};
```

### 21 另一个树的子树

```javaScript
// 21 另一个树的子树 257
// 给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树
// s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
// 示例 1:
// 给定的树 s:
//      3
//     / \
//    4   5
//   / \
//  1   2
// 给定的树 t：
//    4 
//   / \
//  1   2
// 返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。

// 示例 2:
// 给定的树 s：
//      3
//     / \
//    4   5
//   / \
//  1   2
//     /
//    0
// 给定的树 t：
//    4
//   / \
//  1   2
// 返回 false

var isSubtree = function(s, t) {
	if (!s) {
		return false;
	}
	if (isSameTree(s, t)) {
		return true;
	}
	return isSubtree(s.left, t) || isSubtree(s.right, t); // 有一个true就true
};

function isSameTree(s, t) { // 100题
	if (!s && !t) {
		return true;
	};
	if (!s || !t ) {
		return false;
	}
	return s.val == t.val && isSameTree(s.left, t.left) && isSameTree(s.right, t.right);
}
```

```javaScript
// 22 从前序与中序遍历序列构造二叉树 105
// 根据一棵树的前序遍历与中序遍历构造二叉树。
// 注意:
// 你可以假设树中没有重复的元素。

// 例如，给出
// 前序遍历 preorder = [3,9,20,15,7]
// 中序遍历 inorder = [9,3,15,20,7]
// 返回如下的二叉树：
//     3
//    / \
//   9  20
//     /  \
//    15   7
var buildTree = function(preorder, inorder) {
	if(!inorder.length) return null;
	const rootVal = preorder[0];
	const rootIndex = inorder.indexOf(rootVal);
	let root = new TreeNode(rootVal);
	root.left = buildTree(preorder.slice(1, rootIndex + 1),inorder.slice(0, rootIndex));
	root.right = buildTree(preorder.slice(rootIndex + 1),inorder.slice(rootIndex + 1));
	return root;
	// 解法二
	// let build = (inorder) => {
	// 	if(!inorder || !inorder.length) return null;
	// 	const rootVal = preorder.shift();
	// 	const rootIndex = inorder.indexOf(rootVal);
	// 	let root = new TreeNode(rootVal);
	// 	root.left = build(inorder.slice(0, rootIndex));
	// 	root.right = build(inorder.slice(rootIndex + 1));
	// 	return root
	// }
	// return build(inorder)
};
```

```javaScript
// 23 从中序与后序遍历序列构造二叉树 106
// 根据一棵树的前序遍历与中序遍历构造二叉树。
// 注意:
// 你可以假设树中没有重复的元素。

// 例如，给出
// 前序遍历 preorder = [3,9,20,15,7]
// 中序遍历 inorder = [9,3,15,20,7]
// 返回如下的二叉树：
//     3
//    / \
//   9  20
//     /  \
//    15   7
var buildTree = (inorder, postorder) => {
	if(!inorder.length) return null;
	const rootVal = postorder.pop();
	const rootIndex = inorder.indexOf(rootVal);
	const root = new TreeNode(rootVal);
	root.left = buildTree(inorder.slice(0, rootIndex), postorder.slice(0, rootIndex));
	root.right = buildTree(inorder.slice(rootIndex + 1), postorder.slice(rootIndex));
	return root;
};

```

```javaScript
// 24 平衡二叉树 110
// 给定一个二叉树，判断它是否是高度平衡的二叉树。
// 本题中，一棵高度平衡二叉树定义为：
// 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。
// 示例 1：
// 输入：root = [3,9,20,null,null,15,7]
// 输出：true
// 示例 2：
// 输入：root = [1,2,2,3,3,null,null,4,4]
// 输出：false
// 示例 3：
// 输入：root = []
// 输出：true
// 解法一
var isBalanced = function(root) {
    if(!root || root.length === 0) return true;
    const maxLeft = getMaxLevel(root.left);
    const maxRight = getMaxLevel(root.right);
    return Math.abs(maxLeft - maxRight) <= 1 && isBalanced(root.left) && isBalanced(root.right);
};
function getMaxLevel(root) {
    if (!root) return 0;
    let max = 1;
    const dp = function(root, l) {
        if (!root.left && !root.right)  max = Math.max(max, l);
        if (root.left) dp(root.left, l + 1);
        if (root.right) dp(root.right, l + 1);
    }
    dp(root, 1);
    return max;
}

// 解法二
const isBalanced = function (root) {
    // 获取当前节点高度的递归函数
    const getH = root => {
        if (!root) return 0;
        // 返回左右节点的最大高度+1,（+1:根节点）
        return Math.max(getH(root.left), getH(root.right)) + 1;
    };
    // 能递归到达这里，这个子树肯定是平衡二叉树
    if (!root) return true;
    // 平衡二叉树的条件：
    return (
        // 1. 根节点的左右节点高度差不超过1
        Math.abs(getH(root.left) - getH(root.right)) <= 1 &&
        // 2. 左子树是平衡二叉树
        isBalanced(root.left) &&
        // 3. 右子树是平衡二叉树
        isBalanced(root.right)
    );
};

// 解法三
var isBalanced = function (root) {
    return balanced(root) !== -1
};
var balanced = function (node) {
    if (!node) return 0
    const left = balanced(node.left)
    const right = balanced(node.right)
    if (left === -1 || right === -1 || Math.abs(left - right) > 1) {
        return -1
    }
    return Math.max(left, right) + 1
}
```

```javaScript
// 25 有序链表转换平衡二叉树 109
// 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。
// 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
// 示例:
// 给定的有序链表： [-10, -3, 0, 5, 9],
// 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：
//       0
//      / \
//    -3   9
//    /   /
//  -10  5
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {ListNode} head
 * @return {TreeNode}
 */
var sortedListToBST = function(head) {
	function getTree(head, end) {
		if (head === end) return null
		let p1 = head; // 慢指针，中间节点
		let p2 = head; // 快指针，结束节点
		while(p2 !== end) {
			p2 = p2.next;
			if (p2 !== end) {
					p1 = p1.next;
					p2 = p2.next;
			}
		}
		return new TreeNode(p1.val, getTree(head, p1), getTree(p1.next, end))
	}
	return getTree(head, null)
};
```

### 26 路径总和

```javaScript
// 26-1 路径总和 Ⅰ 112
// 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。
// 实例
// 输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
// 输出：true
var hasPathSum = function(root, sum) {
	if(!root) return false;
	let res = false;
	const dpt = (root, s) => {
		if (!root.left && !root.right && s === sum) {
			res = true;
		}
		if (root.left) {
			dpt(root.left, s + root.left.val)
		}
		if (root.right) {
			dpt(root.right, s + root.right.val)
		}
	}
	dpt(root, root.val);
	return res;
};

// 26-2 路径总和 ⅠⅠ 113
// 给你二叉树的根节点 root 和一个整数目标和 targetSum
// 找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。
// 实例1：
// 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
// 输出：[[5,4,11,2],[5,8,4,5]]
var pathSum = function(root, targetSum) {
	if (!root) return [];
	const res = [];
	const dp = function(root, arr) {
		if (!root.left && !root.right) {
			const sum = arr.reduce((acc, cur) => acc + cur);
			if (sum == targetSum) {
					res.push(arr);
			}
			return;
		}
		if (root.left) dp(root.left, [...arr, root.left.val]);
		if (root.right) dp(root.right, [...arr, root.right.val]);
	}
	dp(root, [root.val]);
	return res;
};

```

```javaScript
// 27  填充每个节点的下一个右侧节点指针 116
// 给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。
// 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
// 初始状态下，所有 next 指针都被设置为 NULL。
// 实例1：
// 输入：root = [1,2,3,4,5,6,7]
// 输出：[1,#,2,3,#,4,5,6,7,#]
// 解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。

// 进阶：
// 1. 你只能使用常量级额外空间。
// 2. 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

var connect = function(root) {
	// 解法一: 广度遍历
	if(!root) return null;
	const stack = [root];
	while(stack.length) {
		let len = stack.length;
		let pre = null;
		while(len) {
			const item = stack.shift();
			if (item && item.left) stack.push(item.left);
			if (item && item.right) stack.push(item.right);
			if (pre) pre.next = item;
			pre = item;
			len--;
		}
	}
	return root;

	// 解法二: 递归 
	// 解法二更符合题目中进阶的要求
	if (!root) return null;
	if (root.left) root.left.next = root.right;
	if (root.right && root.next) root.right.next = root.next.left;
	connect(root.left);
	connect(root.right);
	return root;
};
```

## 三 数组

1 全排列 ——（给定一个 没有重复 nums，返回其所有可能的全排列）
2 全排列II ——（给定一个 可能重复 的数组 nums ，返回所有不重复的全排列）
3 子集 ——（给你一个整数数组 nums，返回所有子集数组）
4 子集II ——（给定一个可能重复数组 nums，返回所有子集数组）
5 组合总和 ——（从无重复数组 nums 中找到和 为target 的所有子数组）
6 组合总和II ——（从可能重复数组 nums 中找到和 为target 的所有子数组）
7 组合 ——（给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合）
8 优美的排列
9 优美的排列II
10 电话号码的字母组合 —— (从一个仅包含数字2-9的字符串，返回所有它能表示的字母组合)
11 括号生成 —— (数字 n 代表生成括号的对数，找到所有 有效的 括号组合)
12 盛最多水的容器 ——（从数组中找到 盛最多水的 两个值）
13 三数之和 ——（三数之和为0）
14 删除有序数组中的重复项
15 加一
16 移动零 —— （把数组 nums 的所有 0 移动到数组的末尾）
17 最小栈 —— （设计一个栈，支持push/pop/top/操作，以及检索到最小元素的栈）
18 跳跃游戏 —— （nums元素代表可以跳跃的最大长度，判断是否能够到达最后一个下标）
19 跳跃游戏 II —— （nums元素代表可以跳跃的最大长度，判断是否能够到达最后一个下标）
20 最大子序和 —— （从数组中找到最大和的连续子数组的和）
21 最接近的三数之和 —— （找出 nums 中的三个整数的和与 target 最接近）
22 四数之和
23 字母异位词分组 —— 字符串数组，将包含相同字母项组合在一起
24 最长连续递增序列 —— 找到数组中找到 最长且 连续递增 的子序列
25 最长递增子序列 —— 找到其中最长严格递增子序列的长度
26 寻找两个正序数组的中位数 - 找到两个正序数组的中位数
27 和为K的子数组 —— 找到数组中和为 k 的连续的子数组的个数
28 两数之和 II - 输入有序数组 —— 升序的有序数组中找到和为target的目标
29 合并区间 —— 合并二维数组中区间重复的项
30 插入区间 —— 将一个区间数组 插入 到另一个 二维区间数组中
31 搜索旋转排序数组 —— 从已排序的数组中找到 指定的值
32 在排序数组中查找元素的第一个和最后一个位置
33 下一个排列 —— 找到数组的下一个更大的值
34 旋转图像
35 螺旋矩阵 —— 把二维数组(m * n) 按照 顺时针螺旋顺序 旋转

### 1 全排列

```javaScript
// 1 全排列 46
// 给定一个 没有重复 数字的序列，返回其所有可能的全排列。
// 示例:
// 输入: [1,2,3]
// 输出:
// [
//   [1,2,3],
//   [1,3,2],
//   [2,1,3],
//   [2,3,1],
//   [3,1,2],
//   [3,2,1]
// ]
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
	// 时间复杂度：O(!n) ; !n = 1 x 2 x 3 x ... x (n-1) x n
	// 空间复杂度：O(n)
	const res = [];
	const backtrck = path => {
		if (path.length === nums.length) {
			res.push(path);
			return;
		}
		nums.forEach(n => {
			if (path.includes(n)) return;
			backtrck(path.concat(n));
		})
	}
	backtrck([]);
	return res;
};
```

```javaScript
// 2 全排列II 47
// 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。
// 示例 1：
// 输入：nums = [1,1,2]
// 输出：
// [[1,1,2],
//  [1,2,1],
//  [2,1,1]]
// 示例 2：
// 输入：nums = [1,2,3]
// 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
var permuteUnique = function(nums) {
	const len = nums.length;
	const res = [];
	const used = [];
	nums.sort((a, b) => a - b)
	const backtrack = (deepStack) => {
		if (deepStack.length === len) {
			res.push(deepStack.slice())
			return
		}
		for (let i = 0; i < len; i++) {
			// 当前选项与上一项相同、且上一项存在、且没有被使用过，则忽略
			if (nums[i - 1] === nums[i] && i - 1 >= 0 && !used[i - 1]) continue 
			if (used[i]) continue // 使用过便不再使用
			deepStack.push(nums[i])
			used[i] = true
			backtrack(deepStack)
			deepStack.pop()
			used[i] = false
		}
	}
	backtrack([])
	return res
}
```

```javaScript
// 3 子集 78
// 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
// 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。
// 示例 1：
// 输入：nums = [1,2,3]
// 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

// 解法一： 回溯
var subsets = function(nums) {
    // 时间复杂度：O(2^n) 因为每个元素都有两种可能（存在或不存在）
    // 空间复杂度：O(n)
	const res = [];
	const backtrack = function(arr, len, startIndex) {
		if (arr.length === len) {
			res.push(arr);
			return;
		}
		for (let index = startIndex; index < nums.length; index++) {
			backtrack([...arr, nums[index]], len, index + 1);
		}
	}
	let i = 0;
	while (i <= nums.length) {
		backtrack([], i, 0);
		i++;
	}
	return res;
};
// 解法二 迭代 动态规划
// 重复将新的元素加入到上一个结果集中的每个子集当中去
// 形成n个新的子集，再全部加入到结果集中去
var subsets = function(nums) {
	let res = [[]];
	for(let i = 0; i < nums.length; i++){
		let len = res.length;
		for(let j = 0; j < len; j++){
			let sub = res[j].slice();
			sub.push(nums[i]);
			res.push(sub);
		}
	}
	return res;
};
// 解法三 递归
const subsets = (nums) => {
	const res = [];
	const dfs = (index, list) => {
		res.push(list.slice());     // 调用子递归前，加入解集
		for (let i = index; i < nums.length; i++) { // 枚举出所有可选的数
			list.push(nums[i]);       // 选这个数
			dfs(i + 1, list);         // 基于选这个数，继续递归，传入的是i+1，不是index+1
			list.pop();               // 撤销选这个数
		}
	};
	dfs(0, []);
	return res;
};
```

```javaScript
// 4 子集II  90.
// 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。
// 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。
// 示例 1：
// 输入：nums = [1,2,2]
// 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
var subsetsWithDup = function(nums) {
	if (nums.length==0){
		return [nums];
	}
	if (nums.length==1){
		return [[],nums];
	}
	nums.sort((a, b) => a - b); // 先排序
	let result = [[]]; // 记录全部子数组
	let lastLength = 0; // 记录上一个元素添加前，result的长度
	for (let i = 0; i < nums.length; i++){
		let j = 0;
		// 当遇到重复元素时，从上一个元素添加前
		// result的长度处，开始每一个子数组都添加该元素
		if (i > 0 && nums[i] == nums[i-1]){
			j = lastLength;
		}
		let n = result.length;
		// 保持lastLength的更新
		lastLength = result.length;
		// 如果不是重复元素，j初始为0,从result开头，每个子数组都添加上该元素
		for (; j < n; j++){
			result.push([...result[j],nums[i]])
		}
	}
	return result;
};
// 解法二 
var subsetsWithDup = function(nums) {
	let n = nums.length;
	nums = nums.sort((a,b) => {return a - b});
	let tmpPath = [];
	let res = [];
	let hash = {}
	let backtrack = (tmpPath,start) => {
		res.push(tmpPath);
		for(let i = start;i < n;i++){
			if(hash[i] || (i > 0 && !hash[i-1] && nums[i-1] == nums[i])) continue;
			hash[i] = true;
			tmpPath.push(nums[i]);
			backtrack(tmpPath.slice(),i+1);
			hash[i] = false;
			tmpPath.pop();
		} 
	}
	backtrack(tmpPath,0);
	return res;
};
```

```javaScript
// 5 组合总和 39
// 给定一个无重复元素的数组 candidates 和一个目标数 target 
// 找出 candidates 中所有可以使数字和为 target 的组合。
// candidates 中的数字可以无限制重复被选取。
// 说明：
// 所有数字（包括 target）都是正整数。
// 解集不能包含重复的组合。 
// 示例 1：
// 输入：candidates = [2,3,6,7], target = 7,
// 所求解集为：
// [
//   [7],
//   [2,2,3]
// ]
var combinationSum = function(nums,target) {
	let res = [];
	let sum = 0;
	let dfs = (subArr, sum, start) => {
		if(sum > target) return;
		if(sum  == target){
			//这里不能直接push subArr这个数组，对于js这门语言来说，可以充分利用js的...运算符
			res.push([...subArr]);
			return;
		}
		for(let i  = start ; i < nums.length ; i++){
			let temp = sum;
			sum = sum + nums[i];
			subArr.push(nums[i]);
			dfs(subArr, sum,i);
			//回到之前的状态，对于数组来讲就是pop，对于sum来讲可以用一个变量来记录以前的值
			subArr.pop(nums[i]);
			sum = temp;
		}
	}
	dfs([], 0, 0);
	return res;
};
// 解法二
var combinationSum = function(candidates, target) {
	let n = candidates.length;
	let res = [];
	let tmpPath = [];
	let backtrack = (tmpPath,target,start) => {
		if(target < 0){
			return;
		}
		if(target == 0){
			res.push(tmpPath);
			return;
		}
		for(let i = start;i < n;i++){
			tmpPath.push(candidates[i]);
			backtrack(tmpPath.slice(),target - candidates[i],i);
			tmpPath.pop();
		}
	}
	backtrack(tmpPath, target, 0);
	return res;
};
```

### 6 组合总和 II

```javaScript
// 6 组合总和 II 40
// 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
// candidates 中的每个数字在每个组合中只能使用一次。
// 说明：
// 所有数字（包括目标数）都是正整数。
// 解集不能包含重复的组合。 
// 示例 1:
// 输入: candidates = [10,1,2,7,6,1,5], target = 8,
// 所求解集为:
// [
//   [1, 7],
//   [1, 2, 5],
//   [2, 6],
//   [1, 1, 6]
// ]
var combinationSum2 = function(candidates, target) {
	let n = candidates.length;
	let res = [];
	let tmpPath = [];
	candidates = candidates.sort((a,b) => {return a - b})
	let backtrack = (tmpPath,target,start) => {
		if(target == 0){
			res.push(tmpPath);
			return;
		}
		for(let i = start;i < n;i++){
			if(target < candidates[i]) break;
			if(i > start && candidates[i-1] == candidates[i]) continue;
			tmpPath.push(candidates[i]);
			backtrack(tmpPath.slice(),target - candidates[i],i + 1);
			tmpPath.pop();
		}
	}
	backtrack(tmpPath,target,0);
	return res;
};
```

```javaScript
// 7 组合 77
// 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。
// 示例:
// 输入: n = 4, k = 2
// 输出:
// [
//   [2,4],
//   [3,4],
//   [2,3],
//   [1,2],
//   [1,3],
//   [1,4],
// ]
// 解法一 动态规划
var combine = function(n, k) {
	var dp = new Array(n + 1);
	for(let i = 0; i <= n; i++){
		dp[i] = new Array(k+1);
		dp[i][0] = [[]];
	}
	console.log(dp);
	// i：1~n
	for(let i = 1; i <= n; i++){
		//j：1～i/k
		for(let j = 1;j <= i && j <= k ;j++){
			dp[i][j] = [];
			// 从 i-1 个里选 j 个
			// 即从上题解法的：从 n-1 个里选 k个
			if(i > j){
					var tmpA = dp[i-1][j];
					for(var t = 0;t<tmpA.length;t++){
						dp[i][j].push(tmpA[t]);
					}
			}
			// 从 i-1 个里选 j-1个
			var tmpB = dp[i-1][j-1];
			for(let z = 0; z < tmpB.length; z++){
					// 这里注意不能修改dp[i-1][j-1]的原数组元素，需要深拷贝
					var tmpC = [].concat(tmpB[z]);
					tmpC.push(i);
					dp[i][j].push(tmpC);
			}
		}
	}
	return dp[n][k];
};

// 解法二：迭代回溯
var combine = function(n, k) {
	var result = [];
	var subresult = [];
	// 初始化k个数字的临时组合各个元素为0
	// 便于++对应 n的1，2，3，4..n
	for(let r = 0; r < k; r++){
		subresult[r] = 0;
	}
	// n的总个数达不到k组合的个数 不可能实现
	if(n < k){
		return result;
	}
	// 迭代索引
	var i = 0;
	while(i >= 0){
		// 当前数字加一 对于回溯中 subresult push 一个新的i 即为上一个i+1
		subresult[i]++;
		// 当i循环到n时，此时 i=n+1 
		// i-- 对应回溯的函数调用执行栈的逆序出栈 即回到上一层的组合状态操作
		if(subresult[i] > n){
			i--;
		} else if (i == k -1){
			// 索引从0开始 i == k-1 相等于 回溯i从1开始后i==k 的情况
			result.push(subresult.slice(0));
		} else {
			// 对于回溯外层for循环的下一层i操作 即start
			++i;
			// 相当于回溯的pop操作 去掉新加的值 退回上一层的值重新递归 此处为迭代
			subresult[i] = subresult[i-1];
		}
	}
	return result;
};

// 解法三 
var combine = function(n, k) {
	var result = [];
	var subresult = [];
	function combineSub(start,subresult){
		if(subresult.length == k){
			result.push(subresult.slice(0));
			return;
		}
		var len = subresult.length;
		for(var i= start;i<=n-(k-len)+1;i++){
			subresult.push(i);
			combineSub(i+1,subresult);
			subresult.pop();            
		}   
	}
	combineSub(1,subresult);
	return result;
};
```

```javaScript
// 8 优美的排列 526
// 假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组
// 使得数组的第 i 位 (1 <= i <= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：
// 第 i 位的数字能被 i 整除
// i 能被第 i 位上的数字整除
// 现在给定一个整数 N，请问可以构造多少个优美的排列？

// 示例1:
// 输入: 2
// 输出: 2
// 解释: 
// 第 1 个优美的排列是 [1, 2]:
//   第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除
//   第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除
// 第 2 个优美的排列是 [2, 1]:
//   第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除
//   第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除
// 说明:
// N 是一个正整数，并且不会超过15。

var countArrangement = function(N) {
	// visited[num]表示num是否被使用
	// 每次循环都通过visited去找下一个符合要求的数字 找到后索引值加一
	// 一个for循环中每个数字只使用一次 使用完成以后需要释放 即visited[num] = false
	// arr.fill(value[, start[, end]])
	// value 填充值
	let visited = new Array(N+1).fill(false);
	let res = 0;
	let dfs = function(index) {
		if (index > N) {
			++res;
			return;
		}
		for (let num = 1; num <= N; ++num) {
			if (!visited[num] && (num % index === 0 || index % num === 0)) {
			visited[num] = true;
			dfs(index+1)
			visited[num] = false;
			}
		}
	} 
	dfs(1)
	return res;
};
```

```javaScript
// 9 优美的排列II 667
// 给你两个整数 n 和 k ，请你构造一个答案列表 answer ，该列表应当包含从 1 到 n 的 n 个不同正整数
// 并同时满足下述条件：
// 假设该列表是 answer = [a1, a2, a3, ... , an] 
// 那么列表 [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] 中应该有且仅有 k 个不同整数。
// 返回列表 answer 。如果存在多种答案，只需返回其中 任意一种 。
// 示例 1：
// 输入：n = 3, k = 1
// 输出：[1, 2, 3]
// 解释：[1, 2, 3] 包含 3 个范围在 1-3 的不同整数，并且 [1, 1] 中有且仅有 1 个不同整数：1
// 示例 2：

// 输入：n = 3, k = 2
// 输出：[1, 3, 2]
// 解释：[1, 3, 2] 包含 3 个范围在 1-3 的不同整数，并且 [2, 1] 中有且仅有 2 个不同整数：1 和 2
// 提示：
// 1 <= k < n <= 104

var constructArray = function (n, k) {
	// 寻找规律：
	// 使用k+1个数字，即可组成k个差值，剩余的部分直接使用差值为1顺序填充即可
	// [1, 1**+k**, 1+k**-(k-1), 1+k-(k-1)+(k-1-1)**,,,]
	let result = [1];
	let i = k;
	let num = 1;
	let flag = true; // true为正，false为负
	while (result.length <= k) {
		num = flag ? num + i : num - i;
		result.push(num);
		i--;
		flag = !flag;
	}
	// 基数已经准备好，进行剩余部分的填充
	num = result.length + 1;
	while (num <= n) {
		result.push(num++);
	}
	return result;
};
```

```javaScript
// 10 电话号码的字母组合 17
// 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。
// 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
// 示例 1：
// 输入：digits = "23"
// 输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
// 示例 2：
// 输入：digits = ""
// 输出：[]
// 示例 3：
// 输入：digits = "2"
// 输出：["a","b","c"]
var letterCombinations = (digits) => {
	if (!digits.length) return [];
	const map = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz'];
	let result = [];
	const backtrack = (str, index) => {
		// 1 如果单个字符串到底了，那就添加它
		if (index === digits.length) {
			result.push(str);
			return;
		}
		// 2 获取当前数字对应的字母
		const currentStr = map[Number(digits[index])];
		// 3 遍历这串字母，将其添加到下一次遍历中，同时位置向后挪一
		for (let i = 0; i < currentStr.length; i++) {
			backtrack(str + currentStr[i], index + 1);
		}
	};
	// 回溯
	backtrack('', 0);
	return result;
};
// 解法二： 暴力枚举
var letterCombinations = (digits) => {
	if (!digits.length) return [];
	const map = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz'];
	let result = map[Number(digits[0])].split('');
	const backtrack = (prev, next) => {
		// 1 设置 temp 获取当前的组合
		let temp = [];
		// 2 暴力遍历添加
		for (let i = 0; i < prev.length; i++) {
			for (let j = 0; j < next.length; j++) {
				temp.push(prev[i] + next[j]);
			}
		}
		// 3 返回拼接后的组合
		return temp;
	};
	// 遍历字符串
	for (let i = 1; i < digits.length; i++) {
		// 1 获取下一项添加的
		const next = map[Number(digits[i])];
		// 2 组合后返回给 result
		result = backtrack(result, next);
	}
	return result;
};
```

### 11 括号生成 22

```javaScript
// 11 括号生成 22
// 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
// 示例 1：
// 输入：n = 3
// 输出：["((()))","(()())","(())()","()(())","()()()"]
// 递归
var generateParenthesis = function (n) {
	let list = []
	function generate(left, right, s) {
		//  终止条件：如果左右括弧都用完则结束
		if (left === n && right === n) {
			list.push(s)
			return
		}
		// 如果左括弧未用完则继续增加左括弧
		if (left < n) {
			generate(left + 1, right, s + "(")
		}
		// 如果右括弧少于左括弧则继续增加右括弧
		if (left > right) {
			generate(left, right + 1, s + ")")
		}
	}
	generate(0, 0, "")
	return list
}
```

```javaScript
// 12 盛最多水的容器 11
// 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 
//在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)
// 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
// 说明：你不能倾斜容器。
// 输入：[1,8,6,2,5,4,8,3,7]
// 输出：49 
// 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
// 示例 2：
// 输入：height = [1,1]
// 输出：1
// 示例 3：
// 输入：height = [4,3,2,1,4]
// 输出：16
// 示例 4：
// 输入：height = [1,2,1]
// 输出：2
var maxArea = function (height) {
	let res = 0;
	let left = 0;
	let right = height.length - 1;
	while (left < right) {
		const area = Math.min(height[left], height[right]) * (right - left);
		res = Math.max(res, area);
		if (height[left] < height[right]) {
			left++;
		} else {
			right--;
		}
	}
	return res;
}
```

```javaScript
// 13 三数之和 15
// 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c 
// 使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
// 注意：答案中不可以包含重复的三元组。
// 示例 1：
// 输入：nums = [-1,0,1,2,-1,-4]
// 输出：[[-1,-1,2],[-1,0,1]]
// 示例 2：
// 输入：nums = []
// 输出：[]
// 示例 3：
// 输入：nums = [0]
// 输出：[]
var threeSum = function(nums) {
	if (nums.length < 3) {
		return [];
	}

	const res = [];

	let arr = [...nums];
	arr = arr.sort((a, b) => a - b);

	if(arr[0] > 0) {
		return [];
	}

	for(let i = 0; i < arr.length - 2; i++) {
		const target = 0 - arr[i];

		let p1 = i + 1;
		let p2 = arr.length - 1;
		while (p1 < p2) {
			if (arr[p1] + arr[p2] === target) {
				const subArr = [arr[i], arr[p1], arr[p2]];
				if (!isIncludes(res, subArr)) {
					res.push(subArr);
				}
				p1++;
			} else if (arr[p1] + arr[p2] < target) {
				p1++;
			} else {
				p2--;
			}
		}
	}
	return res;
}

var isIncludes = function(arr, subArr) {
	if(!arr.length) {
		return false;
	}
	return arr.some(item => item[0] === subArr[0] && item[1] === subArr[1] && item[2] === subArr[2])
}

// 扩展:从长度为 n 的数组中找到 长度为 m 的所有子集
function getSub(nums, m) {
	if (nums.length < m) return []; 
	const res = [];
	const backtrck = (arr, i) => {
		if (arr.length === m) {
			res.push(arr);
			return;
		}
		nums.forEach((item, index) => {
			if (index > i) {
				backtrck([...arr, item], index);
			} else {
				return;
			}
		})
	}
	backtrck([], -1);
	return res;
}

```

```javaScript
// 14 删除有序数组中的重复项 26
// 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。
// 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
// 说明:
// 为什么返回数值是整数，但输出的答案是数组呢?
// 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
// 你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
// int len = removeDuplicates(nums);
// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
// for (int i = 0; i < len; i++) {
//     print(nums[i]);
// }
// 示例 1：
// 输入：nums = [1,1,2]
// 输出：2, nums = [1,2]
// 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 
// 不需要考虑数组中超出新长度后面的元素。
var removeDuplicates = function (nums) {
	let p1 = 0;
	let p2 = 0;
	while (p2 < nums.length) {
		if (nums[p1] !== nums[p2]) {
			p1++;
			nums[p1] = nums[p2];
		}
		p2++;
	}
	while(nums.length > p1 + 1){
	nums.length--;
	}
	// 返回的是实际的长度，因为下标是从0开始的
	return p1 + 1;
};
```

```javaScript
// 15 加一 66
// 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。
// 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
// 你可以假设除了整数 0 之外，这个整数不会以零开头。
// 示例 1：
// 输入：digits = [1,2,3]
// 输出：[1,2,4]
// 解释：输入数组表示数字 123。
// 示例 2：
// 输入：digits = [4,3,2,1]
// 输出：[4,3,2,2]
// 解释：输入数组表示数字 4321。
var plusOne = function(digits) {
	let carry = false;
	digits[digits.length - 1] ++;
	for(let i = digits.length - 1; i >= 0; i--){
		if(carry) digits[i]++;
		carry = digits[i] > 9;
		digits[i] %= 10;
	}
	if(carry) digits.unshift(1);
	return digits;
};


```

### 16 移动零

```javaScript
// 16 移动零 283
// 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
// 示例:
// 输入: [0,1,0,3,12]
// 输出: [1,3,12,0,0]
// 说明:
// 必须在原数组上操作，不能拷贝额外的数组。
// 尽量减少操作次数。
var moveZeroes = function (nums) {
	let p = 0;
	// 把所有的非0移到前面
	for (let i = 0; i < nums.length; i++) {
		if (nums[i] != 0) { // 遇到非0项
			nums[p] = nums[i]; // 覆盖到p上
			p++;    // j后移
		}
	}
	// 剩下的位置赋为0
	for (let i = p; i < nums.length; i++) {
		nums[i] = 0;
	}
};
```

```javaScript
// 17 最小栈 155
// 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
// push(x) —— 将元素 x 推入栈中。
// pop() —— 删除栈顶的元素。
// top() —— 获取栈顶元素。
// getMin() —— 检索栈中的最小元素。
var MinStack = function() {
    this.stack = [];
    this.min_stack = [];
};
MinStack.prototype.push = function(val) {
    this.stack.push(val);
    if (val <= this.getMin() || this.min_stack.length == 0) {
        this.min_stack.push(val);
    }
};
MinStack.prototype.pop = function() {
    let out = this.stack.pop();
    if (this.getMin() == out) {
        this.min_stack.pop();
    }
};
MinStack.prototype.top = function() {
    return this.stack[this.stack.length - 1];
};
MinStack.prototype.getMin = function() {
    return this.min_stack[this.min_stack.length - 1];
};
```

```javaScript
// 18 跳跃游戏 55
// 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
// 数组中的每个元素代表你在该位置可以跳跃的最大长度。
// 判断你是否能够到达最后一个下标。
// 示例 1：
// 输入：nums = [2,3,1,1,4]
// 输出：true
// 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
// 示例 2：
// 输入：nums = [3,2,1,0,4]
// 输出：false
// 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
// 解法一： 贪心算法
var canJump = function (nums) {
	// maxStep 代表跳到的最远的距离
	let maxStep = 0;
	for (let i = 0; i < nums.length; i++) {
		// 如果遍历的到的索引已经比最远能到到的距离还要大
		// 说明根本没有机会再继续走下去
		if (i > maxStep) {
			return false;
		}
		maxStep = Math.max(maxStep, i + nums[i]);
	}
	return true;
};
// 解法二：
// 1、起跳点：当前位置
// 2、最大可能：跳一次能影响的最大长度
// 3、return 起跳点+最大可能 >= 终点
var canJump = function(nums) {
	if(nums.length < 2) return true;

	for(let i = 0; i < nums.length - 1;) {
		// i: 起跳点
		if(nums[i] === 0) return false
		let n = nums[i];
		let index = 1;
		for(let j = 1; j <= nums[i]; j++) {
			let m = j + nums[i+j];
			if(m > n) {
				n = m;
				index = j; // 最大可能时的位移长度
			}
		}
		if(i + n >= nums.length - 1) return true;
		i += index;
	}
	return false;
};
```

```javaScript
// 19 跳跃游戏 II 45
// 给定一个非负整数数组，你最初位于数组的第一个位置。
// 数组中的每个元素代表你在该位置可以跳跃的最大长度。
// 你的目标是使用最少的跳跃次数到达数组的最后一个位置。
// 假设你总是可以到达数组的最后一个位置。

// 示例 1:
// 输入: [2,3,1,1,4]
// 输出: 2
// 解释: 跳到最后一个位置的最小跳跃数是 2。
//      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
// 示例 2:
// 输入: [2,3,0,1,4]
// 输出: 2

// 贪心算法 动态规划
// 从第一项出发，用最少的步数跳到最后一项
// (1)遍历一个可抵达的区间，从中选出能跳最远的点
// (2)就有了新的可抵达的区间，然后跳跃一次，进入新的区间继续遍历寻求最优解
var jump = function (nums) {
	// 记录当前能去到的最远的位置
	// 遍历每个点都会求能跳到的最远位置，与它比较，如果把它大就更新它
	let p1 = 0; // farthestPos
	let p2 = 0; // endOfCanReach
	let res = 0;
	for (let i = 0; i < nums.length - 1; i++) {
		p1 = Math.max(p1, i + nums[i]);
		if (i === p2) { 
			// 可抵达区间的右端位置
			p2 = p1;
			res++;
		}
		// 一旦新的可抵达区间触碰到nums数组的边界，则直接break，不用对区间的点遍历了
		if (p2 >= nums.length - 1) {
			break;
		}
	}
	return res;
};
```

```javaScript
// 20 最大子序和 53
// 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素）
// 返回其最大和。
// 示例 1：
// 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
// 输出：6
// 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 
// 动态规划

var maxSubArray = function(nums) {
	let ans = nums[0];
	let sum = 0;
	for(let num of nums) {
		// if(sum > 0) { 可以写成这样
		if(sum + num > num ){
			sum = sum + num;
		} else {
			sum = num;
		}
		ans = Math.max(ans, sum);
	};
	return ans;
};

```

### 21 最接近的三数之和

```javaScript
// 21 最接近的三数之和 16
// 给定一个包括 n 个整数的数组 nums 和 一个目标值 target,找出 nums 中的三个整数
// 使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
// 示例：
// 输入：nums = [-1,2,1,-4], target = 1
// 输出：2
// 解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。

var threeSumClosest = function(nums, target) {
	nums = nums.sort((a, b) => a - b);
	let res = nums[0] + nums[1] + nums[2];
	for(let i = 0; i < nums.length - 2; i++) {
		let p1 = i + 1;
		let p2 = nums.length - 1;
		while (p1 < p2) {
			const sum = nums[i] + nums[p1] + nums[p2];
			if (Math.abs(target - sum) < Math.abs(target - res)) {
				res = sum;
			}
			if (target > sum) {
				p1++;
			} else {
				p2--;
			}
		}
	}
	return res;
}
```

```javaScript
// 22 四数之和 18
// 给定一个包含 n 个整数的数组 nums 和一个目标值 target
// 判断 nums 中是否存在四个元素 a，b，c 和 d 
// 使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。
// 注意：答案中不可以包含重复的四元组。
// 示例 1：
// 输入：nums = [1,0,-1,0,-2,2], target = 0
// 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
// 示例 2：
// 输入：nums = [], target = 0
// 输出：[]
var fourSum = function(nums, target) {
    const res = [{}, []];
    nums.sort((a, b) => a - b);
    for (var i = 0, len = nums.length, key; i < len - 3; i++) {
        for (var j = i + 1; j < len - 2; j++) {
            let l = j + 1;
            let r = len - 1;
            const sum = nums[i] + nums[j];
            while (l < r) {
                if (sum + nums[l] + nums[r] === target) {
                    const key = '' + nums[i] + nums[j] + nums[l] + nums[r];
                    if (!res[0][key]) {
                        res[0][key] = 1;
                        res[1].push([nums[i], nums[j], nums[l], nums[r]]);
                    }
                    r--;
                } else {
                    if (!(sum + nums[l] + nums[r] > target && r--)) {
                        l++;
                    }
                }
            }
        }
    }
    return res[1];
};
```

```javaScript
// 23 字母异位词分组 49
// 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。
// 示例:
// 输入: ["eat", "tea", "tan", "ate", "nat", "bat"]
// 输出:
// [
//   ["ate","eat","tea"],
//   ["nat","tan"],
//   ["bat"]
// ]
/**
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function (strs) {
	const hashTable = {};
	// 这个方法需要排序，因此不是很优，但是很直观，容易想到
	for (let i = 0; i < strs.length; i++) {
		const str = strs[i];
		const key = str.split("").sort().join("");
		if (!hashTable[key]) {
			hashTable[key] = [str];
		} else {
			hashTable[key].push(str);
		}
	}
	return Object.values(hashTable);
};
```

```javaScript
// 24 最长连续递增序列 674
// 给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。
// 连续递增的子序列 可以由两个下标 l 和 r（l < r）确定
// 如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] 
// 那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。
// 示例 1：
// 输入：nums = [1,3,5,4,7]
// 输出：3
// 解释：最长连续递增序列是 [1,3,5], 长度为3。
// 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
// 示例 2：
// 输入：nums = [2,2,2,2,2]
// 输出：1
// 解释：最长连续递增序列是 [2], 长度为1。
// 解法一：贪心算法
var findLengthOfLCIS = function(nums) {
	if (nums.length === 0) return 0;
	const n = nums.length;
	let left = 0;
	let right = 1;
	let res = 1
	let maxLen = 1;
	while (right < n) {
		if (nums[right] > nums[left]){
			maxLen++;
		} else {
			maxLen = 1;
		}
		left++;
		right++;
		res = Math.max(res, maxLen);
	}
	return res;
};
// 解法二：双指针
// var findLengthOfLCIS = function(nums) {
// 	if(!nums.length) return 0;
// 	let res = 0;
// 	let left = 0;
// 	let right = 0;
// 	while(right < nums.length) {
// 		while(nums[right + 1] > nums[right]) {
// 			right++;
// 		}
// 		const sub = nums.slice(left, right + 1);
// 		res = Math.max(res, sub.length);
// 		right++;
// 		left = right;
// 	}
// 	return res;
// }
```

```javaScript
// 25 最长递增子序列 300
// 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
// 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
// 示例 1：
// 输入：nums = [10,9,2,5,3,7,101,18]
// 输出：4
// 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
// 示例 2：
// 输入：nums = [0,1,0,3,2,3]
// 输出：4
// 示例 3：
// 输入：nums = [7,7,7,7,7,7,7]
// 输出：1
// 动态规划
var lengthOfLIS = function(nums) {
	if (!nums.length) return 0;
	let i = 0;
	const temArr = new Array(nums.length);
	let res = 1;
	while(i < nums.length) {
		temArr[i] = 1;
		if (i > 0) {
			let m = i - 1;
			while(m > -1) {
				if (nums[i] > nums[m] && temArr[m] + 1 > temArr[i]) {
					temArr[i] = temArr[m] + 1;
					res = Math.max(res, temArr[i])
				}
				m--;
			}
		}
		i++;
	}
	return res;
};
```

### 26 寻找两个正序数组的中位数

```javaScript
// 26 寻找两个正序数组的中位数 4
// 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2
// 请你找出并返回这两个正序数组的 中位数 。
// 示例 1：
// 输入：nums1 = [1,3], nums2 = [2]
// 输出：2.00000
// 解释：合并数组 = [1,2,3] ，中位数 2
// 示例 2：
// 输入：nums1 = [1,2], nums2 = [3,4]
// 输出：2.50000
// 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
// 示例 3：
// 输入：nums1 = [0,0], nums2 = [0,0]
// 输出：0.00000
// 示例 4：
// 输入：nums1 = [], nums2 = [1]
// 输出：1.00000
// 示例 5：
// 输入：nums1 = [2], nums2 = []
// 输出：2.00000
//  
// 提示：
// nums1.length == m
// nums2.length == n
// 0 <= m <= 1000
// 0 <= n <= 1000
// 1 <= m + n <= 2000
// -106 <= nums1[i], nums2[i] <= 106
var findMedianSortedArrays = function(nums1, nums2) {
	let m = nums1.length;
	let n = nums2.length;
	let i = 0;
	let j = 0;
	let newArr = [];
	while (i < m && j < n) {
		if (nums1[i] < nums2[j]) {
			newArr.push(nums1[i++]);
		} else {
			newArr.push(nums2[j++]);
		}
	}
	newArr = newArr.concat(i < m ? nums1.slice(i) : nums2.slice(j));
	const len = newArr.length;
	if (len % 2 === 0) {
		return (newArr[len / 2] + newArr[len / 2 - 1]) / 2;
	} else {
		return newArr[Math.floor(len / 2)];
	}
};
```

```javaScript
// 27 和为K的子数组 560
// 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
// 示例 1 :
// 输入:nums = [1,1,1], k = 2
// 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
// 说明 :
// 数组的长度为 [1, 20,000]。
// 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。
var subarraySum = function(nums, k) {
	let res = 0;
	let sum1 = 0;
	let sum2 = 0;
	let map = new Map();
	map.set(0, 1);
	for (let i = 0; i <= nums.length; i++) {
		sum1 += nums[i];
		sum2 = sum1 - k;
		if (map.has(sum2)) {
			res += map.get(sum2);
		}
		let sumCnt = map.get(sum1) || 0;
		map.set(sum1, sumCnt + 1);
	}
	return res;
};

```

```javaScript
// 28 两数之和 II - 输入有序数组 167
// 给定一个已按照 升序排列  的整数数组 numbers
// 请你从数组中找出两个数满足相加之和等于目标数 target 。
// 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。
// numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 <= answer[0] < answer[1] <= numbers.length 。
// 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
// 示例 1：
// 输入：numbers = [2,7,11,15], target = 9
// 输出：[1,2]
// 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
// 示例 2：
// 输入：numbers = [2,3,4], target = 6
// 输出：[1,3]
// 示例 3：
// 输入：numbers = [-1,0], target = -1
// 输出：[1,2]
var twoSum = function (numbers, target) {
	const map = new Map();
	for (let i = 0; i < numbers.length; i++) {
		let tmp = target - numbers[i]
		if (map.has(tmp)) {
			return [map.get(tmp) + 1, i + 1]
		}
		map.set(numbers[i], i)
	}
}
```

```javaScript
// 29 合并区间 56
// 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi]
// 请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。
// 示例 1：
// 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
// 输出：[[1,6],[8,10],[15,18]]
// 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
// 示例 2：
// 输入：intervals = [[1,4],[4,5]]
// 输出：[[1,5]]
// 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
var merge = function(intervals) {
	if (intervals.length === 0) return [];
	intervals.sort((a, b) => a[0] - b[0]);
	const mergeArr = [intervals[0]];
	for (let i = 1; i < intervals.length; i++) {
		const item = intervals[i];
		const last = mergeArr[mergeArr.length - 1];
		if (last[1] >= item[0]) {
			last[1] = Math.max(item[1], last[1]);
		} else {
			mergeArr.push(item);
		}
	}
	return mergeArr;
};
```

```javaScript
// 30 插入区间 57
// 给你一个 无重叠的 ，按照区间起始端点排序的区间列表。
// 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。

// 示例 1：
// 输入：intervals = [[1,3],[6,9]], newInterval = [2,5]
// 输出：[[1,5],[6,9]]

// 示例 2：
// 输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
// 输出：[[1,2],[3,10],[12,16]]
// 解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。

// 示例 3：
// 输入：intervals = [], newInterval = [5,7]
// 输出：[[5,7]]

// 示例 4：
// 输入：intervals = [[1,5]], newInterval = [2,3]
// 输出：[[1,5]]

// 示例 5：
// 输入：intervals = [[1,5]], newInterval = [2,7]
// 输出：[[1,7]]

var insert = function(intervals, newInterval) {
	if (intervals.length === 0) return [newInterval];
	// 最左侧
	if (newInterval[1] < intervals[0][0]) {
		return [newInterval, ...intervals];
	}
	// 最右侧
	if (newInterval[0] > intervals[intervals.length - 1][1]) {
		return [...intervals, newInterval];
	}
	let leftSub = [];
	let midSub = [];
	let rifhtSub = [];
	for(let i = 0; i < intervals.length; i++) {
		// 左侧 有重叠
		if (intervals[i][0] <= newInterval[0] && newInterval[0] <= intervals[i][1]) {
			midSub[0] = intervals[i][0];
			leftSub = intervals.slice(0, i);
		}
		// 右侧 有重叠
		if (intervals[i][0] <= newInterval[1] && newInterval[1] <= intervals[i][1]) {
			midSub[1] = intervals[i][1];
			rifhtSub = intervals.slice(i + 1);
		}
		if (i > 0) {
			// 左侧 无重叠，在区间中
			if (intervals[i - 1][1] < newInterval[0] && newInterval[0] < intervals[i][0]) {
					midSub[0] = newInterval[0];
					leftSub = intervals.slice(0, i);
			}
			// 右侧 无重叠，在区间中
			if (intervals[i - 1][1] < newInterval[1] &&  newInterval[1] < intervals[i][0]) {
					midSub[1] = newInterval[1];
					rifhtSub = intervals.slice(i);
			}
		}
		// 超出左侧边界
		if (newInterval[0] < intervals[0][0]) {
			midSub[0] = newInterval[0];
		}
		// 超出右侧边界
		if (i === intervals.length - 1 && newInterval[1] > intervals[i][1]) {
			midSub[1] = newInterval[1];
		}
	}
	return [...leftSub, midSub, ...rifhtSub];
};
```

### 31 搜索旋转排序数组

```javaScript
// 31 搜索旋转排序数组 I 33 / II 81
// 整数数组 nums 按升序排列，数组中的值 互不相同 。
// 在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，
// 使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]
// （下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
// 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，
// 则返回它的下标，否则返回 -1 。

// 示例 1：
// 输入：nums = [4,5,6,7,0,1,2], target = 0
// 输出：4

// 示例 2：
// 输入：nums = [4,5,6,7,0,1,2], target = 3
// 输出：-1

// 示例 3：
// 输入：nums = [1], target = 0
// 输出：-1

var search = function(nums, target) {
	let start = 0;
	let end = nums.length - 1;
	while(start <= end) {
		const mid = start + Math.floor((end - start) / 2);
		if (nums[mid] === target) {
			return mid;
		}
		if (nums[mid] >= nums[start]) {
			if (target >= nums[start] && target < nums[mid]) {
					end = mid - 1;
			} else {
					start = mid + 1;
			}
		} else {
			if (target <= nums[end] && target > nums[mid]) {
					start = mid + 1;
			} else {
					end = mid - 1;
			}
		}
	}
	return -1;
};

// 搜索旋转排序数组 II 81
// 已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。

// 在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转 ，
// 使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]
// （下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 
// 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。
// 给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。
// 如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。

// 示例 1：
// 输入：nums = [2,5,6,0,0,1,2], target = 0
// 输出：true

// 示例 2：
// 输入：nums = [2,5,6,0,0,1,2], target = 3
// 输出：false

var search = function(nums, target) {
	let start = 0
	let end = nums.length - 1
	while (start <= end) {
		// let mid = start + ((end - start) >> 1)
		let mid = start + Math.floor((end - start) / 2);

		if (nums[mid] === target) {
			return true
		}
		
		if (nums[start] > nums[mid]) { 
			// 左大于中, 最大值在左边

			if (nums[mid] < target && nums[end] >= target) { 
				start = mid + 1;
			} else {
				end = mid - 1;
			}
		} else if (nums[start] < nums[mid]) {
			// 左小于中, 说明左边是非递减的

			if (nums[start] <= target && nums[mid] > target) {
				end = mid - 1;
			} else {
				start = mid + 1;
			}
		} else {
			// 左等于中, 无法判断

			start++;
			if (nums[end] === nums[mid]) {
				end--;
			}
		}
	}
	return false
};
```

```javaScript
// 32 在排序数组中查找元素的第一个和最后一个位置
// 给定一个按照升序排列的整数数组 nums，和一个目标值 target。
// 找出给定目标值在数组中的开始位置和结束位置。
// 如果数组中不存在目标值 target，返回 [-1, -1]。

// 示例 1：

// 输入：nums = [5,7,7,8,8,10], target = 8
// 输出：[3,4]

// 示例 2：
// 输入：nums = [5,7,7,8,8,10], target = 6
// 输出：[-1,-1]

// 示例 3：
// 输入：nums = [], target = 0
// 输出：[-1,-1]

var searchRange = function(nums, target) {

	function search (nums, target, flag) {
		let start = 0;
		let end = nums.length - 1;
		while (start <= end) {
			let mid = start + (Math.floor((end - start) / 2));
			if (nums[mid] === target) {
				if (flag) {
					if (mid === 0 || nums[mid - 1] !== target) {
						return mid;
					}
					end = mid - 1;
				} else {
					if (mid === nums.length - 1 || nums[mid + 1] !== target) {
						return mid;
					}
					start = mid + 1;
				}
			} else if (nums[mid] > target) {
				end = mid - 1;
			} else if (nums[mid] < target) {
				start = mid + 1;
			}
		}
		return -1;
	}
	return [search(nums, target, true), search(nums, target, false)]
};
```

```javaScript
// 33 下一个排列 31
// 实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
// 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
// 必须 原地 修改，只允许使用额外常数空间。

// 示例 1：

// 输入：nums = [1,2,3]
// 输出：[1,3,2]

// 示例 2：
// 输入：nums = [3,2,1]
// 输出：[1,2,3]

// 示例 3：
// 输入：nums = [1,1,5]
// 输出：[1,5,1]

// 示例 4：
// 输入：nums = [1]
// 输出：[1]

// 示例 5：
// 输入 [4,2,3,1]
// 输出 [4,3,1,2]

// 1 从右往左，找到第一个小于 它右边的 数字
// 2 把这个数字 与 它右边 互换
// 3 把它右边所有的数 翻转
function nextPermutation(nums) {
	// 从右向左遍历，i从倒数第二开始是为了nums[index1+1]要存在
	let index1 = nums.length - 2;

	// 寻找第一个小于右邻居的数
	while (index1 >= 0 && nums[index1] >= nums[index1 + 1]) {
		index1--;
	}
	// 这个数在数组中存在，从它身后挑一个数，和它换
	if (index1 >= 0) {
		// 从最后一项，向左遍历                     
		let index2 = nums.length - 1;   
		// 寻找第一个大于 nums[index1] 的数             
		while (index2 >= 0 && nums[index2] <= nums[index1]) {  
			index2--;
		}
		// 两数交换，实现变大
		[nums[index1], nums[index2]] = [nums[index2], nums[index1]]; 
	}

	// 抹平另外两种情况：
	// 1、如果 index1 = -1，说明是递减排列，如 3 2 1，没有下一排列，直接翻转为最小排列：1 2 3
	// 2、[4,2,3,1] 预期结果 [4,3,1,2], 结果却是[4,3,2,1]
	let l = index1 + 1;           
	let r = nums.length - 1;
	// index1 右边的数进行翻转，使得变大的幅度小一些
	while (l < r) {                            
		[nums[l], nums[r]] = [nums[r], nums[l]];
		l++;
		r--;
	}
}

```

```javaScript
// 34 旋转图像 48
// 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。
// 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。
// 示例 1：
// 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
// 输出：[[7,4,1],[8,5,2],[9,6,3]]

// 示例 2：
// 输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
// 输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]

// 示例 3：
// 输入：matrix = [[1]]
// 输出：[[1]]

// 示例 4：
// 输入：matrix = [[1,2],[3,4]]
// 输出：[[3,1],[4,2]]

var rotate = function(matrix) {
	let n = matrix.length
	for(let i = 0; i < n; i++) {
		for(let j = i; j < n - 1 - i; j++) {
			let tmp = matrix[i][j];
			matrix[i][j] = matrix[n - 1 - j][i];
			matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];
			matrix[n - 1 - i][n - 1 -j] = matrix[j][n - 1 - i];
			matrix[j][n - 1 - i] = tmp;
		}
	}
};
```

```javaScript
// 35 螺旋矩阵 54
// 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

// 示例 1：
// 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
// 输出：[1,2,3,6,9,8,7,4,5]

// 示例 2：
// 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
// 输出：[1,2,3,4,8,12,11,10,9,5,6,7]

var spiralOrder = function (matrix) {
	if (matrix.length == 0) return []
	const res = [];
	let top = 0;
	let bottom = matrix.length - 1;
	let left = 0;
	let right = matrix[0].length - 1;
	while (top <= bottom && left <= right) {
		for (let i = left; i <= right; i++) {
			res.push(matrix[top][i]);
		}
		top++;
		for (let i = top; i <= bottom; i++) {
			res.push(matrix[i][right]);
		}
		right--;
		if (top > bottom || left > right) break
		for (let i = right; i >= left; i--) {
			res.push(matrix[bottom][i]);
		}
		bottom--;
		for (let i = bottom; i >= top; i--) {
			res.push(matrix[i][left]);
		}
		left++;
	}
	return res;
};

```

## 四 字符串

1 验证回文串 —— 给定一个字符串，验证它是否是回文串
2 爬楼梯 —— 每次你可以爬 1 或 2 个台阶。求有多少种方法
3 打家劫舍 —— 数组n的最大和，其中每一项不能相互连续
4 最长回文子串 —— 找到字符串 s 中最长的回文子串
5 编辑距离 —— 计算将 word1 转换成 word2 所使用的最少操作数
6 无重复字符的最长子串 —— 找出其中不含有重复字符的 最长子串 的长度
7 整数转罗马数字
8 罗马数字转整数
9 最小路径和 —— 从二位数组 的 第一个 到 最后一个 的最小路径和
10 最长公共前缀 —— 字符串数组中的最长公共前缀
11 最小覆盖子串 —— 找到字符串 s 中最小覆盖 字符串的 t
12 单词拆分 —— 判断 s 是否可以被空格拆分为一个或多个在字典中出现的单词
13 100层丢鸡蛋 —— 有2个鸡蛋，从100层中丢下，找到刚好破的那一层
14 较大分组的位置 —— 找到字符串中 最大连续(同样)的 子串
15 下划线与驼峰互换
16 Z 字形变换 —— 将字符串按照 从上往下、从左到右进行 Z 字形排列
17 不同的路径 —— 从 m*n 表格的左上角移动到右下角，有多少种路径

### 1 验证回文串

```javaScript
// 1 验证回文串 125
// 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
// 说明：本题中，我们将空字符串定义为有效的回文串。
// 示例 1:
// 输入: "A man, a plan, a canal: Panama"
// 输出: true
// 示例 2:
// 输入: "race a car"
// 输出: false
var isPalindrome = function(s) {
	const strArr = s.toLocaleLowerCase().match(/[A-Za-z0-9]+/g);
	if(!strArr) return true;
	const str = strArr.join('');
	let left = 0;
	let right = str.length - 1;
	while(left < right){
		if(str[left] === str[right]){
			left++;
			right--;
		} else {
			return false
		}
	}
	return true
};
```

```javaScript
// 2 爬楼梯 70
// 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
// 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
// 注意：给定 n 是一个正整数。
// 示例 1：
// 输入： 2
// 输出： 2
// 解释： 有两种方法可以爬到楼顶。
// 1.  1 阶 + 1 阶
// 2.  2 阶
/**
 * @param {number} n
 * @return {number}
 */
// 动态规划一： 时间复杂度 O(n) 空间复杂度：O(n)
var climbStairs = function(n) {
	if (n < 2) {
	    return 1;
	}
	const dp = [1, 1];
	for(let i = 2; i <= n; i++) {
	// 斐波那契数列 f(n) = f(n-1) + f(n-2)
		dp[i] = dp[i - 1] + dp[i - 2];
	}
	return dp[n];
};

// 动态规划二： 时间复杂度 O(n) 空间复杂度 O(1)
var climbStairs = function(n) {
	if (n < 2) {
		return 1;
	}
	let dp1 = 1; // 记录 n-2 的值
	let dp2 = 1; // 记录 n-1 的值
	for(let i = 2; i <= n; i++) {
		// 将 n-1 的值赋值给 n-2
		// 将 n-1 和 n-2 的和, 赋值给 n-1
		// 即 完成了 f(n) = f(n-1) + f(n-2)
		const tem = dp1;
		dp1 = dp2;
		dp2 = tem + dp1;
	}
	return dp2;
};
```

```javaScript
// 3 打家劫舍 198
// 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金
// 影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统
// 如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
// 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
// 示例 1：
// 输入：[1,2,3,1]
// 输出：4
// 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
//      偷窃到的最高金额 = 1 + 3 = 4 
// 动态规划解法一：
var rob = function(nums) {
	// 解题步骤：
	// 1. 用 fn1(k) 代表 前k个房屋中能偷窃到的最大金额
	// 2. 用 fn2(k) 代表 第k个房屋中的金额
	// 3. fn1(k) = Math.max(fn1(k-2) + fn2(k), fn1(k-1))
	if (nums.length === 0) {
		return 0;
	}
	if (nums.length === 1) {
		return nums[0];
	}
	// dp[0]代表第0个房屋的金额, dp[1]代表第1个房屋的金额
	const dp = [0, nums[0]];
	for(let i = 2; i <= nums.length; i++) {
		dp[i] = Math.max(dp[i - 2] + nums[i - 1], dp[i - 1]);
	}
	return dp[dp.length - 1];
};

// 动态规划解法二：
var rob = function(nums) {
	if (nums.length === 0) {
		return 0;
	}
	if (nums.length === 1) {
		return nums[0];
	}
	let dp0 = 0;
	let dp1 = nums[0];
	for(let i = 2; i <= nums.length; i++) {
		const tem = Math.max(dp0 + nums[i - 1], dp1);
		dp0 = dp1;
		dp1 = tem;
	}
	return dp1;
};
```

```javaScript
// 4 最长回文子串 5
// 给你一个字符串 s，找到 s 中最长的回文子串。
// 示例 1：
// 输入：s = "babad"
// 输出："bab"
// 解释："aba" 同样是符合题意的答案。
// 示例 2：
// 输入：s = "cbbd"
// 输出："bb"

// 解法一: 动态规划, 性能比较查
var longestPalindrome = function(s) {
	let len = s.length;
	let res = '';
	// 创建二维数组
	let dp = Array.from(new Array(len),()=>(new Array(len).fill(0)));
	// 从字符串首部开始
	for(let i = 0; i < len; i++) {
		// 从字符串i前开始依次向前查找
		for(let j = i; j >= 0; j--) {
			dp[j][i] = s[i] == s[j] && (i - j < 2 || dp[j + 1][i - 1]);
			if(dp[j][i] && i - j + 1 > res.length) {
				res = s.substring(j, i + 1);
			}
		}
	}
	// console.log(dp)
	return res
};

// 解法二: 从中间往两边寻找, 性能更好
var longestPalindrome = function(s) {
	if (s.length === 1) return s;
	let maxRes = 0, maxStr = '';
	for (let i = 0; i < s.length; i++) {
		// str1 是为了防止 "aba" 的情况
		let str1 = palindrome(s, i, i);
		// str2 是为了防止 "abba" 的情况
		let str2 = palindrome(s, i, i + 1);   
		if (str1.length > maxRes) {
			maxStr = str1;
			maxRes = str1.length;
		}
		if (str2.length > maxRes) {
			maxStr = str2;
			maxRes = str2.length;
		}
	}
	return maxStr;
};
function palindrome(s, l, r) {
	while (l >= 0 && r < s.length && s[l] === s[r]) {
		l--;
		r++;
	}
	return s.slice(l + 1, r);
}
```

```javaScript
// 5 编辑距离 72
// 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
// 你可以对一个单词进行如下三种操作：
//  - 插入一个字符
//  - 删除一个字符
//  - 替换一个字符
// 示例 1：
// 输入：word1 = "horse", word2 = "ros"
// 输出：3
// 解释：
// horse -> rorse (将 'h' 替换为 'r')
// rorse -> rose (删除 'r')
// rose -> ros (删除 'e')
// 示例 2：
// 输入：word1 = "intention", word2 = "execution"
// 输出：5
// 解释：
// intention -> inention (删除 't')
// inention -> enention (将 'i' 替换为 'e')
// enention -> exention (将 'n' 替换为 'x')
// exention -> exection (将 'n' 替换为 'c')
// exection -> execution (插入 'u')
var minDistance = function(word1, word2) {
	let m = word1.length + 1;
	let n = word2.length + 1;
	let dp = new Array(m);
	for(let k = 0; k < m; k++) {
		dp[k] = new Array(n);
	}
	for(let i = 0; i < m; i++ ) {
		dp[i][0] =  i;
	}
	for(let j = 0; j < n; j++ ) {
		dp[0][j] =  j;
	}
	for(let i = 1; i < m; i++ ) {
		for(let j = 1; j < n; j++ ) {
			if(word1[i-1] == word2[j-1]) {
				dp[i][j] = dp[i-1][j-1]
			} else {
				dp[i][j] = 1 + Math.min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])
			}
		}
	}
	return dp[m-1][n-1]
};
```

### 6 无重复字符的最长子串

```javaScript
// 6 无重复字符的最长子串 3
// 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
// 示例 1:
// 输入: s = "abcabcbb"
// 输出: 3 
// 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
// 示例 2:
// 输入: s = "bbbbb"
// 输出: 1
// 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
/**
 * 解题思路：
 * 1、用双指针维护一个滑动窗口，从来剪切子串
 * 2、不断移动右指针，遇到重复字符串，就把左指针移动到重复字符串的下一位
 * 3、移动右指针的过程中，记录所有窗口的长度，并返回最大值
 * 时间复杂度： O(n)
 * 空间复杂度： O(m)  m是字符串s不重复字符的个数
 */
var lengthOfLongestSubstring = function(s) {
	if(!s) return 0;
	const m = new Map();
	let res = 0;
	let l = 0;
	for(let i = 0; i < s.length; i++) {
		if (m.has(s[i]) && m.get(s[i]) >= l) {
			l = m.get(s[i]) + 1;
		}
		m.set(s[i], i);
		res = Math.max(res, i - l + 1);
	}
	return res;
};
```

```javaScript
// 7 整数转罗马数字 12
// 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。
// 字符          数值
// I             1
// V             5
// X             10
// L             50
// C             100
// D             500
// M             1000
// 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。
// 27 写做  XXVII, 即为 XX + V + II 。
// 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，
// 例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。
// 同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
//  - I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
//  - X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
//  - C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
// 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。
// 示例 1:
// 输入: 3
// 输出: "III"
// 示例 2:
// 输入: 4
// 输出: "IV"
// 示例 3:
// 输入: 9
// 输出: "IX"
// 示例 4:
// 输入: 58
// 输出: "LVIII"
// 解释: L = 50, V = 5, III = 3.
// 示例 5:
// 输入: 1994
// 输出: "MCMXCIV"
// 解释: M = 1000, CM = 900, XC = 90, IV = 4.
// var intToRoman = function (num) {
//     let keys = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
//         values = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'];
//     let res = "";
//     for (let i = 0; i < keys.length; i++) {
//         while (num >= keys[i]) {
//             num -= keys[i];
//             res += values[i];
//         }
//     }
//     return res;
// };
var intToRoman = function(num) {
	let keys = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];
	const values = ['M','CM','D','CD','C','XC','L','XL','X','IX','V','IV','I'];
	let result = '';
	while(num){
		if(num >= keys[0]){
			result += values[0];
			num -= keys[0];
		}else{
			keys.shift();
			values.shift();
		}
	}
	return result;
};
```

```javaScript
// 8 罗马数字转整数 13
var romanToInt = function(s) {
	const map = {
		"I": 1,
		"V": 5,
		"X": 10,
		"L": 50,
		"C": 100,
		"D": 500,
		"M": 1000
	}
	let result = 0;
	for(let i = 0; i < s.length; i++){
		map[s[i]] < map[s[i+1]] ?
			result -= map[s[i]] : result += map[s[i]];
	}
	return result;
};
```

```javaScript
// 9 最小路径和 64
// 给定一个包含非负整数的 m x n 网格 grid ，
// 请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
// 说明：每次只能向下或者向右移动一步。

// 动态规划
var minPathSum = function(grid) {
	let m = grid.length;
	let n = grid[0].length;
	const arr = new Array(m);
	for(let i = 0; i < arr.length; i++) {
		arr[i] = new Array(n).fill(0);
	}
	for(let i = 0; i < m; i++) {
		const subArr = grid[i];
		for(let j = 0; j < subArr.length; j++) {
			if (i === 0) {
				arr[i][j] = j === 0 ? subArr[0] : arr[i][j - 1] + subArr[j];
			} else {
				if (j === 0) {
					arr[i][j] = arr[i - 1][j] + subArr[j];
				} else {
					const tem = Math.min(arr[i - 1][j], arr[i][j - 1]);
					arr[i][j] = subArr[j] + tem;
				}
			}
		}
	}
	return arr[m-1][n-1];
};
```

```javaScript
// 10 最长公共前缀 14
// 编写一个函数来查找字符串数组中的最长公共前缀。
// 如果不存在公共前缀，返回空字符串 ""。
// 示例 1：
// 输入：strs = ["flower","flow","flight"]
// 输出："fl"
// 示例 2：
// 输入：strs = ["dog","racecar","car"]
// 输出：""
// 解释：输入不存在公共前缀。

var longestCommonPrefix = function(strs) {
	let str = strs[0]
	if(!str) return ''
	let res = ''
	for(let i = 0; i < str.length; i++){
		let flag = strs.every(item => item[i] == str[i]);
		if (flag) {
			res += str[i];
		}else {
			return res;
		}
	}
	return res
};
```

### 11 最小覆盖子串

```javaScript
// 11 最小覆盖子串 76
// 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串
// 如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
// 注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。
// 示例 1：
// 输入：s = "ADOBECODEBANC", t = "ABC"
// 输出："BANC"
// 示例 2：
// 输入：s = "a", t = "a"
// 输出："a"
/**
 * 用双指针维护一个滑动窗口
 * 移动右指针，直到找到包含t的所有子串，此时再移动左指针，尽量减少包含t的子串的长度。
 * 时间复杂度:  O(m + n) ,m是t的长度,n是s的长度
 * 空间复杂度:  O(m) ,m是t中不同字符的个数
 */

var minWindow = function(s, t) {
	let l = 0; // 左指针
	let r = 0; // 右指针
	let m = new Map(); // 保存t的map对象
	for(let item of t) {
		m.set(item, m.has(item) ? m.get(item) + 1 : 1);
	}
	let res = ''; // 结果值
	let size = m.size; // 记录
	while(r < s.length){
		const ri = s[r];
		// 记录右指针移动中对 m 和 size 的影响
		if (m.has(ri)) {
			m.set(ri, m.get(ri) - 1);
			if(m.get(ri) === 0) size-- ;
		}
		// 当 size = 0 表示 s 从 l 到 r 正好涵盖 t
		while (size === 0) {
			// 记录子串
			let sub = s.substring(l, r + 1);
			res = !res || sub.length < res.length ? sub : res;
			// 记录左指针移动中对 m 和 size 的影响
			const li = s[l];
			if (m.has(li)) {
				m.set(li, m.get(li) + 1);
				if(m.get(li) === 1) size ++;
			}
			l++;
		}
		r++;
	}
	return res; 
}
```

```javaScript
// 12 单词拆分 139
// 给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。
// 说明：
// 1. 拆分时可以重复使用字典中的单词。
// 2. 你可以假设字典中没有重复的单词。

// 示例 1：
// 输入: s = "leetcode", wordDict = ["leet", "code"]
// 输出: true
// 解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。

// 示例 2：
// 输入: s = "applepenapple", wordDict = ["apple", "pen"]
// 输出: true
// 解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
//      注意你可以重复使用字典中的单词。

// 示例 3：
// 输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
// 输出: false

// 动态规划， 从后往前扫描
var wordBreak = function (s, wordDict) {
	const set = new Set(wordDict);
	const dp = new Array(s.length + 1).fill(false);
	dp[0] = true;
	for (let i = 1; i <= s.length; i++) {
		for (let j = i - 1; j >= 0; j--) {
			if (dp[i] == true) break;
			const subStr = s.slice(j, i);
			if (set.has(subStr) && dp[j]) {
				dp[i] = true;
				break;
			}
		}
	}
	return dp[s.length];
};

// 解法二： DFS
const wordBreak = (s, wordDict) => {
	const len = s.length;
	const set = new Set(wordDict);
	const buffer = new Array(len);

	const dfs = startIndex => {
		if (startIndex == len) return true;
		// memo中有，就用memo中的
		if (buffer[startIndex] !== undefined) return buffer[startIndex];

		for (let i = startIndex + 1; i <= len; i++) {
			const subStr = s.slice(startIndex, i);
			if (set.has(subStr) && dfs(i)) {
				buffer[startIndex] = true; // 当前递归的结果存一下
				return true;
			}
		}
		buffer[startIndex] = false; // 当前递归的结果存一下
		return false;
	};
	return dfs(0);
};
```

```javaScript
// 13 100层丢鸡蛋
// 有2个鸡蛋，可能在任意一层丢下刚好会摔破
// 现在假设有num层，找到最少尝试的次数m

function getFlort(num) {
	let i = 1;
	while(i < num) {
		let t = i;
		let sum = 0;
		while(t > 0 && sum < num) {
			sum += t;
			if (sum + (t - 1) > num) {
				return i;
			}
			t--;
		}
		i++;
	}
}
```

```javaScript
// 14 较大分组的位置 830
// 在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。
// 例如，在字符串 s = "abbxxxxzyy" 中，就含有 "a", "bb", "xxxx", "z" 和 "yy" 这样的一些分组。
// 分组可以用区间 [start, end] 表示，其中 start 和 end 
//    分别表示该分组的起始和终止位置的下标。上例中的 "xxxx" 分组用区间表示为 [3,6] 。
// 我们称所有包含大于或等于三个连续字符的分组为 较大分组 。

// 找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。
// 示例 1：
// 输入：s = "abbxxxxzzy"
// 输出：[[3,6]]
// 解释："xxxx" 是一个起始于 3 且终止于 6 的较大分组。

// 示例 2：
// 输入：s = "abc"
// 输出：[]
// 解释："a","b" 和 "c" 均不是符合要求的较大分组。

// 示例 3：
// 输入：s = "abcdddeeeeaabbbcd"
// 输出：[[3,5],[6,9],[12,14]]
// 解释：较大分组为 "ddd", "eeee" 和 "bbb"

// 示例 4：
// 输入：s = "aba"
// 输出：[]

// 解法一: 双指针
var largeGroupPositions = function(s) {
	let res = [];
	if (!s) return res;
	let p1 = 0;
	while(p1 < s.length - 1) {
		let p2 = p1 + 1;
		while(s[p1] === s[p2]) {
			p2++;
		}
		if(p2 - p1 >= 3 ) {
			res.push([p1, p2 - 1]);
			p1 = p2;
		} else {
			p1++;
		}
	}
	return res;
}

// 解法二: 正则:matchAll —— ([a-z])捕获小写字母，\1反向引用刚才捕获的字母，{2,}该字母又出现>=2次
var largeGroupPositions = function(s) {
	const res = [];
	const iterator = s.matchAll(/([a-z])\1{2,}/g);
	let ite = iterator.next();
	// ite.done = false,表示迭代器还没有结束
	while (!ite.done) {
		// res = { done: false, value: {0: 'bbb', 1: 'b', index: 2, input: "aabbbcccdddddeeeeee"}}
		res.push([ite.value.index, ite.value.index + ite.value[0].length - 1])
		ite = iterator.next();
	}
	return res;
}

// 解法三 正则:replace  \1反向引用刚才捕获的字母，{2,}该字母又出现>=2次
var largeGroupPositions = function(s) {
	const r = [];
	s.replace(/([a-z])\1{2,}/g, (a, _, i)=> r.push([i, i + a.length - 1]));
	return r;
};
```

```javaScript
// 15 下划线与驼峰互换

// 解法一 正则 replace
// 1-1.驼峰式转下横线：
function toLowerLine(str) {
	var resStr = str.replace(/[A-Z]/g, match => "_" + match.toLowerCase());
	//如果首字母是大写，执行replace时会多一个_ ,这里需要去掉
  	if(resStr.slice(0, 1) === '_') { // resStr.startsWith('_')
  		resStr = resStr.slice(1);
  	}
	return resStr;
};
// test:
toLowerLine("TestToLowerLine");  //test_to_lower_line
toLowerLine("testToLowerLine");  //test_to_lower_line

// 1-2.下横线转驼峰式：
function toCamel(str) {
  	return str.replace(/([^_])(?:_+([^_]))/g, function (match, $1, $2) {
		// match=t_b, $1=t, $2=b
		// match=e_c, $1=e, $2=c
		return $1 + $2.toUpperCase();
  	});
}
// test
toCamel('test_be_camel') // testBeCamel

// 解法二: reduce
// 2-1.驼峰式转下横线：
function toLowerLine(str){
	return Array.prototype.reduce.call(str, (pre, cur, index) => {
		if(/[A-Z]/.test(cur)){
			cur = cur.toLowerCase();
			return index === 0 ? pre + cur :  pre + '_' + cur
		} else {
			return pre + cur;
		}
	}, '')
}
// test
toLowerLine('TestToLowerLine'); // test_to_lower_line

// 2-2.下横线转驼峰式：
function toCamel(str) {
	return Array.prototype.reduce.call(str, (pre, cur) => {
		if (pre.endsWith('_')) {
			return pre.substring(0, pre.length - 1) + cur.toUpperCase();
		} else {
			return pre + cur;
		}
	})
}
// test
toCamel('test_to_camel'); // testToCamel

// 解法三: Array.map()
// 3-1.驼峰式转下横线：
function toLowerLine(arr){
	// return [].map.call(arr, doLowerLine).join('');
	return Array.prototype.map.call(arr, (val, index) => {
		if(/[A-Z]/.test(val)){
			return index === 0 ? val.toLowerCase() : '_' + val.toLowerCase();
		} else {
			return val;
		}
	}).join('');
}
```

### 16 Z 字形变换

```javaScript
// 16 Z 字形变换 6
// 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。
// 比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：
// P   A   H   N
// A P L S I I G
// Y   I   R
// 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。

// 示例 1：
// 输入：s = "PAYPALISHIRING", numRows = 3
// 输出："PAHNAPLSIIGYIR"

// 示例 2：
// 输入：s = "PAYPALISHIRING", numRows = 4
// 输出："PINALSIGYAHRPI"
// 解释：
// P     I    N
// A   L S  I G
// Y A   H R
// P     I

// 示例 3：
// 输入：s = "A", numRows = 1
// 输出："A"
var convert = function(s, numRows) {
	if (numRows === 1) {
		return s;
	}
	const arr = new Array(numRows).fill('');
	const n = 2 * numRows - 2;
	for(let i = 0; i < s.length; i++) {
		const index = Math.min(i % n, n - i % n);
		arr[index] += s[i]
	}
	return arr.join('');
};
```

```javaScript
// 17 不同的路径 62
// 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
// 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
// 问总共有多少条不同的路径？

// 示例 1：
// 输入：m = 3, n = 7
// 输出：28

// 示例 2：
// 输入：m = 3, n = 2
// 输出：3
// 解释：
// 从左上角开始，总共有 3 条路径可以到达右下角。
// 1. 向右 -> 向下 -> 向下
// 2. 向下 -> 向下 -> 向右
// 3. 向下 -> 向右 -> 向下

// 示例 3：
// 输入：m = 7, n = 3
// 输出：28

// 示例 4：
// 输入：m = 3, n = 3
// 输出：6

var uniquePaths = function(m, n) {
	// 新建一个 m行 n列 的二维数组
	const arr = new Array(m);
   // 每一列的第一个值 置为1
	for(let i = 0; i < m; i++){
		arr[i] = new Array(n);
		arr[i][0] = 1;
	}
    // 每一列的第一个值 置为1
	for(let i = 0; i < n; i++) {
		arr[0][i] = 1;
	}
	for(let i = 1; i < m; i++) {
		for(let j = 1; j < n; j++){
			arr[i][j] = arr[i - 1][j] + arr[i][j - 1];
		}
	}
	return arr[m - 1][n - 1];
};

// var uniquePaths = function(m, n) {
// 	let res = 1;
// 	for (let x = n, y = 1; y < m; ++x, ++y) {
// 		res = Math.floor(res * x / y);
// 	}
// 	return res;
// };
```

## 五 链表

1 反转链表
2 两数相加
3 删除链表的倒数第 N 个结点
4 合并两个有序链表
5 两两交换链表中的节点 —— 给定一个链表，两两交换其中相邻的节点
6 相交链表 —— 找到两个单链表相交的起始节点
7 回文链表 —— 判断一个链表是否为回文链表
8 合并K个升序链表 —— 将n个升序链表合并的一个链表
9 排序链表 —— 将链表升序排列

### 1 反转链表

```JavaScript
// 1 反转链表 206
// 反转一个单链表。
// 示例:
// 输入: 1->2->3->4->5->NULL
// 输出: 5->4->3->2->1->NULL
// 进阶:
// 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

var reverseList = function(head) {
    let p1 = head;
    let p2 = null;
    while(p1) {
        const tmp = p1.next; 	// 1. 临时存储当前指针后续内容
        p1.next = p2;			// 2. 反转链表
        p2 = p1;					// 3. 接收反转结果
        p1 = tmp;					// 4. 接回临时存储的后续内容
    }
    return p2;
};

// 反转链表 II 92
// 给你单链表的头指针 head 和两个整数 left 和 right ，
// 其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 

// 示例 1：
// 输入：head = [1,2,3,4,5], left = 2, right = 4
// 输出：[1,4,3,2,5]

// 示例 2：
// 输入：head = [5], left = 1, right = 1
// 输出：[5]

/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} left
 * @param {number} right
 * @return {ListNode}
 */

// 解法一: 把原链表 分割，再反转，再拼接
var reverseBetween = function(head, left, right) {
	if (left === right) return head;
	let p = head;
	let res;
	let index = 1;

	let leftList = new ListNode();
	let p1 = leftList;

	let midList = new ListNode();
	let p2 = midList;

	let rightList = new ListNode();
	let p3 = rightList;

	// 1 先找到 leftList、midList、rightList
	while(p) {
		 if (index < left) {
			  p1.next = new ListNode(p.val);
			  p1 = p1.next;
		 } else if (index > right) {
			  p3.next = new ListNode(p.val);
			  p3 = p3.next;
		 } else {
			  p2.next = new ListNode(p.val);
			  p2 = p2.next;
		 }
		 p = p.next;
		 index++;
	}
	leftList = leftList.next;
	midList = midList.next;
	rightList = rightList.next;

	// 2 将 midList 反转
	let pre = null;
	let p4 = midList;
	while (p4) {
		let tem = p4.next;
		p4.next = pre;
		pre = p4;
		p4 = tem;
	}
	midList.next = rightList;

	// 3 将 leftList、midList、rightList 组合 得到结果
	if (leftList) {
		res = leftList;
		p1.next = pre;
	} else {
		res = pre;
	}
	return res;
};

// 解法二: 找到反转的 位置，直接进行反转
var reverseBetween = function(head, left, right) {
	let res = new ListNode();
	res.next = head;

	let pre = res;
	let index = 1;
	while (index < left) {
		pre = pre.next;
		index++;
	}

	let cur = pre.next;
	while(index < right) {
		const tem = cur.next;
		cur.next = tem.next;
		tem.next = pre.next;
		pre.next = tem;
		index++;
	}

	return res.next;
}
```

```javascript
// 2 两数相加 (链表) 2
// 给你两个 非空 的链表，表示两个非负的整数
// 它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
// 请你将两个数相加，并以相同形式返回一个表示和的链表。
// 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
// 示例 1：
// 输入：l1 = [2,4,3], l2 = [5,6,4]
// 输出：[7,0,8]
// 解释：342 + 465 = 807.
// 示例 2：
// 输入：l1 = [0], l2 = [0]
// 输出：[0]
// 示例 3：
// 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
// 输出：[8,9,9,9,0,0,0,1]
var addTwoNumbers = function(l1, l2) {
	const l3 = new ListNode(0);
	let p1 = l1;
	let p2 = l2;
	let p3 = l3;
	let carry = 0;
	while(p1 || p2) {
		const v1 = p1 ? p1.val : 0;
		const v2 = p2 ? p2.val : 0;
		const val = v1 + v2 + carry;
		carry = Math.floor(val / 10);
		p3.next = new ListNode(val % 10);
		if (p1) p1 = p1.next;
		if (p2) p2 = p2.next;
		p3 = p3.next;
	}
	if (carry) {
		p3.next = new ListNode(carry);
	}
	return l3.next;
};
```

```javaScript
// 3 删除链表的倒数第 N 个结点  19
// 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
// 进阶：你能尝试使用一趟扫描实现吗？
// 示例 1：
// 输入：head = [1,2,3,4,5], n = 2
// 输出：[1,2,3,5]
// 示例 2：
// 输入：head = [1], n = 1
// 输出：[]
// 示例 3：
// 输入：head = [1,2], n = 1
// 输出：[1]]
// 找到删除节点的前一个节点
var removeNthFromEnd = function(head, n) {
	let node = head;
	let count = 0;
	while(node) {
		node = node.next;
		count++;
	}
	count = count - n - 1;
	if (count === -1) return head.next;
	node = head;
	while(count > 0) {
		node = node.next;
		count--;
	}
	node.next = node.next.next;
	return head;
};

```

```javaScript
// 4 合并两个有序链表 21
// 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
// 示例 1：
// 输入：l1 = [1,2,4], l2 = [1,3,4]
// 输出：[1,1,2,3,4,4]
// 示例 2：
// 输入：l1 = [], l2 = []
// 输出：[]
// 示例 3：
// 输入：l1 = [], l2 = [0]
// 输出：[0]
var mergeTwoLists = function(l1, l2) {
	let l3 = new ListNode(null);
	let p1 = l1;
	let p2 = l2;
	let p3 = l3;
	while(p1 && p2) {
		if (p1.val > p2.val) {
			p3.next = p2;
			p2 = p2.next
		} else if (p1.val <= p2.val) {
			p3.next = p1;
			p1 = p1.next
		}
		p3 = p3.next;
	}
	p3.next = p1 ? p1 : p2;
	return l3.next;
};
```

```javaScript
// 5 两两交换链表中的节点 24
// 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。
// 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
// 示例 1：
// 输入：head = [1,2,3,4]
// 输出：[2,1,4,3]
// 示例 2：
// 输入：head = []
// 输出：[]
// 示例 3：
// 输入：head = [1]
// 输出：[1]
const swapPairs = (head) => {
	const resNode = new ListNode(0);
	resNode.next = head;
	let prev = resNode;

	while (head && head.next) {
		// 临时保存head.next，因为head.next待会要改变
		const next = head.next;
		head.next = next.next;
		next.next = head;
		prev.next = next;  

		prev = head;      // 指针更新
		head = head.next; // 指针更新
	}
	return resNode.next;
};
```

### 6 相交链表

```javaScript
// 6 相交链表 160
// 编写一个程序，找到两个单链表相交的起始节点。
// 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

// 示例 1：
// 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
// 输出：Reference of the node with value = 8
// 输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
// 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
// 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

// 示例 2：
// 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
// 输出：Reference of the node with value = 2
// 输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
// 从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
var getIntersectionNode = function(headA, headB) {
	// 解法一: 对headA打标记
	// while(headA) {
	//     headA.flag = true;
	//     headA = headA.next;
	// }
	// while(headB) {
	//     if(headB.flag) return headB;
	//     headB = headB.next;
	// }
	// return null;

	// 解法二: 嵌套循环
	// let p1 = headA;
	// while(p1) {
	//     let p2 = headB;
	//     while(p2) {
	//         if (p1 === p2) {
	//             return p1
	//         }
	//         p2 = p2.next;
	//     }
	//     p1 = p1.next;
	// }
	// return null;

	// 解法三: 消除多余
	let p1 = headA;
	let p2 = headB;
	while(p1 || p2) {
		if (p1 === p2) {
			return p1;
		}
		p1 = p1 === null ? headB : p1.next;
		p2 = p2 === null ? headA : p2.next;
	}
	return null;
};
```

```javaScript
// 7  回文链表 234
// 请判断一个链表是否为回文链表。
// 示例 1:
// 输入: 1->2
// 输出: false
// 示例 2:
// 输入: 1->2->2->1
// 输出: true

// 解法一
var isPalindrome = function(head) {
	let a = '';
	let b = '';
	let p = head;
	while(p){
		a = a + p.val;
		b = p.val + b;
		p = p.next;
	}
  	return a === b;
};

// 解法二
var isPalindrome = function(head) {
	let left = head;
	function traverse(right) {
		if (right == null) return true;
		let res = traverse(right.next);
		res = res && (right.val === left.val);
		left = left.next;
		return res;
	}
	return traverse(head);
};
```

```javaScript
// 8 合并K个升序链表 23
// 给你一个链表数组，每个链表都已经按升序排列。
// 请你将所有链表合并到一个升序链表中，返回合并后的链表。
//  
// 示例 1：
// 输入：lists = [[1,4,5],[1,3,4],[2,6]]
// 输出：[1,1,2,3,4,4,5,6]
// 解释：链表数组如下：
// [
//   1->4->5,
//   1->3->4,
//   2->6
// ]
// 将它们合并到一个有序链表中得到。
// 1->1->2->3->4->4->5->6
// 示例 2：
// 输入：lists = []
// 输出：[]
// 示例 3：
// 输入：lists = [[]]
// 输出：[]
/*
解法一：
	reduce，将链表数组中的每一个值放入新数组
	sort，以链表的val作参考冒泡排序
	reduceRight，从右向左遍历，将数组连成链表
*/
// 解法一：
var mergeKLists = function(lists) {
	return lists.reduce((p, n) => {
		while (n) {
			p.push(n), n = n.next
		}
		return p
	}, []).sort((a, b) => a.val - b.val).reduceRight((p, n) => (n.next = p, p = n, p), null)
};

// 解法二：
var mergeKLists = function(lists) {
	let mergeTwoLists = (l1, l2) => {
		let preHead = new ListNode(-1);
		let preNode = preHead;
		while(l1 && l2){
			if(l1.val <= l2.val){
				preNode.next = l1;
				l1 = l1.next;
			} else {
				preNode.next = l2;
				l2 = l2.next;
			}
			preNode = preNode.next;
		}
		preNode.next = l1 ? l1 : l2;
		return preHead.next;
	}
	let n = lists.length;
	if(n == 0) return null;
	let res = lists[0];
	for(let i = 1; i < n; i++){
		if(lists[i]){
			res = mergeTwoLists(res, lists[i]);
		}
	}
	return res;
};
```

```javaScript
// 9 排序链表148
// 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。

// 解法一: 将对链表进行归并排序  比解法二更好、更快
var sortList = function(head) {
	if (!head || !head.next) return head;
	let p = head;
	return mergeList(p);
};

// 归并排序 => o(n logn)
function mergeList(head) {
	if (head.next) {
		// 找到中间节点
		let p1 = head;
		let p2 = head.next;
		while(p1 && p2 && p2.next) {
			p1 = p1.next;
			p2 = p2.next.next;
		}
		let rightPart = p1.next;
		p1.next = null;

		const left = mergeList(head);
		const right = mergeList(rightPart);

		head = sortMerge(left, right);
	}
	return head;
}

// 合并两个有序链表
function sortMerge(left, right) {
	let head = null;
	let p = null;
	while (left != null && right != null) {
		if (left.val < right.val) {
			if (!head) {
				head = left;
				p = head;
			} else {
				p.next = left;
				p = p.next;
			}
			left = left.next;
		} else {
			if (!head) {
				head = right;
				p = head;
			} else {
				p.next = right;
				p = p.next;
			}
			right = right.next;
		}
	}
	p.next = left ? left : right;
	return head;
}

// 解法二: 将链表转为数组,进行归并排序, 然后再转为链表
var sortList = function(head) {
	if (!head || !head.next) return head;
	let p = head;
	let arr = [];
	while(p) {
		arr.push(p);
		p = p.next;
	}
	arr.forEach(item => {
		item.next = null;
	})
	arr = mergeSort(arr);

	const newHead = arr[0];
	let p1 = newHead;
	let index = 1;
	while(index < arr.length) {
		p1.next = arr[index];
		p1 = p1.next;
		index++;
	}
	return newHead;
};

var mergeSort = function(arr) {
	if (arr.length === 1) {
		return arr;
	}
	const mid = arr.length / 2;
	const left = arr.slice(0, mid);
	const right = arr.slice(mid);

	let leftPart = mergeSort(left);
	let rightPart = mergeSort(right);

	const res = [];
	while(leftPart.length || rightPart.length) {
		if (leftPart.length && rightPart.length) {
			const item = leftPart[0].val < rightPart[0].val ? leftPart.shift() : rightPart.shift();
			res.push(item);
		} else if (leftPart.length) {
			res.push(leftPart.shift());
		} else if (rightPart.length) {
			res.push(rightPart.shift());
		}
	}
	return res;
}
```

## 六 堆

1 数组中的第K个最大元素
2 前K个高频元素
3 合并K个升序链表

堆是一种特殊的完全二叉树，所有的节点都大于等于（最大堆）或者 小于等于（最小堆）它的子节点。
堆的应用：

- 堆能高效、快速的找出最大值和最小值——之间复杂度是 O(1)
- 找出第 K 个最大（小）值
  - 构建一个最小堆，并将元素一次插入堆中
  - 当堆的容量超过 K，就删除堆顶
  - 插入结束后，堆顶就是第 K 个最大元素

```javascript
// 1 数组中的第K个最大元素 215
// 在未排序的数组中找到第 k 个最大的元素
// 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
// 示例 1:
// 输入: [3,2,1,5,6,4] 和 k = 2
// 输出: 5
// 示例 2:
// 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
// 输出: 4
/**
 * 解题思路：
 * 1、构建一个最小堆，并依次把数组的值插入堆中
 * 2、当堆的容量超过K， 就删除堆顶
 * 3、插入结束后，堆顶就是第K个最大元素
 * 时间复杂度： O(n * log(k))
 * 空间复杂度： O(k)
 */
class MinHead {
	constructor() {
		this.heap = [];
	}
	insert(value) { // 插入
		this.heap.push(value); // 插入到底部
		this.shiftUp(this.heap.length - 1);
	}
	// 删除堆顶
	pop() {
		this.heap[0] = this.heap.pop();
		this.shiftDown(0); // 下移操作
	}
	// 获取堆顶
	peek() {
		return this.heap[0];
	}
	// 获取堆的大小
	size() {
		return this.heap.length;
	}

	// 获取父节点
	getParentIndex(i) {
		// return Math.floor((i - 1) / 2);
		return (i - 1) >> 1; // 把二进制的数字右移一位
	}
	// 获取左侧子节点
	getLeftIndex(i) {
		return i * 2 + 1;
	}
	// 获取右侧子节点
	getRightIndex(i) {
		return i * 2 + 2;
	}
	// 将两个节点的位置进行交换
	swap(i1, i2) {
		const temp = this.heap[i1];
		this.heap[i1] = this.heap[i2];
		this.heap[i2] = temp;
	}
	// 上移
	shiftUp(index) {
		// 递归的终点: 到达堆顶
		if(index == 0) return;
		const parentIndex = this.getParentIndex(index);
		if(this.heap[parentIndex] > this.heap[index]) {
			this.swap(parentIndex, index);
			this.shiftUp(parentIndex);
		}
	}
	// 下移
	shiftDown(index) {
		const leftIndex = this.getLeftIndex(index);
		const rightIndex = this.getRightIndex(index);
		if (this.heap[leftIndex] < this.heap[index]) {
			this.swap(leftIndex, index);
			this.shiftDown(leftIndex);
		}
		if (this.heap[rightIndex] < this.heap[index]) {
			this.swap(rightIndex, index);
			this.shiftDown(rightIndex);
		}
	}
}
var findKthLargest = function(nums, k) {
	const h1 = new MinHead();
	nums.forEach(n => {
		h1.insert(n);
		if(h1.size() > k) {
			h1.pop();
		}
	})
	return h1.peek();
};

// 解法二：排序
let findKthLargest = function(nums, k) {
	nums.sort((a, b) => b - a).slice(0, k);
	return nums[k-1]
};
// 时间复杂度: O(n^2 log n) [Array.sort => O(n log n), Array.slice => O(n)]

```

```javaScript
// 2 前 K 个高频元素 347
// 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。
// 示例 1:
// 输入: nums = [1,1,1,2,2,3], k = 2
// 输出: [1,2]
// 示例 2:
// 输入: nums = [1], k = 1
// 输出: [1]
// 提示：
// 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
// 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。
// 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。
// 你可以按任意顺序返回答案。
var topKFrequent = function(nums, k) {
	/**
    解法一：
        1、建立最小堆
		  2、当堆的容量超过K， 就删除堆顶
		  3、插入结束后，堆顶就是第K个最大元素

    时间复杂度： 
        1、nums.forEach => O(n)
        2、map.forEach => O(n) 而 嵌套的 insert 和 pop 都是 logK, 结合起来就是 O(n log k)
        所以结合起来， 时间复杂度 就是 O(n log K) ，由于 k < n 所有符合题目要求的
   */
	const map = new Map();
	nums.forEach(n => {
		map.set(n, map.has(n) ? map.get(n) + 1 : 1);
	});
	const h = new MinHead();
	map.forEach((value, key) => {
		h.insert({value, key});
		if (h.size() > k) {
			h.pop();
		}
	})
	return h.heap.map(a => a.key)
    
};

class MinHead {
	constructor() {
		this.heap = [];
	}
	insert(value) { // 插入
		this.heap.push(value); // 插入到底部
		this.shiftUp(this.heap.length - 1); // 上移
	}
	pop() { // 删除堆顶
		this.heap[0] = this.heap.pop(); 
		this.shiftDown(0); // 下移
	}
	peek() { // 获取堆顶
		return this.heap[0];
	}
	size() { // 获取堆的大小
		return this.heap.length;
	}
	// 获取父节点
	getParentIndex(i) {
		// return Math.floor((i - 1) / 2);
		return (i - 1) >> 1;
	}
	// 获取左侧子节点
	getLeftIndex(i) {
		return i * 2 + 1;
	}
	// 获取右侧子节点
	getRightIndex(i) {
		return i * 2 + 2;
	}
	// 将两个节点的位置进行交换
	swap(i1, i2) {
		const temp = this.heap[i1];
		this.heap[i1] = this.heap[i2];
		this.heap[i2] = temp;
	}
	shiftUp(index) { // 上移
		// 递归的终点: 到达堆顶
		if(index == 0) return;
		const parentIndex = this.getParentIndex(index);
		if(this.heap[parentIndex] && this.heap[parentIndex].value > this.heap[index].value) {
			this.swap(parentIndex, index); // 实现交换的方法
			this.shiftUp(parentIndex); // 如果还是需要上移，则递归
		}
	}
	shiftDown(index) { // 下移
		const leftIndex = this.getLeftIndex(index);
		const rightIndex = this.getRightIndex(index);
		if (this.heap[leftIndex] && this.heap[leftIndex].value < this.heap[index].value) {
			this.swap(leftIndex, index);
			this.shiftDown(leftIndex);
		}
		if (this.heap[rightIndex] && this.heap[rightIndex].value < this.heap[index].value) {
			this.swap(rightIndex, index);
			this.shiftDown(rightIndex);
		}
	}
}

/**
解法二：
	1、将输入的数组进行统计，得到每个元素出现次数的二维数组（二维数组的第一项是元素，第二项是元素出现的次数）
	2、再将元素按照统计次数进行降序排列，数组的前K个就是所需要的结果
	3、但是这个解法 不符合 题目时间复杂度的要求

时间复杂度： 
	1、nums.forEach => O(n)
	2、Array.sort => O(n log n)
	所以结合起来， 时间复杂度 就是 O(n log n) ，不符合题目要求的 时间复杂度必须优于 O(n log n)
*/
const map = new Map();
nums.forEach(n => {
	map.set(n, map.has(n) ? map.get(n) + 1 : 1);
});
const arr = Array.from(map).sort((a, b) => b[1] - a[1]);
return arr.slice(0, k).map(n => n[0]);
```

```javaScript
// 3合并K个升序链表 23
// 给你一个链表数组，每个链表都已经按升序排列。
// 请你将所有链表合并到一个升序链表中，返回合并后的链表。
//  
// 示例 1：
// 输入：lists = [[1,4,5],[1,3,4],[2,6]]
// 输出：[1,1,2,3,4,4,5,6]
// 解释：链表数组如下：
// [
//   1->4->5,
//   1->3->4,
//   2->6
// ]
// 将它们合并到一个有序链表中得到。
// 1->1->2->3->4->4->5->6
// 示例 2：
// 输入：lists = []
// 输出：[]
// 示例 3：
// 输入：lists = [[]]
// 输出：[]
/**
 * 时间复杂度： O(n) * logK // n是所有链表树的和，k是链表的数
 * 空间复杂度： O(k) // 中间遍历是 堆，堆的大小是K，k是链表的数
 */
var mergeKLists = function(lists) {
	const res = new ListNode(0);
	let p = res;
	const h = new MinHead();
	lists.forEach(l => {
		if(l) h.insert(l);
	})
	while(h.size()) {
		const n = h.pop(); // 弹出堆顶（即lists中最小的那个链表节点）
		p.next = n;
		p = p.next;
		if(n.next) h.insert(n.next); // 再把最小节点的下一个节点加到堆中
	}
	return res.next;
    
};
// 构建一个最小堆（堆中的元素时 链表的节点）
class MinHead {
	constructor() {
		this.heap = [];
	}
	// 插入方法
	insert(value) {
		this.heap.push(value); // 插入到底部
		this.shiftUp(this.heap.length - 1); // 上移操作
	}
	pop() { // 删除堆顶
		// 与原生的最小堆相比，需要做修改。 需要记住 top 的元素，并返回
		if(this.size() === 1) return this.heap.shift();
		const top = this.heap[0]; 
		// 把原来heap中最末尾的推出来, 并赋值给堆顶
		this.heap[0] = this.heap.pop();
		this.shiftDown(0); // 下移操作
		return top;
	}
	// 获取堆顶
	peek() {
		return this.heap[0];
	}
	// 获取堆的大小
	size() {
		return this.heap.length;
	}
	// 获取父节点
	getParentIndex(i) {
		// 二进制操作，把二进制的数字右移一位
		// return Math.floor((i - 1) / 2);
		return (i - 1) >> 1;
	}
	// 获取左侧子节点
	getLeftIndex(i) {
		return i * 2 + 1;
	}
	// 获取右侧子节点
	getRightIndex(i) {
		return i * 2 + 2;
	}
	// 将两个节点的位置进行交换
	swap(i1, i2) {
		const temp = this.heap[i1];
		this.heap[i1] = this.heap[i2];
		this.heap[i2] = temp;
	}
	shiftUp(index) { // 上移
		// 递归的终点: 到达堆顶
		if(index == 0) return;
		const parentIndex = this.getParentIndex(index);
		if(this.heap[parentIndex] && this.heap[parentIndex].val > this.heap[index].val) {
			this.swap(parentIndex, index); // 实现交换的方法
			this.shiftUp(parentIndex); // 如果还是需要上移，则递归
		}
	}
	shiftDown(index) { // 下移
		const leftIndex = this.getLeftIndex(index);
		const rightIndex = this.getRightIndex(index);
		if (this.heap[leftIndex] && this.heap[leftIndex].val < this.heap[index].val) {
			this.swap(leftIndex, index);
			this.shiftDown(leftIndex);
		}
		if (this.heap[rightIndex] && this.heap[rightIndex].val < this.heap[index].val) {
			this.swap(rightIndex, index);
			this.shiftDown(rightIndex);
		}
	}
}

/*
解法二：
	reduce，将链表数组中的每一个值放入新数组
	sort，以链表的val作参考冒泡排序
	reduceRight，从右向左遍历，将数组连成链表
*/
var mergeKLists = function(lists) {
	return lists.reduce((p, n) => {
		while (n) {
			p.push(n), n = n.next
		}
		return p
	}, []).sort((a, b) => a.val - b.val).reduceRight((p, n) => (n.next = p, p = n, p), null)
};

/*
解法三：
*/
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
	let mergeTwoLists = (l1, l2) => {
		let preHead = new ListNode(-1);
		let preNode = preHead;
		while(l1 && l2){
			if(l1.val <= l2.val){
				preNode.next = l1;
				l1 = l1.next;
			} else {
				preNode.next = l2;
				l2 = l2.next;
			}
			preNode = preNode.next;
		}
		preNode.next = l1 ? l1 : l2;
		return preHead.next;
	}
	let n = lists.length;
	if(n == 0) return null;
	let res = lists[0];
	for(let i = 1; i < n; i++){
		if(lists[i]){
			res = mergeTwoLists(res, lists[i]);
		}
	}
	return res;
};
```

## 七 买卖股票

1 不限制交易次数，多次买卖一只股票
2 最多交易两次
3 可以交易k次
4 最佳买卖股票时机含冷冻期
5 买卖股票的最佳时机含手续费

```javaScript
// 1 买卖股票的最佳时机 II 122
// 给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。
// 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
// 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
// 示例 1:
// 输入: prices = [7,1,5,3,6,4]
// 输出: 7
// 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
//      随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
// 示例 2:
// 输入: prices = [1,2,3,4,5]
// 输出: 4
// 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
//      注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
// 示例 3:
// 输入: prices = [7,6,4,3,1]
// 输出: 0
// 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

var maxProfit = function(prices) {
	// 解法一: 统计找到最大利润
	// var min = prices[0];
	// var resArr = [];
	// var tem = 0;
	// for (let i = 1 ; i < prices.length ; i++) {
	//     if (prices[i] > prices[i - 1]) {
	//         tem = prices[i] - min
	//         if (i === prices.length - 1) {
	//             resArr.push(tem)
	//         }
	//     } else {
	//         resArr.push(tem)
	//         min = prices[i];
	//         tem = 0
	//     }
	// }
	// return resArr.reduce((x, y) => {
	//     return x + y
	// }, 0)

	// 解法二：贪心算法，只要有利润就赚
	let res = 0;
	for (let i = 1; i < prices.length; i++) {
		if(prices[i] > prices[i - 1]) {
			res += prices[i] - prices[i - 1];
		}
	}
	return res;
};
```

```javaScript
// 2 买卖股票的最佳时机 III 123
// 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
// 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
// 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
// 示例 1:
// 输入：prices = [3,3,5,0,0,3,1,4]
// 输出：6
// 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
//      随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
// 示例 2：
// 输入：prices = [1,2,3,4,5]
// 输出：4
// 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
//      注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
//      因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
// 示例 3：
// 输入：prices = [7,6,4,3,1] 
// 输出：0 
// 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
// 示例 4：
// 输入：prices = [1]
// 输出：0]
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
	if(prices.length === 0){
		return 0;
	}
	// 第一次 买入， 卖出的利润
	let firIn = -prices[0];
	let firOut = 0;
	// 继第一次之后，第二次买入卖出的利润
	let secIn = -prices[0];
	let secOut = 0;
	// 卖出时利润：求最大值（上次交易卖出时利润，本次交易卖出时利润）
	// 买入时利润：求最大值（上次买入时利润，本次买入时利润）
	for (let i = 1; i < prices.length; i++) {
		secOut = Math.max(secOut, secIn + prices[i]);
		// 第二次买入后的利润: 第一次卖出的利润 - prices[i]
		secIn = Math.max(secIn, firOut - prices[i]);
		firOut = Math.max(firOut, firIn + prices[i]);
		// 第一次买入后: 利润为 -prices[i]
		firIn = Math.max(firIn, -prices[i]);
	}
	return secOut
};


var maxProfit = function(prices) {
	if (prices.length === 0){
		return 0;
	}
	let firIn = -prices[0];
	let firOut = 0;
	let secIn = -prices[0];
	let secOut = 0;
	for (let i = 1; i < prices.length; i++) {
		// 第1次交易前 分支：什么都不做 或 买入 → 第1次交易后
		firIn = Math.max(firIn, -prices[i]);
		// 第1次交易后 分支：什么都不做 或 卖出 → 第2次交易前
		firOut = Math.max(firOut, firIn + prices[i]);
		// 第2次交易前 分支：什么都不做 或 买入 → 第2次交易后
		secIn = Math.max(secIn, firOut - prices[i]);
		// 第2次交易后 分支：什么都不做 或 卖出 → 第3次交易前
		secOut = Math.max(secOut, secIn + prices[i]);
	}
	return secOut
};
```

```javaScript
// 3 买卖股票的最佳时机 IV 188
// 给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。
// 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。
// 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
// 示例 1：
// 输入：k = 2, prices = [2,4,1]
// 输出：2
// 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
// 示例 2：
// 输入：k = 2, prices = [3,2,6,5,0,3]
// 输出：7
// 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
//      随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
var maxProfit = function(k, prices) {
	let n = prices.length;
	if (k > n / 2) {
		k = Math.floor(n / 2);
	}
	// 记录每次交易的利润
	let profit = new Array(k);
	//初始化买入卖出时的利润
	for (let j = 0; j <= k; j++){
		profit[j] = {
			in: -prices[0],
			out: 0
		};
	}
	for (let i = 0; i < n; i++){
		for (let j = 1; j <= k; j++){
			profit[j] = {
				out: Math.max(profit[j].out, profit[j].in + prices[i]), 
				in: Math.max(profit[j].in, profit[j - 1].out - prices[i])
			}
		}
	}
	return profit[k].out;
};
```

```javaScript
// 4 最佳买卖股票时机含冷冻期 309
// 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​
// 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
// 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
// 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
// 示例:
// 输入: [1,2,3,0,2]
// 输出: 3 
// 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

var maxProfit = function(prices) {
	let n = prices.length;
	if(n == 0){
		return 0;
	}
	let dp = Array.from(new Array(n),() => new Array(2));
	for(var i = 0; i < n; i++){
		if (i == 0){
			dp[0][0] = 0;
			dp[0][1] = -prices[i];
			continue;
		} else if(i == 1) {
			dp[1][0] = Math.max(dp[0][0], dp[0][1]+prices[i]);
			dp[1][1] = Math.max(dp[0][1], - prices[i]);
			continue;
		} else {
			dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
			dp[i][1] = Math.max(dp[i-1][1], dp[i-2][0] - prices[i]);
		}
	}
	return dp[n-1][0];
};
// 解法二
var maxProfit = function(prices) {
	if(prices.length == 0){
		return 0;
	}
	let inProfit = 0;
	let outProfit = -Infinity;
	let pre = 0;
	for(var i = 0; i < prices.length; i++){
		let tmp = inProfit;
		inProfit = Math.max(inProfit, outProfit + prices[i]);
		outProfit = Math.max(outProfit, pre - prices[i]);
		pre = tmp;
	}
	return inProfit;
};
```

```javaScript
// 5 买卖股票的最佳时机含手续费 714
// 给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；
// 非负整数 fee 代表了交易股票的手续费用。
// 你可以无限次地完成交易，但是你每笔交易都需要付手续费。
// 如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。
// 返回获得利润的最大值。
// 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。
// 示例 1:
// 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
// 输出: 8
// 解释: 能够达到的最大利润:  
// 在此处买入 prices[0] = 1
// 在此处卖出 prices[3] = 8
// 在此处买入 prices[4] = 4
// 在此处卖出 prices[5] = 9
// 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.

// 解法一 动态规划
var maxProfit = function(prices, fee) {
	const dp = [0, -prices[0]];
	for(let i = 1, t; i < prices.length; i++) {
		t = dp[0] // 中间变量可省略，因为当天买入卖出不影响结果
		dp[0] = Math.max(dp[0], dp[1] + prices[i] - fee)
		dp[1] = Math.max(dp[1], t - prices[i])
	}
	return dp[0] // 最后一天，无股票 利润 > 有股票时 利润
};

// 解法二：动态规划
var maxProfit = function(prices, fee) {
	// 初始利润
	var getIn = 0 - prices[0];
	var getOut = 0;
	for (let i = 1; i < prices.length; i++){
		// 卖出： 当前买入状态时的利润 + 卖出的股票 - 手续费
		getOut = Math.max(getOut, getIn + prices[i] - fee); 
		//买入： 当前卖出时的利润 - 买进的股票
		getIn = Math.max(getIn, getOut - prices[i]);     
	}
	return getOut;
};

// 解法三：贪心算法
var maxProfit = function(prices, fee) {
	let min = prices[0];
	let res = 0;
	let i = 0;
	while(i < prices.length) {
		let profit;
		if (prices[i] < min) {
			min = prices[i];
		} else if ((profit = prices[i] - min - fee) > 0) {
			// 两种情况：
			// 1 无股票时：profit = 今天价格 - 最低买入价格min - 手续费 > 0，即有利润就卖
			// 2 有股票时：今天价格大于昨天价格。改今天卖。手续费昨天扣过，不再扣
			//		profit = pricep[i] - price[i - 1] = price[i] - (prices[i-1] - fee) - fee
			//    profit = 昨天利润 + 今天价格 - 新最低买入价格 - 手续费
			//    		 = 昨天利润 + 今天价格 - （昨天价格 - 手续费） - 手续费
			//    		 = 昨天利润 + 今天价格 - 昨天价格
			res += profit;
			min = prices[i] - fee;
		}
		i++;
	}
	return res;
};
```

## 八 算法总结

### 分而治之

分而治之是将一个问题**分**成多个和原问题相似的小问题，通过**递归**解决这些小问题，再将小问题的结果**合并**以解决原来的问题。

例题：反转二叉树、相同的树

场景一： 归并排序

- 分：先把数组从中间一分为二
- 解：递归的对两个子数组进行归并排序
- 合：合并有序子数组

场景二： 快速排序

- 分：选基准，按基准把数组分成两个子数组
- 解：递归的对两个子数组进行快速排序
- 合：对两个子数组进行合并

### 动态规划

动态规划是将一个问题分解为**相互重叠**的子问题，通过反复求解子问题，来解决原来的问题。

例题：斐波那契数列、连续子数组的最大和

**动态规划** 与 **分而治之** 的区别：

- 动态规划: 它们的子问题是**相互重叠**的
- 分而治之: 它们的子问题是**完全独立**的

### 回溯算法

回溯算法是一种**渐进式**寻找并构建问题解决方式的策略
回溯算法会先从一个可能的动作开始解决问题，如果不行，就回溯并选择另一个动作，直到将问题解决

例题：数组子集的全排列

### 贪心算法

期盼通过每个阶段的**局部最优**选择，从而达到全局的最优
结果并**一定是最优**

例题：分发饼干、买卖股票的最佳时机
