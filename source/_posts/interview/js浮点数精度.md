---
layout: js
title: JavaScript-深入理解浮点数精度问题
## date: 2019-04-15 22:48:29
tags: [js,interview]
## keywords: 博客文章密码
## password: 123123
## message:  输入密码，查看文章
---

>[JavaScript-深入理解浮点数精度问题-Ninnka](https://zhuanlan.zhihu.com/p/371530318)

**深入问题前的准备**

在深入问题之前，我们先来了解下JS的Number在二进制中是怎么存储的

**双精度浮点数**

JS中的Number是以双精度浮点数的形式计算的，双精度浮点数总共有8个字节（byte），每字节有8比特（bit-位），即 8bit/byet，所以总共占位64位。

根据IEEE754的标准，双精度浮点数中的占位分为3个部分

<img src="https://i.loli.net/2021/05/12/MtiLfeyuD4wZoGx.jpg" >

这三个部分组成这样一个公式

<img src="https://i.loli.net/2021/05/12/fokFy5Qp2VmYnqP.jpg" >

**第一部分：**
Sign-符号位，长度是1，0是整数，1是负数

**第二部分：**
Exponent-指数位，长度是11，取值范围是[0,2047]（也可以说是0 ~ 2^11-1），本身是无符号位，取值范围是[0,2047]

**第三部分**
Mantissa-尾数，长度是52，取值范围是[0, 2^53-1]

根据第二部分的描述，我们可以把公式优化成这样：

<img src="https://i.loli.net/2021/05/12/CpJmeGOixKycjhb.jpg" >

看完这两个公式，可能有同学开始疑惑了？？？

为什么需要M+1 ？

公式是遵循科学计数法规范的，我们常见的科学计数法是这样的

```javaScript
const a = 2021;
// => 2.21 * 10^3
// => 2.21E3;
```

二进制中的科学计数法则是这样的

```javaScript
const a = "101011000";
// => 1.01011 * 2^8
// 去除整数部分的1后，剩余 M=01011
// 整数部分只能为1，满足 0 < N < 2
// M 是去除1之后剩下的部分，最终计算时需要加回来，所以会有 M+1
```

为什么需要E-1023 ？

```javaScript
const a = "101011000";
// => 1.01011 * 2^8
// E本身是无符号位，取值范围是[0,2047]，但是指数可以是负数
// 所以IEEE754标准规定，对于E为11位的情况，中间数是 2^10-1=1023
// 正数和负数各占1023个数字
```

所以E的实际取值范围分为负数[0,1022]，正数[1024,2047]

举个例子

```javaScript
// 举一个我们常用的十进制数字
const num = 8080;
// 这个数字转成二进制之后
const numDec = num.toString(2);
// => 1111110010000
// 用科学计数法表示
// => 1.111110010000 * 2^12
// E = 12 + 1023 => 10000001011
// M = 111110010000{000...000补全到52位}
// 结果如下图
```

<img src="https://i.loli.net/2021/05/12/5cnlKYbfitAZ4vF.jpg" >

**0.1 + 0.2 === 0.3 ？**
大家一定经常看到 0.1 + 0.2 这样的送命题，也知道结果肯定不等于0.3

相似的问题还有

0.1 + 0.7 === 0.8 ？

0.2 + 0.4 === 0.6 ？

等等...

**问题出现的原因**
在我们了解完JS的Number存储机制后，我们分析一下0.1+0.2中出现的问题

先分析0.1

```javaScript
const a = 0.1;
// 转为二进制
const aDec = a.toString(2)
// => 0.000110011001100110011001100110011001100110011001100110011001100{后面循环1100}
// 0.1转为二进制时因为有无限循环，在获取尾数时，第53位需要判断是否为1来进行进位，存在精度丢失
// 因为第53位为1的缘故，最后得到的二进制会比真实的0.1要大
// => 11001100110011001100110011001100110011001100110011010 * 2^-4
// 转换回十进制后
// => 1.00000000000000005551115123126E-1
// => 0.100000000000000005551115123126 > 0.1
```

同理 0.2 也会进行一样的操作

```javaScript
const a = 0.2;
// 转为二进制
const aDec = a.toString(2)
// => 0.001100110011001100110011001100110011001100110011001101{后面循环0011}
// 0.2转为二进制时因为有无限循环，在获取尾数时，第53位需要判断是否为1来进行进位，存在精度丢失
// 因为第53位为1的缘故，最后得到的二进制会比真实的0.1要大
// => 1100110011001100110011001100110011001100110011001101 * 2^-3
// 转换回十进制后
// => 2.00000000000000011102230246252E-1
// => 0.200000000000000011102230246252 > 0.2
```

0.1+0.2 ===

0.100000000000000005551115123126 + 0.200000000000000011102230246252 ===

0.30000000000000004

到这里真实应该都大白了(●—●)

最大安全数为什么是 2^53-1
JavaScript 中的 API 都是精度安全的吗？

> [JavaScript-深入理解浮点数精度问题-Ninnka](https://zhuanlan.zhihu.com/p/371530318)
> [JavaScript 浮点数陷阱及解法](https://github.com/camsong/blog/issues/9)
> [浮点数的二进制表示](http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html)
